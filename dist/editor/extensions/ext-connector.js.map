{"version":3,"file":"ext-connector.js","sources":["../../../src/editor/extensions/ext-connector.js"],"sourcesContent":["/**\n * @file ext-connector.js\n *\n * @license MIT\n *\n * @copyright 2010 Alexis Deveria\n *\n */\n\nexport default {\n  name: 'connector',\n  async init (S) {\n    const svgEditor = this;\n    const svgCanvas = svgEditor.canvas;\n    const {getElem} = svgCanvas;\n    const {$, svgroot, importLocale} = S,\n      addElem = svgCanvas.addSVGElementFromJson,\n      selManager = S.selectorManager,\n      connSel = '.se_connector',\n      // connect_str = '-SE_CONNECT-',\n      elData = $.data;\n    const strings = await importLocale();\n\n    let startX,\n      startY,\n      curLine,\n      startElem,\n      endElem,\n      seNs,\n      {svgcontent} = S,\n      started = false,\n      connections = [],\n      selElems = [];\n\n    /**\n     *\n     * @param {Float} x\n     * @param {Float} y\n     * @param {module:utilities.BBoxObject} bb\n     * @param {Float} offset\n     * @returns {module:math.XYObject}\n     */\n    function getBBintersect (x, y, bb, offset) {\n      if (offset) {\n        offset -= 0;\n        bb = $.extend({}, bb);\n        bb.width += offset;\n        bb.height += offset;\n        bb.x -= offset / 2;\n        bb.y -= offset / 2;\n      }\n\n      const midX = bb.x + bb.width / 2;\n      const midY = bb.y + bb.height / 2;\n      const lenX = x - midX;\n      const lenY = y - midY;\n\n      const slope = Math.abs(lenY / lenX);\n\n      let ratio;\n      if (slope < bb.height / bb.width) {\n        ratio = (bb.width / 2) / Math.abs(lenX);\n      } else {\n        ratio = lenY\n          ? (bb.height / 2) / Math.abs(lenY)\n          : 0;\n      }\n\n      return {\n        x: midX + lenX * ratio,\n        y: midY + lenY * ratio\n      };\n    }\n\n    /**\n    * @param {\"start\"|\"end\"} side\n    * @param {Element} line\n    * @returns {Float}\n    */\n    function getOffset (side, line) {\n      const giveOffset = line.getAttribute('marker-' + side);\n      // const giveOffset = $(line).data(side+'_off');\n\n      // TODO: Make this number (5) be based on marker width/height\n      const size = line.getAttribute('stroke-width') * 5;\n      return giveOffset ? size : 0;\n    }\n\n    /**\n    * @param {boolean} on\n    * @returns {void}\n    */\n    function showPanel (on) {\n      let connRules = $('#connector_rules');\n      if (!connRules.length) {\n        connRules = $('<style id=\"connector_rules\"></style>').appendTo('head');\n      }\n      connRules.text(!on ? '' : '#tool_clone, #tool_topath, #tool_angle, #xy_panel { display: none !important; }');\n      $('#connector_panel').toggle(on);\n    }\n\n    /**\n     * @param {Element} elem\n     * @param {Integer|\"end\"} pos\n     * @param {Float} x\n     * @param {Float} y\n     * @param {boolean} [setMid]\n     * @returns {void}\n    */\n    function setPoint (elem, pos, x, y, setMid) {\n      const pts = elem.points;\n      const pt = svgroot.createSVGPoint();\n      pt.x = x;\n      pt.y = y;\n      if (pos === 'end') { pos = pts.numberOfItems - 1; }\n      // TODO: Test for this on init, then use alt only if needed\n      try {\n        pts.replaceItem(pt, pos);\n      } catch (err) {\n        // Should only occur in FF which formats points attr as \"n,n n,n\", so just split\n        const ptArr = elem.getAttribute('points').split(' ');\n        for (let i = 0; i < ptArr.length; i++) {\n          if (i === pos) {\n            ptArr[i] = x + ',' + y;\n          }\n        }\n        elem.setAttribute('points', ptArr.join(' '));\n      }\n\n      if (setMid) {\n        // Add center point\n        const ptStart = pts.getItem(0);\n        const ptEnd = pts.getItem(pts.numberOfItems - 1);\n        setPoint(elem, 1, (ptEnd.x + ptStart.x) / 2, (ptEnd.y + ptStart.y) / 2);\n      }\n    }\n\n    /**\n    * @param {Float} diffX\n    * @param {Float} diffY\n    * @returns {void}\n    */\n    function updateLine (diffX, diffY) {\n      // Update line with element\n      let i = connections.length;\n      while (i--) {\n        const conn = connections[i];\n        const line = conn.connector;\n        // const {elem} = conn;\n\n        const pre = conn.is_start ? 'start' : 'end';\n        // const sw = line.getAttribute('stroke-width') * 5;\n\n        // Update bbox for this element\n        const bb = elData(line, pre + '_bb');\n        bb.x = conn.start_x + diffX;\n        bb.y = conn.start_y + diffY;\n        elData(line, pre + '_bb', bb);\n\n        const altPre = conn.is_start ? 'end' : 'start';\n\n        // Get center pt of connected element\n        const bb2 = elData(line, altPre + '_bb');\n        const srcX = bb2.x + bb2.width / 2;\n        const srcY = bb2.y + bb2.height / 2;\n\n        // Set point of element being moved\n        const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line)); // $(line).data(pre+'_off')?sw:0\n        setPoint(line, conn.is_start ? 0 : 'end', pt.x, pt.y, true);\n\n        // Set point of connected element\n        const pt2 = getBBintersect(pt.x, pt.y, elData(line, altPre + '_bb'), getOffset(altPre, line));\n        setPoint(line, conn.is_start ? 'end' : 0, pt2.x, pt2.y, true);\n      }\n    }\n\n    /**\n    *\n    * @param {Element[]} [elems=selElems] Array of elements\n    * @returns {void}\n    */\n    function findConnectors (elems = selElems) {\n      const connectors = $(svgcontent).find(connSel);\n      connections = [];\n\n      // Loop through connectors to see if one is connected to the element\n      connectors.each(function () {\n        let addThis;\n        /**\n        *\n        * @returns {void}\n        */\n        function add () {\n          if (elems.includes(this)) {\n            // Pretend this element is selected\n            addThis = true;\n          }\n        }\n\n        // Grab the ends\n        const parts = [];\n        ['start', 'end'].forEach(function (pos, i) {\n          const key = 'c_' + pos;\n          let part = elData(this, key);\n          if (part === null || part === undefined) { // Does this ever return nullish values?\n            part = document.getElementById(\n              this.attributes['se:connector'].value.split(' ')[i]\n            );\n            elData(this, 'c_' + pos, part.id);\n            elData(this, pos + '_bb', svgCanvas.getStrokedBBox([part]));\n          } else part = document.getElementById(part);\n          parts.push(part);\n        }, this);\n\n        for (let i = 0; i < 2; i++) {\n          const cElem = parts[i];\n\n          addThis = false;\n          // The connected element might be part of a selected group\n          $(cElem).parents().each(add);\n\n          if (!cElem || !cElem.parentNode) {\n            $(this).remove();\n            continue;\n          }\n          if (elems.includes(cElem) || addThis) {\n            const bb = svgCanvas.getStrokedBBox([cElem]);\n            connections.push({\n              elem: cElem,\n              connector: this,\n              is_start: (i === 0),\n              start_x: bb.x,\n              start_y: bb.y\n            });\n          }\n        }\n      });\n    }\n\n    /**\n    * @param {Element[]} [elems=selElems]\n    * @returns {void}\n    */\n    function updateConnectors (elems) {\n      // Updates connector lines based on selected elements\n      // Is not used on mousemove, as it runs getStrokedBBox every time,\n      // which isn't necessary there.\n      findConnectors(elems);\n      if (connections.length) {\n        // Update line with element\n        let i = connections.length;\n        while (i--) {\n          const conn = connections[i];\n          const line = conn.connector;\n          const {elem} = conn;\n\n          // const sw = line.getAttribute('stroke-width') * 5;\n          const pre = conn.is_start ? 'start' : 'end';\n\n          // Update bbox for this element\n          const bb = svgCanvas.getStrokedBBox([elem]);\n          bb.x = conn.start_x;\n          bb.y = conn.start_y;\n          elData(line, pre + '_bb', bb);\n          /* const addOffset = */ elData(line, pre + '_off');\n\n          const altPre = conn.is_start ? 'end' : 'start';\n\n          // Get center pt of connected element\n          const bb2 = elData(line, altPre + '_bb');\n          const srcX = bb2.x + bb2.width / 2;\n          const srcY = bb2.y + bb2.height / 2;\n\n          // Set point of element being moved\n          let pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line));\n          setPoint(line, conn.is_start ? 0 : 'end', pt.x, pt.y, true);\n\n          // Set point of connected element\n          const pt2 = getBBintersect(pt.x, pt.y, elData(line, altPre + '_bb'), getOffset(altPre, line));\n          setPoint(line, conn.is_start ? 'end' : 0, pt2.x, pt2.y, true);\n\n          // Update points attribute manually for webkit\n          if (navigator.userAgent.includes('AppleWebKit')) {\n            const pts = line.points;\n            const len = pts.numberOfItems;\n            const ptArr = [];\n            for (let j = 0; j < len; j++) {\n              pt = pts.getItem(j);\n              ptArr[j] = pt.x + ',' + pt.y;\n            }\n            line.setAttribute('points', ptArr.join(' '));\n          }\n        }\n      }\n    }\n\n    // Do once\n    (function () {\n      const gse = svgCanvas.groupSelectedElements;\n\n      svgCanvas.groupSelectedElements = function (...args) {\n        svgCanvas.removeFromSelection($(connSel).toArray());\n        return gse.apply(this, args);\n      };\n\n      const mse = svgCanvas.moveSelectedElements;\n\n      svgCanvas.moveSelectedElements = function (...args) {\n        const cmd = mse.apply(this, args);\n        updateConnectors();\n        return cmd;\n      };\n\n      seNs = svgCanvas.getEditorNS();\n    }());\n\n    /**\n    * Do on reset.\n    * @returns {void}\n    */\n    function init () {\n      // Make sure all connectors have data set\n      $(svgcontent).find('*').each(function () {\n        const conn = this.getAttributeNS(seNs, 'connector');\n        if (conn) {\n          this.setAttribute('class', connSel.substr(1));\n          const connData = conn.split(' ');\n          const sbb = svgCanvas.getStrokedBBox([getElem(connData[0])]);\n          const ebb = svgCanvas.getStrokedBBox([getElem(connData[1])]);\n          $(this).data('c_start', connData[0])\n            .data('c_end', connData[1])\n            .data('start_bb', sbb)\n            .data('end_bb', ebb);\n          svgCanvas.getEditorNS(true);\n        }\n      });\n      // updateConnectors();\n    }\n\n    // $(svgroot).parent().mousemove(function (e) {\n    // // if (started\n    // //   || svgCanvas.getMode() !== 'connector'\n    // //  || e.target.parentNode.parentNode !== svgcontent) return;\n    //\n    // console.log('y')\n    // // if (e.target.parentNode.parentNode === svgcontent) {\n    // //\n    // // }\n    // });\n\n    const buttons = [{\n      id: 'mode_connect',\n      type: 'mode',\n      icon: svgEditor.curConfig.imgPath + 'cut.png',\n      includeWith: {\n        button: '#tool_line',\n        isDefault: false,\n        position: 1\n      },\n      events: {\n        click () {\n          svgCanvas.setMode('connector');\n        }\n      }\n    }];\n\n    return {\n      name: strings.name,\n      svgicons: 'conn.svg',\n      buttons: strings.buttons.map((button, i) => {\n        return Object.assign(buttons[i], button);\n      }),\n      /* async */ addLangData ({lang}) { // , importLocale: importLoc\n        return {\n          data: strings.langList\n        };\n      },\n      mouseDown (opts) {\n        const e = opts.event;\n        startX = opts.start_x;\n        startY = opts.start_y;\n        const mode = svgCanvas.getMode();\n        const {curConfig: {initStroke}} = svgEditor;\n\n        if (mode === 'connector') {\n          if (started) { return undefined; }\n\n          const mouseTarget = e.target;\n\n          const parents = $(mouseTarget).parents();\n\n          if ($.inArray(svgcontent, parents) !== -1) {\n            // Connectable element\n\n            // If child of foreignObject, use parent\n            const fo = $(mouseTarget).closest('foreignObject');\n            startElem = fo.length ? fo[0] : mouseTarget;\n\n            // Get center of source element\n            const bb = svgCanvas.getStrokedBBox([startElem]);\n            const x = bb.x + bb.width / 2;\n            const y = bb.y + bb.height / 2;\n\n            started = true;\n            curLine = addElem({\n              element: 'polyline',\n              attr: {\n                id: svgCanvas.getNextId(),\n                points: (x + ',' + y + ' ' + x + ',' + y + ' ' + startX + ',' + startY),\n                stroke: '#' + initStroke.color,\n                'stroke-width': (!startElem.stroke_width || startElem.stroke_width === 0)\n                  ? initStroke.width\n                  : startElem.stroke_width,\n                fill: 'none',\n                opacity: initStroke.opacity,\n                style: 'pointer-events:none'\n              }\n            });\n            elData(curLine, 'start_bb', bb);\n          }\n          return {\n            started: true\n          };\n        }\n        if (mode === 'select') {\n          findConnectors();\n        }\n        return undefined;\n      },\n      mouseMove (opts) {\n        const zoom = svgCanvas.getZoom();\n        // const e = opts.event;\n        const x = opts.mouse_x / zoom;\n        const y = opts.mouse_y / zoom;\n\n        const diffX = x - startX,\n          diffY = y - startY;\n\n        const mode = svgCanvas.getMode();\n\n        if (mode === 'connector' && started) {\n          // const sw = curLine.getAttribute('stroke-width') * 3;\n          // Set start point (adjusts based on bb)\n          const pt = getBBintersect(x, y, elData(curLine, 'start_bb'), getOffset('start', curLine));\n          startX = pt.x;\n          startY = pt.y;\n\n          setPoint(curLine, 0, pt.x, pt.y, true);\n\n          // Set end point\n          setPoint(curLine, 'end', x, y, true);\n        } else if (mode === 'select') {\n          let slen = selElems.length;\n          while (slen--) {\n            const elem = selElems[slen];\n            // Look for selected connector elements\n            if (elem && elData(elem, 'c_start')) {\n              // Remove the \"translate\" transform given to move\n              svgCanvas.removeFromSelection([elem]);\n              svgCanvas.getTransformList(elem).clear();\n            }\n          }\n          if (connections.length) {\n            updateLine(diffX, diffY);\n          }\n        }\n      },\n      mouseUp (opts) {\n        // const zoom = svgCanvas.getZoom();\n        const e = opts.event;\n        // , x = opts.mouse_x / zoom,\n        // , y = opts.mouse_y / zoom,\n        let mouseTarget = e.target;\n\n        if (svgCanvas.getMode() !== 'connector') {\n          return undefined;\n        }\n        const fo = $(mouseTarget).closest('foreignObject');\n        if (fo.length) { mouseTarget = fo[0]; }\n\n        const parents = $(mouseTarget).parents();\n\n        if (mouseTarget === startElem) {\n          // Start line through click\n          started = true;\n          return {\n            keep: true,\n            element: null,\n            started\n          };\n        }\n        if ($.inArray(svgcontent, parents) === -1) {\n          // Not a valid target element, so remove line\n          $(curLine).remove();\n          started = false;\n          return {\n            keep: false,\n            element: null,\n            started\n          };\n        }\n        // Valid end element\n        endElem = mouseTarget;\n\n        const startId = startElem.id, endId = endElem.id;\n        const connStr = startId + ' ' + endId;\n        const altStr = endId + ' ' + startId;\n        // Don't create connector if one already exists\n        const dupe = $(svgcontent).find(connSel).filter(function () {\n          const conn = this.getAttributeNS(seNs, 'connector');\n          if (conn === connStr || conn === altStr) { return true; }\n          return false;\n        });\n        if (dupe.length) {\n          $(curLine).remove();\n          return {\n            keep: false,\n            element: null,\n            started: false\n          };\n        }\n\n        const bb = svgCanvas.getStrokedBBox([endElem]);\n\n        const pt = getBBintersect(startX, startY, bb, getOffset('start', curLine));\n        setPoint(curLine, 'end', pt.x, pt.y, true);\n        $(curLine)\n          .data('c_start', startId)\n          .data('c_end', endId)\n          .data('end_bb', bb);\n        seNs = svgCanvas.getEditorNS(true);\n        curLine.setAttributeNS(seNs, 'se:connector', connStr);\n        curLine.setAttribute('class', connSel.substr(1));\n        curLine.setAttribute('opacity', 1);\n        svgCanvas.addToSelection([curLine]);\n        svgCanvas.moveToBottomSelectedElement();\n        selManager.requestSelector(curLine).showGrips(false);\n        started = false;\n        return {\n          keep: true,\n          element: curLine,\n          started\n        };\n      },\n      selectedChanged (opts) {\n        // TODO: Find better way to skip operations if no connectors are in use\n        if (!$(svgcontent).find(connSel).length) { return; }\n\n        if (svgCanvas.getMode() === 'connector') {\n          svgCanvas.setMode('select');\n        }\n\n        // Use this to update the current selected elements\n        selElems = opts.elems;\n\n        let i = selElems.length;\n        while (i--) {\n          const elem = selElems[i];\n          if (elem && elData(elem, 'c_start')) {\n            selManager.requestSelector(elem).showGrips(false);\n            if (opts.selectedElement && !opts.multiselected) {\n              // TODO: Set up context tools and hide most regular line tools\n              showPanel(true);\n            } else {\n              showPanel(false);\n            }\n          } else {\n            showPanel(false);\n          }\n        }\n        updateConnectors();\n      },\n      elementChanged (opts) {\n        let elem = opts.elems[0];\n        if (!elem) return;\n        if (elem.tagName === 'svg' && elem.id === 'svgcontent') {\n          // Update svgcontent (can change on import)\n          svgcontent = elem;\n          init();\n        }\n\n        // Has marker, so change offset\n        if (\n          elem.getAttribute('marker-start') ||\n          elem.getAttribute('marker-mid') ||\n          elem.getAttribute('marker-end')\n        ) {\n          const start = elem.getAttribute('marker-start');\n          const mid = elem.getAttribute('marker-mid');\n          const end = elem.getAttribute('marker-end');\n          curLine = elem;\n          $(elem)\n            .data('start_off', Boolean(start))\n            .data('end_off', Boolean(end));\n\n          if (elem.tagName === 'line' && mid) {\n            // Convert to polyline to accept mid-arrow\n\n            const x1 = Number(elem.getAttribute('x1'));\n            const x2 = Number(elem.getAttribute('x2'));\n            const y1 = Number(elem.getAttribute('y1'));\n            const y2 = Number(elem.getAttribute('y2'));\n            const {id} = elem;\n\n            const midPt = (' ' + ((x1 + x2) / 2) + ',' + ((y1 + y2) / 2) + ' ');\n            const pline = addElem({\n              element: 'polyline',\n              attr: {\n                points: (x1 + ',' + y1 + midPt + x2 + ',' + y2),\n                stroke: elem.getAttribute('stroke'),\n                'stroke-width': elem.getAttribute('stroke-width'),\n                'marker-mid': mid,\n                fill: 'none',\n                opacity: elem.getAttribute('opacity') || 1\n              }\n            });\n            $(elem).after(pline).remove();\n            svgCanvas.clearSelection();\n            pline.id = id;\n            svgCanvas.addToSelection([pline]);\n            elem = pline;\n          }\n        }\n        // Update line if it's a connector\n        if (elem.getAttribute('class') === connSel.substr(1)) {\n          const start = getElem(elData(elem, 'c_start'));\n          updateConnectors([start]);\n        } else {\n          updateConnectors();\n        }\n      },\n      IDsUpdated (input) {\n        const remove = [];\n        input.elems.forEach(function (elem) {\n          if ('se:connector' in elem.attr) {\n            elem.attr['se:connector'] = elem.attr['se:connector'].split(' ')\n              .map(function (oldID) { return input.changes[oldID]; }).join(' ');\n\n            // Check validity - the field would be something like 'svg_21 svg_22', but\n            // if one end is missing, it would be 'svg_21' and therefore fail this test\n            if (!(/. ./).test(elem.attr['se:connector'])) {\n              remove.push(elem.attr.id);\n            }\n          }\n        });\n        return {remove};\n      },\n      toolButtonStateUpdate (opts) {\n        if (opts.nostroke) {\n          if ($('#mode_connect').hasClass('tool_button_current')) {\n            svgEditor.clickSelect();\n          }\n        }\n        $('#mode_connect')\n          .toggleClass('disabled', opts.nostroke);\n      }\n    };\n  }\n};\n"],"names":["name","init","S","getBBintersect","getOffset","showPanel","setPoint","updateLine","findConnectors","updateConnectors","$","svgcontent","find","each","conn","this","getAttributeNS","seNs","setAttribute","connSel","substr","connData","split","sbb","svgCanvas","getStrokedBBox","getElem","ebb","data","getEditorNS","elems","connections","length","i","line","connector","elem","pre","is_start","bb","x","start_x","y","start_y","elData","altPre","bb2","srcX","width","srcY","height","pt","pt2","navigator","userAgent","includes","pts","points","len","numberOfItems","ptArr","j","getItem","join","selElems","connectors","addThis","add","parts","forEach","pos","part","document","getElementById","attributes","value","id","push","cElem","parents","parentNode","remove","diffX","diffY","setMid","svgroot","createSVGPoint","replaceItem","err","getAttribute","ptStart","ptEnd","on","connRules","appendTo","text","toggle","side","giveOffset","size","offset","extend","ratio","midX","midY","lenX","lenY","Math","abs","svgEditor","_this","canvas","importLocale","addElem","addSVGElementFromJson","selManager","selectorManager","strings","started","gse","groupSelectedElements","removeFromSelection","toArray","args","apply","mse","moveSelectedElements","cmd","buttons","type","icon","curConfig","imgPath","includeWith","button","isDefault","position","events","click","setMode","svgicons","map","Object","assign","addLangData","lang","langList","mouseDown","opts","e","event","startX","startY","mode","getMode","initStroke","mouseTarget","target","inArray","fo","closest","startElem","curLine","element","attr","getNextId","stroke","color","stroke_width","fill","opacity","style","mouseMove","zoom","getZoom","mouse_x","mouse_y","slen","getTransformList","clear","mouseUp","keep","endElem","startId","endId","connStr","altStr","filter","setAttributeNS","addToSelection","moveToBottomSelectedElement","requestSelector","showGrips","selectedChanged","selectedElement","multiselected","elementChanged","tagName","start","mid","end","Boolean","x1","Number","x2","y1","y2","pline","after","clearSelection","IDsUpdated","input","oldID","changes","test","toolButtonStateUpdate","nostroke","hasClass","clickSelect","toggleClass"],"mappings":"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"}