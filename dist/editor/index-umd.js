(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var check = function check(it) {
    return it && it.Math == Math && it;
  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


  var global_1 = // eslint-disable-next-line no-undef
  check((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self) || check(_typeof(commonjsGlobal) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
  Function('return this')();

  var fails = function fails(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var descriptors = !fails(function () {
    return Object.defineProperty({}, 1, {
      get: function get() {
        return 7;
      }
    })[1] != 7;
  });

  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

  var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
    1: 2
  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable;
  var objectPropertyIsEnumerable = {
    f: f
  };

  var createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var toString = {}.toString;

  var classofRaw = function classofRaw(it) {
    return toString.call(it).slice(8, -1);
  };

  var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
  } : Object;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function requireObjectCoercible(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
  };

  var toIndexedObject = function toIndexedObject(it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var isObject = function isObject(it) {
    return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
  };

  // https://tc39.github.io/ecma262/#sec-toprimitive
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string

  var toPrimitive = function toPrimitive(input, PREFERRED_STRING) {
    if (!isObject(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var has = function has(it, key) {
    return hasOwnProperty.call(it, key);
  };

  var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

  var EXISTS = isObject(document$1) && isObject(document$1.createElement);

  var documentCreateElement = function documentCreateElement(it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  var ie8DomDefine = !descriptors && !fails(function () {
    return Object.defineProperty(documentCreateElement('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPrimitive(P, true);
    if (ie8DomDefine) try {
      return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) {
      /* empty */
    }
    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
  };
  var objectGetOwnPropertyDescriptor = {
    f: f$1
  };

  var anObject = function anObject(it) {
    if (!isObject(it)) {
      throw TypeError(String(it) + ' is not an object');
    }

    return it;
  };

  var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty

  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return nativeDefineProperty(O, P, Attributes);
    } catch (error) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var objectDefineProperty = {
    f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var setGlobal = function setGlobal(key, value) {
    try {
      createNonEnumerableProperty(global_1, key, value);
    } catch (error) {
      global_1[key] = value;
    }

    return value;
  };

  var SHARED = '__core-js_shared__';
  var store = global_1[SHARED] || setGlobal(SHARED, {});
  var sharedStore = store;

  var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

  if (typeof sharedStore.inspectSource != 'function') {
    sharedStore.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap = global_1.WeakMap;
  var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

  var isPure = false;

  var shared = createCommonjsModule(function (module) {
    (module.exports = function (key, value) {
      return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.6.5',
      mode:  'global',
      copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
    });
  });

  var id = 0;
  var postfix = Math.random();

  var uid = function uid(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
  };

  var keys = shared('keys');

  var sharedKey = function sharedKey(key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var WeakMap$1 = global_1.WeakMap;
  var set, get, has$1;

  var enforce = function enforce(it) {
    return has$1(it) ? get(it) : set(it, {});
  };

  var getterFor = function getterFor(TYPE) {
    return function (it) {
      var state;

      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError('Incompatible receiver, ' + TYPE + ' required');
      }

      return state;
    };
  };

  if (nativeWeakMap) {
    var store$1 = new WeakMap$1();
    var wmget = store$1.get;
    var wmhas = store$1.has;
    var wmset = store$1.set;

    set = function set(it, metadata) {
      wmset.call(store$1, it, metadata);
      return metadata;
    };

    get = function get(it) {
      return wmget.call(store$1, it) || {};
    };

    has$1 = function has(it) {
      return wmhas.call(store$1, it);
    };
  } else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;

    set = function set(it, metadata) {
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };

    get = function get(it) {
      return has(it, STATE) ? it[STATE] : {};
    };

    has$1 = function has$1(it) {
      return has(it, STATE);
    };
  }

  var internalState = {
    set: set,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
  };

  var redefine = createCommonjsModule(function (module) {
    var getInternalState = internalState.get;
    var enforceInternalState = internalState.enforce;
    var TEMPLATE = String(String).split('String');
    (module.exports = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;

      if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
      }

      if (O === global_1) {
        if (simple) O[key] = value;else setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }

      if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    })(Function.prototype, 'toString', function toString() {
      return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
    });
  });

  var path = global_1;

  var aFunction = function aFunction(variable) {
    return typeof variable == 'function' ? variable : undefined;
  };

  var getBuiltIn = function getBuiltIn(namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
  };

  var ceil = Math.ceil;
  var floor = Math.floor; // `ToInteger` abstract operation
  // https://tc39.github.io/ecma262/#sec-tointeger

  var toInteger = function toInteger(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
  };

  var min = Math.min; // `ToLength` abstract operation
  // https://tc39.github.io/ecma262/#sec-tolength

  var toLength = function toLength(argument) {
    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min; // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

  var toAbsoluteIndex = function toAbsoluteIndex(index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  var createMethod = function createMethod(IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;

  var objectKeysInternal = function objectKeysInternal(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) {
      !has(hiddenKeys, key) && has(O, key) && result.push(key);
    } // Don't enum bug & hidden keys


    while (names.length > i) {
      if (has(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }
    }

    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
    f: f$3
  };

  var f$4 = Object.getOwnPropertySymbols;
  var objectGetOwnPropertySymbols = {
    f: f$4
  };

  var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function copyConstructorProperties(target, source) {
    var keys = ownKeys(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function isForced(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = 'N';
  var POLYFILL = isForced.POLYFILL = 'P';
  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
  */

  var _export = function _export(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;

    if (GLOBAL) {
      target = global_1;
    } else if (STATIC) {
      target = global_1[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global_1[TARGET] || {}).prototype;
    }

    if (target) for (key in source) {
      sourceProperty = source[key];

      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];

      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

      if (!FORCED && targetProperty !== undefined) {
        if (_typeof(sourceProperty) === _typeof(targetProperty)) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      } // add a flag to not completely full polyfills


      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, 'sham', true);
      } // extend global


      redefine(target, key, sourceProperty, options);
    }
  };

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
  });

  var useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef
  && !Symbol.sham // eslint-disable-next-line no-undef
  && _typeof(Symbol.iterator) == 'symbol';

  // https://tc39.github.io/ecma262/#sec-isarray

  var isArray = Array.isArray || function isArray(arg) {
    return classofRaw(arg) == 'Array';
  };

  // https://tc39.github.io/ecma262/#sec-toobject

  var toObject = function toObject(argument) {
    return Object(requireObjectCoercible(argument));
  };

  // https://tc39.github.io/ecma262/#sec-object.keys

  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  // https://tc39.github.io/ecma262/#sec-object.defineproperties

  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;

    while (length > index) {
      objectDefineProperty.f(O, key = keys[index++], Properties[key]);
    }

    return O;
  };

  var html = getBuiltIn('document', 'documentElement');

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO = sharedKey('IE_PROTO');

  var EmptyConstructor = function EmptyConstructor() {
    /* empty */
  };

  var scriptTag = function scriptTag(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


  var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak

    return temp;
  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


  var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  }; // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug


  var activeXDocument;

  var _NullProtoObject = function NullProtoObject() {
    try {
      /* global ActiveXObject */
      activeXDocument = document.domain && new ActiveXObject('htmlfile');
    } catch (error) {
      /* ignore */
    }

    _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;

    while (length--) {
      delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    }

    return _NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true; // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create

  var objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO] = O;
    } else result = _NullProtoObject();

    return Properties === undefined ? result : objectDefineProperties(result, Properties);
  };

  var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
  var toString$1 = {}.toString;
  var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function getWindowNames(it) {
    try {
      return nativeGetOwnPropertyNames(it);
    } catch (error) {
      return windowNames.slice();
    }
  }; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


  var f$5 = function getOwnPropertyNames(it) {
    return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
  };

  var objectGetOwnPropertyNamesExternal = {
    f: f$5
  };

  var WellKnownSymbolsStore = shared('wks');
  var _Symbol = global_1.Symbol;
  var createWellKnownSymbol = useSymbolAsUid ? _Symbol : _Symbol && _Symbol.withoutSetter || uid;

  var wellKnownSymbol = function wellKnownSymbol(name) {
    if (!has(WellKnownSymbolsStore, name)) {
      if (nativeSymbol && has(_Symbol, name)) WellKnownSymbolsStore[name] = _Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }

    return WellKnownSymbolsStore[name];
  };

  var f$6 = wellKnownSymbol;
  var wellKnownSymbolWrapped = {
    f: f$6
  };

  var defineProperty = objectDefineProperty.f;

  var defineWellKnownSymbol = function defineWellKnownSymbol(NAME) {
    var _Symbol = path.Symbol || (path.Symbol = {});

    if (!has(_Symbol, NAME)) defineProperty(_Symbol, NAME, {
      value: wellKnownSymbolWrapped.f(NAME)
    });
  };

  var defineProperty$1 = objectDefineProperty.f;
  var TO_STRING_TAG = wellKnownSymbol('toStringTag');

  var setToStringTag = function setToStringTag(it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
      defineProperty$1(it, TO_STRING_TAG, {
        configurable: true,
        value: TAG
      });
    }
  };

  var aFunction$1 = function aFunction(it) {
    if (typeof it != 'function') {
      throw TypeError(String(it) + ' is not a function');
    }

    return it;
  };

  var functionBindContext = function functionBindContext(fn, that, length) {
    aFunction$1(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 0:
        return function () {
          return fn.call(that);
        };

      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function ()
    /* ...args */
    {
      return fn.apply(that, arguments);
    };
  };

  var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
  // https://tc39.github.io/ecma262/#sec-arrayspeciescreate

  var arraySpeciesCreate = function arraySpeciesCreate(originalArray, length) {
    var C;

    if (isArray(originalArray)) {
      C = originalArray.constructor; // cross-realm fallback

      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    }

    return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
  };

  var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

  var createMethod$1 = function createMethod(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = indexedObject(O);
      var boundFunction = functionBindContext(callbackfn, that, 3);
      var length = toLength(self.length);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var value, result;

      for (; length > index; index++) {
        if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);

          if (TYPE) {
            if (IS_MAP) target[index] = result; // map
            else if (result) switch (TYPE) {
                case 3:
                  return true;
                // some

                case 5:
                  return value;
                // find

                case 6:
                  return index;
                // findIndex

                case 2:
                  push.call(target, value);
                // filter
              } else if (IS_EVERY) return false; // every
          }
        }
      }

      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$1(0),
    // `Array.prototype.map` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.map
    map: createMethod$1(1),
    // `Array.prototype.filter` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.filter
    filter: createMethod$1(2),
    // `Array.prototype.some` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.some
    some: createMethod$1(3),
    // `Array.prototype.every` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.every
    every: createMethod$1(4),
    // `Array.prototype.find` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    find: createMethod$1(5),
    // `Array.prototype.findIndex` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$1(6)
  };

  var $forEach = arrayIteration.forEach;
  var HIDDEN = sharedKey('hidden');
  var SYMBOL = 'Symbol';
  var PROTOTYPE$1 = 'prototype';
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
  var setInternalState = internalState.set;
  var getInternalState = internalState.getterFor(SYMBOL);
  var ObjectPrototype = Object[PROTOTYPE$1];
  var $Symbol = global_1.Symbol;
  var $stringify = getBuiltIn('JSON', 'stringify');
  var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var nativeDefineProperty$1 = objectDefineProperty.f;
  var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
  var AllSymbols = shared('symbols');
  var ObjectPrototypeSymbols = shared('op-symbols');
  var StringToSymbolRegistry = shared('string-to-symbol-registry');
  var SymbolToStringRegistry = shared('symbol-to-string-registry');
  var WellKnownSymbolsStore$1 = shared('wks');
  var QObject = global_1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

  var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

  var setSymbolDescriptor = descriptors && fails(function () {
    return objectCreate(nativeDefineProperty$1({}, 'a', {
      get: function get() {
        return nativeDefineProperty$1(this, 'a', {
          value: 7
        }).a;
      }
    })).a != 7;
  }) ? function (O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
    nativeDefineProperty$1(O, P, Attributes);

    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
      nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
    }
  } : nativeDefineProperty$1;

  var wrap = function wrap(tag, description) {
    var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
    setInternalState(symbol, {
      type: SYMBOL,
      tag: tag,
      description: description
    });
    if (!descriptors) symbol.description = description;
    return symbol;
  };

  var isSymbol = useSymbolAsUid ? function (it) {
    return _typeof(it) == 'symbol';
  } : function (it) {
    return Object(it) instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(O, P, Attributes) {
    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject(O);
    var key = toPrimitive(P, true);
    anObject(Attributes);

    if (has(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
        O[HIDDEN][key] = true;
      } else {
        if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
        Attributes = objectCreate(Attributes, {
          enumerable: createPropertyDescriptor(0, false)
        });
      }

      return setSymbolDescriptor(O, key, Attributes);
    }

    return nativeDefineProperty$1(O, key, Attributes);
  };

  var $defineProperties = function defineProperties(O, Properties) {
    anObject(O);
    var properties = toIndexedObject(Properties);
    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
    $forEach(keys, function (key) {
      if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
  };

  var $create = function create(O, Properties) {
    return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
  };

  var $propertyIsEnumerable = function propertyIsEnumerable(V) {
    var P = toPrimitive(V, true);
    var enumerable = nativePropertyIsEnumerable$1.call(this, P);
    if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
    var it = toIndexedObject(O);
    var key = toPrimitive(P, true);
    if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

    if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
      descriptor.enumerable = true;
    }

    return descriptor;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
    var result = [];
    $forEach(names, function (key) {
      if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
    });
    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
    var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
    var result = [];
    $forEach(names, function (key) {
      if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
        result.push(AllSymbols[key]);
      }
    });
    return result;
  }; // `Symbol` constructor
  // https://tc39.github.io/ecma262/#sec-symbol-constructor


  if (!nativeSymbol) {
    $Symbol = function _Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
      var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
      var tag = uid(description);

      var setter = function setter(value) {
        if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
      };

      if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
        configurable: true,
        set: setter
      });
      return wrap(tag, description);
    };

    redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
      return getInternalState(this).tag;
    });
    redefine($Symbol, 'withoutSetter', function (description) {
      return wrap(uid(description), description);
    });
    objectPropertyIsEnumerable.f = $propertyIsEnumerable;
    objectDefineProperty.f = $defineProperty;
    objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
    objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

    wellKnownSymbolWrapped.f = function (name) {
      return wrap(wellKnownSymbol(name), name);
    };

    if (descriptors) {
      // https://github.com/tc39/proposal-Symbol-description
      nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
        configurable: true,
        get: function description() {
          return getInternalState(this).description;
        }
      });

      {
        redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
          unsafe: true
        });
      }
    }
  }

  _export({
    global: true,
    wrap: true,
    forced: !nativeSymbol,
    sham: !nativeSymbol
  }, {
    Symbol: $Symbol
  });
  $forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
    defineWellKnownSymbol(name);
  });
  _export({
    target: SYMBOL,
    stat: true,
    forced: !nativeSymbol
  }, {
    // `Symbol.for` method
    // https://tc39.github.io/ecma262/#sec-symbol.for
    'for': function _for(key) {
      var string = String(key);
      if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
      var symbol = $Symbol(string);
      StringToSymbolRegistry[string] = symbol;
      SymbolToStringRegistry[symbol] = string;
      return symbol;
    },
    // `Symbol.keyFor` method
    // https://tc39.github.io/ecma262/#sec-symbol.keyfor
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
      if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    },
    useSetter: function useSetter() {
      USE_SETTER = true;
    },
    useSimple: function useSimple() {
      USE_SETTER = false;
    }
  });
  _export({
    target: 'Object',
    stat: true,
    forced: !nativeSymbol,
    sham: !descriptors
  }, {
    // `Object.create` method
    // https://tc39.github.io/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
  });
  _export({
    target: 'Object',
    stat: true,
    forced: !nativeSymbol
  }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames,
    // `Object.getOwnPropertySymbols` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
    getOwnPropertySymbols: $getOwnPropertySymbols
  }); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
  // https://bugs.chromium.org/p/v8/issues/detail?id=3443

  _export({
    target: 'Object',
    stat: true,
    forced: fails(function () {
      objectGetOwnPropertySymbols.f(1);
    })
  }, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return objectGetOwnPropertySymbols.f(toObject(it));
    }
  }); // `JSON.stringify` method behavior with symbols
  // https://tc39.github.io/ecma262/#sec-json.stringify

  if ($stringify) {
    var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
      var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

      return $stringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
      || $stringify({
        a: symbol
      }) != '{}' // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
    });
    _export({
      target: 'JSON',
      stat: true,
      forced: FORCED_JSON_STRINGIFY
    }, {
      // eslint-disable-next-line no-unused-vars
      stringify: function stringify(it, replacer, space) {
        var args = [it];
        var index = 1;
        var $replacer;

        while (arguments.length > index) {
          args.push(arguments[index++]);
        }

        $replacer = replacer;
        if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

        if (!isArray(replacer)) replacer = function replacer(key, value) {
          if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return $stringify.apply(null, args);
      }
    });
  } // `Symbol.prototype[@@toPrimitive]` method
  // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive


  if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
    createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
  } // `Symbol.prototype[@@toStringTag]` property
  // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag


  setToStringTag($Symbol, SYMBOL);
  hiddenKeys[HIDDEN] = true;

  var defineProperty$2 = objectDefineProperty.f;
  var NativeSymbol = global_1.Symbol;

  if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
  NativeSymbol().description !== undefined)) {
    var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

    var SymbolWrapper = function _Symbol() {
      var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
      var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
      if (description === '') EmptyStringDescriptionStore[result] = true;
      return result;
    };

    copyConstructorProperties(SymbolWrapper, NativeSymbol);
    var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
    symbolPrototype.constructor = SymbolWrapper;
    var symbolToString = symbolPrototype.toString;

    var _native = String(NativeSymbol('test')) == 'Symbol(test)';

    var regexp = /^Symbol\((.*)\)[^)]+$/;
    defineProperty$2(symbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        var symbol = isObject(this) ? this.valueOf() : this;
        var string = symbolToString.call(symbol);
        if (has(EmptyStringDescriptionStore, symbol)) return '';
        var desc = _native ? string.slice(7, -1) : string.replace(regexp, '$1');
        return desc === '' ? undefined : desc;
      }
    });
    _export({
      global: true,
      forced: true
    }, {
      Symbol: SymbolWrapper
    });
  }

  // https://tc39.github.io/ecma262/#sec-symbol.asynciterator

  defineWellKnownSymbol('asyncIterator');

  // https://tc39.github.io/ecma262/#sec-symbol.hasinstance

  defineWellKnownSymbol('hasInstance');

  // https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable

  defineWellKnownSymbol('isConcatSpreadable');

  // https://tc39.github.io/ecma262/#sec-symbol.iterator

  defineWellKnownSymbol('iterator');

  // https://tc39.github.io/ecma262/#sec-symbol.match

  defineWellKnownSymbol('match');

  defineWellKnownSymbol('matchAll');

  // https://tc39.github.io/ecma262/#sec-symbol.replace

  defineWellKnownSymbol('replace');

  // https://tc39.github.io/ecma262/#sec-symbol.search

  defineWellKnownSymbol('search');

  // https://tc39.github.io/ecma262/#sec-symbol.species

  defineWellKnownSymbol('species');

  // https://tc39.github.io/ecma262/#sec-symbol.split

  defineWellKnownSymbol('split');

  // https://tc39.github.io/ecma262/#sec-symbol.toprimitive

  defineWellKnownSymbol('toPrimitive');

  // https://tc39.github.io/ecma262/#sec-symbol.tostringtag

  defineWellKnownSymbol('toStringTag');

  // https://tc39.github.io/ecma262/#sec-symbol.unscopables

  defineWellKnownSymbol('unscopables');

  var createProperty = function createProperty(object, key, value) {
    var propertyKey = toPrimitive(key);
    if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
  };

  var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

  var process = global_1.process;
  var versions = process && process.versions;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    version = match[0] + match[1];
  } else if (engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);

    if (!match || match[1] >= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version && +version;

  var SPECIES$1 = wellKnownSymbol('species');

  var arrayMethodHasSpeciesSupport = function arrayMethodHasSpeciesSupport(METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return engineV8Version >= 51 || !fails(function () {
      var array = [];
      var constructor = array.constructor = {};

      constructor[SPECIES$1] = function () {
        return {
          foo: 1
        };
      };

      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679

  var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });
  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

  var isConcatSpreadable = function isConcatSpreadable(O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
  };

  var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species

  _export({
    target: 'Array',
    proto: true,
    forced: FORCED
  }, {
    concat: function concat(arg) {
      // eslint-disable-line no-unused-vars
      var O = toObject(this);
      var A = arraySpeciesCreate(O, 0);
      var n = 0;
      var i, k, length, len, E;

      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];

        if (isConcatSpreadable(E)) {
          len = toLength(E.length);
          if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

          for (k = 0; k < len; k++, n++) {
            if (k in E) createProperty(A, n, E[k]);
          }
        } else {
          if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty(A, n++, E);
        }
      }

      A.length = n;
      return A;
    }
  });

  var min$2 = Math.min; // `Array.prototype.copyWithin` method implementation
  // https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

  var arrayCopyWithin = [].copyWithin || function copyWithin(target
  /* = 0 */
  , start
  /* = 0, end = @length */
  ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;

    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }

    while (count-- > 0) {
      if (from in O) O[to] = O[from];else delete O[to];
      to += inc;
      from += inc;
    }

    return O;
  };

  var UNSCOPABLES = wellKnownSymbol('unscopables');
  var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  } // add a key to Array.prototype[@@unscopables]


  var addToUnscopables = function addToUnscopables(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  // https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

  _export({
    target: 'Array',
    proto: true
  }, {
    copyWithin: arrayCopyWithin
  }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables('copyWithin');

  var arrayMethodIsStrict = function arrayMethodIsStrict(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function () {
      // eslint-disable-next-line no-useless-call,no-throw-literal
      method.call(null, argument || function () {
        throw 1;
      }, 1);
    });
  };

  var defineProperty$3 = Object.defineProperty;
  var cache = {};

  var thrower = function thrower(it) {
    throw it;
  };

  var arrayMethodUsesToLength = function arrayMethodUsesToLength(METHOD_NAME, options) {
    if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
    if (!options) options = {};
    var method = [][METHOD_NAME];
    var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
    var argument0 = has(options, 0) ? options[0] : thrower;
    var argument1 = has(options, 1) ? options[1] : undefined;
    return cache[METHOD_NAME] = !!method && !fails(function () {
      if (ACCESSORS && !descriptors) return true;
      var O = {
        length: -1
      };
      if (ACCESSORS) defineProperty$3(O, 1, {
        enumerable: true,
        get: thrower
      });else O[1] = 1;
      method.call(O, argument0, argument1);
    });
  };

  var $every = arrayIteration.every;
  var STRICT_METHOD = arrayMethodIsStrict('every');
  var USES_TO_LENGTH = arrayMethodUsesToLength('every'); // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every

  _export({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD || !USES_TO_LENGTH
  }, {
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.github.io/ecma262/#sec-array.prototype.fill


  var arrayFill = function fill(value
  /* , start = 0, end = @length */
  ) {
    var O = toObject(this);
    var length = toLength(O.length);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

    while (endPos > index) {
      O[index++] = value;
    }

    return O;
  };

  // https://tc39.github.io/ecma262/#sec-array.prototype.fill

  _export({
    target: 'Array',
    proto: true
  }, {
    fill: arrayFill
  }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables('fill');

  var $filter = arrayIteration.filter;
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // Edge 14- issue

  var USES_TO_LENGTH$1 = arrayMethodUsesToLength('filter'); // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  // with adding support of @@species

  _export({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1
  }, {
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $find = arrayIteration.find;
  var FIND = 'find';
  var SKIPS_HOLES = true;
  var USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND); // Shouldn't skip holes

  if (FIND in []) Array(1)[FIND](function () {
    SKIPS_HOLES = false;
  }); // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find

  _export({
    target: 'Array',
    proto: true,
    forced: SKIPS_HOLES || !USES_TO_LENGTH$2
  }, {
    find: function find(callbackfn
    /* , that = undefined */
    ) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables(FIND);

  var $findIndex = arrayIteration.findIndex;
  var FIND_INDEX = 'findIndex';
  var SKIPS_HOLES$1 = true;
  var USES_TO_LENGTH$3 = arrayMethodUsesToLength(FIND_INDEX); // Shouldn't skip holes

  if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
    SKIPS_HOLES$1 = false;
  }); // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findindex

  _export({
    target: 'Array',
    proto: true,
    forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$3
  }, {
    findIndex: function findIndex(callbackfn
    /* , that = undefined */
    ) {
      return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables(FIND_INDEX);

  // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray


  var flattenIntoArray = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
    var element;

    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

        if (depth > 0 && isArray(element)) {
          targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
        } else {
          if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
          target[targetIndex] = element;
        }

        targetIndex++;
      }

      sourceIndex++;
    }

    return targetIndex;
  };

  var flattenIntoArray_1 = flattenIntoArray;

  // https://github.com/tc39/proposal-flatMap


  _export({
    target: 'Array',
    proto: true
  }, {
    flat: function flat()
    /* depthArg = 1 */
    {
      var depthArg = arguments.length ? arguments[0] : undefined;
      var O = toObject(this);
      var sourceLen = toLength(O.length);
      var A = arraySpeciesCreate(O, 0);
      A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
      return A;
    }
  });

  // https://github.com/tc39/proposal-flatMap


  _export({
    target: 'Array',
    proto: true
  }, {
    flatMap: function flatMap(callbackfn
    /* , thisArg */
    ) {
      var O = toObject(this);
      var sourceLen = toLength(O.length);
      var A;
      aFunction$1(callbackfn);
      A = arraySpeciesCreate(O, 0);
      A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      return A;
    }
  });

  var $forEach$1 = arrayIteration.forEach;
  var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');
  var USES_TO_LENGTH$4 = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach

  var arrayForEach = !STRICT_METHOD$1 || !USES_TO_LENGTH$4 ? function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  } : [].forEach;

  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach


  _export({
    target: 'Array',
    proto: true,
    forced: [].forEach != arrayForEach
  }, {
    forEach: arrayForEach
  });

  var callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
    } catch (error) {
      var returnMethod = iterator['return'];
      if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
      throw error;
    }
  };

  var iterators = {};

  var ITERATOR = wellKnownSymbol('iterator');
  var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

  var isArrayIteratorMethod = function isArrayIteratorMethod(it) {
    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR] === it);
  };

  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
  var test = {};
  test[TO_STRING_TAG$1] = 'z';
  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag'); // ES3 wrong here

  var CORRECT_ARGUMENTS = classofRaw(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function tryGet(it, key) {
    try {
      return it[key];
    } catch (error) {
      /* empty */
    }
  }; // getting tag from ES6+ `Object.prototype.toString`


  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
  };

  var ITERATOR$1 = wellKnownSymbol('iterator');

  var getIteratorMethod = function getIteratorMethod(it) {
    if (it != undefined) return it[ITERATOR$1] || it['@@iterator'] || iterators[classof(it)];
  };

  // https://tc39.github.io/ecma262/#sec-array.from


  var arrayFrom = function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var index = 0;
    var length, result, step, iterator, next, value;
    if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case

    if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
      iterator = iteratorMethod.call(O);
      next = iterator.next;
      result = new C();

      for (; !(step = next.call(iterator)).done; index++) {
        value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
        createProperty(result, index, value);
      }
    } else {
      length = toLength(O.length);
      result = new C(length);

      for (; length > index; index++) {
        value = mapping ? mapfn(O[index], index) : O[index];
        createProperty(result, index, value);
      }
    }

    result.length = index;
    return result;
  };

  var ITERATOR$2 = wellKnownSymbol('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function next() {
        return {
          done: !!called++
        };
      },
      'return': function _return() {
        SAFE_CLOSING = true;
      }
    };

    iteratorWithReturn[ITERATOR$2] = function () {
      return this;
    }; // eslint-disable-next-line no-throw-literal


    Array.from(iteratorWithReturn, function () {
      throw 2;
    });
  } catch (error) {
    /* empty */
  }

  var checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;

    try {
      var object = {};

      object[ITERATOR$2] = function () {
        return {
          next: function next() {
            return {
              done: ITERATION_SUPPORT = true
            };
          }
        };
      };

      exec(object);
    } catch (error) {
      /* empty */
    }

    return ITERATION_SUPPORT;
  };

  var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
    Array.from(iterable);
  }); // `Array.from` method
  // https://tc39.github.io/ecma262/#sec-array.from

  _export({
    target: 'Array',
    stat: true,
    forced: INCORRECT_ITERATION
  }, {
    from: arrayFrom
  });

  var $includes = arrayIncludes.includes;
  var USES_TO_LENGTH$5 = arrayMethodUsesToLength('indexOf', {
    ACCESSORS: true,
    1: 0
  }); // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes

  _export({
    target: 'Array',
    proto: true,
    forced: !USES_TO_LENGTH$5
  }, {
    includes: function includes(el
    /* , fromIndex = 0 */
    ) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables('includes');

  var $indexOf = arrayIncludes.indexOf;
  var nativeIndexOf = [].indexOf;
  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
  var STRICT_METHOD$2 = arrayMethodIsStrict('indexOf');
  var USES_TO_LENGTH$6 = arrayMethodUsesToLength('indexOf', {
    ACCESSORS: true,
    1: 0
  }); // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof

  _export({
    target: 'Array',
    proto: true,
    forced: NEGATIVE_ZERO || !STRICT_METHOD$2 || !USES_TO_LENGTH$6
  }, {
    indexOf: function indexOf(searchElement
    /* , fromIndex = 0 */
    ) {
      return NEGATIVE_ZERO // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.github.io/ecma262/#sec-array.isarray

  _export({
    target: 'Array',
    stat: true
  }, {
    isArray: isArray
  });

  var correctPrototypeGetter = !fails(function () {
    function F() {
      /* empty */
    }

    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var IE_PROTO$1 = sharedKey('IE_PROTO');
  var ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method
  // https://tc39.github.io/ecma262/#sec-object.getprototypeof

  var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }

    return O instanceof Object ? ObjectPrototype$1 : null;
  };

  var ITERATOR$3 = wellKnownSymbol('iterator');
  var BUGGY_SAFARI_ITERATORS = false;

  var returnThis = function returnThis() {
    return this;
  }; // `%IteratorPrototype%` object
  // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

  if ([].keys) {
    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
      PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }

  if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

  if ( !has(IteratorPrototype, ITERATOR$3)) {
    createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
  };

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

  var returnThis$1 = function returnThis() {
    return this;
  };

  var createIteratorConstructor = function createIteratorConstructor(IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
      next: createPropertyDescriptor(1, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
    iterators[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var aPossiblePrototype = function aPossiblePrototype(it) {
    if (!isObject(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + ' as a prototype');
    }

    return it;
  };

  // https://tc39.github.io/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.

  /* eslint-disable no-proto */

  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;

    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
      setter.call(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
      /* empty */
    }

    return function setPrototypeOf(O, proto) {
      anObject(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$4 = wellKnownSymbol('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis$2 = function returnThis() {
    return this;
  };

  var defineIterator = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function getIterationMethod(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };

        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };

        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }

      return function () {
        return new IteratorConstructor(this);
      };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY; // fix native

    if (anyNativeIterator) {
      CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

      if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
        if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
          if (objectSetPrototypeOf) {
            objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
            createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
          }
        } // Set @@toStringTag to native iterators


        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    } // fix Array#{values, @@iterator}.name in V8 / FF


    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      INCORRECT_VALUES_NAME = true;

      defaultIterator = function values() {
        return nativeIterator.call(this);
      };
    } // define iterator


    if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {
      createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
    }

    iterators[NAME] = defaultIterator; // export additional methods

    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine(IterablePrototype, KEY, methods[KEY]);
        }
      } else _export({
        target: NAME,
        proto: true,
        forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
      }, methods);
    }

    return methods;
  };

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$1 = internalState.set;
  var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.github.io/ecma262/#sec-createarrayiterator

  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState$1(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      // target
      index: 0,
      // next index
      kind: kind // kind

    }); // `%ArrayIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;

    if (!target || index >= target.length) {
      state.target = undefined;
      return {
        value: undefined,
        done: true
      };
    }

    if (kind == 'keys') return {
      value: index,
      done: false
    };
    if (kind == 'values') return {
      value: target[index],
      done: false
    };
    return {
      value: [index, target[index]],
      done: false
    };
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

  iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  var nativeJoin = [].join;
  var ES3_STRINGS = indexedObject != Object;
  var STRICT_METHOD$3 = arrayMethodIsStrict('join', ','); // `Array.prototype.join` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.join

  _export({
    target: 'Array',
    proto: true,
    forced: ES3_STRINGS || !STRICT_METHOD$3
  }, {
    join: function join(separator) {
      return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
  });

  var min$3 = Math.min;
  var nativeLastIndexOf = [].lastIndexOf;
  var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
  var STRICT_METHOD$4 = arrayMethodIsStrict('lastIndexOf'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

  var USES_TO_LENGTH$7 = arrayMethodUsesToLength('indexOf', {
    ACCESSORS: true,
    1: 0
  });
  var FORCED$1 = NEGATIVE_ZERO$1 || !STRICT_METHOD$4 || !USES_TO_LENGTH$7; // `Array.prototype.lastIndexOf` method implementation
  // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

  var arrayLastIndexOf = FORCED$1 ? function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO$1) return nativeLastIndexOf.apply(this, arguments) || 0;
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) {
      if (index in O && O[index] === searchElement) return index || 0;
    }

    return -1;
  } : nativeLastIndexOf;

  // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

  _export({
    target: 'Array',
    proto: true,
    forced: arrayLastIndexOf !== [].lastIndexOf
  }, {
    lastIndexOf: arrayLastIndexOf
  });

  var $map = arrayIteration.map;
  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map'); // FF49- issue

  var USES_TO_LENGTH$8 = arrayMethodUsesToLength('map'); // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  // with adding support of @@species

  _export({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$8
  }, {
    map: function map(callbackfn
    /* , thisArg */
    ) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var ISNT_GENERIC = fails(function () {
    function F() {
      /* empty */
    }

    return !(Array.of.call(F) instanceof F);
  }); // `Array.of` method
  // https://tc39.github.io/ecma262/#sec-array.of
  // WebKit Array.of isn't generic

  _export({
    target: 'Array',
    stat: true,
    forced: ISNT_GENERIC
  }, {
    of: function of()
    /* ...args */
    {
      var index = 0;
      var argumentsLength = arguments.length;
      var result = new (typeof this == 'function' ? this : Array)(argumentsLength);

      while (argumentsLength > index) {
        createProperty(result, index, arguments[index++]);
      }

      result.length = argumentsLength;
      return result;
    }
  });

  var createMethod$2 = function createMethod(IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aFunction$1(callbackfn);
      var O = toObject(that);
      var self = indexedObject(O);
      var length = toLength(O.length);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }

        index += i;

        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError('Reduce of empty array with no initial value');
        }
      }

      for (; IS_RIGHT ? index >= 0 : length > index; index += i) {
        if (index in self) {
          memo = callbackfn(memo, self[index], index, O);
        }
      }

      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
    left: createMethod$2(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
    right: createMethod$2(true)
  };

  var $reduce = arrayReduce.left;
  var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
  var USES_TO_LENGTH$9 = arrayMethodUsesToLength('reduce', {
    1: 0
  }); // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce

  _export({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9
  }, {
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $reduceRight = arrayReduce.right;
  var STRICT_METHOD$6 = arrayMethodIsStrict('reduceRight'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

  var USES_TO_LENGTH$a = arrayMethodUsesToLength('reduce', {
    1: 0
  }); // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright

  _export({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$6 || !USES_TO_LENGTH$a
  }, {
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var nativeReverse = [].reverse;
  var test$1 = [1, 2]; // `Array.prototype.reverse` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
  // fix for Safari 12.0 bug
  // https://bugs.webkit.org/show_bug.cgi?id=188794

  _export({
    target: 'Array',
    proto: true,
    forced: String(test$1) === String(test$1.reverse())
  }, {
    reverse: function reverse() {
      // eslint-disable-next-line no-self-assign
      if (isArray(this)) this.length = this.length;
      return nativeReverse.call(this);
    }
  });

  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
  var USES_TO_LENGTH$b = arrayMethodUsesToLength('slice', {
    ACCESSORS: true,
    0: 0,
    1: 2
  });
  var SPECIES$2 = wellKnownSymbol('species');
  var nativeSlice = [].slice;
  var max$1 = Math.max; // `Array.prototype.slice` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects

  _export({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$b
  }, {
    slice: function slice(start, end) {
      var O = toIndexedObject(this);
      var length = toLength(O.length);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

      var Constructor, result, n;

      if (isArray(O)) {
        Constructor = O.constructor; // cross-realm fallback

        if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject(Constructor)) {
          Constructor = Constructor[SPECIES$2];
          if (Constructor === null) Constructor = undefined;
        }

        if (Constructor === Array || Constructor === undefined) {
          return nativeSlice.call(O, k, fin);
        }
      }

      result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));

      for (n = 0; k < fin; k++, n++) {
        if (k in O) createProperty(result, n, O[k]);
      }

      result.length = n;
      return result;
    }
  });

  var $some = arrayIteration.some;
  var STRICT_METHOD$7 = arrayMethodIsStrict('some');
  var USES_TO_LENGTH$c = arrayMethodUsesToLength('some'); // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some

  _export({
    target: 'Array',
    proto: true,
    forced: !STRICT_METHOD$7 || !USES_TO_LENGTH$c
  }, {
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var test$2 = [];
  var nativeSort = test$2.sort; // IE8-

  var FAILS_ON_UNDEFINED = fails(function () {
    test$2.sort(undefined);
  }); // V8 bug

  var FAILS_ON_NULL = fails(function () {
    test$2.sort(null);
  }); // Old WebKit

  var STRICT_METHOD$8 = arrayMethodIsStrict('sort');
  var FORCED$2 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$8; // `Array.prototype.sort` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.sort

  _export({
    target: 'Array',
    proto: true,
    forced: FORCED$2
  }, {
    sort: function sort(comparefn) {
      return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction$1(comparefn));
    }
  });

  var SPECIES$3 = wellKnownSymbol('species');

  var setSpecies = function setSpecies(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = objectDefineProperty.f;

    if (descriptors && Constructor && !Constructor[SPECIES$3]) {
      defineProperty(Constructor, SPECIES$3, {
        configurable: true,
        get: function get() {
          return this;
        }
      });
    }
  };

  // https://tc39.github.io/ecma262/#sec-get-array-@@species

  setSpecies('Array');

  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
  var USES_TO_LENGTH$d = arrayMethodUsesToLength('splice', {
    ACCESSORS: true,
    0: 0,
    1: 2
  });
  var max$2 = Math.max;
  var min$4 = Math.min;
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.splice
  // with adding support of @@species

  _export({
    target: 'Array',
    proto: true,
    forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$d
  }, {
    splice: function splice(start, deleteCount
    /* , ...items */
    ) {
      var O = toObject(this);
      var len = toLength(O.length);
      var actualStart = toAbsoluteIndex(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;

      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min$4(max$2(toInteger(deleteCount), 0), len - actualStart);
      }

      if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
        throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }

      A = arraySpeciesCreate(O, actualDeleteCount);

      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }

      A.length = actualDeleteCount;

      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];else delete O[to];
        }

        for (k = len; k > len - actualDeleteCount + insertCount; k--) {
          delete O[k - 1];
        }
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];else delete O[to];
        }
      }

      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }

      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  // in popular engines, so it's moved to a separate module

  addToUnscopables('flat');

  // in popular engines, so it's moved to a separate module

  addToUnscopables('flatMap');

  var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

  var redefineAll = function redefineAll(target, src, options) {
    for (var key in src) {
      redefine(target, key, src[key], options);
    }

    return target;
  };

  var anInstance = function anInstance(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    }

    return it;
  };

  // https://tc39.github.io/ecma262/#sec-toindex

  var toIndex = function toIndex(it) {
    if (it === undefined) return 0;
    var number = toInteger(it);
    var length = toLength(number);
    if (number !== length) throw RangeError('Wrong length or index');
    return length;
  };

  // IEEE754 conversions based on https://github.com/feross/ieee754
  // eslint-disable-next-line no-shadow-restricted-names
  var Infinity$1 = 1 / 0;
  var abs = Math.abs;
  var pow = Math.pow;
  var floor$1 = Math.floor;
  var log = Math.log;
  var LN2 = Math.LN2;

  var pack = function pack(number, mantissaLength, bytes) {
    var buffer = new Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number); // eslint-disable-next-line no-self-compare

    if (number != number || number === Infinity$1) {
      // eslint-disable-next-line no-self-compare
      mantissa = number != number ? 1 : 0;
      exponent = eMax;
    } else {
      exponent = floor$1(log(number) / LN2);

      if (number * (c = pow(2, -exponent)) < 1) {
        exponent--;
        c *= 2;
      }

      if (exponent + eBias >= 1) {
        number += rt / c;
      } else {
        number += rt * pow(2, 1 - eBias);
      }

      if (number * c >= 2) {
        exponent++;
        c /= 2;
      }

      if (exponent + eBias >= eMax) {
        mantissa = 0;
        exponent = eMax;
      } else if (exponent + eBias >= 1) {
        mantissa = (number * c - 1) * pow(2, mantissaLength);
        exponent = exponent + eBias;
      } else {
        mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
        exponent = 0;
      }
    }

    for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8) {
    }

    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;

    for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8) {
    }

    buffer[--index] |= sign * 128;
    return buffer;
  };

  var unpack = function unpack(buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;

    for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8) {
    }

    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;

    for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8) {
    }

    if (exponent === 0) {
      exponent = 1 - eBias;
    } else if (exponent === eMax) {
      return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
    } else {
      mantissa = mantissa + pow(2, mantissaLength);
      exponent = exponent - eBias;
    }

    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
  };

  var ieee754 = {
    pack: pack,
    unpack: unpack
  };

  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var defineProperty$4 = objectDefineProperty.f;
  var getInternalState$2 = internalState.get;
  var setInternalState$2 = internalState.set;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var DATA_VIEW = 'DataView';
  var PROTOTYPE$2 = 'prototype';
  var WRONG_LENGTH = 'Wrong length';
  var WRONG_INDEX = 'Wrong index';
  var NativeArrayBuffer = global_1[ARRAY_BUFFER];
  var $ArrayBuffer = NativeArrayBuffer;
  var $DataView = global_1[DATA_VIEW];
  var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$2];
  var ObjectPrototype$2 = Object.prototype;
  var RangeError$1 = global_1.RangeError;
  var packIEEE754 = ieee754.pack;
  var unpackIEEE754 = ieee754.unpack;

  var packInt8 = function packInt8(number) {
    return [number & 0xFF];
  };

  var packInt16 = function packInt16(number) {
    return [number & 0xFF, number >> 8 & 0xFF];
  };

  var packInt32 = function packInt32(number) {
    return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
  };

  var unpackInt32 = function unpackInt32(buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
  };

  var packFloat32 = function packFloat32(number) {
    return packIEEE754(number, 23, 4);
  };

  var packFloat64 = function packFloat64(number) {
    return packIEEE754(number, 52, 8);
  };

  var addGetter = function addGetter(Constructor, key) {
    defineProperty$4(Constructor[PROTOTYPE$2], key, {
      get: function get() {
        return getInternalState$2(this)[key];
      }
    });
  };

  var get$1 = function get(view, count, index, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState$2(view);
    if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
    var bytes = getInternalState$2(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = bytes.slice(start, start + count);
    return isLittleEndian ? pack : pack.reverse();
  };

  var set$1 = function set(view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState$2(view);
    if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
    var bytes = getInternalState$2(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);

    for (var i = 0; i < count; i++) {
      bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
    }
  };

  if (!arrayBufferNative) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
      var byteLength = toIndex(length);
      setInternalState$2(this, {
        bytes: arrayFill.call(new Array(byteLength), 0),
        byteLength: byteLength
      });
      if (!descriptors) this.byteLength = byteLength;
    };

    $DataView = function DataView(buffer, byteOffset, byteLength) {
      anInstance(this, $DataView, DATA_VIEW);
      anInstance(buffer, $ArrayBuffer, DATA_VIEW);
      var bufferLength = getInternalState$2(buffer).byteLength;
      var offset = toInteger(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
      byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
      if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
      setInternalState$2(this, {
        buffer: buffer,
        byteLength: byteLength,
        byteOffset: offset
      });

      if (!descriptors) {
        this.buffer = buffer;
        this.byteLength = byteLength;
        this.byteOffset = offset;
      }
    };

    if (descriptors) {
      addGetter($ArrayBuffer, 'byteLength');
      addGetter($DataView, 'buffer');
      addGetter($DataView, 'byteLength');
      addGetter($DataView, 'byteOffset');
    }

    redefineAll($DataView[PROTOTYPE$2], {
      getInt8: function getInt8(byteOffset) {
        return get$1(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get$1(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset
      /* , littleEndian */
      ) {
        var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset
      /* , littleEndian */
      ) {
        var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset
      /* , littleEndian */
      ) {
        return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
      },
      getUint32: function getUint32(byteOffset
      /* , littleEndian */
      ) {
        return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset
      /* , littleEndian */
      ) {
        return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
      },
      getFloat64: function getFloat64(byteOffset
      /* , littleEndian */
      ) {
        return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
      },
      setInt8: function setInt8(byteOffset, value) {
        set$1(this, 1, byteOffset, packInt8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set$1(this, 1, byteOffset, packInt8, value);
      },
      setInt16: function setInt16(byteOffset, value
      /* , littleEndian */
      ) {
        set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint16: function setUint16(byteOffset, value
      /* , littleEndian */
      ) {
        set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setInt32: function setInt32(byteOffset, value
      /* , littleEndian */
      ) {
        set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint32: function setUint32(byteOffset, value
      /* , littleEndian */
      ) {
        set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat32: function setFloat32(byteOffset, value
      /* , littleEndian */
      ) {
        set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat64: function setFloat64(byteOffset, value
      /* , littleEndian */
      ) {
        set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
      }
    });
  } else {
    if (!fails(function () {
      NativeArrayBuffer(1);
    }) || !fails(function () {
      new NativeArrayBuffer(-1); // eslint-disable-line no-new
    }) || fails(function () {
      new NativeArrayBuffer(); // eslint-disable-line no-new

      new NativeArrayBuffer(1.5); // eslint-disable-line no-new

      new NativeArrayBuffer(NaN); // eslint-disable-line no-new

      return NativeArrayBuffer.name != ARRAY_BUFFER;
    })) {
      $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, $ArrayBuffer);
        return new NativeArrayBuffer(toIndex(length));
      };

      var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$2] = NativeArrayBuffer[PROTOTYPE$2];

      for (var keys$1 = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys$1.length > j;) {
        if (!((key = keys$1[j++]) in $ArrayBuffer)) {
          createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
        }
      }

      ArrayBufferPrototype.constructor = $ArrayBuffer;
    } // WebKit bug - the same parent prototype for typed arrays and data view


    if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
      objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
    } // iOS Safari 7.x bug


    var testView = new $DataView(new $ArrayBuffer(2));
    var nativeSetInt8 = $DataViewPrototype.setInt8;
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
      setInt8: function setInt8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
      }
    }, {
      unsafe: true
    });
  }

  setToStringTag($ArrayBuffer, ARRAY_BUFFER);
  setToStringTag($DataView, DATA_VIEW);
  var arrayBuffer = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
  };

  var ARRAY_BUFFER$1 = 'ArrayBuffer';
  var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
  var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1]; // `ArrayBuffer` constructor
  // https://tc39.github.io/ecma262/#sec-arraybuffer-constructor

  _export({
    global: true,
    forced: NativeArrayBuffer$1 !== ArrayBuffer$1
  }, {
    ArrayBuffer: ArrayBuffer$1
  });
  setSpecies(ARRAY_BUFFER$1);

  var defineProperty$5 = objectDefineProperty.f;
  var Int8Array$1 = global_1.Int8Array;
  var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
  var Uint8ClampedArray$1 = global_1.Uint8ClampedArray;
  var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
  var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
  var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
  var ObjectPrototype$3 = Object.prototype;
  var isPrototypeOf = ObjectPrototype$3.isPrototypeOf;
  var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
  var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
  var TYPED_ARRAY_TAG_REQIRED = false;
  var NAME;
  var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };

  var isView = function isView(it) {
    var klass = classof(it);
    return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
  };

  var isTypedArray = function isTypedArray(it) {
    return isObject(it) && has(TypedArrayConstructorsList, classof(it));
  };

  var aTypedArray = function aTypedArray(it) {
    if (isTypedArray(it)) return it;
    throw TypeError('Target is not a typed array');
  };

  var aTypedArrayConstructor = function aTypedArrayConstructor(C) {
    if (objectSetPrototypeOf) {
      if (isPrototypeOf.call(TypedArray, C)) return C;
    } else for (var ARRAY in TypedArrayConstructorsList) {
      if (has(TypedArrayConstructorsList, NAME)) {
        var TypedArrayConstructor = global_1[ARRAY];

        if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
          return C;
        }
      }
    }

    throw TypeError('Target is not a typed array constructor');
  };

  var exportTypedArrayMethod = function exportTypedArrayMethod(KEY, property, forced) {
    if (!descriptors) return;
    if (forced) for (var ARRAY in TypedArrayConstructorsList) {
      var TypedArrayConstructor = global_1[ARRAY];

      if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
        delete TypedArrayConstructor.prototype[KEY];
      }
    }

    if (!TypedArrayPrototype[KEY] || forced) {
      redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
    }
  };

  var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod(KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!descriptors) return;

    if (objectSetPrototypeOf) {
      if (forced) for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global_1[ARRAY];

        if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
          delete TypedArrayConstructor[KEY];
        }
      }

      if (!TypedArray[KEY] || forced) {
        // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
        try {
          return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
        } catch (error) {
          /* empty */
        }
      } else return;
    }

    for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];

      if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
        redefine(TypedArrayConstructor, KEY, property);
      }
    }
  };

  for (NAME in TypedArrayConstructorsList) {
    if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
  } // WebKit bug - typed arrays constructors prototype is Object.prototype


  if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
    // eslint-disable-next-line no-shadow
    TypedArray = function TypedArray() {
      throw TypeError('Incorrect invocation');
    };

    if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
      if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
    }
  }

  if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$3) {
    TypedArrayPrototype = TypedArray.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
      if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
    }
  } // WebKit bug - one more object in Uint8ClampedArray prototype chain


  if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
    objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
  }

  if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$3)) {
    TYPED_ARRAY_TAG_REQIRED = true;
    defineProperty$5(TypedArrayPrototype, TO_STRING_TAG$3, {
      get: function get() {
        return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
      }
    });

    for (NAME in TypedArrayConstructorsList) {
      if (global_1[NAME]) {
        createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
      }
    }
  }

  var arrayBufferViewCore = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
    aTypedArray: aTypedArray,
    aTypedArrayConstructor: aTypedArrayConstructor,
    exportTypedArrayMethod: exportTypedArrayMethod,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
    isView: isView,
    isTypedArray: isTypedArray,
    TypedArray: TypedArray,
    TypedArrayPrototype: TypedArrayPrototype
  };

  var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS; // `ArrayBuffer.isView` method
  // https://tc39.github.io/ecma262/#sec-arraybuffer.isview

  _export({
    target: 'ArrayBuffer',
    stat: true,
    forced: !NATIVE_ARRAY_BUFFER_VIEWS$1
  }, {
    isView: arrayBufferViewCore.isView
  });

  var SPECIES$4 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
  // https://tc39.github.io/ecma262/#sec-speciesconstructor

  var speciesConstructor = function speciesConstructor(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES$4]) == undefined ? defaultConstructor : aFunction$1(S);
  };

  var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
  var DataView$1 = arrayBuffer.DataView;
  var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;
  var INCORRECT_SLICE = fails(function () {
    return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
  }); // `ArrayBuffer.prototype.slice` method
  // https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice

  _export({
    target: 'ArrayBuffer',
    proto: true,
    unsafe: true,
    forced: INCORRECT_SLICE
  }, {
    slice: function slice(start, end) {
      if (nativeArrayBufferSlice !== undefined && end === undefined) {
        return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
      }

      var length = anObject(this).byteLength;
      var first = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
      var viewSource = new DataView$1(this);
      var viewTarget = new DataView$1(result);
      var index = 0;

      while (first < fin) {
        viewTarget.setUint8(index++, viewSource.getUint8(first++));
      }

      return result;
    }
  });

  // https://tc39.github.io/ecma262/#sec-dataview-constructor

  _export({
    global: true,
    forced: !arrayBufferNative
  }, {
    DataView: arrayBuffer.DataView
  });

  // https://tc39.github.io/ecma262/#sec-date.now

  _export({
    target: 'Date',
    stat: true
  }, {
    now: function now() {
      return new Date().getTime();
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.repeat


  var stringRepeat = ''.repeat || function repeat(count) {
    var str = String(requireObjectCoercible(this));
    var result = '';
    var n = toInteger(count);
    if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');

    for (; n > 0; (n >>>= 1) && (str += str)) {
      if (n & 1) result += str;
    }

    return result;
  };

  var ceil$1 = Math.ceil; // `String.prototype.{ padStart, padEnd }` methods implementation

  var createMethod$3 = function createMethod(IS_END) {
    return function ($this, maxLength, fillString) {
      var S = String(requireObjectCoercible($this));
      var stringLength = S.length;
      var fillStr = fillString === undefined ? ' ' : String(fillString);
      var intMaxLength = toLength(maxLength);
      var fillLen, stringFiller;
      if (intMaxLength <= stringLength || fillStr == '') return S;
      fillLen = intMaxLength - stringLength;
      stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
      if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
      return IS_END ? S + stringFiller : stringFiller + S;
    };
  };

  var stringPad = {
    // `String.prototype.padStart` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
    start: createMethod$3(false),
    // `String.prototype.padEnd` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.padend
    end: createMethod$3(true)
  };

  var padStart = stringPad.start;
  var abs$1 = Math.abs;
  var DatePrototype = Date.prototype;
  var getTime = DatePrototype.getTime;
  var nativeDateToISOString = DatePrototype.toISOString; // `Date.prototype.toISOString` method implementation
  // https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
  // PhantomJS / old WebKit fails here:

  var dateToIsoString = fails(function () {
    return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
  }) || !fails(function () {
    nativeDateToISOString.call(new Date(NaN));
  }) ? function toISOString() {
    if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
    var date = this;
    var year = date.getUTCFullYear();
    var milliseconds = date.getUTCMilliseconds();
    var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
    return sign + padStart(abs$1(year), sign ? 6 : 4, 0) + '-' + padStart(date.getUTCMonth() + 1, 2, 0) + '-' + padStart(date.getUTCDate(), 2, 0) + 'T' + padStart(date.getUTCHours(), 2, 0) + ':' + padStart(date.getUTCMinutes(), 2, 0) + ':' + padStart(date.getUTCSeconds(), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
  } : nativeDateToISOString;

  // https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
  // PhantomJS / old WebKit has a broken implementations

  _export({
    target: 'Date',
    proto: true,
    forced: Date.prototype.toISOString !== dateToIsoString
  }, {
    toISOString: dateToIsoString
  });

  var FORCED$3 = fails(function () {
    return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
      toISOString: function toISOString() {
        return 1;
      }
    }) !== 1;
  }); // `Date.prototype.toJSON` method
  // https://tc39.github.io/ecma262/#sec-date.prototype.tojson

  _export({
    target: 'Date',
    proto: true,
    forced: FORCED$3
  }, {
    // eslint-disable-next-line no-unused-vars
    toJSON: function toJSON(key) {
      var O = toObject(this);
      var pv = toPrimitive(O);
      return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
    }
  });

  var dateToPrimitive = function dateToPrimitive(hint) {
    if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
      throw TypeError('Incorrect hint');
    }

    return toPrimitive(anObject(this), hint !== 'number');
  };

  var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');
  var DatePrototype$1 = Date.prototype; // `Date.prototype[@@toPrimitive]` method
  // https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive

  if (!(TO_PRIMITIVE$1 in DatePrototype$1)) {
    createNonEnumerableProperty(DatePrototype$1, TO_PRIMITIVE$1, dateToPrimitive);
  }

  var DatePrototype$2 = Date.prototype;
  var INVALID_DATE = 'Invalid Date';
  var TO_STRING = 'toString';
  var nativeDateToString = DatePrototype$2[TO_STRING];
  var getTime$1 = DatePrototype$2.getTime; // `Date.prototype.toString` method
  // https://tc39.github.io/ecma262/#sec-date.prototype.tostring

  if (new Date(NaN) + '' != INVALID_DATE) {
    redefine(DatePrototype$2, TO_STRING, function toString() {
      var value = getTime$1.call(this); // eslint-disable-next-line no-self-compare

      return value === value ? nativeDateToString.call(this) : INVALID_DATE;
    });
  }

  var slice = [].slice;
  var factories = {};

  var construct = function construct(C, argsLength, args) {
    if (!(argsLength in factories)) {
      for (var list = [], i = 0; i < argsLength; i++) {
        list[i] = 'a[' + i + ']';
      } // eslint-disable-next-line no-new-func


      factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
    }

    return factories[argsLength](C, args);
  }; // `Function.prototype.bind` method implementation
  // https://tc39.github.io/ecma262/#sec-function.prototype.bind


  var functionBind = Function.bind || function bind(that
  /* , ...args */
  ) {
    var fn = aFunction$1(this);
    var partArgs = slice.call(arguments, 1);

    var boundFunction = function bound()
    /* args... */
    {
      var args = partArgs.concat(slice.call(arguments));
      return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
    };

    if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
    return boundFunction;
  };

  // https://tc39.github.io/ecma262/#sec-function.prototype.bind

  _export({
    target: 'Function',
    proto: true
  }, {
    bind: functionBind
  });

  var HAS_INSTANCE = wellKnownSymbol('hasInstance');
  var FunctionPrototype = Function.prototype; // `Function.prototype[@@hasInstance]` method
  // https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance

  if (!(HAS_INSTANCE in FunctionPrototype)) {
    objectDefineProperty.f(FunctionPrototype, HAS_INSTANCE, {
      value: function value(O) {
        if (typeof this != 'function' || !isObject(O)) return false;
        if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

        while (O = objectGetPrototypeOf(O)) {
          if (this.prototype === O) return true;
        }

        return false;
      }
    });
  }

  var defineProperty$6 = objectDefineProperty.f;
  var FunctionPrototype$1 = Function.prototype;
  var FunctionPrototypeToString = FunctionPrototype$1.toString;
  var nameRE = /^\s*function ([^ (]*)/;
  var NAME$1 = 'name'; // Function instances `.name` property
  // https://tc39.github.io/ecma262/#sec-function-instances-name

  if (descriptors && !(NAME$1 in FunctionPrototype$1)) {
    defineProperty$6(FunctionPrototype$1, NAME$1, {
      configurable: true,
      get: function get() {
        try {
          return FunctionPrototypeToString.call(this).match(nameRE)[1];
        } catch (error) {
          return '';
        }
      }
    });
  }

  // https://github.com/tc39/proposal-global

  _export({
    global: true
  }, {
    globalThis: global_1
  });

  var $stringify$1 = getBuiltIn('JSON', 'stringify');
  var re = /[\uD800-\uDFFF]/g;
  var low = /^[\uD800-\uDBFF]$/;
  var hi = /^[\uDC00-\uDFFF]$/;

  var fix = function fix(match, offset, string) {
    var prev = string.charAt(offset - 1);
    var next = string.charAt(offset + 1);

    if (low.test(match) && !hi.test(next) || hi.test(match) && !low.test(prev)) {
      return "\\u" + match.charCodeAt(0).toString(16);
    }

    return match;
  };

  var FORCED$4 = fails(function () {
    return $stringify$1("\uDF06\uD834") !== "\"\\udf06\\ud834\"" || $stringify$1("\uDEAD") !== "\"\\udead\"";
  });

  if ($stringify$1) {
    // https://github.com/tc39/proposal-well-formed-stringify
    _export({
      target: 'JSON',
      stat: true,
      forced: FORCED$4
    }, {
      // eslint-disable-next-line no-unused-vars
      stringify: function stringify(it, replacer, space) {
        var result = $stringify$1.apply(null, arguments);
        return typeof result == 'string' ? result.replace(re, fix) : result;
      }
    });
  }

  // https://tc39.github.io/ecma262/#sec-json-@@tostringtag

  setToStringTag(global_1.JSON, 'JSON', true);

  var freezing = !fails(function () {
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var internalMetadata = createCommonjsModule(function (module) {
    var defineProperty = objectDefineProperty.f;
    var METADATA = uid('meta');
    var id = 0;

    var isExtensible = Object.isExtensible || function () {
      return true;
    };

    var setMetadata = function setMetadata(it) {
      defineProperty(it, METADATA, {
        value: {
          objectID: 'O' + ++id,
          // object ID
          weakData: {} // weak collections IDs

        }
      });
    };

    var fastKey = function fastKey(it, create) {
      // return a primitive with prefix
      if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

      if (!has(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F'; // not necessary to add metadata

        if (!create) return 'E'; // add missing metadata

        setMetadata(it); // return object ID
      }

      return it[METADATA].objectID;
    };

    var getWeakData = function getWeakData(it, create) {
      if (!has(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true; // not necessary to add metadata

        if (!create) return false; // add missing metadata

        setMetadata(it); // return the store of weak collections IDs
      }

      return it[METADATA].weakData;
    }; // add metadata on freeze-family methods calling


    var onFreeze = function onFreeze(it) {
      if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
      return it;
    };

    var meta = module.exports = {
      REQUIRED: false,
      fastKey: fastKey,
      getWeakData: getWeakData,
      onFreeze: onFreeze
    };
    hiddenKeys[METADATA] = true;
  });

  var iterate_1 = createCommonjsModule(function (module) {
    var Result = function Result(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };

    var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
      var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
      var iterator, iterFn, index, length, result, next, step;

      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = toLength(iterable.length); length > index; index++) {
            result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
            if (result && result instanceof Result) return result;
          }

          return new Result(false);
        }

        iterator = iterFn.call(iterable);
      }

      next = iterator.next;

      while (!(step = next.call(iterator)).done) {
        result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
        if (_typeof(result) == 'object' && result && result instanceof Result) return result;
      }

      return new Result(false);
    };

    iterate.stop = function (result) {
      return new Result(true, result);
    };
  });

  var inheritIfRequired = function inheritIfRequired($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if ( // it can work only with native `setPrototypeOf`
    objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
    return $this;
  };

  var collection = function collection(CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global_1[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var Constructor = NativeConstructor;
    var exported = {};

    var fixMethod = function fixMethod(KEY) {
      var nativeMethod = NativePrototype[KEY];
      redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      });
    }; // eslint-disable-next-line max-len


    if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    })))) {
      // create collection constructor
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      internalMetadata.REQUIRED = true;
    } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
      var instance = new Constructor(); // early implementations not supports chaining

      var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

      var THROWS_ON_PRIMITIVES = fails(function () {
        instance.has(1);
      }); // most early implementations doesn't supports iterables, most modern - not close it correctly
      // eslint-disable-next-line no-new

      var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
        new NativeConstructor(iterable);
      }); // for early implementations -0 and +0 not the same

      var BUGGY_ZERO = !IS_WEAK && fails(function () {
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new NativeConstructor();
        var index = 5;

        while (index--) {
          $instance[ADDER](index, index);
        }

        return !$instance.has(-0);
      });

      if (!ACCEPT_ITERABLES) {
        Constructor = wrapper(function (dummy, iterable) {
          anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
          var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
          if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
          return that;
        });
        Constructor.prototype = NativePrototype;
        NativePrototype.constructor = Constructor;
      }

      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }

      if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

      if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
    }

    exported[CONSTRUCTOR_NAME] = Constructor;
    _export({
      global: true,
      forced: Constructor != NativeConstructor
    }, exported);
    setToStringTag(Constructor, CONSTRUCTOR_NAME);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
  };

  var defineProperty$7 = objectDefineProperty.f;
  var fastKey = internalMetadata.fastKey;
  var setInternalState$3 = internalState.set;
  var internalStateGetterFor = internalState.getterFor;
  var collectionStrong = {
    getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        anInstance(that, C, CONSTRUCTOR_NAME);
        setInternalState$3(that, {
          type: CONSTRUCTOR_NAME,
          index: objectCreate(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!descriptors) that.size = 0;
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
      });
      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

      var define = function define(that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index; // change existing entry

        if (entry) {
          entry.value = value; // create new entry
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key: key,
            value: value,
            previous: previous = state.last,
            next: undefined,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (descriptors) state.size++;else that.size++; // add to index

          if (index !== 'F') state.index[index] = entry;
        }

        return that;
      };

      var getEntry = function getEntry(that, key) {
        var state = getInternalState(that); // fast case

        var index = fastKey(key);
        var entry;
        if (index !== 'F') return state.index[index]; // frozen object case

        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key == key) return entry;
        }
      };

      redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var data = state.index;
          var entry = state.first;

          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = undefined;
            delete data[entry.index];
            entry = entry.next;
          }

          state.first = state.last = undefined;
          if (descriptors) state.size = 0;else that.size = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function _delete(key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);

          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first == entry) state.first = next;
            if (state.last == entry) state.last = prev;
            if (descriptors) state.size--;else that.size--;
          }

          return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn
        /* , that = undefined */
        ) {
          var state = getInternalState(this);
          var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;

          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this); // revert to the last existing entry

            while (entry && entry.removed) {
              entry = entry.previous;
            }
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      redefineAll(C.prototype, IS_MAP ? {
        // 23.1.3.6 Map.prototype.get(key)
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function set(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // 23.2.3.1 Set.prototype.add(value)
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (descriptors) defineProperty$7(C.prototype, 'size', {
        get: function get() {
          return getInternalState(this).size;
        }
      });
      return C;
    },
    setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

      defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
        setInternalState$3(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind: kind,
          last: undefined
        });
      }, function () {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last; // revert to the last existing entry

        while (entry && entry.removed) {
          entry = entry.previous;
        } // get next entry


        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          // or finish the iteration
          state.target = undefined;
          return {
            value: undefined,
            done: true
          };
        } // return step by kind


        if (kind == 'keys') return {
          value: entry.key,
          done: false
        };
        if (kind == 'values') return {
          value: entry.value,
          done: false
        };
        return {
          value: [entry.key, entry.value],
          done: false
        };
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

      setSpecies(CONSTRUCTOR_NAME);
    }
  };

  // https://tc39.github.io/ecma262/#sec-map-objects


  var es_map = collection('Map', function (init) {
    return function Map() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong);

  var log$1 = Math.log; // `Math.log1p` method implementation
  // https://tc39.github.io/ecma262/#sec-math.log1p

  var mathLog1p = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$1(1 + x);
  };

  var nativeAcosh = Math.acosh;
  var log$2 = Math.log;
  var sqrt = Math.sqrt;
  var LN2$1 = Math.LN2;
  var FORCED$5 = !nativeAcosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
  || nativeAcosh(Infinity) != Infinity; // `Math.acosh` method
  // https://tc39.github.io/ecma262/#sec-math.acosh

  _export({
    target: 'Math',
    stat: true,
    forced: FORCED$5
  }, {
    acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log$2(x) + LN2$1 : mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }
  });

  var nativeAsinh = Math.asinh;
  var log$3 = Math.log;
  var sqrt$1 = Math.sqrt;

  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$3(x + sqrt$1(x * x + 1));
  } // `Math.asinh` method
  // https://tc39.github.io/ecma262/#sec-math.asinh
  // Tor Browser bug: Math.asinh(0) -> -0


  _export({
    target: 'Math',
    stat: true,
    forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0)
  }, {
    asinh: asinh
  });

  var nativeAtanh = Math.atanh;
  var log$4 = Math.log; // `Math.atanh` method
  // https://tc39.github.io/ecma262/#sec-math.atanh
  // Tor Browser bug: Math.atanh(-0) -> 0

  _export({
    target: 'Math',
    stat: true,
    forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0)
  }, {
    atanh: function atanh(x) {
      return (x = +x) == 0 ? x : log$4((1 + x) / (1 - x)) / 2;
    }
  });

  // `Math.sign` method implementation
  // https://tc39.github.io/ecma262/#sec-math.sign
  var mathSign = Math.sign || function sign(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };

  var abs$2 = Math.abs;
  var pow$1 = Math.pow; // `Math.cbrt` method
  // https://tc39.github.io/ecma262/#sec-math.cbrt

  _export({
    target: 'Math',
    stat: true
  }, {
    cbrt: function cbrt(x) {
      return mathSign(x = +x) * pow$1(abs$2(x), 1 / 3);
    }
  });

  var floor$2 = Math.floor;
  var log$5 = Math.log;
  var LOG2E = Math.LOG2E; // `Math.clz32` method
  // https://tc39.github.io/ecma262/#sec-math.clz32

  _export({
    target: 'Math',
    stat: true
  }, {
    clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - floor$2(log$5(x + 0.5) * LOG2E) : 32;
    }
  });

  var nativeExpm1 = Math.expm1;
  var exp = Math.exp; // `Math.expm1` method implementation
  // https://tc39.github.io/ecma262/#sec-math.expm1

  var mathExpm1 = !nativeExpm1 // Old FF bug
  || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168 // Tor Browser bug
  || nativeExpm1(-2e-17) != -2e-17 ? function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  } : nativeExpm1;

  var nativeCosh = Math.cosh;
  var abs$3 = Math.abs;
  var E = Math.E; // `Math.cosh` method
  // https://tc39.github.io/ecma262/#sec-math.cosh

  _export({
    target: 'Math',
    stat: true,
    forced: !nativeCosh || nativeCosh(710) === Infinity
  }, {
    cosh: function cosh(x) {
      var t = mathExpm1(abs$3(x) - 1) + 1;
      return (t + 1 / (t * E * E)) * (E / 2);
    }
  });

  // https://tc39.github.io/ecma262/#sec-math.expm1

  _export({
    target: 'Math',
    stat: true,
    forced: mathExpm1 != Math.expm1
  }, {
    expm1: mathExpm1
  });

  var abs$4 = Math.abs;
  var pow$2 = Math.pow;
  var EPSILON = pow$2(2, -52);
  var EPSILON32 = pow$2(2, -23);
  var MAX32 = pow$2(2, 127) * (2 - EPSILON32);
  var MIN32 = pow$2(2, -126);

  var roundTiesToEven = function roundTiesToEven(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  }; // `Math.fround` method implementation
  // https://tc39.github.io/ecma262/#sec-math.fround


  var mathFround = Math.fround || function fround(x) {
    var $abs = abs$4(x);
    var $sign = mathSign(x);
    var a, result;
    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs); // eslint-disable-next-line no-self-compare

    if (result > MAX32 || result != result) return $sign * Infinity;
    return $sign * result;
  };

  // https://tc39.github.io/ecma262/#sec-math.fround

  _export({
    target: 'Math',
    stat: true
  }, {
    fround: mathFround
  });

  var $hypot = Math.hypot;
  var abs$5 = Math.abs;
  var sqrt$2 = Math.sqrt; // Chrome 77 bug
  // https://bugs.chromium.org/p/v8/issues/detail?id=9546

  var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
  // https://tc39.github.io/ecma262/#sec-math.hypot

  _export({
    target: 'Math',
    stat: true,
    forced: BUGGY
  }, {
    hypot: function hypot(value1, value2) {
      // eslint-disable-line no-unused-vars
      var sum = 0;
      var i = 0;
      var aLen = arguments.length;
      var larg = 0;
      var arg, div;

      while (i < aLen) {
        arg = abs$5(arguments[i++]);

        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else sum += arg;
      }

      return larg === Infinity ? Infinity : larg * sqrt$2(sum);
    }
  });

  var nativeImul = Math.imul;
  var FORCED$6 = fails(function () {
    return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
  }); // `Math.imul` method
  // https://tc39.github.io/ecma262/#sec-math.imul
  // some WebKit versions fails with big numbers, some has wrong arity

  _export({
    target: 'Math',
    stat: true,
    forced: FORCED$6
  }, {
    imul: function imul(x, y) {
      var UINT16 = 0xFFFF;
      var xn = +x;
      var yn = +y;
      var xl = UINT16 & xn;
      var yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
  });

  var log$6 = Math.log;
  var LOG10E = Math.LOG10E; // `Math.log10` method
  // https://tc39.github.io/ecma262/#sec-math.log10

  _export({
    target: 'Math',
    stat: true
  }, {
    log10: function log10(x) {
      return log$6(x) * LOG10E;
    }
  });

  // https://tc39.github.io/ecma262/#sec-math.log1p

  _export({
    target: 'Math',
    stat: true
  }, {
    log1p: mathLog1p
  });

  var log$7 = Math.log;
  var LN2$2 = Math.LN2; // `Math.log2` method
  // https://tc39.github.io/ecma262/#sec-math.log2

  _export({
    target: 'Math',
    stat: true
  }, {
    log2: function log2(x) {
      return log$7(x) / LN2$2;
    }
  });

  // https://tc39.github.io/ecma262/#sec-math.sign

  _export({
    target: 'Math',
    stat: true
  }, {
    sign: mathSign
  });

  var abs$6 = Math.abs;
  var exp$1 = Math.exp;
  var E$1 = Math.E;
  var FORCED$7 = fails(function () {
    return Math.sinh(-2e-17) != -2e-17;
  }); // `Math.sinh` method
  // https://tc39.github.io/ecma262/#sec-math.sinh
  // V8 near Chromium 38 has a problem with very small numbers

  _export({
    target: 'Math',
    stat: true,
    forced: FORCED$7
  }, {
    sinh: function sinh(x) {
      return abs$6(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E$1 / 2);
    }
  });

  var exp$2 = Math.exp; // `Math.tanh` method
  // https://tc39.github.io/ecma262/#sec-math.tanh

  _export({
    target: 'Math',
    stat: true
  }, {
    tanh: function tanh(x) {
      var a = mathExpm1(x = +x);
      var b = mathExpm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
    }
  });

  // https://tc39.github.io/ecma262/#sec-math-@@tostringtag

  setToStringTag(Math, 'Math', true);

  var ceil$2 = Math.ceil;
  var floor$3 = Math.floor; // `Math.trunc` method
  // https://tc39.github.io/ecma262/#sec-math.trunc

  _export({
    target: 'Math',
    stat: true
  }, {
    trunc: function trunc(it) {
      return (it > 0 ? floor$3 : ceil$2)(it);
    }
  });

  // a string of all valid unicode whitespaces
  // eslint-disable-next-line max-len
  var whitespaces = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

  var whitespace = '[' + whitespaces + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

  var createMethod$4 = function createMethod(TYPE) {
    return function ($this) {
      var string = String(requireObjectCoercible($this));
      if (TYPE & 1) string = string.replace(ltrim, '');
      if (TYPE & 2) string = string.replace(rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
    start: createMethod$4(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
    end: createMethod$4(2),
    // `String.prototype.trim` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.trim
    trim: createMethod$4(3)
  };

  var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var defineProperty$8 = objectDefineProperty.f;
  var trim = stringTrim.trim;
  var NUMBER = 'Number';
  var NativeNumber = global_1[NUMBER];
  var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

  var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
  // https://tc39.github.io/ecma262/#sec-tonumber

  var toNumber = function toNumber(argument) {
    var it = toPrimitive(argument, false);
    var first, third, radix, maxCode, digits, length, index, code;

    if (typeof it == 'string' && it.length > 2) {
      it = trim(it);
      first = it.charCodeAt(0);

      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66:
          case 98:
            radix = 2;
            maxCode = 49;
            break;
          // fast equal of /^0b[01]+$/i

          case 79:
          case 111:
            radix = 8;
            maxCode = 55;
            break;
          // fast equal of /^0o[0-7]+$/i

          default:
            return +it;
        }

        digits = it.slice(2);
        length = digits.length;

        for (index = 0; index < length; index++) {
          code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
          // but ToNumber should return NaN if a string contains unavailable symbols

          if (code < 48 || code > maxCode) return NaN;
        }

        return parseInt(digits, radix);
      }
    }

    return +it;
  }; // `Number` constructor
  // https://tc39.github.io/ecma262/#sec-number-constructor


  if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
    var NumberWrapper = function Number(value) {
      var it = arguments.length < 1 ? 0 : value;
      var dummy = this;
      return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () {
        NumberPrototype.valueOf.call(dummy);
      }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
    };

    for (var keys$2 = descriptors ? getOwnPropertyNames$1(NativeNumber) : ( // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key$1; keys$2.length > j$1; j$1++) {
      if (has(NativeNumber, key$1 = keys$2[j$1]) && !has(NumberWrapper, key$1)) {
        defineProperty$8(NumberWrapper, key$1, getOwnPropertyDescriptor$2(NativeNumber, key$1));
      }
    }

    NumberWrapper.prototype = NumberPrototype;
    NumberPrototype.constructor = NumberWrapper;
    redefine(global_1, NUMBER, NumberWrapper);
  }

  // https://tc39.github.io/ecma262/#sec-number.epsilon

  _export({
    target: 'Number',
    stat: true
  }, {
    EPSILON: Math.pow(2, -52)
  });

  var globalIsFinite = global_1.isFinite; // `Number.isFinite` method
  // https://tc39.github.io/ecma262/#sec-number.isfinite

  var numberIsFinite = Number.isFinite || function isFinite(it) {
    return typeof it == 'number' && globalIsFinite(it);
  };

  // https://tc39.github.io/ecma262/#sec-number.isfinite

  _export({
    target: 'Number',
    stat: true
  }, {
    isFinite: numberIsFinite
  });

  var floor$4 = Math.floor; // `Number.isInteger` method implementation
  // https://tc39.github.io/ecma262/#sec-number.isinteger

  var isInteger = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor$4(it) === it;
  };

  // https://tc39.github.io/ecma262/#sec-number.isinteger

  _export({
    target: 'Number',
    stat: true
  }, {
    isInteger: isInteger
  });

  // https://tc39.github.io/ecma262/#sec-number.isnan

  _export({
    target: 'Number',
    stat: true
  }, {
    isNaN: function isNaN(number) {
      // eslint-disable-next-line no-self-compare
      return number != number;
    }
  });

  var abs$7 = Math.abs; // `Number.isSafeInteger` method
  // https://tc39.github.io/ecma262/#sec-number.issafeinteger

  _export({
    target: 'Number',
    stat: true
  }, {
    isSafeInteger: function isSafeInteger(number) {
      return isInteger(number) && abs$7(number) <= 0x1FFFFFFFFFFFFF;
    }
  });

  // https://tc39.github.io/ecma262/#sec-number.max_safe_integer

  _export({
    target: 'Number',
    stat: true
  }, {
    MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
  });

  // https://tc39.github.io/ecma262/#sec-number.min_safe_integer

  _export({
    target: 'Number',
    stat: true
  }, {
    MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
  });

  var trim$1 = stringTrim.trim;
  var $parseFloat = global_1.parseFloat;
  var FORCED$8 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
  // https://tc39.github.io/ecma262/#sec-parsefloat-string

  var numberParseFloat = FORCED$8 ? function parseFloat(string) {
    var trimmedString = trim$1(String(string));
    var result = $parseFloat(trimmedString);
    return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  // https://tc39.github.io/ecma262/#sec-number.parseFloat

  _export({
    target: 'Number',
    stat: true,
    forced: Number.parseFloat != numberParseFloat
  }, {
    parseFloat: numberParseFloat
  });

  var trim$2 = stringTrim.trim;
  var $parseInt = global_1.parseInt;
  var hex = /^[+-]?0[Xx]/;
  var FORCED$9 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method
  // https://tc39.github.io/ecma262/#sec-parseint-string-radix

  var numberParseInt = FORCED$9 ? function parseInt(string, radix) {
    var S = trim$2(String(string));
    return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
  } : $parseInt;

  // https://tc39.github.io/ecma262/#sec-number.parseint

  _export({
    target: 'Number',
    stat: true,
    forced: Number.parseInt != numberParseInt
  }, {
    parseInt: numberParseInt
  });

  // https://tc39.github.io/ecma262/#sec-thisnumbervalue

  var thisNumberValue = function thisNumberValue(value) {
    if (typeof value != 'number' && classofRaw(value) != 'Number') {
      throw TypeError('Incorrect invocation');
    }

    return +value;
  };

  var nativeToFixed = 1.0.toFixed;
  var floor$5 = Math.floor;

  var pow$3 = function pow(x, n, acc) {
    return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
  };

  var log$8 = function log(x) {
    var n = 0;
    var x2 = x;

    while (x2 >= 4096) {
      n += 12;
      x2 /= 4096;
    }

    while (x2 >= 2) {
      n += 1;
      x2 /= 2;
    }

    return n;
  };

  var FORCED$a = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
    // V8 ~ Android 4.3-
    nativeToFixed.call({});
  }); // `Number.prototype.toFixed` method
  // https://tc39.github.io/ecma262/#sec-number.prototype.tofixed

  _export({
    target: 'Number',
    proto: true,
    forced: FORCED$a
  }, {
    // eslint-disable-next-line max-statements
    toFixed: function toFixed(fractionDigits) {
      var number = thisNumberValue(this);
      var fractDigits = toInteger(fractionDigits);
      var data = [0, 0, 0, 0, 0, 0];
      var sign = '';
      var result = '0';
      var e, z, j, k;

      var multiply = function multiply(n, c) {
        var index = -1;
        var c2 = c;

        while (++index < 6) {
          c2 += n * data[index];
          data[index] = c2 % 1e7;
          c2 = floor$5(c2 / 1e7);
        }
      };

      var divide = function divide(n) {
        var index = 6;
        var c = 0;

        while (--index >= 0) {
          c += data[index];
          data[index] = floor$5(c / n);
          c = c % n * 1e7;
        }
      };

      var dataToString = function dataToString() {
        var index = 6;
        var s = '';

        while (--index >= 0) {
          if (s !== '' || index === 0 || data[index] !== 0) {
            var t = String(data[index]);
            s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
          }
        }

        return s;
      };

      if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits'); // eslint-disable-next-line no-self-compare

      if (number != number) return 'NaN';
      if (number <= -1e21 || number >= 1e21) return String(number);

      if (number < 0) {
        sign = '-';
        number = -number;
      }

      if (number > 1e-21) {
        e = log$8(number * pow$3(2, 69, 1)) - 69;
        z = e < 0 ? number * pow$3(2, -e, 1) : number / pow$3(2, e, 1);
        z *= 0x10000000000000;
        e = 52 - e;

        if (e > 0) {
          multiply(0, z);
          j = fractDigits;

          while (j >= 7) {
            multiply(1e7, 0);
            j -= 7;
          }

          multiply(pow$3(10, j, 1), 0);
          j = e - 1;

          while (j >= 23) {
            divide(1 << 23);
            j -= 23;
          }

          divide(1 << j);
          multiply(1, 1);
          divide(2);
          result = dataToString();
        } else {
          multiply(0, z);
          multiply(1 << -e, 0);
          result = dataToString() + stringRepeat.call('0', fractDigits);
        }
      }

      if (fractDigits > 0) {
        k = result.length;
        result = sign + (k <= fractDigits ? '0.' + stringRepeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
      } else {
        result = sign + result;
      }

      return result;
    }
  });

  var nativeToPrecision = 1.0.toPrecision;
  var FORCED$b = fails(function () {
    // IE7-
    return nativeToPrecision.call(1, undefined) !== '1';
  }) || !fails(function () {
    // V8 ~ Android 4.3-
    nativeToPrecision.call({});
  }); // `Number.prototype.toPrecision` method
  // https://tc39.github.io/ecma262/#sec-number.prototype.toprecision

  _export({
    target: 'Number',
    proto: true,
    forced: FORCED$b
  }, {
    toPrecision: function toPrecision(precision) {
      return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
    }
  });

  var nativeAssign = Object.assign;
  var defineProperty$9 = Object.defineProperty; // `Object.assign` method
  // https://tc39.github.io/ecma262/#sec-object.assign

  var objectAssign = !nativeAssign || fails(function () {
    // should have correct order of operations (Edge bug)
    if (descriptors && nativeAssign({
      b: 1
    }, nativeAssign(defineProperty$9({}, 'a', {
      enumerable: true,
      get: function get() {
        defineProperty$9(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), {
      b: 2
    })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

    var A = {};
    var B = {}; // eslint-disable-next-line no-undef

    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) {
      B[chr] = chr;
    });
    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    var propertyIsEnumerable = objectPropertyIsEnumerable.f;

    while (argumentsLength > index) {
      var S = indexedObject(arguments[index++]);
      var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;

      while (length > j) {
        key = keys[j++];
        if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
      }
    }

    return T;
  } : nativeAssign;

  // https://tc39.github.io/ecma262/#sec-object.assign

  _export({
    target: 'Object',
    stat: true,
    forced: Object.assign !== objectAssign
  }, {
    assign: objectAssign
  });

  // https://tc39.github.io/ecma262/#sec-object.create

  _export({
    target: 'Object',
    stat: true,
    sham: !descriptors
  }, {
    create: objectCreate
  });

  var objectPrototypeAccessorsForced =  !fails(function () {
    var key = Math.random(); // In FF throws only define methods
    // eslint-disable-next-line no-undef, no-useless-call

    __defineSetter__.call(null, key, function () {
      /* empty */
    });

    delete global_1[key];
  });

  // https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__


  if (descriptors) {
    _export({
      target: 'Object',
      proto: true,
      forced: objectPrototypeAccessorsForced
    }, {
      __defineGetter__: function __defineGetter__(P, getter) {
        objectDefineProperty.f(toObject(this), P, {
          get: aFunction$1(getter),
          enumerable: true,
          configurable: true
        });
      }
    });
  }

  // https://tc39.github.io/ecma262/#sec-object.defineproperties

  _export({
    target: 'Object',
    stat: true,
    forced: !descriptors,
    sham: !descriptors
  }, {
    defineProperties: objectDefineProperties
  });

  // https://tc39.github.io/ecma262/#sec-object.defineproperty

  _export({
    target: 'Object',
    stat: true,
    forced: !descriptors,
    sham: !descriptors
  }, {
    defineProperty: objectDefineProperty.f
  });

  // https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__


  if (descriptors) {
    _export({
      target: 'Object',
      proto: true,
      forced: objectPrototypeAccessorsForced
    }, {
      __defineSetter__: function __defineSetter__(P, setter) {
        objectDefineProperty.f(toObject(this), P, {
          set: aFunction$1(setter),
          enumerable: true,
          configurable: true
        });
      }
    });
  }

  var propertyIsEnumerable = objectPropertyIsEnumerable.f; // `Object.{ entries, values }` methods implementation

  var createMethod$5 = function createMethod(TO_ENTRIES) {
    return function (it) {
      var O = toIndexedObject(it);
      var keys = objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;

      while (length > i) {
        key = keys[i++];

        if (!descriptors || propertyIsEnumerable.call(O, key)) {
          result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
        }
      }

      return result;
    };
  };

  var objectToArray = {
    // `Object.entries` method
    // https://tc39.github.io/ecma262/#sec-object.entries
    entries: createMethod$5(true),
    // `Object.values` method
    // https://tc39.github.io/ecma262/#sec-object.values
    values: createMethod$5(false)
  };

  var $entries = objectToArray.entries; // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries

  _export({
    target: 'Object',
    stat: true
  }, {
    entries: function entries(O) {
      return $entries(O);
    }
  });

  var onFreeze = internalMetadata.onFreeze;
  var nativeFreeze = Object.freeze;
  var FAILS_ON_PRIMITIVES = fails(function () {
    nativeFreeze(1);
  }); // `Object.freeze` method
  // https://tc39.github.io/ecma262/#sec-object.freeze

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES,
    sham: !freezing
  }, {
    freeze: function freeze(it) {
      return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
    }
  });

  // https://github.com/tc39/proposal-object-from-entries

  _export({
    target: 'Object',
    stat: true
  }, {
    fromEntries: function fromEntries(iterable) {
      var obj = {};
      iterate_1(iterable, function (k, v) {
        createProperty(obj, k, v);
      }, undefined, true);
      return obj;
    }
  });

  var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var FAILS_ON_PRIMITIVES$1 = fails(function () {
    nativeGetOwnPropertyDescriptor$2(1);
  });
  var FORCED$c = !descriptors || FAILS_ON_PRIMITIVES$1; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

  _export({
    target: 'Object',
    stat: true,
    forced: FORCED$c,
    sham: !descriptors
  }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
      return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
    }
  });

  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors

  _export({
    target: 'Object',
    stat: true,
    sham: !descriptors
  }, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIndexedObject(object);
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
      var keys = ownKeys(O);
      var result = {};
      var index = 0;
      var key, descriptor;

      while (keys.length > index) {
        descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
        if (descriptor !== undefined) createProperty(result, key, descriptor);
      }

      return result;
    }
  });

  var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
  var FAILS_ON_PRIMITIVES$2 = fails(function () {
    return !Object.getOwnPropertyNames(1);
  }); // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$2
  }, {
    getOwnPropertyNames: nativeGetOwnPropertyNames$2
  });

  var FAILS_ON_PRIMITIVES$3 = fails(function () {
    objectGetPrototypeOf(1);
  }); // `Object.getPrototypeOf` method
  // https://tc39.github.io/ecma262/#sec-object.getprototypeof

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$3,
    sham: !correctPrototypeGetter
  }, {
    getPrototypeOf: function getPrototypeOf(it) {
      return objectGetPrototypeOf(toObject(it));
    }
  });

  // `SameValue` abstract operation
  // https://tc39.github.io/ecma262/#sec-samevalue
  var sameValue = Object.is || function is(x, y) {
    // eslint-disable-next-line no-self-compare
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };

  // https://tc39.github.io/ecma262/#sec-object.is

  _export({
    target: 'Object',
    stat: true
  }, {
    is: sameValue
  });

  var nativeIsExtensible = Object.isExtensible;
  var FAILS_ON_PRIMITIVES$4 = fails(function () {
    nativeIsExtensible(1);
  }); // `Object.isExtensible` method
  // https://tc39.github.io/ecma262/#sec-object.isextensible

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$4
  }, {
    isExtensible: function isExtensible(it) {
      return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
    }
  });

  var nativeIsFrozen = Object.isFrozen;
  var FAILS_ON_PRIMITIVES$5 = fails(function () {
    nativeIsFrozen(1);
  }); // `Object.isFrozen` method
  // https://tc39.github.io/ecma262/#sec-object.isfrozen

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$5
  }, {
    isFrozen: function isFrozen(it) {
      return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
    }
  });

  var nativeIsSealed = Object.isSealed;
  var FAILS_ON_PRIMITIVES$6 = fails(function () {
    nativeIsSealed(1);
  }); // `Object.isSealed` method
  // https://tc39.github.io/ecma262/#sec-object.issealed

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$6
  }, {
    isSealed: function isSealed(it) {
      return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
    }
  });

  var FAILS_ON_PRIMITIVES$7 = fails(function () {
    objectKeys(1);
  }); // `Object.keys` method
  // https://tc39.github.io/ecma262/#sec-object.keys

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$7
  }, {
    keys: function keys(it) {
      return objectKeys(toObject(it));
    }
  });

  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f; // `Object.prototype.__lookupGetter__` method
  // https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__

  if (descriptors) {
    _export({
      target: 'Object',
      proto: true,
      forced: objectPrototypeAccessorsForced
    }, {
      __lookupGetter__: function __lookupGetter__(P) {
        var O = toObject(this);
        var key = toPrimitive(P, true);
        var desc;

        do {
          if (desc = getOwnPropertyDescriptor$3(O, key)) return desc.get;
        } while (O = objectGetPrototypeOf(O));
      }
    });
  }

  var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f; // `Object.prototype.__lookupSetter__` method
  // https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__

  if (descriptors) {
    _export({
      target: 'Object',
      proto: true,
      forced: objectPrototypeAccessorsForced
    }, {
      __lookupSetter__: function __lookupSetter__(P) {
        var O = toObject(this);
        var key = toPrimitive(P, true);
        var desc;

        do {
          if (desc = getOwnPropertyDescriptor$4(O, key)) return desc.set;
        } while (O = objectGetPrototypeOf(O));
      }
    });
  }

  var onFreeze$1 = internalMetadata.onFreeze;
  var nativePreventExtensions = Object.preventExtensions;
  var FAILS_ON_PRIMITIVES$8 = fails(function () {
    nativePreventExtensions(1);
  }); // `Object.preventExtensions` method
  // https://tc39.github.io/ecma262/#sec-object.preventextensions

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$8,
    sham: !freezing
  }, {
    preventExtensions: function preventExtensions(it) {
      return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze$1(it)) : it;
    }
  });

  var onFreeze$2 = internalMetadata.onFreeze;
  var nativeSeal = Object.seal;
  var FAILS_ON_PRIMITIVES$9 = fails(function () {
    nativeSeal(1);
  }); // `Object.seal` method
  // https://tc39.github.io/ecma262/#sec-object.seal

  _export({
    target: 'Object',
    stat: true,
    forced: FAILS_ON_PRIMITIVES$9,
    sham: !freezing
  }, {
    seal: function seal(it) {
      return nativeSeal && isObject(it) ? nativeSeal(onFreeze$2(it)) : it;
    }
  });

  // https://tc39.github.io/ecma262/#sec-object.setprototypeof

  _export({
    target: 'Object',
    stat: true
  }, {
    setPrototypeOf: objectSetPrototypeOf
  });

  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring


  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return '[object ' + classof(this) + ']';
  };

  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring

  if (!toStringTagSupport) {
    redefine(Object.prototype, 'toString', objectToString, {
      unsafe: true
    });
  }

  var $values = objectToArray.values; // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values

  _export({
    target: 'Object',
    stat: true
  }, {
    values: function values(O) {
      return $values(O);
    }
  });

  // https://tc39.github.io/ecma262/#sec-parsefloat-string

  _export({
    global: true,
    forced: parseFloat != numberParseFloat
  }, {
    parseFloat: numberParseFloat
  });

  // https://tc39.github.io/ecma262/#sec-parseint-string-radix

  _export({
    global: true,
    forced: parseInt != numberParseInt
  }, {
    parseInt: numberParseInt
  });

  var nativePromiseConstructor = global_1.Promise;

  var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

  var location$1 = global_1.location;
  var set$2 = global_1.setImmediate;
  var clear = global_1.clearImmediate;
  var process$1 = global_1.process;
  var MessageChannel = global_1.MessageChannel;
  var Dispatch = global_1.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function run(id) {
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var runner = function runner(id) {
    return function () {
      run(id);
    };
  };

  var listener = function listener(event) {
    run(event.data);
  };

  var post = function post(id) {
    // old engines have not location.origin
    global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


  if (!set$2 || !clear) {
    set$2 = function setImmediate(fn) {
      var args = [];
      var i = 1;

      while (arguments.length > i) {
        args.push(arguments[i++]);
      }

      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
      };

      defer(counter);
      return counter;
    };

    clear = function clearImmediate(id) {
      delete queue[id];
    }; // Node.js 0.8-


    if (classofRaw(process$1) == 'process') {
      defer = function defer(id) {
        process$1.nextTick(runner(id));
      }; // Sphere (JS game engine) Dispatch API

    } else if (Dispatch && Dispatch.now) {
      defer = function defer(id) {
        Dispatch.now(runner(id));
      }; // Browsers with MessageChannel, includes WebWorkers
      // except iOS - https://github.com/zloirock/core-js/issues/624

    } else if (MessageChannel && !engineIsIos) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = functionBindContext(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post) && location$1.protocol !== 'file:') {
      defer = post;
      global_1.addEventListener('message', listener, false); // IE8-
    } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
      defer = function defer(id) {
        html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run(id);
        };
      }; // Rest old browsers

    } else {
      defer = function defer(id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task = {
    set: set$2,
    clear: clear
  };

  var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task.set;
  var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
  var process$2 = global_1.process;
  var Promise$1 = global_1.Promise;
  var IS_NODE = classofRaw(process$2) == 'process'; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$5(global_1, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
  var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

  if (!queueMicrotask) {
    flush = function flush() {
      var parent, fn;
      if (IS_NODE && (parent = process$2.domain)) parent.exit();

      while (head) {
        fn = head.fn;
        head = head.next;

        try {
          fn();
        } catch (error) {
          if (head) notify();else last = undefined;
          throw error;
        }
      }

      last = undefined;
      if (parent) parent.enter();
    }; // Node.js


    if (IS_NODE) {
      notify = function notify() {
        process$2.nextTick(flush);
      }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339

    } else if (MutationObserver$1 && !engineIsIos) {
      toggle = true;
      node = document.createTextNode('');
      new MutationObserver$1(flush).observe(node, {
        characterData: true
      });

      notify = function notify() {
        node.data = toggle = !toggle;
      }; // environments with maybe non-completely correct, but existent Promise

    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      then = promise.then;

      notify = function notify() {
        then.call(promise, flush);
      }; // for other environments - macrotask based on:
      // - setImmediate
      // - MessageChannel
      // - window.postMessag
      // - onreadystatechange
      // - setTimeout

    } else {
      notify = function notify() {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global_1, flush);
      };
    }
  }

  var microtask = queueMicrotask || function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };

  var PromiseCapability = function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction$1(resolve);
    this.reject = aFunction$1(reject);
  }; // 25.4.1.5 NewPromiseCapability(C)


  var f$7 = function f(C) {
    return new PromiseCapability(C);
  };

  var newPromiseCapability = {
    f: f$7
  };

  var promiseResolve = function promiseResolve(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var hostReportErrors = function hostReportErrors(a, b) {
    var console = global_1.console;

    if (console && console.error) {
      arguments.length === 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform = function perform(exec) {
    try {
      return {
        error: false,
        value: exec()
      };
    } catch (error) {
      return {
        error: true,
        value: error
      };
    }
  };

  var task$1 = task.set;
  var SPECIES$5 = wellKnownSymbol('species');
  var PROMISE = 'Promise';
  var getInternalState$3 = internalState.get;
  var setInternalState$4 = internalState.set;
  var getInternalPromiseState = internalState.getterFor(PROMISE);
  var PromiseConstructor = nativePromiseConstructor;
  var TypeError$1 = global_1.TypeError;
  var document$2 = global_1.document;
  var process$3 = global_1.process;
  var $fetch = getBuiltIn('fetch');
  var newPromiseCapability$1 = newPromiseCapability.f;
  var newGenericPromiseCapability = newPromiseCapability$1;
  var IS_NODE$1 = classofRaw(process$3) == 'process';
  var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
  var FORCED$d = isForced_1(PROMISE, function () {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

    if (!GLOBAL_CORE_JS_PROMISE) {
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (engineV8Version === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

      if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
    } // We need Promise#finally in the pure version for preventing prototype pollution
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679

    if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

    var promise = PromiseConstructor.resolve(1);

    var FakePromise = function FakePromise(exec) {
      exec(function () {
        /* empty */
      }, function () {
        /* empty */
      });
    };

    var constructor = promise.constructor = {};
    constructor[SPECIES$5] = FakePromise;
    return !(promise.then(function () {
      /* empty */
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION$1 = FORCED$d || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () {
      /* empty */
    });
  }); // helpers

  var isThenable = function isThenable(it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify$1 = function notify(promise, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function () {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0; // variable length - can't use forEach

      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;

        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
              state.rejection = HANDLED;
            }

            if (handler === true) result = value;else {
              if (domain) domain.enter();
              result = handler(value); // can throw

              if (domain) {
                domain.exit();
                exited = true;
              }
            }

            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      }

      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(promise, state);
    });
  };

  var dispatchEvent = function dispatchEvent(name, promise, reason) {
    var event, handler;

    if (DISPATCH_EVENT) {
      event = document$2.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global_1.dispatchEvent(event);
    } else event = {
      promise: promise,
      reason: reason
    };

    if (handler = global_1['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function onUnhandled(promise, state) {
    task$1.call(global_1, function () {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;

      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE$1) {
            process$3.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

        state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function isUnhandled(state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function onHandleUnhandled(promise, state) {
    task$1.call(global_1, function () {
      if (IS_NODE$1) {
        process$3.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function bind(fn, promise, state, unwrap) {
    return function (value) {
      fn(promise, state, value, unwrap);
    };
  };

  var internalReject = function internalReject(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify$1(promise, state, true);
  };

  var internalResolve = function internalResolve(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;

    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      var then = isThenable(value);

      if (then) {
        microtask(function () {
          var wrapper = {
            done: false
          };

          try {
            then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
          } catch (error) {
            internalReject(promise, wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify$1(promise, state, false);
      }
    } catch (error) {
      internalReject(promise, {
        done: false
      }, error, state);
    }
  }; // constructor polyfill


  if (FORCED$d) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromiseConstructor, PROMISE);
      aFunction$1(executor);
      Internal.call(this);
      var state = getInternalState$3(this);

      try {
        executor(bind(internalResolve, this, state), bind(internalReject, this, state));
      } catch (error) {
        internalReject(this, state, error);
      }
    }; // eslint-disable-next-line no-unused-vars


    Internal = function Promise(executor) {
      setInternalState$4(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };

    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify$1(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      'catch': function _catch(onRejected) {
        return this.then(undefined, onRejected);
      }
    });

    OwnPromiseCapability = function OwnPromiseCapability() {
      var promise = new Internal();
      var state = getInternalState$3(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, promise, state);
      this.reject = bind(internalReject, promise, state);
    };

    newPromiseCapability.f = newPromiseCapability$1 = function newPromiseCapability(C) {
      return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };

    if ( typeof nativePromiseConstructor == 'function') {
      nativeThen = nativePromiseConstructor.prototype.then; // wrap native Promise#then for native async functions

      redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          nativeThen.call(that, resolve, reject);
        }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
      }, {
        unsafe: true
      }); // wrap fetch result

      if (typeof $fetch == 'function') _export({
        global: true,
        enumerable: true,
        forced: true
      }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch(input
        /* , init */
        ) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
        }
      });
    }
  }

  _export({
    global: true,
    wrap: true,
    forced: FORCED$d
  }, {
    Promise: PromiseConstructor
  });
  setToStringTag(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);
  PromiseWrapper = getBuiltIn(PROMISE); // statics

  _export({
    target: PROMISE,
    stat: true,
    forced: FORCED$d
  }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability$1(this);
      capability.reject.call(undefined, r);
      return capability.promise;
    }
  });
  _export({
    target: PROMISE,
    stat: true,
    forced:  FORCED$d
  }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve( this, x);
    }
  });
  _export({
    target: PROMISE,
    stat: true,
    forced: INCORRECT_ITERATION$1
  }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          $promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        iterate_1(iterable, function (promise) {
          $promiseResolve.call(C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  // https://github.com/tc39/proposal-promise-allSettled


  _export({
    target: 'Promise',
    stat: true
  }, {
    allSettled: function allSettled(iterable) {
      var C = this;
      var capability = newPromiseCapability.f(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = {
              status: 'fulfilled',
              value: value
            };
            --remaining || resolve(values);
          }, function (e) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = {
              status: 'rejected',
              reason: e
            };
            --remaining || resolve(values);
          });
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
    nativePromiseConstructor.prototype['finally'].call({
      then: function then() {
        /* empty */
      }
    }, function () {
      /* empty */
    });
  }); // `Promise.prototype.finally` method
  // https://tc39.github.io/ecma262/#sec-promise.prototype.finally

  _export({
    target: 'Promise',
    proto: true,
    real: true,
    forced: NON_GENERIC
  }, {
    'finally': function _finally(onFinally) {
      var C = speciesConstructor(this, getBuiltIn('Promise'));
      var isFunction = typeof onFinally == 'function';
      return this.then(isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () {
          return x;
        });
      } : onFinally, isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () {
          throw e;
        });
      } : onFinally);
    }
  }); // patch native Promise.prototype for native async functions

  if ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
    redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
  }

  var nativeApply = getBuiltIn('Reflect', 'apply');
  var functionApply = Function.apply; // MS Edge argumentsList argument is optional

  var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
    nativeApply(function () {
      /* empty */
    });
  }); // `Reflect.apply` method
  // https://tc39.github.io/ecma262/#sec-reflect.apply

  _export({
    target: 'Reflect',
    stat: true,
    forced: OPTIONAL_ARGUMENTS_LIST
  }, {
    apply: function apply(target, thisArgument, argumentsList) {
      aFunction$1(target);
      anObject(argumentsList);
      return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
    }
  });

  var nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method
  // https://tc39.github.io/ecma262/#sec-reflect.construct
  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it

  var NEW_TARGET_BUG = fails(function () {
    function F() {
      /* empty */
    }

    return !(nativeConstruct(function () {
      /* empty */
    }, [], F) instanceof F);
  });
  var ARGS_BUG = !fails(function () {
    nativeConstruct(function () {
      /* empty */
    });
  });
  var FORCED$e = NEW_TARGET_BUG || ARGS_BUG;
  _export({
    target: 'Reflect',
    stat: true,
    forced: FORCED$e,
    sham: FORCED$e
  }, {
    construct: function construct(Target, args
    /* , newTarget */
    ) {
      aFunction$1(Target);
      anObject(args);
      var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0:
            return new Target();

          case 1:
            return new Target(args[0]);

          case 2:
            return new Target(args[0], args[1]);

          case 3:
            return new Target(args[0], args[1], args[2]);

          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        } // w/o altered newTarget, lot of arguments case


        var $args = [null];
        $args.push.apply($args, args);
        return new (functionBind.apply(Target, $args))();
      } // with altered newTarget, not support built-in constructors


      var proto = newTarget.prototype;
      var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }
  });

  var ERROR_INSTEAD_OF_FALSE = fails(function () {
    // eslint-disable-next-line no-undef
    Reflect.defineProperty(objectDefineProperty.f({}, 1, {
      value: 1
    }), 1, {
      value: 2
    });
  }); // `Reflect.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-reflect.defineproperty

  _export({
    target: 'Reflect',
    stat: true,
    forced: ERROR_INSTEAD_OF_FALSE,
    sham: !descriptors
  }, {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      var key = toPrimitive(propertyKey, true);
      anObject(attributes);

      try {
        objectDefineProperty.f(target, key, attributes);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f; // `Reflect.deleteProperty` method
  // https://tc39.github.io/ecma262/#sec-reflect.deleteproperty

  _export({
    target: 'Reflect',
    stat: true
  }, {
    deleteProperty: function deleteProperty(target, propertyKey) {
      var descriptor = getOwnPropertyDescriptor$6(anObject(target), propertyKey);
      return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.get

  function get$2(target, propertyKey
  /* , receiver */
  ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var descriptor, prototype;
    if (anObject(target) === receiver) return target[propertyKey];
    if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
    if (isObject(prototype = objectGetPrototypeOf(target))) return get$2(prototype, propertyKey, receiver);
  }

  _export({
    target: 'Reflect',
    stat: true
  }, {
    get: get$2
  });

  // https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor

  _export({
    target: 'Reflect',
    stat: true,
    sham: !descriptors
  }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.getprototypeof

  _export({
    target: 'Reflect',
    stat: true,
    sham: !correctPrototypeGetter
  }, {
    getPrototypeOf: function getPrototypeOf(target) {
      return objectGetPrototypeOf(anObject(target));
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.has

  _export({
    target: 'Reflect',
    stat: true
  }, {
    has: function has(target, propertyKey) {
      return propertyKey in target;
    }
  });

  var objectIsExtensible = Object.isExtensible; // `Reflect.isExtensible` method
  // https://tc39.github.io/ecma262/#sec-reflect.isextensible

  _export({
    target: 'Reflect',
    stat: true
  }, {
    isExtensible: function isExtensible(target) {
      anObject(target);
      return objectIsExtensible ? objectIsExtensible(target) : true;
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.ownkeys

  _export({
    target: 'Reflect',
    stat: true
  }, {
    ownKeys: ownKeys
  });

  // https://tc39.github.io/ecma262/#sec-reflect.preventextensions

  _export({
    target: 'Reflect',
    stat: true,
    sham: !freezing
  }, {
    preventExtensions: function preventExtensions(target) {
      anObject(target);

      try {
        var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
        if (objectPreventExtensions) objectPreventExtensions(target);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.set

  function set$3(target, propertyKey, V
  /* , receiver */
  ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
    var existingDescriptor, prototype;

    if (!ownDescriptor) {
      if (isObject(prototype = objectGetPrototypeOf(target))) {
        return set$3(prototype, propertyKey, V, receiver);
      }

      ownDescriptor = createPropertyDescriptor(0);
    }

    if (has(ownDescriptor, 'value')) {
      if (ownDescriptor.writable === false || !isObject(receiver)) return false;

      if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
        if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
        existingDescriptor.value = V;
        objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
      } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));

      return true;
    }

    return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
  } // MS Edge 17-18 Reflect.set allows setting the property to object
  // with non-writable property on the prototype


  var MS_EDGE_BUG = fails(function () {
    var object = objectDefineProperty.f({}, 'a', {
      configurable: true
    }); // eslint-disable-next-line no-undef

    return Reflect.set(objectGetPrototypeOf(object), 'a', 1, object) !== false;
  });
  _export({
    target: 'Reflect',
    stat: true,
    forced: MS_EDGE_BUG
  }, {
    set: set$3
  });

  // https://tc39.github.io/ecma262/#sec-reflect.setprototypeof

  if (objectSetPrototypeOf) _export({
    target: 'Reflect',
    stat: true
  }, {
    setPrototypeOf: function setPrototypeOf(target, proto) {
      anObject(target);
      aPossiblePrototype(proto);

      try {
        objectSetPrototypeOf(target, proto);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
  // https://tc39.github.io/ecma262/#sec-isregexp

  var isRegexp = function isRegexp(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
  };

  // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags


  var regexpFlags = function regexpFlags() {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };

  // so we use an intermediate function.


  function RE(s, f) {
    return RegExp(s, f);
  }

  var UNSUPPORTED_Y = fails(function () {
    // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
    var re = RE('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
  });
  var BROKEN_CARET = fails(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = RE('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
  });
  var regexpStickyHelpers = {
    UNSUPPORTED_Y: UNSUPPORTED_Y,
    BROKEN_CARET: BROKEN_CARET
  };

  var defineProperty$a = objectDefineProperty.f;
  var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
  var setInternalState$5 = internalState.set;
  var MATCH$1 = wellKnownSymbol('match');
  var NativeRegExp = global_1.RegExp;
  var RegExpPrototype = NativeRegExp.prototype;
  var re1 = /a/g;
  var re2 = /a/g; // "new" should create a new object, old webkit bug

  var CORRECT_NEW = new NativeRegExp(re1) !== re1;
  var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y;
  var FORCED$f = descriptors && isForced_1('RegExp', !CORRECT_NEW || UNSUPPORTED_Y$1 || fails(function () {
    re2[MATCH$1] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
  })); // `RegExp` constructor
  // https://tc39.github.io/ecma262/#sec-regexp-constructor

  if (FORCED$f) {
    var RegExpWrapper = function RegExp(pattern, flags) {
      var thisIsRegExp = this instanceof RegExpWrapper;
      var patternIsRegExp = isRegexp(pattern);
      var flagsAreUndefined = flags === undefined;
      var sticky;

      if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
        return pattern;
      }

      if (CORRECT_NEW) {
        if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
      } else if (pattern instanceof RegExpWrapper) {
        if (flagsAreUndefined) flags = regexpFlags.call(pattern);
        pattern = pattern.source;
      }

      if (UNSUPPORTED_Y$1) {
        sticky = !!flags && flags.indexOf('y') > -1;
        if (sticky) flags = flags.replace(/y/g, '');
      }

      var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
      if (UNSUPPORTED_Y$1 && sticky) setInternalState$5(result, {
        sticky: sticky
      });
      return result;
    };

    var proxy = function proxy(key) {
      key in RegExpWrapper || defineProperty$a(RegExpWrapper, key, {
        configurable: true,
        get: function get() {
          return NativeRegExp[key];
        },
        set: function set(it) {
          NativeRegExp[key] = it;
        }
      });
    };

    var keys$3 = getOwnPropertyNames$2(NativeRegExp);
    var index = 0;

    while (keys$3.length > index) {
      proxy(keys$3[index++]);
    }

    RegExpPrototype.constructor = RegExpWrapper;
    RegExpWrapper.prototype = RegExpPrototype;
    redefine(global_1, 'RegExp', RegExpWrapper);
  } // https://tc39.github.io/ecma262/#sec-get-regexp-@@species


  setSpecies('RegExp');

  var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
  // which loads this file before patching the method.

  var nativeReplace = String.prototype.replace;
  var patchedExec = nativeExec;

  var UPDATES_LAST_INDEX_WRONG = function () {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  }();

  var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$2;

  if (PATCH) {
    patchedExec = function exec(str) {
      var re = this;
      var lastIndex, reCopy, match, i;
      var sticky = UNSUPPORTED_Y$2 && re.sticky;
      var flags = regexpFlags.call(re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = flags.replace('y', '');

        if (flags.indexOf('g') === -1) {
          flags += 'g';
        }

        strCopy = String(str).slice(re.lastIndex); // Support anchored sticky behavior.

        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
          source = '(?: ' + source + ')';
          strCopy = ' ' + strCopy;
          charsAdded++;
        } // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.


        reCopy = new RegExp('^(?:' + source + ')', flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
      }

      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
      match = nativeExec.call(sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = match.input.slice(charsAdded);
          match[0] = match[0].slice(charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }

      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        nativeReplace.call(match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      return match;
    };
  }

  var regexpExec = patchedExec;

  _export({
    target: 'RegExp',
    proto: true,
    forced: /./.exec !== regexpExec
  }, {
    exec: regexpExec
  });

  var UNSUPPORTED_Y$3 = regexpStickyHelpers.UNSUPPORTED_Y; // `RegExp.prototype.flags` getter
  // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags

  if (descriptors && (/./g.flags != 'g' || UNSUPPORTED_Y$3)) {
    objectDefineProperty.f(RegExp.prototype, 'flags', {
      configurable: true,
      get: regexpFlags
    });
  }

  var UNSUPPORTED_Y$4 = regexpStickyHelpers.UNSUPPORTED_Y;
  var defineProperty$b = objectDefineProperty.f;
  var getInternalState$4 = internalState.get;
  var RegExpPrototype$1 = RegExp.prototype; // `RegExp.prototype.sticky` getter

  if (descriptors && UNSUPPORTED_Y$4) {
    defineProperty$b(RegExp.prototype, 'sticky', {
      configurable: true,
      get: function get() {
        if (this === RegExpPrototype$1) return undefined; // We can't use InternalStateModule.getterFor because
        // we don't add metadata for regexps created by a literal.

        if (this instanceof RegExp) {
          return !!getInternalState$4(this).sticky;
        }

        throw TypeError('Incompatible receiver, RegExp required');
      }
    });
  }

  var DELEGATES_TO_EXEC = function () {
    var execCalled = false;
    var re = /[ac]/;

    re.exec = function () {
      execCalled = true;
      return /./.exec.apply(this, arguments);
    };

    return re.test('abc') === true && execCalled;
  }();

  var nativeTest = /./.test;
  _export({
    target: 'RegExp',
    proto: true,
    forced: !DELEGATES_TO_EXEC
  }, {
    test: function test(str) {
      if (typeof this.exec !== 'function') {
        return nativeTest.call(this, str);
      }

      var result = this.exec(str);

      if (result !== null && !isObject(result)) {
        throw new Error('RegExp exec method returned something other than an Object or null');
      }

      return !!result;
    }
  });

  var TO_STRING$1 = 'toString';
  var RegExpPrototype$2 = RegExp.prototype;
  var nativeToString = RegExpPrototype$2[TO_STRING$1];
  var NOT_GENERIC = fails(function () {
    return nativeToString.call({
      source: 'a',
      flags: 'b'
    }) != '/a/b';
  }); // FF44- RegExp#toString has a wrong name

  var INCORRECT_NAME = nativeToString.name != TO_STRING$1; // `RegExp.prototype.toString` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

  if (NOT_GENERIC || INCORRECT_NAME) {
    redefine(RegExp.prototype, TO_STRING$1, function toString() {
      var R = anObject(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$2) ? regexpFlags.call(R) : rf);
      return '/' + p + '/' + f;
    }, {
      unsafe: true
    });
  }

  // https://tc39.github.io/ecma262/#sec-set-objects


  var es_set = collection('Set', function (init) {
    return function Set() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong);

  var createMethod$6 = function createMethod(CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = String(requireObjectCoercible($this));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$6(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$6(true)
  };

  var codeAt = stringMultibyte.codeAt; // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat

  _export({
    target: 'String',
    proto: true
  }, {
    codePointAt: function codePointAt(pos) {
      return codeAt(this, pos);
    }
  });

  var notARegexp = function notARegexp(it) {
    if (isRegexp(it)) {
      throw TypeError("The method doesn't accept regular expressions");
    }

    return it;
  };

  var MATCH$2 = wellKnownSymbol('match');

  var correctIsRegexpLogic = function correctIsRegexpLogic(METHOD_NAME) {
    var regexp = /./;

    try {
      '/./'[METHOD_NAME](regexp);
    } catch (e) {
      try {
        regexp[MATCH$2] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (f) {
        /* empty */
      }
    }

    return false;
  };

  var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
  var nativeEndsWith = ''.endsWith;
  var min$5 = Math.min;
  var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith'); // https://github.com/zloirock/core-js/pull/702

  var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
    var descriptor = getOwnPropertyDescriptor$7(String.prototype, 'endsWith');
    return descriptor && !descriptor.writable;
  }(); // `String.prototype.endsWith` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.endswith

  _export({
    target: 'String',
    proto: true,
    forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
  }, {
    endsWith: function endsWith(searchString
    /* , endPosition = @length */
    ) {
      var that = String(requireObjectCoercible(this));
      notARegexp(searchString);
      var endPosition = arguments.length > 1 ? arguments[1] : undefined;
      var len = toLength(that.length);
      var end = endPosition === undefined ? len : min$5(toLength(endPosition), len);
      var search = String(searchString);
      return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }
  });

  var fromCharCode = String.fromCharCode;
  var nativeFromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

  var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1; // `String.fromCodePoint` method
  // https://tc39.github.io/ecma262/#sec-string.fromcodepoint

  _export({
    target: 'String',
    stat: true,
    forced: INCORRECT_LENGTH
  }, {
    fromCodePoint: function fromCodePoint(x) {
      // eslint-disable-line no-unused-vars
      var elements = [];
      var length = arguments.length;
      var i = 0;
      var code;

      while (length > i) {
        code = +arguments[i++];
        if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
        elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00));
      }

      return elements.join('');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.includes


  _export({
    target: 'String',
    proto: true,
    forced: !correctIsRegexpLogic('includes')
  }, {
    includes: function includes(searchString
    /* , position = 0 */
    ) {
      return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var charAt = stringMultibyte.charAt;
  var STRING_ITERATOR = 'String Iterator';
  var setInternalState$6 = internalState.set;
  var getInternalState$5 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

  defineIterator(String, 'String', function (iterated) {
    setInternalState$6(this, {
      type: STRING_ITERATOR,
      string: String(iterated),
      index: 0
    }); // `%StringIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState$5(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
      value: undefined,
      done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
      value: point,
      done: false
    };
  });

  var SPECIES$6 = wellKnownSymbol('species');
  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a "grops" property.
    var re = /./;

    re.exec = function () {
      var result = [];
      result.groups = {
        a: '7'
      };
      return result;
    };

    return ''.replace(re, '$<a>') !== '7';
  }); // IE <= 11 replaces $0 with the whole match, as if it was $&
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0

  var REPLACE_KEEPS_$0 = function () {
    return 'a'.replace(/./, '$0') === '$0';
  }();

  var REPLACE = wellKnownSymbol('replace'); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string

  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
    if (/./[REPLACE]) {
      return /./[REPLACE]('a', '$0') === '';
    }

    return false;
  }(); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper


  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
    var re = /(?:)/;
    var originalExec = re.exec;

    re.exec = function () {
      return originalExec.apply(this, arguments);
    };

    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
  });

  var fixRegexpWellKnownSymbolLogic = function fixRegexpWellKnownSymbolLogic(KEY, length, exec, sham) {
    var SYMBOL = wellKnownSymbol(KEY);
    var DELEGATES_TO_SYMBOL = !fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};

      O[SYMBOL] = function () {
        return 7;
      };

      return ''[KEY](O) != 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === 'split') {
        // We can't use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.

        re.constructor = {};

        re.constructor[SPECIES$6] = function () {
          return re;
        };

        re.flags = '';
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () {
        execCalled = true;
        return null;
      };

      re[SYMBOL]('');
      return !execCalled;
    });

    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return {
              done: true,
              value: nativeRegExpMethod.call(regexp, str, arg2)
            };
          }

          return {
            done: true,
            value: nativeMethod.call(str, regexp, arg2)
          };
        }

        return {
          done: false
        };
      }, {
        REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      });
      var stringMethod = methods[0];
      var regexMethod = methods[1];
      redefine(String.prototype, KEY, stringMethod);
      redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) {
        return regexMethod.call(string, this, arg);
      } // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) {
        return regexMethod.call(string, this);
      });
    }

    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
  };

  var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
  // https://tc39.github.io/ecma262/#sec-advancestringindex

  var advanceStringIndex = function advanceStringIndex(S, index, unicode) {
    return index + (unicode ? charAt$1(S, index).length : 1);
  };

  // https://tc39.github.io/ecma262/#sec-regexpexec

  var regexpExecAbstract = function regexpExecAbstract(R, S) {
    var exec = R.exec;

    if (typeof exec === 'function') {
      var result = exec.call(R, S);

      if (_typeof(result) !== 'object') {
        throw TypeError('RegExp exec method returned something other than an Object or null');
      }

      return result;
    }

    if (classofRaw(R) !== 'RegExp') {
      throw TypeError('RegExp#exec called on incompatible receiver');
    }

    return regexpExec.call(R, S);
  };

  fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
    return [// `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    }, // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regexpExecAbstract(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;

      while ((result = regexpExecAbstract(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }

      return n === 0 ? null : A;
    }];
  });

  var MATCH_ALL = wellKnownSymbol('matchAll');
  var REGEXP_STRING = 'RegExp String';
  var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
  var setInternalState$7 = internalState.set;
  var getInternalState$6 = internalState.getterFor(REGEXP_STRING_ITERATOR);
  var RegExpPrototype$3 = RegExp.prototype;
  var regExpBuiltinExec = RegExpPrototype$3.exec;
  var nativeMatchAll = ''.matchAll;
  var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
    'a'.matchAll(/./);
  });

  var regExpExec = function regExpExec(R, S) {
    var exec = R.exec;
    var result;

    if (typeof exec == 'function') {
      result = exec.call(R, S);
      if (_typeof(result) != 'object') throw TypeError('Incorrect exec result');
      return result;
    }

    return regExpBuiltinExec.call(R, S);
  }; // eslint-disable-next-line max-len


  var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
    setInternalState$7(this, {
      type: REGEXP_STRING_ITERATOR,
      regexp: regexp,
      string: string,
      global: global,
      unicode: fullUnicode,
      done: false
    });
  }, REGEXP_STRING, function next() {
    var state = getInternalState$6(this);
    if (state.done) return {
      value: undefined,
      done: true
    };
    var R = state.regexp;
    var S = state.string;
    var match = regExpExec(R, S);
    if (match === null) return {
      value: undefined,
      done: state.done = true
    };

    if (state.global) {
      if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
      return {
        value: match,
        done: false
      };
    }

    state.done = true;
    return {
      value: match,
      done: false
    };
  });

  var $matchAll = function $matchAll(string) {
    var R = anObject(this);
    var S = String(string);
    var C, flagsValue, flags, matcher, global, fullUnicode;
    C = speciesConstructor(R, RegExp);
    flagsValue = R.flags;

    if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$3)) {
      flagsValue = regexpFlags.call(R);
    }

    flags = flagsValue === undefined ? '' : String(flagsValue);
    matcher = new C(C === RegExp ? R.source : R, flags);
    global = !!~flags.indexOf('g');
    fullUnicode = !!~flags.indexOf('u');
    matcher.lastIndex = toLength(R.lastIndex);
    return new $RegExpStringIterator(matcher, S, global, fullUnicode);
  }; // `String.prototype.matchAll` method
  // https://github.com/tc39/proposal-string-matchall


  _export({
    target: 'String',
    proto: true,
    forced: WORKS_WITH_NON_GLOBAL_REGEX
  }, {
    matchAll: function matchAll(regexp) {
      var O = requireObjectCoercible(this);
      var flags, S, matcher, rx;

      if (regexp != null) {
        if (isRegexp(regexp)) {
          flags = String(requireObjectCoercible('flags' in RegExpPrototype$3 ? regexp.flags : regexpFlags.call(regexp)));
          if (!~flags.indexOf('g')) throw TypeError('`.matchAll` does not allow non-global regexes');
        }

        if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
        matcher = regexp[MATCH_ALL];
        if (matcher === undefined && isPure && classofRaw(regexp) == 'RegExp') matcher = $matchAll;
        if (matcher != null) return aFunction$1(matcher).call(regexp, O);
      } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);

      S = String(O);
      rx = new RegExp(regexp, 'g');
      return  rx[MATCH_ALL](S);
    }
  });
   MATCH_ALL in RegExpPrototype$3 || createNonEnumerableProperty(RegExpPrototype$3, MATCH_ALL, $matchAll);

  // eslint-disable-next-line unicorn/no-unsafe-regex

  var stringPadWebkitBug = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(engineUserAgent);

  var $padEnd = stringPad.end; // `String.prototype.padEnd` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padend

  _export({
    target: 'String',
    proto: true,
    forced: stringPadWebkitBug
  }, {
    padEnd: function padEnd(maxLength
    /* , fillString = ' ' */
    ) {
      return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $padStart = stringPad.start; // `String.prototype.padStart` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart

  _export({
    target: 'String',
    proto: true,
    forced: stringPadWebkitBug
  }, {
    padStart: function padStart(maxLength
    /* , fillString = ' ' */
    ) {
      return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.raw

  _export({
    target: 'String',
    stat: true
  }, {
    raw: function raw(template) {
      var rawTemplate = toIndexedObject(template.raw);
      var literalSegments = toLength(rawTemplate.length);
      var argumentsLength = arguments.length;
      var elements = [];
      var i = 0;

      while (literalSegments > i) {
        elements.push(String(rawTemplate[i++]));
        if (i < argumentsLength) elements.push(String(arguments[i]));
      }

      return elements.join('');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.repeat

  _export({
    target: 'String',
    proto: true
  }, {
    repeat: stringRepeat
  });

  var max$3 = Math.max;
  var min$6 = Math.min;
  var floor$6 = Math.floor;
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

  var maybeToString = function maybeToString(it) {
    return it === undefined ? it : String(it);
  }; // @@replace logic


  fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
    var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
    return [// `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
    }, // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;

      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }

      var results = [];

      while (true) {
        var result = regexpExecAbstract(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;

      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max$3(min$6(toInteger(result.index), S.length), 0);
        var captures = []; // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

        for (var j = 1; j < result.length; j++) {
          captures.push(maybeToString(result[j]));
        }

        var namedCaptures = result.groups;

        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }

        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }

      return accumulatedResult + S.slice(nextSourcePosition);
    }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }

      return nativeReplace.call(replacement, symbols, function (match, ch) {
        var capture;

        switch (ch.charAt(0)) {
          case '$':
            return '$';

          case '&':
            return matched;

          case '`':
            return str.slice(0, position);

          case "'":
            return str.slice(tailPos);

          case '<':
            capture = namedCaptures[ch.slice(1, -1)];
            break;

          default:
            // \d\d?
            var n = +ch;
            if (n === 0) return match;

            if (n > m) {
              var f = floor$6(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match;
            }

            capture = captures[n - 1];
        }

        return capture === undefined ? '' : capture;
      });
    }
  });

  fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
    return [// `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    }, // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regexpExecAbstract(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }];
  });

  var arrayPush = [].push;
  var min$7 = Math.min;
  var MAX_UINT32 = 0xFFFFFFFF; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

  var SUPPORTS_Y = !fails(function () {
    return !RegExp(MAX_UINT32, 'y');
  }); // @@split logic

  fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;

    if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function internalSplit(separator, limit) {
        var string = String(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

        if (!isRegexp(separator)) {
          return nativeSplit.call(string, separator, lim);
        }

        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
        var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;

        while (match = regexpExec.call(separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;

          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }

          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }

        if (lastLastIndex === string.length) {
          if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));

        return output.length > lim ? output.slice(0, lim) : output;
      }; // Chakra, V8

    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function internalSplit(separator, limit) {
        return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [// `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
    }, // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.

      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];

      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;

        if (z === null || (e = min$7(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;

          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }

          q = p = e;
        }
      }

      A.push(S.slice(p));
      return A;
    }];
  }, !SUPPORTS_Y);

  var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;
  var nativeStartsWith = ''.startsWith;
  var min$8 = Math.min;
  var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('startsWith'); // https://github.com/zloirock/core-js/pull/702

  var MDN_POLYFILL_BUG$1 =  !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
    var descriptor = getOwnPropertyDescriptor$8(String.prototype, 'startsWith');
    return descriptor && !descriptor.writable;
  }(); // `String.prototype.startsWith` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.startswith

  _export({
    target: 'String',
    proto: true,
    forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1
  }, {
    startsWith: function startsWith(searchString
    /* , position = 0 */
    ) {
      var that = String(requireObjectCoercible(this));
      notARegexp(searchString);
      var index = toLength(min$8(arguments.length > 1 ? arguments[1] : undefined, that.length));
      var search = String(searchString);
      return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }
  });

  var non = "\u200B\x85\u180E"; // check that a method works with the correct list
  // of whitespaces and has a correct name

  var stringTrimForced = function stringTrimForced(METHOD_NAME) {
    return fails(function () {
      return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
  };

  var $trim = stringTrim.trim; // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim

  _export({
    target: 'String',
    proto: true,
    forced: stringTrimForced('trim')
  }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  var $trimEnd = stringTrim.end;
  var FORCED$g = stringTrimForced('trimEnd');
  var trimEnd = FORCED$g ? function trimEnd() {
    return $trimEnd(this);
  } : ''.trimEnd; // `String.prototype.{ trimEnd, trimRight }` methods
  // https://github.com/tc39/ecmascript-string-left-right-trim

  _export({
    target: 'String',
    proto: true,
    forced: FORCED$g
  }, {
    trimEnd: trimEnd,
    trimRight: trimEnd
  });

  var $trimStart = stringTrim.start;
  var FORCED$h = stringTrimForced('trimStart');
  var trimStart = FORCED$h ? function trimStart() {
    return $trimStart(this);
  } : ''.trimStart; // `String.prototype.{ trimStart, trimLeft }` methods
  // https://github.com/tc39/ecmascript-string-left-right-trim

  _export({
    target: 'String',
    proto: true,
    forced: FORCED$h
  }, {
    trimStart: trimStart,
    trimLeft: trimStart
  });

  var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
  // https://tc39.github.io/ecma262/#sec-createhtml

  var createHtml = function createHtml(string, tag, attribute, value) {
    var S = String(requireObjectCoercible(string));
    var p1 = '<' + tag;
    if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
    return p1 + '>' + S + '</' + tag + '>';
  };

  // of a tag and escaping quotes in arguments

  var stringHtmlForced = function stringHtmlForced(METHOD_NAME) {
    return fails(function () {
      var test = ''[METHOD_NAME]('"');
      return test !== test.toLowerCase() || test.split('"').length > 3;
    });
  };

  // https://tc39.github.io/ecma262/#sec-string.prototype.anchor


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('anchor')
  }, {
    anchor: function anchor(name) {
      return createHtml(this, 'a', 'name', name);
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.big


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('big')
  }, {
    big: function big() {
      return createHtml(this, 'big', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.blink


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('blink')
  }, {
    blink: function blink() {
      return createHtml(this, 'blink', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.bold


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('bold')
  }, {
    bold: function bold() {
      return createHtml(this, 'b', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.fixed


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('fixed')
  }, {
    fixed: function fixed() {
      return createHtml(this, 'tt', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('fontcolor')
  }, {
    fontcolor: function fontcolor(color) {
      return createHtml(this, 'font', 'color', color);
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.fontsize


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('fontsize')
  }, {
    fontsize: function fontsize(size) {
      return createHtml(this, 'font', 'size', size);
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.italics


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('italics')
  }, {
    italics: function italics() {
      return createHtml(this, 'i', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.link


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('link')
  }, {
    link: function link(url) {
      return createHtml(this, 'a', 'href', url);
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.small


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('small')
  }, {
    small: function small() {
      return createHtml(this, 'small', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.strike


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('strike')
  }, {
    strike: function strike() {
      return createHtml(this, 'strike', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.sub


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('sub')
  }, {
    sub: function sub() {
      return createHtml(this, 'sub', '', '');
    }
  });

  // https://tc39.github.io/ecma262/#sec-string.prototype.sup


  _export({
    target: 'String',
    proto: true,
    forced: stringHtmlForced('sup')
  }, {
    sup: function sup() {
      return createHtml(this, 'sup', '', '');
    }
  });

  /* eslint-disable no-new */

  var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var ArrayBuffer$3 = global_1.ArrayBuffer;
  var Int8Array$2 = global_1.Int8Array;
  var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$2 || !fails(function () {
    Int8Array$2(1);
  }) || !fails(function () {
    new Int8Array$2(-1);
  }) || !checkCorrectnessOfIteration(function (iterable) {
    new Int8Array$2();
    new Int8Array$2(null);
    new Int8Array$2(1.5);
    new Int8Array$2(iterable);
  }, true) || fails(function () {
    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
    return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
  });

  var toPositiveInteger = function toPositiveInteger(it) {
    var result = toInteger(it);
    if (result < 0) throw RangeError("The argument can't be less than 0");
    return result;
  };

  var toOffset = function toOffset(it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw RangeError('Wrong offset');
    return offset;
  };

  var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

  var typedArrayFrom = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, step, iterator, next;

    if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
      iterator = iteratorMethod.call(O);
      next = iterator.next;
      O = [];

      while (!(step = next.call(iterator)).done) {
        O.push(step.value);
      }
    }

    if (mapping && argumentsLength > 2) {
      mapfn = functionBindContext(mapfn, arguments[2], 2);
    }

    length = toLength(O.length);
    result = new (aTypedArrayConstructor$1(this))(length);

    for (i = 0; length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var typedArrayConstructor = createCommonjsModule(function (module) {

    var getOwnPropertyNames = objectGetOwnPropertyNames.f;
    var forEach = arrayIteration.forEach;
    var getInternalState = internalState.get;
    var setInternalState = internalState.set;
    var nativeDefineProperty = objectDefineProperty.f;
    var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var round = Math.round;
    var RangeError = global_1.RangeError;
    var ArrayBuffer = arrayBuffer.ArrayBuffer;
    var DataView = arrayBuffer.DataView;
    var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
    var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
    var TypedArray = arrayBufferViewCore.TypedArray;
    var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
    var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
    var isTypedArray = arrayBufferViewCore.isTypedArray;
    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
    var WRONG_LENGTH = 'Wrong length';

    var fromList = function fromList(C, list) {
      var index = 0;
      var length = list.length;
      var result = new (aTypedArrayConstructor(C))(length);

      while (length > index) {
        result[index] = list[index++];
      }

      return result;
    };

    var addGetter = function addGetter(it, key) {
      nativeDefineProperty(it, key, {
        get: function get() {
          return getInternalState(this)[key];
        }
      });
    };

    var isArrayBuffer = function isArrayBuffer(it) {
      var klass;
      return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
    };

    var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
      return isTypedArray(target) && _typeof(key) != 'symbol' && key in target && String(+key) == String(key);
    };

    var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
      return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
    };

    var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
      if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
      && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
        target[key] = descriptor.value;
        return target;
      }

      return nativeDefineProperty(target, key, descriptor);
    };

    if (descriptors) {
      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
        objectDefineProperty.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, 'buffer');
        addGetter(TypedArrayPrototype, 'byteOffset');
        addGetter(TypedArrayPrototype, 'byteLength');
        addGetter(TypedArrayPrototype, 'length');
      }

      _export({
        target: 'Object',
        stat: true,
        forced: !NATIVE_ARRAY_BUFFER_VIEWS
      }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
      });

      module.exports = function (TYPE, wrapper, CLAMPED) {
        var BYTES = TYPE.match(/\d+$/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + TYPE;
        var SETTER = 'set' + TYPE;
        var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {};

        var getter = function getter(that, index) {
          var data = getInternalState(that);
          return data.view[GETTER](index * BYTES + data.byteOffset, true);
        };

        var setter = function setter(that, index, value) {
          var data = getInternalState(that);
          if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
          data.view[SETTER](index * BYTES + data.byteOffset, value, true);
        };

        var addElement = function addElement(that, index) {
          nativeDefineProperty(that, index, {
            get: function get() {
              return getter(this, index);
            },
            set: function set(value) {
              return setter(this, index, value);
            },
            enumerable: true
          });
        };

        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
            anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
            var index = 0;
            var byteOffset = 0;
            var buffer, byteLength, length;

            if (!isObject(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new ArrayBuffer(byteLength);
            } else if (isArrayBuffer(data)) {
              buffer = data;
              byteOffset = toOffset(offset, BYTES);
              var $len = data.byteLength;

              if ($length === undefined) {
                if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                byteLength = $len - byteOffset;
                if (byteLength < 0) throw RangeError(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
              }

              length = byteLength / BYTES;
            } else if (isTypedArray(data)) {
              return fromList(TypedArrayConstructor, data);
            } else {
              return typedArrayFrom.call(TypedArrayConstructor, data);
            }

            setInternalState(that, {
              buffer: buffer,
              byteOffset: byteOffset,
              byteLength: byteLength,
              length: length,
              view: new DataView(buffer)
            });

            while (index < length) {
              addElement(that, index++);
            }
          });
          if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
          TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
        } else if (typedArrayConstructorsRequireWrappers) {
          TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
            anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
            return inheritIfRequired(function () {
              if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
              if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
              if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
              return typedArrayFrom.call(TypedArrayConstructor, data);
            }(), dummy, TypedArrayConstructor);
          });
          if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
          forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
            if (!(key in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
            }
          });
          TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }

        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
        }

        if (TYPED_ARRAY_TAG) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        }

        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
        _export({
          global: true,
          forced: TypedArrayConstructor != NativeTypedArrayConstructor,
          sham: !NATIVE_ARRAY_BUFFER_VIEWS
        }, exported);

        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        }

        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        }

        setSpecies(CONSTRUCTOR_NAME);
      };
    } else module.exports = function () {
      /* empty */
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Float32', function (init) {
    return function Float32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Float64', function (init) {
    return function Float64Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Int8', function (init) {
    return function Int8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Int16', function (init) {
    return function Int16Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Int32', function (init) {
    return function Int32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Uint8', function (init) {
    return function Uint8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Uint8', function (init) {
    return function Uint8ClampedArray(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  }, true);

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Uint16', function (init) {
    return function Uint16Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  // https://tc39.github.io/ecma262/#sec-typedarray-objects

  typedArrayConstructor('Uint32', function (init) {
    return function Uint32Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin

  exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start
  /* , end */
  ) {
    return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
  });

  var $every$1 = arrayIteration.every;
  var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every

  exportTypedArrayMethod$2('every', function every(callbackfn
  /* , thisArg */
  ) {
    return $every$1(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
  // eslint-disable-next-line no-unused-vars

  exportTypedArrayMethod$3('fill', function fill(value
  /* , start, end */
  ) {
    return arrayFill.apply(aTypedArray$3(this), arguments);
  });

  var $filter$1 = arrayIteration.filter;
  var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
  var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
  var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter

  exportTypedArrayMethod$4('filter', function filter(callbackfn
  /* , thisArg */
  ) {
    var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    var C = speciesConstructor(this, this.constructor);
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor$2(C))(length);

    while (length > index) {
      result[index] = list[index++];
    }

    return result;
  });

  var $find$1 = arrayIteration.find;
  var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find

  exportTypedArrayMethod$5('find', function find(predicate
  /* , thisArg */
  ) {
    return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $findIndex$1 = arrayIteration.findIndex;
  var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex

  exportTypedArrayMethod$6('findIndex', function findIndex(predicate
  /* , thisArg */
  ) {
    return $findIndex$1(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $forEach$2 = arrayIteration.forEach;
  var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach

  exportTypedArrayMethod$7('forEach', function forEach(callbackfn
  /* , thisArg */
  ) {
    $forEach$2(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod; // `%TypedArray%.from` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.from

  exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

  var $includes$1 = arrayIncludes.includes;
  var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes

  exportTypedArrayMethod$8('includes', function includes(searchElement
  /* , fromIndex */
  ) {
    return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $indexOf$1 = arrayIncludes.indexOf;
  var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof

  exportTypedArrayMethod$9('indexOf', function indexOf(searchElement
  /* , fromIndex */
  ) {
    return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
  });

  var ITERATOR$5 = wellKnownSymbol('iterator');
  var Uint8Array$1 = global_1.Uint8Array;
  var arrayValues = es_array_iterator.values;
  var arrayKeys = es_array_iterator.keys;
  var arrayEntries = es_array_iterator.entries;
  var aTypedArray$a = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
  var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR$5];
  var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

  var typedArrayValues = function values() {
    return arrayValues.call(aTypedArray$a(this));
  }; // `%TypedArray%.prototype.entries` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries


  exportTypedArrayMethod$a('entries', function entries() {
    return arrayEntries.call(aTypedArray$a(this));
  }); // `%TypedArray%.prototype.keys` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys

  exportTypedArrayMethod$a('keys', function keys() {
    return arrayKeys.call(aTypedArray$a(this));
  }); // `%TypedArray%.prototype.values` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values

  exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator

  exportTypedArrayMethod$a(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);

  var aTypedArray$b = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
  var $join = [].join; // `%TypedArray%.prototype.join` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
  // eslint-disable-next-line no-unused-vars

  exportTypedArrayMethod$b('join', function join(separator) {
    return $join.apply(aTypedArray$b(this), arguments);
  });

  var aTypedArray$c = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
  // eslint-disable-next-line no-unused-vars

  exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement
  /* , fromIndex */
  ) {
    return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
  });

  var $map$1 = arrayIteration.map;
  var aTypedArray$d = arrayBufferViewCore.aTypedArray;
  var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
  var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map

  exportTypedArrayMethod$d('map', function map(mapfn
  /* , thisArg */
  ) {
    return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
      return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
    });
  });

  var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
  var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod; // `%TypedArray%.of` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.of

  exportTypedArrayStaticMethod$2('of', function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = new (aTypedArrayConstructor$4(this))(length);

    while (length > index) {
      result[index] = arguments[index++];
    }

    return result;
  }, typedArrayConstructorsRequireWrappers);

  var $reduce$1 = arrayReduce.left;
  var aTypedArray$e = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce

  exportTypedArrayMethod$e('reduce', function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce$1(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $reduceRight$1 = arrayReduce.right;
  var aTypedArray$f = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright

  exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduceRight$1(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$g = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
  var floor$7 = Math.floor; // `%TypedArray%.prototype.reverse` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse

  exportTypedArrayMethod$g('reverse', function reverse() {
    var that = this;
    var length = aTypedArray$g(that).length;
    var middle = floor$7(length / 2);
    var index = 0;
    var value;

    while (index < middle) {
      value = that[index];
      that[index++] = that[--length];
      that[length] = value;
    }

    return that;
  });

  var aTypedArray$h = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
  var FORCED$i = fails(function () {
    // eslint-disable-next-line no-undef
    new Int8Array(1).set({});
  }); // `%TypedArray%.prototype.set` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set

  exportTypedArrayMethod$h('set', function set(arrayLike
  /* , offset */
  ) {
    aTypedArray$h(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError('Wrong length');

    while (index < len) {
      this[offset + index] = src[index++];
    }
  }, FORCED$i);

  var aTypedArray$i = arrayBufferViewCore.aTypedArray;
  var aTypedArrayConstructor$5 = arrayBufferViewCore.aTypedArrayConstructor;
  var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
  var $slice = [].slice;
  var FORCED$j = fails(function () {
    // eslint-disable-next-line no-undef
    new Int8Array(1).slice();
  }); // `%TypedArray%.prototype.slice` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice

  exportTypedArrayMethod$i('slice', function slice(start, end) {
    var list = $slice.call(aTypedArray$i(this), start, end);
    var C = speciesConstructor(this, this.constructor);
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor$5(C))(length);

    while (length > index) {
      result[index] = list[index++];
    }

    return result;
  }, FORCED$j);

  var $some$1 = arrayIteration.some;
  var aTypedArray$j = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some

  exportTypedArrayMethod$j('some', function some(callbackfn
  /* , thisArg */
  ) {
    return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$k = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
  var $sort = [].sort; // `%TypedArray%.prototype.sort` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort

  exportTypedArrayMethod$k('sort', function sort(comparefn) {
    return $sort.call(aTypedArray$k(this), comparefn);
  });

  var aTypedArray$l = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray

  exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
    var O = aTypedArray$l(this);
    var length = O.length;
    var beginIndex = toAbsoluteIndex(begin, length);
    return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
  });

  var Int8Array$3 = global_1.Int8Array;
  var aTypedArray$m = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
  var $toLocaleString = [].toLocaleString;
  var $slice$1 = [].slice; // iOS Safari 6.x fails here

  var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
    $toLocaleString.call(new Int8Array$3(1));
  });
  var FORCED$k = fails(function () {
    return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
  }) || !fails(function () {
    Int8Array$3.prototype.toLocaleString.call([1, 2]);
  }); // `%TypedArray%.prototype.toLocaleString` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring

  exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
    return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
  }, FORCED$k);

  var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;
  var Uint8Array$2 = global_1.Uint8Array;
  var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
  var arrayToString = [].toString;
  var arrayJoin = [].join;

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring

  exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

  var getWeakData = internalMetadata.getWeakData;
  var setInternalState$8 = internalState.set;
  var internalStateGetterFor$1 = internalState.getterFor;
  var find = arrayIteration.find;
  var findIndex = arrayIteration.findIndex;
  var id$1 = 0; // fallback for uncaught frozen keys

  var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
    return store.frozen || (store.frozen = new UncaughtFrozenStore());
  };

  var UncaughtFrozenStore = function UncaughtFrozenStore() {
    this.entries = [];
  };

  var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
    return find(store.entries, function (it) {
      return it[0] === key;
    });
  };

  UncaughtFrozenStore.prototype = {
    get: function get(key) {
      var entry = findUncaughtFrozen(this, key);
      if (entry) return entry[1];
    },
    has: function has(key) {
      return !!findUncaughtFrozen(this, key);
    },
    set: function set(key, value) {
      var entry = findUncaughtFrozen(this, key);
      if (entry) entry[1] = value;else this.entries.push([key, value]);
    },
    'delete': function _delete(key) {
      var index = findIndex(this.entries, function (it) {
        return it[0] === key;
      });
      if (~index) this.entries.splice(index, 1);
      return !!~index;
    }
  };
  var collectionWeak = {
    getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        anInstance(that, C, CONSTRUCTOR_NAME);
        setInternalState$8(that, {
          type: CONSTRUCTOR_NAME,
          id: id$1++,
          frozen: undefined
        });
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
      });
      var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

      var define = function define(that, key, value) {
        var state = getInternalState(that);
        var data = getWeakData(anObject(key), true);
        if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
        return that;
      };

      redefineAll(C.prototype, {
        // 23.3.3.2 WeakMap.prototype.delete(key)
        // 23.4.3.3 WeakSet.prototype.delete(value)
        'delete': function _delete(key) {
          var state = getInternalState(this);
          if (!isObject(key)) return false;
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state)['delete'](key);
          return data && has(data, state.id) && delete data[state.id];
        },
        // 23.3.3.4 WeakMap.prototype.has(key)
        // 23.4.3.4 WeakSet.prototype.has(value)
        has: function has$1(key) {
          var state = getInternalState(this);
          if (!isObject(key)) return false;
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).has(key);
          return data && has(data, state.id);
        }
      });
      redefineAll(C.prototype, IS_MAP ? {
        // 23.3.3.3 WeakMap.prototype.get(key)
        get: function get(key) {
          var state = getInternalState(this);

          if (isObject(key)) {
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state).get(key);
            return data ? data[state.id] : undefined;
          }
        },
        // 23.3.3.5 WeakMap.prototype.set(key, value)
        set: function set(key, value) {
          return define(this, key, value);
        }
      } : {
        // 23.4.3.1 WeakSet.prototype.add(value)
        add: function add(value) {
          return define(this, value, true);
        }
      });
      return C;
    }
  };

  var es_weakMap = createCommonjsModule(function (module) {

    var enforceIternalState = internalState.enforce;
    var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
    var isExtensible = Object.isExtensible;
    var InternalWeakMap;

    var wrapper = function wrapper(init) {
      return function WeakMap() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }; // `WeakMap` constructor
    // https://tc39.github.io/ecma262/#sec-weakmap-constructor


    var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
    // We can't use feature detection because it crash some old IE builds
    // https://github.com/zloirock/core-js/issues/485

    if (nativeWeakMap && IS_IE11) {
      InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
      internalMetadata.REQUIRED = true;
      var WeakMapPrototype = $WeakMap.prototype;
      var nativeDelete = WeakMapPrototype['delete'];
      var nativeHas = WeakMapPrototype.has;
      var nativeGet = WeakMapPrototype.get;
      var nativeSet = WeakMapPrototype.set;
      redefineAll(WeakMapPrototype, {
        'delete': function _delete(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeDelete.call(this, key) || state.frozen['delete'](key);
          }

          return nativeDelete.call(this, key);
        },
        has: function has(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeHas.call(this, key) || state.frozen.has(key);
          }

          return nativeHas.call(this, key);
        },
        get: function get(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
          }

          return nativeGet.call(this, key);
        },
        set: function set(key, value) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
          } else nativeSet.call(this, key, value);

          return this;
        }
      });
    }
  });

  // https://tc39.github.io/ecma262/#sec-weakset-constructor


  collection('WeakSet', function (init) {
    return function WeakSet() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionWeak);

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  for (var COLLECTION_NAME in domIterables) {
    var Collection = global_1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

    if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
      createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
    } catch (error) {
      CollectionPrototype.forEach = arrayForEach;
    }
  }

  var ITERATOR$6 = wellKnownSymbol('iterator');
  var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
  var ArrayValues = es_array_iterator.values;

  for (var COLLECTION_NAME$1 in domIterables) {
    var Collection$1 = global_1[COLLECTION_NAME$1];
    var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;

    if (CollectionPrototype$1) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype$1[ITERATOR$6] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$6, ArrayValues);
      } catch (error) {
        CollectionPrototype$1[ITERATOR$6] = ArrayValues;
      }

      if (!CollectionPrototype$1[TO_STRING_TAG$4]) {
        createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$4, COLLECTION_NAME$1);
      }

      if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
        }
      }
    }
  }

  var FORCED$l = !global_1.setImmediate || !global_1.clearImmediate; // http://w3c.github.io/setImmediate/

  _export({
    global: true,
    bind: true,
    enumerable: true,
    forced: FORCED$l
  }, {
    // `setImmediate` method
    // http://w3c.github.io/setImmediate/#si-setImmediate
    setImmediate: task.set,
    // `clearImmediate` method
    // http://w3c.github.io/setImmediate/#si-clearImmediate
    clearImmediate: task.clear
  });

  var process$4 = global_1.process;
  var isNode = classofRaw(process$4) == 'process'; // `queueMicrotask` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask

  _export({
    global: true,
    enumerable: true,
    noTargetGet: true
  }, {
    queueMicrotask: function queueMicrotask(fn) {
      var domain = isNode && process$4.domain;
      microtask(domain ? domain.bind(fn) : fn);
    }
  });

  var ITERATOR$7 = wellKnownSymbol('iterator');
  var nativeUrl = !fails(function () {
    var url = new URL('b?a=1&b=2&c=3', 'http://a');
    var searchParams = url.searchParams;
    var result = '';
    url.pathname = 'c%20d';
    searchParams.forEach(function (value, key) {
      searchParams['delete']('b');
      result += key + value;
    });
    return isPure && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR$7] // throws in Edge
    || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc' // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1' // fails in Chrome 66-
    || result !== 'a1c3' // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
  });

  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80

  var delimiter = '-'; // '\x2D'

  var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars

  var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
  var baseMinusTMin = base - tMin;
  var floor$8 = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   */

  var ucs2decode = function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;

    while (counter < length) {
      var value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  };
  /**
   * Converts a digit/integer into a basic code point.
   */


  var digitToBasic = function digitToBasic(digit) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26);
  };
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   */


  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor$8(delta / damp) : delta >> 1;
    delta += floor$8(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor$8(delta / baseMinusTMin);
    }

    return floor$8(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   */
  // eslint-disable-next-line  max-statements


  var encode = function encode(input) {
    var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

    input = ucs2decode(input); // Cache the length.

    var inputLength = input.length; // Initialize the state.

    var n = initialN;
    var delta = 0;
    var bias = initialBias;
    var i, currentValue; // Handle the basic code points.

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    var basicLength = output.length; // number of basic code points.

    var handledCPCount = basicLength; // number of code points that have been handled;
    // Finish the basic string with a delimiter unless it's empty.

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next larger one:
      var m = maxInt;

      for (i = 0; i < input.length; i++) {
        currentValue = input[i];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.


      var handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor$8((maxInt - delta) / handledCPCountPlusOne)) {
        throw RangeError(OVERFLOW_ERROR);
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (i = 0; i < input.length; i++) {
        currentValue = input[i];

        if (currentValue < n && ++delta > maxInt) {
          throw RangeError(OVERFLOW_ERROR);
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer.
          var q = delta;

          for (var k = base;;
          /* no condition */
          k += base) {
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) break;
            var qMinusT = q - t;
            var baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
            q = floor$8(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  };

  var stringPunycodeToAscii = function stringPunycodeToAscii(input) {
    var encoded = [];
    var labels = input.toLowerCase().replace(regexSeparators, ".").split('.');
    var i, label;

    for (i = 0; i < labels.length; i++) {
      label = labels[i];
      encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
    }

    return encoded.join('.');
  };

  var getIterator = function getIterator(it) {
    var iteratorMethod = getIteratorMethod(it);

    if (typeof iteratorMethod != 'function') {
      throw TypeError(String(it) + ' is not iterable');
    }

    return anObject(iteratorMethod.call(it));
  };

  var $fetch$1 = getBuiltIn('fetch');
  var Headers = getBuiltIn('Headers');
  var ITERATOR$8 = wellKnownSymbol('iterator');
  var URL_SEARCH_PARAMS = 'URLSearchParams';
  var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
  var setInternalState$9 = internalState.set;
  var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
  var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);
  var plus = /\+/g;
  var sequences = Array(4);

  var percentSequence = function percentSequence(bytes) {
    return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
  };

  var percentDecode = function percentDecode(sequence) {
    try {
      return decodeURIComponent(sequence);
    } catch (error) {
      return sequence;
    }
  };

  var deserialize = function deserialize(it) {
    var result = it.replace(plus, ' ');
    var bytes = 4;

    try {
      return decodeURIComponent(result);
    } catch (error) {
      while (bytes) {
        result = result.replace(percentSequence(bytes--), percentDecode);
      }

      return result;
    }
  };

  var find$1 = /[!'()~]|%20/g;
  var replace = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+'
  };

  var replacer = function replacer(match) {
    return replace[match];
  };

  var serialize = function serialize(it) {
    return encodeURIComponent(it).replace(find$1, replacer);
  };

  var parseSearchParams = function parseSearchParams(result, query) {
    if (query) {
      var attributes = query.split('&');
      var index = 0;
      var attribute, entry;

      while (index < attributes.length) {
        attribute = attributes[index++];

        if (attribute.length) {
          entry = attribute.split('=');
          result.push({
            key: deserialize(entry.shift()),
            value: deserialize(entry.join('='))
          });
        }
      }
    }
  };

  var updateSearchParams = function updateSearchParams(query) {
    this.entries.length = 0;
    parseSearchParams(this.entries, query);
  };

  var validateArgumentsLength = function validateArgumentsLength(passed, required) {
    if (passed < required) throw TypeError('Not enough arguments');
  };

  var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
    setInternalState$9(this, {
      type: URL_SEARCH_PARAMS_ITERATOR,
      iterator: getIterator(getInternalParamsState(params).entries),
      kind: kind
    });
  }, 'Iterator', function next() {
    var state = getInternalIteratorState(this);
    var kind = state.kind;
    var step = state.iterator.next();
    var entry = step.value;

    if (!step.done) {
      step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
    }

    return step;
  }); // `URLSearchParams` constructor
  // https://url.spec.whatwg.org/#interface-urlsearchparams

  var URLSearchParamsConstructor = function URLSearchParams()
  /* init */
  {
    anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    var init = arguments.length > 0 ? arguments[0] : undefined;
    var that = this;
    var entries = [];
    var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
    setInternalState$9(that, {
      type: URL_SEARCH_PARAMS,
      entries: entries,
      updateURL: function updateURL() {
        /* empty */
      },
      updateSearchParams: updateSearchParams
    });

    if (init !== undefined) {
      if (isObject(init)) {
        iteratorMethod = getIteratorMethod(init);

        if (typeof iteratorMethod === 'function') {
          iterator = iteratorMethod.call(init);
          next = iterator.next;

          while (!(step = next.call(iterator)).done) {
            entryIterator = getIterator(anObject(step.value));
            entryNext = entryIterator.next;
            if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
            entries.push({
              key: first.value + '',
              value: second.value + ''
            });
          }
        } else for (key in init) {
          if (has(init, key)) entries.push({
            key: key,
            value: init[key] + ''
          });
        }
      } else {
        parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
      }
    }
  };

  var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
  redefineAll(URLSearchParamsPrototype, {
    // `URLSearchParams.prototype.appent` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-append
    append: function append(name, value) {
      validateArgumentsLength(arguments.length, 2);
      var state = getInternalParamsState(this);
      state.entries.push({
        key: name + '',
        value: value + ''
      });
      state.updateURL();
    },
    // `URLSearchParams.prototype.delete` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
    'delete': function _delete(name) {
      validateArgumentsLength(arguments.length, 1);
      var state = getInternalParamsState(this);
      var entries = state.entries;
      var key = name + '';
      var index = 0;

      while (index < entries.length) {
        if (entries[index].key === key) entries.splice(index, 1);else index++;
      }

      state.updateURL();
    },
    // `URLSearchParams.prototype.get` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-get
    get: function get(name) {
      validateArgumentsLength(arguments.length, 1);
      var entries = getInternalParamsState(this).entries;
      var key = name + '';
      var index = 0;

      for (; index < entries.length; index++) {
        if (entries[index].key === key) return entries[index].value;
      }

      return null;
    },
    // `URLSearchParams.prototype.getAll` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
    getAll: function getAll(name) {
      validateArgumentsLength(arguments.length, 1);
      var entries = getInternalParamsState(this).entries;
      var key = name + '';
      var result = [];
      var index = 0;

      for (; index < entries.length; index++) {
        if (entries[index].key === key) result.push(entries[index].value);
      }

      return result;
    },
    // `URLSearchParams.prototype.has` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-has
    has: function has(name) {
      validateArgumentsLength(arguments.length, 1);
      var entries = getInternalParamsState(this).entries;
      var key = name + '';
      var index = 0;

      while (index < entries.length) {
        if (entries[index++].key === key) return true;
      }

      return false;
    },
    // `URLSearchParams.prototype.set` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-set
    set: function set(name, value) {
      validateArgumentsLength(arguments.length, 1);
      var state = getInternalParamsState(this);
      var entries = state.entries;
      var found = false;
      var key = name + '';
      var val = value + '';
      var index = 0;
      var entry;

      for (; index < entries.length; index++) {
        entry = entries[index];

        if (entry.key === key) {
          if (found) entries.splice(index--, 1);else {
            found = true;
            entry.value = val;
          }
        }
      }

      if (!found) entries.push({
        key: key,
        value: val
      });
      state.updateURL();
    },
    // `URLSearchParams.prototype.sort` method
    // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
    sort: function sort() {
      var state = getInternalParamsState(this);
      var entries = state.entries; // Array#sort is not stable in some engines

      var slice = entries.slice();
      var entry, entriesIndex, sliceIndex;
      entries.length = 0;

      for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
        entry = slice[sliceIndex];

        for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
          if (entries[entriesIndex].key > entry.key) {
            entries.splice(entriesIndex, 0, entry);
            break;
          }
        }

        if (entriesIndex === sliceIndex) entries.push(entry);
      }

      state.updateURL();
    },
    // `URLSearchParams.prototype.forEach` method
    forEach: function forEach(callback
    /* , thisArg */
    ) {
      var entries = getInternalParamsState(this).entries;
      var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
      var index = 0;
      var entry;

      while (index < entries.length) {
        entry = entries[index++];
        boundFunction(entry.value, entry.key, this);
      }
    },
    // `URLSearchParams.prototype.keys` method
    keys: function keys() {
      return new URLSearchParamsIterator(this, 'keys');
    },
    // `URLSearchParams.prototype.values` method
    values: function values() {
      return new URLSearchParamsIterator(this, 'values');
    },
    // `URLSearchParams.prototype.entries` method
    entries: function entries() {
      return new URLSearchParamsIterator(this, 'entries');
    }
  }, {
    enumerable: true
  }); // `URLSearchParams.prototype[@@iterator]` method

  redefine(URLSearchParamsPrototype, ITERATOR$8, URLSearchParamsPrototype.entries); // `URLSearchParams.prototype.toString` method
  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior

  redefine(URLSearchParamsPrototype, 'toString', function toString() {
    var entries = getInternalParamsState(this).entries;
    var result = [];
    var index = 0;
    var entry;

    while (index < entries.length) {
      entry = entries[index++];
      result.push(serialize(entry.key) + '=' + serialize(entry.value));
    }

    return result.join('&');
  }, {
    enumerable: true
  });
  setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  _export({
    global: true,
    forced: !nativeUrl
  }, {
    URLSearchParams: URLSearchParamsConstructor
  }); // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
  // https://github.com/zloirock/core-js/issues/674

  if (!nativeUrl && typeof $fetch$1 == 'function' && typeof Headers == 'function') {
    _export({
      global: true,
      enumerable: true,
      forced: true
    }, {
      fetch: function fetch(input
      /* , init */
      ) {
        var args = [input];
        var init, body, headers;

        if (arguments.length > 1) {
          init = arguments[1];

          if (isObject(init)) {
            body = init.body;

            if (classof(body) === URL_SEARCH_PARAMS) {
              headers = init.headers ? new Headers(init.headers) : new Headers();

              if (!headers.has('content-type')) {
                headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
              }

              init = objectCreate(init, {
                body: createPropertyDescriptor(0, String(body)),
                headers: createPropertyDescriptor(0, headers)
              });
            }
          }

          args.push(init);
        }

        return $fetch$1.apply(this, args);
      }
    });
  }

  var web_urlSearchParams = {
    URLSearchParams: URLSearchParamsConstructor,
    getState: getInternalParamsState
  };

  var codeAt$1 = stringMultibyte.codeAt;
  var NativeURL = global_1.URL;
  var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
  var getInternalSearchParamsState = web_urlSearchParams.getState;
  var setInternalState$a = internalState.set;
  var getInternalURLState = internalState.getterFor('URL');
  var floor$9 = Math.floor;
  var pow$4 = Math.pow;
  var INVALID_AUTHORITY = 'Invalid authority';
  var INVALID_SCHEME = 'Invalid scheme';
  var INVALID_HOST = 'Invalid host';
  var INVALID_PORT = 'Invalid port';
  var ALPHA = /[A-Za-z]/;
  var ALPHANUMERIC = /[\d+-.A-Za-z]/;
  var DIGIT = /\d/;
  var HEX_START = /^(0x|0X)/;
  var OCT = /^[0-7]+$/;
  var DEC = /^\d+$/;
  var HEX = /^[\dA-Fa-f]+$/; // eslint-disable-next-line no-control-regex

  var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/; // eslint-disable-next-line no-control-regex

  var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/; // eslint-disable-next-line no-control-regex

  var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g; // eslint-disable-next-line no-control-regex

  var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
  var EOF;

  var parseHost = function parseHost(url, input) {
    var result, codePoints, index;

    if (input.charAt(0) == '[') {
      if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
      result = parseIPv6(input.slice(1, -1));
      if (!result) return INVALID_HOST;
      url.host = result; // opaque host
    } else if (!isSpecial(url)) {
      if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
      result = '';
      codePoints = arrayFrom(input);

      for (index = 0; index < codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }

      url.host = result;
    } else {
      input = stringPunycodeToAscii(input);
      if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      url.host = result;
    }
  };

  var parseIPv4 = function parseIPv4(input) {
    var parts = input.split('.');
    var partsLength, numbers, index, part, radix, number, ipv4;

    if (parts.length && parts[parts.length - 1] == '') {
      parts.pop();
    }

    partsLength = parts.length;
    if (partsLength > 4) return input;
    numbers = [];

    for (index = 0; index < partsLength; index++) {
      part = parts[index];
      if (part == '') return input;
      radix = 10;

      if (part.length > 1 && part.charAt(0) == '0') {
        radix = HEX_START.test(part) ? 16 : 8;
        part = part.slice(radix == 8 ? 1 : 2);
      }

      if (part === '') {
        number = 0;
      } else {
        if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
        number = parseInt(part, radix);
      }

      numbers.push(number);
    }

    for (index = 0; index < partsLength; index++) {
      number = numbers[index];

      if (index == partsLength - 1) {
        if (number >= pow$4(256, 5 - partsLength)) return null;
      } else if (number > 255) return null;
    }

    ipv4 = numbers.pop();

    for (index = 0; index < numbers.length; index++) {
      ipv4 += numbers[index] * pow$4(256, 3 - index);
    }

    return ipv4;
  }; // eslint-disable-next-line max-statements


  var parseIPv6 = function parseIPv6(input) {
    var address = [0, 0, 0, 0, 0, 0, 0, 0];
    var pieceIndex = 0;
    var compress = null;
    var pointer = 0;
    var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

    var _char = function _char() {
      return input.charAt(pointer);
    };

    if (_char() == ':') {
      if (input.charAt(1) != ':') return;
      pointer += 2;
      pieceIndex++;
      compress = pieceIndex;
    }

    while (_char()) {
      if (pieceIndex == 8) return;

      if (_char() == ':') {
        if (compress !== null) return;
        pointer++;
        pieceIndex++;
        compress = pieceIndex;
        continue;
      }

      value = length = 0;

      while (length < 4 && HEX.test(_char())) {
        value = value * 16 + parseInt(_char(), 16);
        pointer++;
        length++;
      }

      if (_char() == '.') {
        if (length == 0) return;
        pointer -= length;
        if (pieceIndex > 6) return;
        numbersSeen = 0;

        while (_char()) {
          ipv4Piece = null;

          if (numbersSeen > 0) {
            if (_char() == '.' && numbersSeen < 4) pointer++;else return;
          }

          if (!DIGIT.test(_char())) return;

          while (DIGIT.test(_char())) {
            number = parseInt(_char(), 10);
            if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
            if (ipv4Piece > 255) return;
            pointer++;
          }

          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          numbersSeen++;
          if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
        }

        if (numbersSeen != 4) return;
        break;
      } else if (_char() == ':') {
        pointer++;
        if (!_char()) return;
      } else if (_char()) return;

      address[pieceIndex++] = value;
    }

    if (compress !== null) {
      swaps = pieceIndex - compress;
      pieceIndex = 7;

      while (pieceIndex != 0 && swaps > 0) {
        swap = address[pieceIndex];
        address[pieceIndex--] = address[compress + swaps - 1];
        address[compress + --swaps] = swap;
      }
    } else if (pieceIndex != 8) return;

    return address;
  };

  var findLongestZeroSequence = function findLongestZeroSequence(ipv6) {
    var maxIndex = null;
    var maxLength = 1;
    var currStart = null;
    var currLength = 0;
    var index = 0;

    for (; index < 8; index++) {
      if (ipv6[index] !== 0) {
        if (currLength > maxLength) {
          maxIndex = currStart;
          maxLength = currLength;
        }

        currStart = null;
        currLength = 0;
      } else {
        if (currStart === null) currStart = index;
        ++currLength;
      }
    }

    if (currLength > maxLength) {
      maxIndex = currStart;
      maxLength = currLength;
    }

    return maxIndex;
  };

  var serializeHost = function serializeHost(host) {
    var result, index, compress, ignore0; // ipv4

    if (typeof host == 'number') {
      result = [];

      for (index = 0; index < 4; index++) {
        result.unshift(host % 256);
        host = floor$9(host / 256);
      }

      return result.join('.'); // ipv6
    } else if (_typeof(host) == 'object') {
      result = '';
      compress = findLongestZeroSequence(host);

      for (index = 0; index < 8; index++) {
        if (ignore0 && host[index] === 0) continue;
        if (ignore0) ignore0 = false;

        if (compress === index) {
          result += index ? ':' : '::';
          ignore0 = true;
        } else {
          result += host[index].toString(16);
          if (index < 7) result += ':';
        }
      }

      return '[' + result + ']';
    }

    return host;
  };

  var C0ControlPercentEncodeSet = {};
  var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
    ' ': 1,
    '"': 1,
    '<': 1,
    '>': 1,
    '`': 1
  });
  var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
    '#': 1,
    '?': 1,
    '{': 1,
    '}': 1
  });
  var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
    '/': 1,
    ':': 1,
    ';': 1,
    '=': 1,
    '@': 1,
    '[': 1,
    '\\': 1,
    ']': 1,
    '^': 1,
    '|': 1
  });

  var percentEncode = function percentEncode(_char2, set) {
    var code = codeAt$1(_char2, 0);
    return code > 0x20 && code < 0x7F && !has(set, _char2) ? _char2 : encodeURIComponent(_char2);
  };

  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };

  var isSpecial = function isSpecial(url) {
    return has(specialSchemes, url.scheme);
  };

  var includesCredentials = function includesCredentials(url) {
    return url.username != '' || url.password != '';
  };

  var cannotHaveUsernamePasswordPort = function cannotHaveUsernamePasswordPort(url) {
    return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
  };

  var isWindowsDriveLetter = function isWindowsDriveLetter(string, normalized) {
    var second;
    return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
  };

  var startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(string) {
    var third;
    return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
  };

  var shortenURLsPath = function shortenURLsPath(url) {
    var path = url.path;
    var pathSize = path.length;

    if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
      path.pop();
    }
  };

  var isSingleDot = function isSingleDot(segment) {
    return segment === '.' || segment.toLowerCase() === '%2e';
  };

  var isDoubleDot = function isDoubleDot(segment) {
    segment = segment.toLowerCase();
    return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
  }; // States:


  var SCHEME_START = {};
  var SCHEME = {};
  var NO_SCHEME = {};
  var SPECIAL_RELATIVE_OR_AUTHORITY = {};
  var PATH_OR_AUTHORITY = {};
  var RELATIVE = {};
  var RELATIVE_SLASH = {};
  var SPECIAL_AUTHORITY_SLASHES = {};
  var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
  var AUTHORITY = {};
  var HOST = {};
  var HOSTNAME = {};
  var PORT = {};
  var FILE = {};
  var FILE_SLASH = {};
  var FILE_HOST = {};
  var PATH_START = {};
  var PATH = {};
  var CANNOT_BE_A_BASE_URL_PATH = {};
  var QUERY = {};
  var FRAGMENT = {}; // eslint-disable-next-line max-statements

  var parseURL = function parseURL(url, input, stateOverride, base) {
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = '';
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;

    var codePoints, _char3, bufferCodePoints, failure;

    if (!stateOverride) {
      url.scheme = '';
      url.username = '';
      url.password = '';
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
    }

    input = input.replace(TAB_AND_NEW_LINE, '');
    codePoints = arrayFrom(input);

    while (pointer <= codePoints.length) {
      _char3 = codePoints[pointer];

      switch (state) {
        case SCHEME_START:
          if (_char3 && ALPHA.test(_char3)) {
            buffer += _char3.toLowerCase();
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;

          break;

        case SCHEME:
          if (_char3 && (ALPHANUMERIC.test(_char3) || _char3 == '+' || _char3 == '-' || _char3 == '.')) {
            buffer += _char3.toLowerCase();
          } else if (_char3 == ':') {
            if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
            url.scheme = buffer;

            if (stateOverride) {
              if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
              return;
            }

            buffer = '';

            if (url.scheme == 'file') {
              state = FILE;
            } else if (isSpecial(url) && base && base.scheme == url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (isSpecial(url)) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] == '/') {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              url.path.push('');
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = '';
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;

          break;

        case NO_SCHEME:
          if (!base || base.cannotBeABaseURL && _char3 != '#') return INVALID_SCHEME;

          if (base.cannotBeABaseURL && _char3 == '#') {
            url.scheme = base.scheme;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }

          state = base.scheme == 'file' ? FILE : RELATIVE;
          continue;

        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (_char3 == '/' && codePoints[pointer + 1] == '/') {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          }

          break;

        case PATH_OR_AUTHORITY:
          if (_char3 == '/') {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }

        case RELATIVE:
          url.scheme = base.scheme;

          if (_char3 == EOF) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (_char3 == '/' || _char3 == '\\' && isSpecial(url)) {
            state = RELATIVE_SLASH;
          } else if (_char3 == '?') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (_char3 == '#') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = base.path.slice();
            url.path.pop();
            state = PATH;
            continue;
          }

          break;

        case RELATIVE_SLASH:
          if (isSpecial(url) && (_char3 == '/' || _char3 == '\\')) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (_char3 == '/') {
            state = AUTHORITY;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            state = PATH;
            continue;
          }

          break;

        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (_char3 != '/' || buffer.charAt(pointer + 1) != '/') continue;
          pointer++;
          break;

        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (_char3 != '/' && _char3 != '\\') {
            state = AUTHORITY;
            continue;
          }

          break;

        case AUTHORITY:
          if (_char3 == '@') {
            if (seenAt) buffer = '%40' + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);

            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];

              if (codePoint == ':' && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }

              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
            }

            buffer = '';
          } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url)) {
            if (seenAt && buffer == '') return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = '';
            state = HOST;
          } else buffer += _char3;

          break;

        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme == 'file') {
            state = FILE_HOST;
            continue;
          } else if (_char3 == ':' && !seenBracket) {
            if (buffer == '') return INVALID_HOST;
            failure = parseHost(url, buffer);
            if (failure) return failure;
            buffer = '';
            state = PORT;
            if (stateOverride == HOSTNAME) return;
          } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url)) {
            if (isSpecial(url) && buffer == '') return INVALID_HOST;
            if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
            failure = parseHost(url, buffer);
            if (failure) return failure;
            buffer = '';
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (_char3 == '[') seenBracket = true;else if (_char3 == ']') seenBracket = false;
            buffer += _char3;
          }

          break;

        case PORT:
          if (DIGIT.test(_char3)) {
            buffer += _char3;
          } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url) || stateOverride) {
            if (buffer != '') {
              var port = parseInt(buffer, 10);
              if (port > 0xFFFF) return INVALID_PORT;
              url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
              buffer = '';
            }

            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;

          break;

        case FILE:
          url.scheme = 'file';
          if (_char3 == '/' || _char3 == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
            if (_char3 == EOF) {
              url.host = base.host;
              url.path = base.path.slice();
              url.query = base.query;
            } else if (_char3 == '?') {
              url.host = base.host;
              url.path = base.path.slice();
              url.query = '';
              state = QUERY;
            } else if (_char3 == '#') {
              url.host = base.host;
              url.path = base.path.slice();
              url.query = base.query;
              url.fragment = '';
              state = FRAGMENT;
            } else {
              if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
                url.host = base.host;
                url.path = base.path.slice();
                shortenURLsPath(url);
              }

              state = PATH;
              continue;
            }
          } else {
            state = PATH;
            continue;
          }
          break;

        case FILE_SLASH:
          if (_char3 == '/' || _char3 == '\\') {
            state = FILE_HOST;
            break;
          }

          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
            if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);else url.host = base.host;
          }

          state = PATH;
          continue;

        case FILE_HOST:
          if (_char3 == EOF || _char3 == '/' || _char3 == '\\' || _char3 == '?' || _char3 == '#') {
            if (!stateOverride && isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer == '') {
              url.host = '';
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = parseHost(url, buffer);
              if (failure) return failure;
              if (url.host == 'localhost') url.host = '';
              if (stateOverride) return;
              buffer = '';
              state = PATH_START;
            }

            continue;
          } else buffer += _char3;

          break;

        case PATH_START:
          if (isSpecial(url)) {
            state = PATH;
            if (_char3 != '/' && _char3 != '\\') continue;
          } else if (!stateOverride && _char3 == '?') {
            url.query = '';
            state = QUERY;
          } else if (!stateOverride && _char3 == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (_char3 != EOF) {
            state = PATH;
            if (_char3 != '/') continue;
          }

          break;

        case PATH:
          if (_char3 == EOF || _char3 == '/' || _char3 == '\\' && isSpecial(url) || !stateOverride && (_char3 == '?' || _char3 == '#')) {
            if (isDoubleDot(buffer)) {
              shortenURLsPath(url);

              if (_char3 != '/' && !(_char3 == '\\' && isSpecial(url))) {
                url.path.push('');
              }
            } else if (isSingleDot(buffer)) {
              if (_char3 != '/' && !(_char3 == '\\' && isSpecial(url))) {
                url.path.push('');
              }
            } else {
              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = '';
                buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
              }

              url.path.push(buffer);
            }

            buffer = '';

            if (url.scheme == 'file' && (_char3 == EOF || _char3 == '?' || _char3 == '#')) {
              while (url.path.length > 1 && url.path[0] === '') {
                url.path.shift();
              }
            }

            if (_char3 == '?') {
              url.query = '';
              state = QUERY;
            } else if (_char3 == '#') {
              url.fragment = '';
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(_char3, pathPercentEncodeSet);
          }

          break;

        case CANNOT_BE_A_BASE_URL_PATH:
          if (_char3 == '?') {
            url.query = '';
            state = QUERY;
          } else if (_char3 == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (_char3 != EOF) {
            url.path[0] += percentEncode(_char3, C0ControlPercentEncodeSet);
          }

          break;

        case QUERY:
          if (!stateOverride && _char3 == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (_char3 != EOF) {
            if (_char3 == "'" && isSpecial(url)) url.query += '%27';else if (_char3 == '#') url.query += '%23';else url.query += percentEncode(_char3, C0ControlPercentEncodeSet);
          }

          break;

        case FRAGMENT:
          if (_char3 != EOF) url.fragment += percentEncode(_char3, fragmentPercentEncodeSet);
          break;
      }

      pointer++;
    }
  }; // `URL` constructor
  // https://url.spec.whatwg.org/#url-class


  var URLConstructor = function URL(url
  /* , base */
  ) {
    var that = anInstance(this, URLConstructor, 'URL');
    var base = arguments.length > 1 ? arguments[1] : undefined;
    var urlString = String(url);
    var state = setInternalState$a(that, {
      type: 'URL'
    });
    var baseState, failure;

    if (base !== undefined) {
      if (base instanceof URLConstructor) baseState = getInternalURLState(base);else {
        failure = parseURL(baseState = {}, String(base));
        if (failure) throw TypeError(failure);
      }
    }

    failure = parseURL(state, urlString, null, baseState);
    if (failure) throw TypeError(failure);
    var searchParams = state.searchParams = new URLSearchParams$1();
    var searchParamsState = getInternalSearchParamsState(searchParams);
    searchParamsState.updateSearchParams(state.query);

    searchParamsState.updateURL = function () {
      state.query = String(searchParams) || null;
    };

    if (!descriptors) {
      that.href = serializeURL.call(that);
      that.origin = getOrigin.call(that);
      that.protocol = getProtocol.call(that);
      that.username = getUsername.call(that);
      that.password = getPassword.call(that);
      that.host = getHost.call(that);
      that.hostname = getHostname.call(that);
      that.port = getPort.call(that);
      that.pathname = getPathname.call(that);
      that.search = getSearch.call(that);
      that.searchParams = getSearchParams.call(that);
      that.hash = getHash.call(that);
    }
  };

  var URLPrototype = URLConstructor.prototype;

  var serializeURL = function serializeURL() {
    var url = getInternalURLState(this);
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ':';

    if (host !== null) {
      output += '//';

      if (includesCredentials(url)) {
        output += username + (password ? ':' + password : '') + '@';
      }

      output += serializeHost(host);
      if (port !== null) output += ':' + port;
    } else if (scheme == 'file') output += '//';

    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
    if (query !== null) output += '?' + query;
    if (fragment !== null) output += '#' + fragment;
    return output;
  };

  var getOrigin = function getOrigin() {
    var url = getInternalURLState(this);
    var scheme = url.scheme;
    var port = url.port;
    if (scheme == 'blob') try {
      return new URL(scheme.path[0]).origin;
    } catch (error) {
      return 'null';
    }
    if (scheme == 'file' || !isSpecial(url)) return 'null';
    return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
  };

  var getProtocol = function getProtocol() {
    return getInternalURLState(this).scheme + ':';
  };

  var getUsername = function getUsername() {
    return getInternalURLState(this).username;
  };

  var getPassword = function getPassword() {
    return getInternalURLState(this).password;
  };

  var getHost = function getHost() {
    var url = getInternalURLState(this);
    var host = url.host;
    var port = url.port;
    return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
  };

  var getHostname = function getHostname() {
    var host = getInternalURLState(this).host;
    return host === null ? '' : serializeHost(host);
  };

  var getPort = function getPort() {
    var port = getInternalURLState(this).port;
    return port === null ? '' : String(port);
  };

  var getPathname = function getPathname() {
    var url = getInternalURLState(this);
    var path = url.path;
    return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  };

  var getSearch = function getSearch() {
    var query = getInternalURLState(this).query;
    return query ? '?' + query : '';
  };

  var getSearchParams = function getSearchParams() {
    return getInternalURLState(this).searchParams;
  };

  var getHash = function getHash() {
    var fragment = getInternalURLState(this).fragment;
    return fragment ? '#' + fragment : '';
  };

  var accessorDescriptor = function accessorDescriptor(getter, setter) {
    return {
      get: getter,
      set: setter,
      configurable: true,
      enumerable: true
    };
  };

  if (descriptors) {
    objectDefineProperties(URLPrototype, {
      // `URL.prototype.href` accessors pair
      // https://url.spec.whatwg.org/#dom-url-href
      href: accessorDescriptor(serializeURL, function (href) {
        var url = getInternalURLState(this);
        var urlString = String(href);
        var failure = parseURL(url, urlString);
        if (failure) throw TypeError(failure);
        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
      }),
      // `URL.prototype.origin` getter
      // https://url.spec.whatwg.org/#dom-url-origin
      origin: accessorDescriptor(getOrigin),
      // `URL.prototype.protocol` accessors pair
      // https://url.spec.whatwg.org/#dom-url-protocol
      protocol: accessorDescriptor(getProtocol, function (protocol) {
        var url = getInternalURLState(this);
        parseURL(url, String(protocol) + ':', SCHEME_START);
      }),
      // `URL.prototype.username` accessors pair
      // https://url.spec.whatwg.org/#dom-url-username
      username: accessorDescriptor(getUsername, function (username) {
        var url = getInternalURLState(this);
        var codePoints = arrayFrom(String(username));
        if (cannotHaveUsernamePasswordPort(url)) return;
        url.username = '';

        for (var i = 0; i < codePoints.length; i++) {
          url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      }),
      // `URL.prototype.password` accessors pair
      // https://url.spec.whatwg.org/#dom-url-password
      password: accessorDescriptor(getPassword, function (password) {
        var url = getInternalURLState(this);
        var codePoints = arrayFrom(String(password));
        if (cannotHaveUsernamePasswordPort(url)) return;
        url.password = '';

        for (var i = 0; i < codePoints.length; i++) {
          url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      }),
      // `URL.prototype.host` accessors pair
      // https://url.spec.whatwg.org/#dom-url-host
      host: accessorDescriptor(getHost, function (host) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        parseURL(url, String(host), HOST);
      }),
      // `URL.prototype.hostname` accessors pair
      // https://url.spec.whatwg.org/#dom-url-hostname
      hostname: accessorDescriptor(getHostname, function (hostname) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        parseURL(url, String(hostname), HOSTNAME);
      }),
      // `URL.prototype.port` accessors pair
      // https://url.spec.whatwg.org/#dom-url-port
      port: accessorDescriptor(getPort, function (port) {
        var url = getInternalURLState(this);
        if (cannotHaveUsernamePasswordPort(url)) return;
        port = String(port);
        if (port == '') url.port = null;else parseURL(url, port, PORT);
      }),
      // `URL.prototype.pathname` accessors pair
      // https://url.spec.whatwg.org/#dom-url-pathname
      pathname: accessorDescriptor(getPathname, function (pathname) {
        var url = getInternalURLState(this);
        if (url.cannotBeABaseURL) return;
        url.path = [];
        parseURL(url, pathname + '', PATH_START);
      }),
      // `URL.prototype.search` accessors pair
      // https://url.spec.whatwg.org/#dom-url-search
      search: accessorDescriptor(getSearch, function (search) {
        var url = getInternalURLState(this);
        search = String(search);

        if (search == '') {
          url.query = null;
        } else {
          if ('?' == search.charAt(0)) search = search.slice(1);
          url.query = '';
          parseURL(url, search, QUERY);
        }

        getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
      }),
      // `URL.prototype.searchParams` getter
      // https://url.spec.whatwg.org/#dom-url-searchparams
      searchParams: accessorDescriptor(getSearchParams),
      // `URL.prototype.hash` accessors pair
      // https://url.spec.whatwg.org/#dom-url-hash
      hash: accessorDescriptor(getHash, function (hash) {
        var url = getInternalURLState(this);
        hash = String(hash);

        if (hash == '') {
          url.fragment = null;
          return;
        }

        if ('#' == hash.charAt(0)) hash = hash.slice(1);
        url.fragment = '';
        parseURL(url, hash, FRAGMENT);
      })
    });
  } // `URL.prototype.toJSON` method
  // https://url.spec.whatwg.org/#dom-url-tojson


  redefine(URLPrototype, 'toJSON', function toJSON() {
    return serializeURL.call(this);
  }, {
    enumerable: true
  }); // `URL.prototype.toString` method
  // https://url.spec.whatwg.org/#URL-stringification-behavior

  redefine(URLPrototype, 'toString', function toString() {
    return serializeURL.call(this);
  }, {
    enumerable: true
  });

  if (NativeURL) {
    var nativeCreateObjectURL = NativeURL.createObjectURL;
    var nativeRevokeObjectURL = NativeURL.revokeObjectURL; // `URL.createObjectURL` method
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
    // eslint-disable-next-line no-unused-vars

    if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
      return nativeCreateObjectURL.apply(NativeURL, arguments);
    }); // `URL.revokeObjectURL` method
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
    // eslint-disable-next-line no-unused-vars

    if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
      return nativeRevokeObjectURL.apply(NativeURL, arguments);
    });
  }

  setToStringTag(URLConstructor, 'URL');
  _export({
    global: true,
    forced: !nativeUrl,
    sham: !descriptors
  }, {
    URL: URLConstructor
  });

  // https://url.spec.whatwg.org/#dom-url-tojson


  _export({
    target: 'URL',
    proto: true,
    enumerable: true
  }, {
    toJSON: function toJSON() {
      return URL.prototype.toString.call(this);
    }
  });

  var runtime_1 = createCommonjsModule(function (module) {
    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};

      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };

      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  });

  // http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/

  /**
   *
   * @param {Event} ev
   * @returns {void}
   */
  function touchHandler(ev) {
    var changedTouches = ev.changedTouches,
        first = changedTouches[0];
    var type = '';

    switch (ev.type) {
      case 'touchstart':
        type = 'mousedown';
        break;

      case 'touchmove':
        type = 'mousemove';
        break;

      case 'touchend':
        type = 'mouseup';
        break;

      default:
        return;
    }

    var screenX = first.screenX,
        screenY = first.screenY,
        clientX = first.clientX,
        clientY = first.clientY; // eslint-disable-line no-shadow

    var simulatedEvent = new MouseEvent(type, {
      // Event interface
      bubbles: true,
      cancelable: true,
      // UIEvent interface
      view: window,
      detail: 1,
      // click count
      // MouseEvent interface (customized)
      screenX: screenX,
      screenY: screenY,
      clientX: clientX,
      clientY: clientY,
      // MouseEvent interface (defaults) - these could be removed
      ctrlKey: false,
      altKey: false,
      shiftKey: false,
      metaKey: false,
      button: 0,
      // main button (usually left)
      relatedTarget: null
    });

    if (changedTouches.length < 2) {
      first.target.dispatchEvent(simulatedEvent);
      ev.preventDefault();
    }
  }

  document.addEventListener('touchstart', touchHandler, true);
  document.addEventListener('touchmove', touchHandler, true);
  document.addEventListener('touchend', touchHandler, true);
  document.addEventListener('touchcancel', touchHandler, true);

  /**
   * Namespaces or tools therefor.
   * @module namespaces
   * @license MIT
  */

  /**
  * Common namepaces constants in alpha order.
  * @enum {string}
  * @type {PlainObject}
  * @memberof module:namespaces
  */
  var NS = {
    HTML: 'http://www.w3.org/1999/xhtml',
    MATH: 'http://www.w3.org/1998/Math/MathML',
    SE: 'http://svg-edit.googlecode.com',
    SVG: 'http://www.w3.org/2000/svg',
    XLINK: 'http://www.w3.org/1999/xlink',
    XML: 'http://www.w3.org/XML/1998/namespace',
    XMLNS: 'http://www.w3.org/2000/xmlns/' // see http://www.w3.org/TR/REC-xml-names/#xmlReserved

  };
  /**
  * @function module:namespaces.getReverseNS
  * @returns {string} The NS with key values switched and lowercase
  */

  var getReverseNS = function getReverseNS() {
    var reverseNS = {};
    Object.entries(NS).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          name = _ref2[0],
          URI = _ref2[1];

      reverseNS[URI] = name.toLowerCase();
    });
    return reverseNS;
  };

  /* eslint-disable import/unambiguous, max-len */

  /* globals SVGPathSeg, SVGPathSegMovetoRel, SVGPathSegMovetoAbs,
      SVGPathSegMovetoRel, SVGPathSegLinetoRel, SVGPathSegLinetoAbs,
      SVGPathSegLinetoHorizontalRel, SVGPathSegLinetoHorizontalAbs,
      SVGPathSegLinetoVerticalRel, SVGPathSegLinetoVerticalAbs,
      SVGPathSegClosePath, SVGPathSegCurvetoCubicRel,
      SVGPathSegCurvetoCubicAbs, SVGPathSegCurvetoCubicSmoothRel,
      SVGPathSegCurvetoCubicSmoothAbs, SVGPathSegCurvetoQuadraticRel,
      SVGPathSegCurvetoQuadraticAbs, SVGPathSegCurvetoQuadraticSmoothRel,
      SVGPathSegCurvetoQuadraticSmoothAbs, SVGPathSegArcRel, SVGPathSegArcAbs */

  /**
  * SVGPathSeg API polyfill
  * https://github.com/progers/pathseg
  *
  * This is a drop-in replacement for the `SVGPathSeg` and `SVGPathSegList` APIs
  * that were removed from SVG2 ({@link https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html}),
  * including the latest spec changes which were implemented in Firefox 43 and
  * Chrome 46.
  */

  /* eslint-disable no-shadow, class-methods-use-this, jsdoc/require-jsdoc */
  // Linting: We avoid `no-shadow` as ESLint thinks these are still available globals
  // Linting: We avoid `class-methods-use-this` as this is a polyfill that must
  //   follow the conventions
  (function () {
    if (!('SVGPathSeg' in window)) {
      // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
      var _SVGPathSeg = /*#__PURE__*/function () {
        function _SVGPathSeg(type, typeAsLetter, owningPathSegList) {
          _classCallCheck(this, _SVGPathSeg);

          this.pathSegType = type;
          this.pathSegTypeAsLetter = typeAsLetter;
          this._owningPathSegList = owningPathSegList;
        } // Notify owning PathSegList on any changes so they can be synchronized back to the path element.


        _createClass(_SVGPathSeg, [{
          key: "_segmentChanged",
          value: function _segmentChanged() {
            if (this._owningPathSegList) {
              this._owningPathSegList.segmentChanged(this);
            }
          }
        }]);

        return _SVGPathSeg;
      }();

      _SVGPathSeg.prototype.classname = 'SVGPathSeg';
      _SVGPathSeg.PATHSEG_UNKNOWN = 0;
      _SVGPathSeg.PATHSEG_CLOSEPATH = 1;
      _SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
      _SVGPathSeg.PATHSEG_MOVETO_REL = 3;
      _SVGPathSeg.PATHSEG_LINETO_ABS = 4;
      _SVGPathSeg.PATHSEG_LINETO_REL = 5;
      _SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
      _SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
      _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
      _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
      _SVGPathSeg.PATHSEG_ARC_ABS = 10;
      _SVGPathSeg.PATHSEG_ARC_REL = 11;
      _SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
      _SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
      _SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
      _SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
      _SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
      _SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
      _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
      _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

      var _SVGPathSegClosePath = /*#__PURE__*/function (_SVGPathSeg2) {
        _inherits(_SVGPathSegClosePath, _SVGPathSeg2);

        var _super = _createSuper(_SVGPathSegClosePath);

        function _SVGPathSegClosePath(owningPathSegList) {
          _classCallCheck(this, _SVGPathSegClosePath);

          return _super.call(this, _SVGPathSeg.PATHSEG_CLOSEPATH, 'z', owningPathSegList);
        }

        _createClass(_SVGPathSegClosePath, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegClosePath]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegClosePath(undefined);
          }
        }]);

        return _SVGPathSegClosePath;
      }(_SVGPathSeg);

      var _SVGPathSegMovetoAbs = /*#__PURE__*/function (_SVGPathSeg3) {
        _inherits(_SVGPathSegMovetoAbs, _SVGPathSeg3);

        var _super2 = _createSuper(_SVGPathSegMovetoAbs);

        function _SVGPathSegMovetoAbs(owningPathSegList, x, y) {
          var _this;

          _classCallCheck(this, _SVGPathSegMovetoAbs);

          _this = _super2.call(this, _SVGPathSeg.PATHSEG_MOVETO_ABS, 'M', owningPathSegList);
          _this._x = x;
          _this._y = y;
          return _this;
        }

        _createClass(_SVGPathSegMovetoAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegMovetoAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegMovetoAbs(undefined, this._x, this._y);
          }
        }]);

        return _SVGPathSegMovetoAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegMovetoAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegMovetoRel = /*#__PURE__*/function (_SVGPathSeg4) {
        _inherits(_SVGPathSegMovetoRel, _SVGPathSeg4);

        var _super3 = _createSuper(_SVGPathSegMovetoRel);

        function _SVGPathSegMovetoRel(owningPathSegList, x, y) {
          var _this2;

          _classCallCheck(this, _SVGPathSegMovetoRel);

          _this2 = _super3.call(this, _SVGPathSeg.PATHSEG_MOVETO_REL, 'm', owningPathSegList);
          _this2._x = x;
          _this2._y = y;
          return _this2;
        }

        _createClass(_SVGPathSegMovetoRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegMovetoRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegMovetoRel(undefined, this._x, this._y);
          }
        }]);

        return _SVGPathSegMovetoRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegMovetoRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegLinetoAbs = /*#__PURE__*/function (_SVGPathSeg5) {
        _inherits(_SVGPathSegLinetoAbs, _SVGPathSeg5);

        var _super4 = _createSuper(_SVGPathSegLinetoAbs);

        function _SVGPathSegLinetoAbs(owningPathSegList, x, y) {
          var _this3;

          _classCallCheck(this, _SVGPathSegLinetoAbs);

          _this3 = _super4.call(this, _SVGPathSeg.PATHSEG_LINETO_ABS, 'L', owningPathSegList);
          _this3._x = x;
          _this3._y = y;
          return _this3;
        }

        _createClass(_SVGPathSegLinetoAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegLinetoAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegLinetoAbs(undefined, this._x, this._y);
          }
        }]);

        return _SVGPathSegLinetoAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegLinetoAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegLinetoRel = /*#__PURE__*/function (_SVGPathSeg6) {
        _inherits(_SVGPathSegLinetoRel, _SVGPathSeg6);

        var _super5 = _createSuper(_SVGPathSegLinetoRel);

        function _SVGPathSegLinetoRel(owningPathSegList, x, y) {
          var _this4;

          _classCallCheck(this, _SVGPathSegLinetoRel);

          _this4 = _super5.call(this, _SVGPathSeg.PATHSEG_LINETO_REL, 'l', owningPathSegList);
          _this4._x = x;
          _this4._y = y;
          return _this4;
        }

        _createClass(_SVGPathSegLinetoRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegLinetoRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegLinetoRel(undefined, this._x, this._y);
          }
        }]);

        return _SVGPathSegLinetoRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegLinetoRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoCubicAbs = /*#__PURE__*/function (_SVGPathSeg7) {
        _inherits(_SVGPathSegCurvetoCubicAbs, _SVGPathSeg7);

        var _super6 = _createSuper(_SVGPathSegCurvetoCubicAbs);

        function _SVGPathSegCurvetoCubicAbs(owningPathSegList, x, y, x1, y1, x2, y2) {
          var _this5;

          _classCallCheck(this, _SVGPathSegCurvetoCubicAbs);

          _this5 = _super6.call(this, _SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, 'C', owningPathSegList);
          _this5._x = x;
          _this5._y = y;
          _this5._x1 = x1;
          _this5._y1 = y1;
          _this5._x2 = x2;
          _this5._y2 = y2;
          return _this5;
        }

        _createClass(_SVGPathSegCurvetoCubicAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoCubicAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
          }
        }]);

        return _SVGPathSegCurvetoCubicAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoCubicAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        x1: {
          get: function get() {
            return this._x1;
          },
          set: function set(x1) {
            this._x1 = x1;

            this._segmentChanged();
          },
          enumerable: true
        },
        y1: {
          get: function get() {
            return this._y1;
          },
          set: function set(y1) {
            this._y1 = y1;

            this._segmentChanged();
          },
          enumerable: true
        },
        x2: {
          get: function get() {
            return this._x2;
          },
          set: function set(x2) {
            this._x2 = x2;

            this._segmentChanged();
          },
          enumerable: true
        },
        y2: {
          get: function get() {
            return this._y2;
          },
          set: function set(y2) {
            this._y2 = y2;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoCubicRel = /*#__PURE__*/function (_SVGPathSeg8) {
        _inherits(_SVGPathSegCurvetoCubicRel, _SVGPathSeg8);

        var _super7 = _createSuper(_SVGPathSegCurvetoCubicRel);

        function _SVGPathSegCurvetoCubicRel(owningPathSegList, x, y, x1, y1, x2, y2) {
          var _this6;

          _classCallCheck(this, _SVGPathSegCurvetoCubicRel);

          _this6 = _super7.call(this, _SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, 'c', owningPathSegList);
          _this6._x = x;
          _this6._y = y;
          _this6._x1 = x1;
          _this6._y1 = y1;
          _this6._x2 = x2;
          _this6._y2 = y2;
          return _this6;
        }

        _createClass(_SVGPathSegCurvetoCubicRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoCubicRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
          }
        }]);

        return _SVGPathSegCurvetoCubicRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoCubicRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        x1: {
          get: function get() {
            return this._x1;
          },
          set: function set(x1) {
            this._x1 = x1;

            this._segmentChanged();
          },
          enumerable: true
        },
        y1: {
          get: function get() {
            return this._y1;
          },
          set: function set(y1) {
            this._y1 = y1;

            this._segmentChanged();
          },
          enumerable: true
        },
        x2: {
          get: function get() {
            return this._x2;
          },
          set: function set(x2) {
            this._x2 = x2;

            this._segmentChanged();
          },
          enumerable: true
        },
        y2: {
          get: function get() {
            return this._y2;
          },
          set: function set(y2) {
            this._y2 = y2;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoQuadraticAbs = /*#__PURE__*/function (_SVGPathSeg9) {
        _inherits(_SVGPathSegCurvetoQuadraticAbs, _SVGPathSeg9);

        var _super8 = _createSuper(_SVGPathSegCurvetoQuadraticAbs);

        function _SVGPathSegCurvetoQuadraticAbs(owningPathSegList, x, y, x1, y1) {
          var _this7;

          _classCallCheck(this, _SVGPathSegCurvetoQuadraticAbs);

          _this7 = _super8.call(this, _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, 'Q', owningPathSegList);
          _this7._x = x;
          _this7._y = y;
          _this7._x1 = x1;
          _this7._y1 = y1;
          return _this7;
        }

        _createClass(_SVGPathSegCurvetoQuadraticAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoQuadraticAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);
          }
        }]);

        return _SVGPathSegCurvetoQuadraticAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoQuadraticAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        x1: {
          get: function get() {
            return this._x1;
          },
          set: function set(x1) {
            this._x1 = x1;

            this._segmentChanged();
          },
          enumerable: true
        },
        y1: {
          get: function get() {
            return this._y1;
          },
          set: function set(y1) {
            this._y1 = y1;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoQuadraticRel = /*#__PURE__*/function (_SVGPathSeg10) {
        _inherits(_SVGPathSegCurvetoQuadraticRel, _SVGPathSeg10);

        var _super9 = _createSuper(_SVGPathSegCurvetoQuadraticRel);

        function _SVGPathSegCurvetoQuadraticRel(owningPathSegList, x, y, x1, y1) {
          var _this8;

          _classCallCheck(this, _SVGPathSegCurvetoQuadraticRel);

          _this8 = _super9.call(this, _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, 'q', owningPathSegList);
          _this8._x = x;
          _this8._y = y;
          _this8._x1 = x1;
          _this8._y1 = y1;
          return _this8;
        }

        _createClass(_SVGPathSegCurvetoQuadraticRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoQuadraticRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);
          }
        }]);

        return _SVGPathSegCurvetoQuadraticRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoQuadraticRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        x1: {
          get: function get() {
            return this._x1;
          },
          set: function set(x1) {
            this._x1 = x1;

            this._segmentChanged();
          },
          enumerable: true
        },
        y1: {
          get: function get() {
            return this._y1;
          },
          set: function set(y1) {
            this._y1 = y1;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegArcAbs = /*#__PURE__*/function (_SVGPathSeg11) {
        _inherits(_SVGPathSegArcAbs, _SVGPathSeg11);

        var _super10 = _createSuper(_SVGPathSegArcAbs);

        function _SVGPathSegArcAbs(owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
          var _this9;

          _classCallCheck(this, _SVGPathSegArcAbs);

          _this9 = _super10.call(this, _SVGPathSeg.PATHSEG_ARC_ABS, 'A', owningPathSegList);
          _this9._x = x;
          _this9._y = y;
          _this9._r1 = r1;
          _this9._r2 = r2;
          _this9._angle = angle;
          _this9._largeArcFlag = largeArcFlag;
          _this9._sweepFlag = sweepFlag;
          return _this9;
        }

        _createClass(_SVGPathSegArcAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegArcAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._r1 + ' ' + this._r2 + ' ' + this._angle + ' ' + (this._largeArcFlag ? '1' : '0') + ' ' + (this._sweepFlag ? '1' : '0') + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
          }
        }]);

        return _SVGPathSegArcAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegArcAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        r1: {
          get: function get() {
            return this._r1;
          },
          set: function set(r1) {
            this._r1 = r1;

            this._segmentChanged();
          },
          enumerable: true
        },
        r2: {
          get: function get() {
            return this._r2;
          },
          set: function set(r2) {
            this._r2 = r2;

            this._segmentChanged();
          },
          enumerable: true
        },
        angle: {
          get: function get() {
            return this._angle;
          },
          set: function set(angle) {
            this._angle = angle;

            this._segmentChanged();
          },
          enumerable: true
        },
        largeArcFlag: {
          get: function get() {
            return this._largeArcFlag;
          },
          set: function set(largeArcFlag) {
            this._largeArcFlag = largeArcFlag;

            this._segmentChanged();
          },
          enumerable: true
        },
        sweepFlag: {
          get: function get() {
            return this._sweepFlag;
          },
          set: function set(sweepFlag) {
            this._sweepFlag = sweepFlag;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegArcRel = /*#__PURE__*/function (_SVGPathSeg12) {
        _inherits(_SVGPathSegArcRel, _SVGPathSeg12);

        var _super11 = _createSuper(_SVGPathSegArcRel);

        function _SVGPathSegArcRel(owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
          var _this10;

          _classCallCheck(this, _SVGPathSegArcRel);

          _this10 = _super11.call(this, _SVGPathSeg.PATHSEG_ARC_REL, 'a', owningPathSegList);
          _this10._x = x;
          _this10._y = y;
          _this10._r1 = r1;
          _this10._r2 = r2;
          _this10._angle = angle;
          _this10._largeArcFlag = largeArcFlag;
          _this10._sweepFlag = sweepFlag;
          return _this10;
        }

        _createClass(_SVGPathSegArcRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegArcRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._r1 + ' ' + this._r2 + ' ' + this._angle + ' ' + (this._largeArcFlag ? '1' : '0') + ' ' + (this._sweepFlag ? '1' : '0') + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
          }
        }]);

        return _SVGPathSegArcRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegArcRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        r1: {
          get: function get() {
            return this._r1;
          },
          set: function set(r1) {
            this._r1 = r1;

            this._segmentChanged();
          },
          enumerable: true
        },
        r2: {
          get: function get() {
            return this._r2;
          },
          set: function set(r2) {
            this._r2 = r2;

            this._segmentChanged();
          },
          enumerable: true
        },
        angle: {
          get: function get() {
            return this._angle;
          },
          set: function set(angle) {
            this._angle = angle;

            this._segmentChanged();
          },
          enumerable: true
        },
        largeArcFlag: {
          get: function get() {
            return this._largeArcFlag;
          },
          set: function set(largeArcFlag) {
            this._largeArcFlag = largeArcFlag;

            this._segmentChanged();
          },
          enumerable: true
        },
        sweepFlag: {
          get: function get() {
            return this._sweepFlag;
          },
          set: function set(sweepFlag) {
            this._sweepFlag = sweepFlag;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegLinetoHorizontalAbs = /*#__PURE__*/function (_SVGPathSeg13) {
        _inherits(_SVGPathSegLinetoHorizontalAbs, _SVGPathSeg13);

        var _super12 = _createSuper(_SVGPathSegLinetoHorizontalAbs);

        function _SVGPathSegLinetoHorizontalAbs(owningPathSegList, x) {
          var _this11;

          _classCallCheck(this, _SVGPathSegLinetoHorizontalAbs);

          _this11 = _super12.call(this, _SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, 'H', owningPathSegList);
          _this11._x = x;
          return _this11;
        }

        _createClass(_SVGPathSegLinetoHorizontalAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegLinetoHorizontalAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegLinetoHorizontalAbs(undefined, this._x);
          }
        }]);

        return _SVGPathSegLinetoHorizontalAbs;
      }(_SVGPathSeg);

      Object.defineProperty(_SVGPathSegLinetoHorizontalAbs.prototype, 'x', {
        get: function get() {
          return this._x;
        },
        set: function set(x) {
          this._x = x;

          this._segmentChanged();
        },
        enumerable: true
      });

      var _SVGPathSegLinetoHorizontalRel = /*#__PURE__*/function (_SVGPathSeg14) {
        _inherits(_SVGPathSegLinetoHorizontalRel, _SVGPathSeg14);

        var _super13 = _createSuper(_SVGPathSegLinetoHorizontalRel);

        function _SVGPathSegLinetoHorizontalRel(owningPathSegList, x) {
          var _this12;

          _classCallCheck(this, _SVGPathSegLinetoHorizontalRel);

          _this12 = _super13.call(this, _SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, 'h', owningPathSegList);
          _this12._x = x;
          return _this12;
        }

        _createClass(_SVGPathSegLinetoHorizontalRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegLinetoHorizontalRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegLinetoHorizontalRel(undefined, this._x);
          }
        }]);

        return _SVGPathSegLinetoHorizontalRel;
      }(_SVGPathSeg);

      Object.defineProperty(_SVGPathSegLinetoHorizontalRel.prototype, 'x', {
        get: function get() {
          return this._x;
        },
        set: function set(x) {
          this._x = x;

          this._segmentChanged();
        },
        enumerable: true
      });

      var _SVGPathSegLinetoVerticalAbs = /*#__PURE__*/function (_SVGPathSeg15) {
        _inherits(_SVGPathSegLinetoVerticalAbs, _SVGPathSeg15);

        var _super14 = _createSuper(_SVGPathSegLinetoVerticalAbs);

        function _SVGPathSegLinetoVerticalAbs(owningPathSegList, y) {
          var _this13;

          _classCallCheck(this, _SVGPathSegLinetoVerticalAbs);

          _this13 = _super14.call(this, _SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, 'V', owningPathSegList);
          _this13._y = y;
          return _this13;
        }

        _createClass(_SVGPathSegLinetoVerticalAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegLinetoVerticalAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegLinetoVerticalAbs(undefined, this._y);
          }
        }]);

        return _SVGPathSegLinetoVerticalAbs;
      }(_SVGPathSeg);

      Object.defineProperty(_SVGPathSegLinetoVerticalAbs.prototype, 'y', {
        get: function get() {
          return this._y;
        },
        set: function set(y) {
          this._y = y;

          this._segmentChanged();
        },
        enumerable: true
      });

      var _SVGPathSegLinetoVerticalRel = /*#__PURE__*/function (_SVGPathSeg16) {
        _inherits(_SVGPathSegLinetoVerticalRel, _SVGPathSeg16);

        var _super15 = _createSuper(_SVGPathSegLinetoVerticalRel);

        function _SVGPathSegLinetoVerticalRel(owningPathSegList, y) {
          var _this14;

          _classCallCheck(this, _SVGPathSegLinetoVerticalRel);

          _this14 = _super15.call(this, _SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, 'v', owningPathSegList);
          _this14._y = y;
          return _this14;
        }

        _createClass(_SVGPathSegLinetoVerticalRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegLinetoVerticalRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegLinetoVerticalRel(undefined, this._y);
          }
        }]);

        return _SVGPathSegLinetoVerticalRel;
      }(_SVGPathSeg);

      Object.defineProperty(_SVGPathSegLinetoVerticalRel.prototype, 'y', {
        get: function get() {
          return this._y;
        },
        set: function set(y) {
          this._y = y;

          this._segmentChanged();
        },
        enumerable: true
      });

      var _SVGPathSegCurvetoCubicSmoothAbs = /*#__PURE__*/function (_SVGPathSeg17) {
        _inherits(_SVGPathSegCurvetoCubicSmoothAbs, _SVGPathSeg17);

        var _super16 = _createSuper(_SVGPathSegCurvetoCubicSmoothAbs);

        function _SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, x, y, x2, y2) {
          var _this15;

          _classCallCheck(this, _SVGPathSegCurvetoCubicSmoothAbs);

          _this15 = _super16.call(this, _SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S', owningPathSegList);
          _this15._x = x;
          _this15._y = y;
          _this15._x2 = x2;
          _this15._y2 = y2;
          return _this15;
        }

        _createClass(_SVGPathSegCurvetoCubicSmoothAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoCubicSmoothAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);
          }
        }]);

        return _SVGPathSegCurvetoCubicSmoothAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoCubicSmoothAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        x2: {
          get: function get() {
            return this._x2;
          },
          set: function set(x2) {
            this._x2 = x2;

            this._segmentChanged();
          },
          enumerable: true
        },
        y2: {
          get: function get() {
            return this._y2;
          },
          set: function set(y2) {
            this._y2 = y2;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoCubicSmoothRel = /*#__PURE__*/function (_SVGPathSeg18) {
        _inherits(_SVGPathSegCurvetoCubicSmoothRel, _SVGPathSeg18);

        var _super17 = _createSuper(_SVGPathSegCurvetoCubicSmoothRel);

        function _SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, x, y, x2, y2) {
          var _this16;

          _classCallCheck(this, _SVGPathSegCurvetoCubicSmoothRel);

          _this16 = _super17.call(this, _SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's', owningPathSegList);
          _this16._x = x;
          _this16._y = y;
          _this16._x2 = x2;
          _this16._y2 = y2;
          return _this16;
        }

        _createClass(_SVGPathSegCurvetoCubicSmoothRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoCubicSmoothRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);
          }
        }]);

        return _SVGPathSegCurvetoCubicSmoothRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoCubicSmoothRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        },
        x2: {
          get: function get() {
            return this._x2;
          },
          set: function set(x2) {
            this._x2 = x2;

            this._segmentChanged();
          },
          enumerable: true
        },
        y2: {
          get: function get() {
            return this._y2;
          },
          set: function set(y2) {
            this._y2 = y2;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoQuadraticSmoothAbs = /*#__PURE__*/function (_SVGPathSeg19) {
        _inherits(_SVGPathSegCurvetoQuadraticSmoothAbs, _SVGPathSeg19);

        var _super18 = _createSuper(_SVGPathSegCurvetoQuadraticSmoothAbs);

        function _SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, x, y) {
          var _this17;

          _classCallCheck(this, _SVGPathSegCurvetoQuadraticSmoothAbs);

          _this17 = _super18.call(this, _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T', owningPathSegList);
          _this17._x = x;
          _this17._y = y;
          return _this17;
        }

        _createClass(_SVGPathSegCurvetoQuadraticSmoothAbs, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoQuadraticSmoothAbs]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);
          }
        }]);

        return _SVGPathSegCurvetoQuadraticSmoothAbs;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoQuadraticSmoothAbs.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        }
      });

      var _SVGPathSegCurvetoQuadraticSmoothRel = /*#__PURE__*/function (_SVGPathSeg20) {
        _inherits(_SVGPathSegCurvetoQuadraticSmoothRel, _SVGPathSeg20);

        var _super19 = _createSuper(_SVGPathSegCurvetoQuadraticSmoothRel);

        function _SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, x, y) {
          var _this18;

          _classCallCheck(this, _SVGPathSegCurvetoQuadraticSmoothRel);

          _this18 = _super19.call(this, _SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't', owningPathSegList);
          _this18._x = x;
          _this18._y = y;
          return _this18;
        }

        _createClass(_SVGPathSegCurvetoQuadraticSmoothRel, [{
          key: "toString",
          value: function toString() {
            return '[object SVGPathSegCurvetoQuadraticSmoothRel]';
          }
        }, {
          key: "_asPathString",
          value: function _asPathString() {
            return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          }
        }, {
          key: "clone",
          value: function clone() {
            return new _SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);
          }
        }]);

        return _SVGPathSegCurvetoQuadraticSmoothRel;
      }(_SVGPathSeg);

      Object.defineProperties(_SVGPathSegCurvetoQuadraticSmoothRel.prototype, {
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(x) {
            this._x = x;

            this._segmentChanged();
          },
          enumerable: true
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(y) {
            this._y = y;

            this._segmentChanged();
          },
          enumerable: true
        }
      }); // Add createSVGPathSeg* functions to SVGPathElement.
      // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathElement.

      SVGPathElement.prototype.createSVGPathSegClosePath = function () {
        return new _SVGPathSegClosePath(undefined);
      };

      SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {
        return new _SVGPathSegMovetoAbs(undefined, x, y);
      };

      SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {
        return new _SVGPathSegMovetoRel(undefined, x, y);
      };

      SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {
        return new _SVGPathSegLinetoAbs(undefined, x, y);
      };

      SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {
        return new _SVGPathSegLinetoRel(undefined, x, y);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {
        return new _SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {
        return new _SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {
        return new _SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {
        return new _SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);
      };

      SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
        return new _SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
      };

      SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
        return new _SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
      };

      SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {
        return new _SVGPathSegLinetoHorizontalAbs(undefined, x);
      };

      SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {
        return new _SVGPathSegLinetoHorizontalRel(undefined, x);
      };

      SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {
        return new _SVGPathSegLinetoVerticalAbs(undefined, y);
      };

      SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {
        return new _SVGPathSegLinetoVerticalRel(undefined, y);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {
        return new _SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {
        return new _SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {
        return new _SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);
      };

      SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {
        return new _SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);
      };

      if (!('getPathSegAtLength' in SVGPathElement.prototype)) {
        // Add getPathSegAtLength to SVGPathElement.
        // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength
        // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.
        SVGPathElement.prototype.getPathSegAtLength = function (distance) {
          if (distance === undefined || !isFinite(distance)) {
            throw new Error('Invalid arguments.');
          }

          var measurementElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          measurementElement.setAttribute('d', this.getAttribute('d'));
          var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1; // If the path is empty, return 0.

          if (lastPathSegment <= 0) {
            return 0;
          }

          do {
            measurementElement.pathSegList.removeItem(lastPathSegment);

            if (distance > measurementElement.getTotalLength()) {
              break;
            }

            lastPathSegment--;
          } while (lastPathSegment > 0);

          return lastPathSegment;
        };
      }

      window.SVGPathSeg = _SVGPathSeg;
      window.SVGPathSegClosePath = _SVGPathSegClosePath;
      window.SVGPathSegMovetoAbs = _SVGPathSegMovetoAbs;
      window.SVGPathSegMovetoRel = _SVGPathSegMovetoRel;
      window.SVGPathSegLinetoAbs = _SVGPathSegLinetoAbs;
      window.SVGPathSegLinetoRel = _SVGPathSegLinetoRel;
      window.SVGPathSegCurvetoCubicAbs = _SVGPathSegCurvetoCubicAbs;
      window.SVGPathSegCurvetoCubicRel = _SVGPathSegCurvetoCubicRel;
      window.SVGPathSegCurvetoQuadraticAbs = _SVGPathSegCurvetoQuadraticAbs;
      window.SVGPathSegCurvetoQuadraticRel = _SVGPathSegCurvetoQuadraticRel;
      window.SVGPathSegArcAbs = _SVGPathSegArcAbs;
      window.SVGPathSegArcRel = _SVGPathSegArcRel;
      window.SVGPathSegLinetoHorizontalAbs = _SVGPathSegLinetoHorizontalAbs;
      window.SVGPathSegLinetoHorizontalRel = _SVGPathSegLinetoHorizontalRel;
      window.SVGPathSegLinetoVerticalAbs = _SVGPathSegLinetoVerticalAbs;
      window.SVGPathSegLinetoVerticalRel = _SVGPathSegLinetoVerticalRel;
      window.SVGPathSegCurvetoCubicSmoothAbs = _SVGPathSegCurvetoCubicSmoothAbs;
      window.SVGPathSegCurvetoCubicSmoothRel = _SVGPathSegCurvetoCubicSmoothRel;
      window.SVGPathSegCurvetoQuadraticSmoothAbs = _SVGPathSegCurvetoQuadraticSmoothAbs;
      window.SVGPathSegCurvetoQuadraticSmoothRel = _SVGPathSegCurvetoQuadraticSmoothRel;
    } // Checking for SVGPathSegList in window checks for the case of an implementation without the
    // SVGPathSegList API.
    // The second check for appendItem is specific to Firefox 59+ which removed only parts of the
    // SVGPathSegList API (e.g., appendItem). In this case we need to re-implement the entire API
    // so the polyfill data (i.e., _list) is used throughout.


    if (!('SVGPathSegList' in window) || !('appendItem' in window.SVGPathSegList.prototype)) {
      // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
      var SVGPathSegList = /*#__PURE__*/function () {
        function SVGPathSegList(pathElement) {
          _classCallCheck(this, SVGPathSegList);

          this._pathElement = pathElement;
          this._list = this._parsePath(this._pathElement.getAttribute('d')); // Use a MutationObserver to catch changes to the path's "d" attribute.

          this._mutationObserverConfig = {
            attributes: true,
            attributeFilter: ['d']
          };
          this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));

          this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
        } // Process any pending mutations to the path element and update the list as needed.
        // This should be the first call of all public functions and is needed because
        // MutationObservers are not synchronous so we can have pending asynchronous mutations.


        _createClass(SVGPathSegList, [{
          key: "_checkPathSynchronizedToList",
          value: function _checkPathSynchronizedToList() {
            this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
          }
        }, {
          key: "_updateListFromPathMutations",
          value: function _updateListFromPathMutations(mutationRecords) {
            if (!this._pathElement) {
              return;
            }

            var hasPathMutations = false;
            mutationRecords.forEach(function (record) {
              if (record.attributeName === 'd') {
                hasPathMutations = true;
              }
            });

            if (hasPathMutations) {
              this._list = this._parsePath(this._pathElement.getAttribute('d'));
            }
          } // Serialize the list and update the path's 'd' attribute.

        }, {
          key: "_writeListToPath",
          value: function _writeListToPath() {
            this._pathElementMutationObserver.disconnect();

            this._pathElement.setAttribute('d', SVGPathSegList._pathSegArrayAsString(this._list));

            this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
          } // When a path segment changes the list needs to be synchronized back to the path element.

        }, {
          key: "segmentChanged",
          value: function segmentChanged(pathSeg) {
            this._writeListToPath();
          }
        }, {
          key: "clear",
          value: function clear() {
            this._checkPathSynchronizedToList();

            this._list.forEach(function (pathSeg) {
              pathSeg._owningPathSegList = null;
            });

            this._list = [];

            this._writeListToPath();
          }
        }, {
          key: "initialize",
          value: function initialize(newItem) {
            this._checkPathSynchronizedToList();

            this._list = [newItem];
            newItem._owningPathSegList = this;

            this._writeListToPath();

            return newItem;
          }
        }, {
          key: "_checkValidIndex",
          value: function _checkValidIndex(index) {
            if (isNaN(index) || index < 0 || index >= this.numberOfItems) {
              throw new Error('INDEX_SIZE_ERR');
            }
          }
        }, {
          key: "getItem",
          value: function getItem(index) {
            this._checkPathSynchronizedToList();

            this._checkValidIndex(index);

            return this._list[index];
          }
        }, {
          key: "insertItemBefore",
          value: function insertItemBefore(newItem, index) {
            this._checkPathSynchronizedToList(); // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.


            if (index > this.numberOfItems) {
              index = this.numberOfItems;
            }

            if (newItem._owningPathSegList) {
              // SVG2 spec says to make a copy.
              newItem = newItem.clone();
            }

            this._list.splice(index, 0, newItem);

            newItem._owningPathSegList = this;

            this._writeListToPath();

            return newItem;
          }
        }, {
          key: "replaceItem",
          value: function replaceItem(newItem, index) {
            this._checkPathSynchronizedToList();

            if (newItem._owningPathSegList) {
              // SVG2 spec says to make a copy.
              newItem = newItem.clone();
            }

            this._checkValidIndex(index);

            this._list[index] = newItem;
            newItem._owningPathSegList = this;

            this._writeListToPath();

            return newItem;
          }
        }, {
          key: "removeItem",
          value: function removeItem(index) {
            this._checkPathSynchronizedToList();

            this._checkValidIndex(index);

            var item = this._list[index];

            this._list.splice(index, 1);

            this._writeListToPath();

            return item;
          }
        }, {
          key: "appendItem",
          value: function appendItem(newItem) {
            this._checkPathSynchronizedToList();

            if (newItem._owningPathSegList) {
              // SVG2 spec says to make a copy.
              newItem = newItem.clone();
            }

            this._list.push(newItem);

            newItem._owningPathSegList = this; // TODO: Optimize this to just append to the existing attribute.

            this._writeListToPath();

            return newItem;
          } // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.

        }, {
          key: "_parsePath",
          value: function _parsePath(string) {
            if (!string || !string.length) {
              return [];
            }

            var owningPathSegList = this;

            var Builder = /*#__PURE__*/function () {
              function Builder() {
                _classCallCheck(this, Builder);

                this.pathSegList = [];
              }

              _createClass(Builder, [{
                key: "appendSegment",
                value: function appendSegment(pathSeg) {
                  this.pathSegList.push(pathSeg);
                }
              }]);

              return Builder;
            }();

            var Source = /*#__PURE__*/function () {
              function Source(string) {
                _classCallCheck(this, Source);

                this._string = string;
                this._currentIndex = 0;
                this._endIndex = this._string.length;
                this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN;

                this._skipOptionalSpaces();
              }

              _createClass(Source, [{
                key: "_isCurrentSpace",
                value: function _isCurrentSpace() {
                  var character = this._string[this._currentIndex];
                  return character <= ' ' && (character === ' ' || character === '\n' || character === '\t' || character === '\r' || character === '\f');
                }
              }, {
                key: "_skipOptionalSpaces",
                value: function _skipOptionalSpaces() {
                  while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {
                    this._currentIndex++;
                  }

                  return this._currentIndex < this._endIndex;
                }
              }, {
                key: "_skipOptionalSpacesOrDelimiter",
                value: function _skipOptionalSpacesOrDelimiter() {
                  if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) !== ',') {
                    return false;
                  }

                  if (this._skipOptionalSpaces()) {
                    if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) === ',') {
                      this._currentIndex++;

                      this._skipOptionalSpaces();
                    }
                  }

                  return this._currentIndex < this._endIndex;
                }
              }, {
                key: "hasMoreData",
                value: function hasMoreData() {
                  return this._currentIndex < this._endIndex;
                }
              }, {
                key: "peekSegmentType",
                value: function peekSegmentType() {
                  var lookahead = this._string[this._currentIndex];
                  return this._pathSegTypeFromChar(lookahead);
                }
              }, {
                key: "_pathSegTypeFromChar",
                value: function _pathSegTypeFromChar(lookahead) {
                  switch (lookahead) {
                    case 'Z':
                    case 'z':
                      return SVGPathSeg.PATHSEG_CLOSEPATH;

                    case 'M':
                      return SVGPathSeg.PATHSEG_MOVETO_ABS;

                    case 'm':
                      return SVGPathSeg.PATHSEG_MOVETO_REL;

                    case 'L':
                      return SVGPathSeg.PATHSEG_LINETO_ABS;

                    case 'l':
                      return SVGPathSeg.PATHSEG_LINETO_REL;

                    case 'C':
                      return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;

                    case 'c':
                      return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;

                    case 'Q':
                      return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;

                    case 'q':
                      return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;

                    case 'A':
                      return SVGPathSeg.PATHSEG_ARC_ABS;

                    case 'a':
                      return SVGPathSeg.PATHSEG_ARC_REL;

                    case 'H':
                      return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;

                    case 'h':
                      return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;

                    case 'V':
                      return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;

                    case 'v':
                      return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;

                    case 'S':
                      return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;

                    case 's':
                      return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;

                    case 'T':
                      return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;

                    case 't':
                      return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;

                    default:
                      return SVGPathSeg.PATHSEG_UNKNOWN;
                  }
                }
              }, {
                key: "_nextCommandHelper",
                value: function _nextCommandHelper(lookahead, previousCommand) {
                  // Check for remaining coordinates in the current command.
                  if ((lookahead === '+' || lookahead === '-' || lookahead === '.' || lookahead >= '0' && lookahead <= '9') && previousCommand !== SVGPathSeg.PATHSEG_CLOSEPATH) {
                    if (previousCommand === SVGPathSeg.PATHSEG_MOVETO_ABS) {
                      return SVGPathSeg.PATHSEG_LINETO_ABS;
                    }

                    if (previousCommand === SVGPathSeg.PATHSEG_MOVETO_REL) {
                      return SVGPathSeg.PATHSEG_LINETO_REL;
                    }

                    return previousCommand;
                  }

                  return SVGPathSeg.PATHSEG_UNKNOWN;
                }
              }, {
                key: "initialCommandIsMoveTo",
                value: function initialCommandIsMoveTo() {
                  // If the path is empty it is still valid, so return true.
                  if (!this.hasMoreData()) {
                    return true;
                  }

                  var command = this.peekSegmentType(); // Path must start with moveTo.

                  return command === SVGPathSeg.PATHSEG_MOVETO_ABS || command === SVGPathSeg.PATHSEG_MOVETO_REL;
                } // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
                // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF

              }, {
                key: "_parseNumber",
                value: function _parseNumber() {
                  var exponent = 0;
                  var integer = 0;
                  var frac = 1;
                  var decimal = 0;
                  var sign = 1;
                  var expsign = 1;
                  var startIndex = this._currentIndex;

                  this._skipOptionalSpaces(); // Read the sign.


                  if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) === '+') {
                    this._currentIndex++;
                  } else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) === '-') {
                    this._currentIndex++;
                    sign = -1;
                  }

                  if (this._currentIndex === this._endIndex || (this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') && this._string.charAt(this._currentIndex) !== '.') {
                    // The first character of a number must be one of [0-9+-.].
                    return undefined;
                  } // Read the integer part, build right-to-left.


                  var startIntPartIndex = this._currentIndex;

                  while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= '0' && this._string.charAt(this._currentIndex) <= '9') {
                    this._currentIndex++; // Advance to first non-digit.
                  }

                  if (this._currentIndex !== startIntPartIndex) {
                    var scanIntPartIndex = this._currentIndex - 1;
                    var multiplier = 1;

                    while (scanIntPartIndex >= startIntPartIndex) {
                      integer += multiplier * (this._string.charAt(scanIntPartIndex--) - '0');
                      multiplier *= 10;
                    }
                  } // Read the decimals.


                  if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) === '.') {
                    this._currentIndex++; // There must be a least one digit following the .

                    if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') {
                      return undefined;
                    }

                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= '0' && this._string.charAt(this._currentIndex) <= '9') {
                      frac *= 10;
                      decimal += (this._string.charAt(this._currentIndex) - '0') / frac;
                      this._currentIndex += 1;
                    }
                  } // Read the exponent part.


                  if (this._currentIndex !== startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) === 'e' || this._string.charAt(this._currentIndex) === 'E') && this._string.charAt(this._currentIndex + 1) !== 'x' && this._string.charAt(this._currentIndex + 1) !== 'm') {
                    this._currentIndex++; // Read the sign of the exponent.

                    if (this._string.charAt(this._currentIndex) === '+') {
                      this._currentIndex++;
                    } else if (this._string.charAt(this._currentIndex) === '-') {
                      this._currentIndex++;
                      expsign = -1;
                    } // There must be an exponent.


                    if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') {
                      return undefined;
                    }

                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= '0' && this._string.charAt(this._currentIndex) <= '9') {
                      exponent *= 10;
                      exponent += this._string.charAt(this._currentIndex) - '0';
                      this._currentIndex++;
                    }
                  }

                  var number = integer + decimal;
                  number *= sign;

                  if (exponent) {
                    number *= Math.pow(10, expsign * exponent);
                  }

                  if (startIndex === this._currentIndex) {
                    return undefined;
                  }

                  this._skipOptionalSpacesOrDelimiter();

                  return number;
                }
              }, {
                key: "_parseArcFlag",
                value: function _parseArcFlag() {
                  if (this._currentIndex >= this._endIndex) {
                    return undefined;
                  }

                  var flag = false;

                  var flagChar = this._string.charAt(this._currentIndex++);

                  if (flagChar === '0') {
                    flag = false;
                  } else if (flagChar === '1') {
                    flag = true;
                  } else {
                    return undefined;
                  }

                  this._skipOptionalSpacesOrDelimiter();

                  return flag;
                }
              }, {
                key: "parseSegment",
                value: function parseSegment() {
                  var lookahead = this._string[this._currentIndex];

                  var command = this._pathSegTypeFromChar(lookahead);

                  if (command === SVGPathSeg.PATHSEG_UNKNOWN) {
                    // Possibly an implicit command. Not allowed if this is the first command.
                    if (this._previousCommand === SVGPathSeg.PATHSEG_UNKNOWN) {
                      return null;
                    }

                    command = this._nextCommandHelper(lookahead, this._previousCommand);

                    if (command === SVGPathSeg.PATHSEG_UNKNOWN) {
                      return null;
                    }
                  } else {
                    this._currentIndex++;
                  }

                  this._previousCommand = command;

                  switch (command) {
                    case SVGPathSeg.PATHSEG_MOVETO_REL:
                      return new SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());

                    case SVGPathSeg.PATHSEG_MOVETO_ABS:
                      return new SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());

                    case SVGPathSeg.PATHSEG_LINETO_REL:
                      return new SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());

                    case SVGPathSeg.PATHSEG_LINETO_ABS:
                      return new SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());

                    case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                      return new SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());

                    case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                      return new SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());

                    case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                      return new SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());

                    case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                      return new SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());

                    case SVGPathSeg.PATHSEG_CLOSEPATH:
                      this._skipOptionalSpaces();

                      return new SVGPathSegClosePath(owningPathSegList);

                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                      {
                        var points = {
                          x1: this._parseNumber(),
                          y1: this._parseNumber(),
                          x2: this._parseNumber(),
                          y2: this._parseNumber(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                      }

                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                      {
                        var _points = {
                          x1: this._parseNumber(),
                          y1: this._parseNumber(),
                          x2: this._parseNumber(),
                          y2: this._parseNumber(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegCurvetoCubicAbs(owningPathSegList, _points.x, _points.y, _points.x1, _points.y1, _points.x2, _points.y2);
                      }

                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                      {
                        var _points2 = {
                          x2: this._parseNumber(),
                          y2: this._parseNumber(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, _points2.x, _points2.y, _points2.x2, _points2.y2);
                      }

                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                      {
                        var _points3 = {
                          x2: this._parseNumber(),
                          y2: this._parseNumber(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, _points3.x, _points3.y, _points3.x2, _points3.y2);
                      }

                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                      {
                        var _points4 = {
                          x1: this._parseNumber(),
                          y1: this._parseNumber(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegCurvetoQuadraticRel(owningPathSegList, _points4.x, _points4.y, _points4.x1, _points4.y1);
                      }

                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                      {
                        var _points5 = {
                          x1: this._parseNumber(),
                          y1: this._parseNumber(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegCurvetoQuadraticAbs(owningPathSegList, _points5.x, _points5.y, _points5.x1, _points5.y1);
                      }

                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                      return new SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());

                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                      return new SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());

                    case SVGPathSeg.PATHSEG_ARC_REL:
                      {
                        var _points6 = {
                          x1: this._parseNumber(),
                          y1: this._parseNumber(),
                          arcAngle: this._parseNumber(),
                          arcLarge: this._parseArcFlag(),
                          arcSweep: this._parseArcFlag(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegArcRel(owningPathSegList, _points6.x, _points6.y, _points6.x1, _points6.y1, _points6.arcAngle, _points6.arcLarge, _points6.arcSweep);
                      }

                    case SVGPathSeg.PATHSEG_ARC_ABS:
                      {
                        var _points7 = {
                          x1: this._parseNumber(),
                          y1: this._parseNumber(),
                          arcAngle: this._parseNumber(),
                          arcLarge: this._parseArcFlag(),
                          arcSweep: this._parseArcFlag(),
                          x: this._parseNumber(),
                          y: this._parseNumber()
                        };
                        return new SVGPathSegArcAbs(owningPathSegList, _points7.x, _points7.y, _points7.x1, _points7.y1, _points7.arcAngle, _points7.arcLarge, _points7.arcSweep);
                      }

                    default:
                      throw new Error('Unknown path seg type.');
                  }
                }
              }]);

              return Source;
            }();

            var builder = new Builder();
            var source = new Source(string);

            if (!source.initialCommandIsMoveTo()) {
              return [];
            }

            while (source.hasMoreData()) {
              var pathSeg = source.parseSegment();

              if (!pathSeg) {
                return [];
              }

              builder.appendSegment(pathSeg);
            }

            return builder.pathSegList;
          } // STATIC

        }], [{
          key: "_pathSegArrayAsString",
          value: function _pathSegArrayAsString(pathSegArray) {
            var string = '';
            var first = true;
            pathSegArray.forEach(function (pathSeg) {
              if (first) {
                first = false;
                string += pathSeg._asPathString();
              } else {
                string += ' ' + pathSeg._asPathString();
              }
            });
            return string;
          }
        }]);

        return SVGPathSegList;
      }();

      SVGPathSegList.prototype.classname = 'SVGPathSegList';
      Object.defineProperty(SVGPathSegList.prototype, 'numberOfItems', {
        get: function get() {
          this._checkPathSynchronizedToList();

          return this._list.length;
        },
        enumerable: true
      }); // Add the pathSegList accessors to SVGPathElement.
      // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData

      Object.defineProperties(SVGPathElement.prototype, {
        pathSegList: {
          get: function get() {
            if (!this._pathSegList) {
              this._pathSegList = new SVGPathSegList(this);
            }

            return this._pathSegList;
          },
          enumerable: true
        },
        // TODO: The following are not implemented and simply return SVGPathElement.pathSegList.
        normalizedPathSegList: {
          get: function get() {
            return this.pathSegList;
          },
          enumerable: true
        },
        animatedPathSegList: {
          get: function get() {
            return this.pathSegList;
          },
          enumerable: true
        },
        animatedNormalizedPathSegList: {
          get: function get() {
            return this.pathSegList;
          },
          enumerable: true
        }
      });
      window.SVGPathSegList = SVGPathSegList;
    }
  })();

  var $ = jQuery;

  var supportsSVG_ = function () {
    return Boolean(document.createElementNS && document.createElementNS(NS.SVG, 'svg').createSVGRect);
  }();
  var _navigator = navigator,
      userAgent = _navigator.userAgent;
  var svg = document.createElementNS(NS.SVG, 'svg'); // Note: Browser sniffing should only be used if no other detection method is possible

  var isOpera_ = Boolean(window.opera);
  var isWebkit_ = userAgent.includes('AppleWebKit');
  var isGecko_ = userAgent.includes('Gecko/');
  var isIE_ = userAgent.includes('MSIE');
  var isChrome_ = userAgent.includes('Chrome/');
  var isWindows_ = userAgent.includes('Windows');
  var isMac_ = userAgent.includes('Macintosh');
  var isTouch_ = ('ontouchstart' in window);

  var supportsSelectors_ = function () {
    return Boolean(svg.querySelector);
  }();

  var supportsXpath_ = function () {
    return Boolean(document.evaluate);
  }(); // segList functions (for FF1.5 and 2.0)


  var supportsPathReplaceItem_ = function () {
    var path = document.createElementNS(NS.SVG, 'path');
    path.setAttribute('d', 'M0,0 10,10');
    var seglist = path.pathSegList;
    var seg = path.createSVGPathSegLinetoAbs(5, 5);

    try {
      seglist.replaceItem(seg, 1);
      return true;
    } catch (err) {}

    return false;
  }();

  var supportsPathInsertItemBefore_ = function () {
    var path = document.createElementNS(NS.SVG, 'path');
    path.setAttribute('d', 'M0,0 10,10');
    var seglist = path.pathSegList;
    var seg = path.createSVGPathSegLinetoAbs(5, 5);

    try {
      seglist.insertItemBefore(seg, 1);
      return true;
    } catch (err) {}

    return false;
  }(); // text character positioning (for IE9 and now Chrome)


  var supportsGoodTextCharPos_ = function () {
    var svgroot = document.createElementNS(NS.SVG, 'svg');
    var svgcontent = document.createElementNS(NS.SVG, 'svg');
    document.documentElement.append(svgroot);
    svgcontent.setAttribute('x', 5);
    svgroot.append(svgcontent);
    var text = document.createElementNS(NS.SVG, 'text');
    text.textContent = 'a';
    svgcontent.append(text);

    try {
      // Chrome now fails here
      var pos = text.getStartPositionOfChar(0).x;
      return pos === 0;
    } catch (err) {
      return false;
    } finally {
      svgroot.remove();
    }
  }();

  var supportsPathBBox_ = function () {
    var svgcontent = document.createElementNS(NS.SVG, 'svg');
    document.documentElement.append(svgcontent);
    var path = document.createElementNS(NS.SVG, 'path');
    path.setAttribute('d', 'M0,0 C0,0 10,10 10,0');
    svgcontent.append(path);
    var bbox = path.getBBox();
    svgcontent.remove();
    return bbox.height > 4 && bbox.height < 5;
  }(); // Support for correct bbox sizing on groups with horizontal/vertical lines


  var supportsHVLineContainerBBox_ = function () {
    var svgcontent = document.createElementNS(NS.SVG, 'svg');
    document.documentElement.append(svgcontent);
    var path = document.createElementNS(NS.SVG, 'path');
    path.setAttribute('d', 'M0,0 10,0');
    var path2 = document.createElementNS(NS.SVG, 'path');
    path2.setAttribute('d', 'M5,0 15,0');
    var g = document.createElementNS(NS.SVG, 'g');
    g.append(path, path2);
    svgcontent.append(g);
    var bbox = g.getBBox();
    svgcontent.remove(); // Webkit gives 0, FF gives 10, Opera (correctly) gives 15

    return bbox.width === 15;
  }();

  var supportsGoodDecimals_ = function () {
    // Correct decimals on clone attributes (Opera < 10.5/win/non-en)
    var rect = document.createElementNS(NS.SVG, 'rect');
    rect.setAttribute('x', 0.1);
    var crect = rect.cloneNode(false);
    var retValue = !crect.getAttribute('x').includes(',');

    if (!retValue) {
      // Todo: i18nize or remove
      $.alert('NOTE: This version of Opera is known to contain bugs in SVG-edit.\n' + 'Please upgrade to the <a href="http://opera.com">latest version</a> in which the problems have been fixed.');
    }

    return retValue;
  }();

  var supportsNonScalingStroke_ = function () {
    var rect = document.createElementNS(NS.SVG, 'rect');
    rect.setAttribute('style', 'vector-effect:non-scaling-stroke');
    return rect.style.vectorEffect === 'non-scaling-stroke';
  }();

  var supportsNativeSVGTransformLists_ = function () {
    var rect = document.createElementNS(NS.SVG, 'rect');
    var rxform = rect.transform.baseVal;
    var t1 = svg.createSVGTransform();
    rxform.appendItem(t1);
    var r1 = rxform.getItem(0);

    var isSVGTransform = function isSVGTransform(o) {
      // https://developer.mozilla.org/en-US/docs/Web/API/SVGTransform
      return o && _typeof(o) === 'object' && typeof o.setMatrix === 'function' && 'angle' in o;
    };

    return isSVGTransform(r1) && isSVGTransform(t1) && r1.type === t1.type && r1.angle === t1.angle && r1.matrix.a === t1.matrix.a && r1.matrix.b === t1.matrix.b && r1.matrix.c === t1.matrix.c && r1.matrix.d === t1.matrix.d && r1.matrix.e === t1.matrix.e && r1.matrix.f === t1.matrix.f;
  }(); // Public API

  /**
   * @function module:browser.isOpera
   * @returns {boolean}
  */


  var isOpera = function isOpera() {
    return isOpera_;
  };
  /**
   * @function module:browser.isWebkit
   * @returns {boolean}
  */

  var isWebkit = function isWebkit() {
    return isWebkit_;
  };
  /**
   * @function module:browser.isGecko
   * @returns {boolean}
  */

  var isGecko = function isGecko() {
    return isGecko_;
  };
  /**
   * @function module:browser.isIE
   * @returns {boolean}
  */

  var isIE = function isIE() {
    return isIE_;
  };
  /**
   * @function module:browser.isChrome
   * @returns {boolean}
  */

  var isChrome = function isChrome() {
    return isChrome_;
  };
  /**
   * @function module:browser.isMac
   * @returns {boolean}
  */

  var isMac = function isMac() {
    return isMac_;
  };
  /**
   * @function module:browser.isTouch
   * @returns {boolean}
  */

  var isTouch = function isTouch() {
    return isTouch_;
  };
  /**
   * @function module:browser.supportsSelectors
   * @returns {boolean}
  */

  var supportsSelectors = function supportsSelectors() {
    return supportsSelectors_;
  };
  /**
   * @function module:browser.supportsXpath
   * @returns {boolean}
  */

  var supportsXpath = function supportsXpath() {
    return supportsXpath_;
  };
  /**
   * @function module:browser.supportsPathReplaceItem
   * @returns {boolean}
  */

  var supportsPathReplaceItem = function supportsPathReplaceItem() {
    return supportsPathReplaceItem_;
  };
  /**
   * @function module:browser.supportsPathInsertItemBefore
   * @returns {boolean}
  */

  var supportsPathInsertItemBefore = function supportsPathInsertItemBefore() {
    return supportsPathInsertItemBefore_;
  };
  /**
   * @function module:browser.supportsPathBBox
   * @returns {boolean}
  */

  var supportsPathBBox = function supportsPathBBox() {
    return supportsPathBBox_;
  };
  /**
   * @function module:browser.supportsHVLineContainerBBox
   * @returns {boolean}
  */

  var supportsHVLineContainerBBox = function supportsHVLineContainerBBox() {
    return supportsHVLineContainerBBox_;
  };
  /**
   * @function module:browser.supportsGoodTextCharPos
   * @returns {boolean}
  */

  var supportsGoodTextCharPos = function supportsGoodTextCharPos() {
    return supportsGoodTextCharPos_;
  };
  /**
  * @function module:browser.supportsNonScalingStroke
  * @returns {boolean}
  */

  var supportsNonScalingStroke = function supportsNonScalingStroke() {
    return supportsNonScalingStroke_;
  };
  /**
  * @function module:browser.supportsNativeTransformLists
  * @returns {boolean}
  */

  var supportsNativeTransformLists = function supportsNativeTransformLists() {
    return supportsNativeSVGTransformLists_;
  };

  /**
   * A jQuery module to work with SVG attributes.
   * @module jQueryAttr
   * @license MIT
   */

  /**
  * This fixes `$(...).attr()` to work as expected with SVG elements.
  * Does not currently use `*AttributeNS()` since we rarely need that.
  * Adds {@link external:jQuery.fn.attr}.
  * See {@link https://api.jquery.com/attr/} for basic documentation of `.attr()`.
  *
  * Additional functionality:
  * - When getting attributes, a string that's a number is returned as type number.
  * - If an array is supplied as the first parameter, multiple values are returned
  *    as an object with values for each given attribute.
  * @function module:jQueryAttr.jQueryAttr
  * @param {external:jQuery} $ The jQuery object to which to add the plug-in
  * @returns {external:jQuery}
  */
  function jQueryPluginSVG($) {
    var proxied = $.fn.attr,
        svgns = 'http://www.w3.org/2000/svg';
    /**
    * @typedef {PlainObject<string, string|Float>} module:jQueryAttr.Attributes
    */

    /**
    * @function external:jQuery.fn.attr
    * @param {string|string[]|PlainObject<string, string>} key
    * @param {string} value
    * @returns {external:jQuery|module:jQueryAttr.Attributes}
    */

    $.fn.attr = function (key, value) {
      var len = this.length;

      if (!len) {
        return proxied.call(this, key, value);
      }

      for (var i = 0; i < len; ++i) {
        var elem = this[i]; // set/get SVG attribute

        if (elem.namespaceURI === svgns) {
          // Setting attribute
          if (value !== undefined) {
            elem.setAttribute(key, value);
          } else if (Array.isArray(key)) {
            // Getting attributes from array
            var obj = {};
            var j = key.length;

            while (j--) {
              var aname = key[j];
              var attr = elem.getAttribute(aname); // This returns a number when appropriate

              if (attr || attr === '0') {
                attr = isNaN(attr) ? attr : attr - 0;
              }

              obj[aname] = attr;
            }

            return obj;
          }

          if (_typeof(key) === 'object') {
            // Setting attributes from object
            for (var _i = 0, _Object$entries = Object.entries(key); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  name = _Object$entries$_i[0],
                  val = _Object$entries$_i[1];

              elem.setAttribute(name, val);
            } // Getting attribute

          } else {
            var _attr = elem.getAttribute(key);

            if (_attr || _attr === '0') {
              _attr = isNaN(_attr) ? _attr : _attr - 0;
            }

            return _attr;
          }
        } else {
          return proxied.call(this, key, value);
        }
      }

      return this;
    };

    return $;
  }

  var svgroot = document.createElementNS(NS.SVG, 'svg');
  /**
   * Helper function to convert `SVGTransform` to a string.
   * @param {SVGTransform} xform
   * @returns {string}
   */

  function transformToString(xform) {
    var m = xform.matrix;
    var text = '';

    switch (xform.type) {
      case 1:
        // MATRIX
        text = 'matrix(' + [m.a, m.b, m.c, m.d, m.e, m.f].join(',') + ')';
        break;

      case 2:
        // TRANSLATE
        text = 'translate(' + m.e + ',' + m.f + ')';
        break;

      case 3:
        // SCALE
        if (m.a === m.d) {
          text = 'scale(' + m.a + ')';
        } else {
          text = 'scale(' + m.a + ',' + m.d + ')';
        }

        break;

      case 4:
        {
          // ROTATE
          var cx = 0;
          var cy = 0; // this prevents divide by zero

          if (xform.angle !== 0) {
            var K = 1 - m.a;
            cy = (K * m.f + m.b * m.e) / (K * K + m.b * m.b);
            cx = (m.e - m.b * cy) / K;
          }

          text = 'rotate(' + xform.angle + ' ' + cx + ',' + cy + ')';
          break;
        }
    }

    return text;
  }
  /**
   * Map of SVGTransformList objects.
   */


  var listMap_ = {};
  /**
  * @interface module:SVGTransformList.SVGEditTransformList
  * @property {Integer} numberOfItems unsigned long
  */

  /**
  * @function module:SVGTransformList.SVGEditTransformList#clear
  * @returns {void}
  */

  /**
  * @function module:SVGTransformList.SVGEditTransformList#initialize
  * @param {SVGTransform} newItem
  * @returns {SVGTransform}
  */

  /**
  * DOES NOT THROW DOMException, INDEX_SIZE_ERR.
  * @function module:SVGTransformList.SVGEditTransformList#getItem
  * @param {Integer} index unsigned long
  * @returns {SVGTransform}
  */

  /**
  * DOES NOT THROW DOMException, INDEX_SIZE_ERR.
  * @function module:SVGTransformList.SVGEditTransformList#insertItemBefore
  * @param {SVGTransform} newItem
  * @param {Integer} index unsigned long
  * @returns {SVGTransform}
  */

  /**
  * DOES NOT THROW DOMException, INDEX_SIZE_ERR.
  * @function module:SVGTransformList.SVGEditTransformList#replaceItem
  * @param {SVGTransform} newItem
  * @param {Integer} index unsigned long
  * @returns {SVGTransform}
  */

  /**
  * DOES NOT THROW DOMException, INDEX_SIZE_ERR.
  * @function module:SVGTransformList.SVGEditTransformList#removeItem
  * @param {Integer} index unsigned long
  * @returns {SVGTransform}
  */

  /**
  * @function module:SVGTransformList.SVGEditTransformList#appendItem
  * @param {SVGTransform} newItem
  * @returns {SVGTransform}
  */

  /**
  * NOT IMPLEMENTED.
  * @ignore
  * @function module:SVGTransformList.SVGEditTransformList#createSVGTransformFromMatrix
  * @param {SVGMatrix} matrix
  * @returns {SVGTransform}
  */

  /**
  * NOT IMPLEMENTED.
  * @ignore
  * @function module:SVGTransformList.SVGEditTransformList#consolidate
  * @returns {SVGTransform}
  */

  /**
  * SVGTransformList implementation for Webkit.
  * These methods do not currently raise any exceptions.
  * These methods also do not check that transforms are being inserted.  This is basically
  * implementing as much of SVGTransformList that we need to get the job done.
  * @implements {module:SVGTransformList.SVGEditTransformList}
  */

  var SVGTransformList = /*#__PURE__*/function () {
    // eslint-disable-line no-shadow

    /**
    * @param {Element} elem
    * @returns {SVGTransformList}
    */
    function SVGTransformList(elem) {
      _classCallCheck(this, SVGTransformList);

      this._elem = elem || null;
      this._xforms = []; // TODO: how do we capture the undo-ability in the changed transform list?

      this._update = function () {
        var tstr = ''; // /* const concatMatrix = */ svgroot.createSVGMatrix();

        for (var i = 0; i < this.numberOfItems; ++i) {
          var xform = this._list.getItem(i);

          tstr += transformToString(xform) + ' ';
        }

        this._elem.setAttribute('transform', tstr);
      };

      this._list = this;

      this._init = function () {
        var _this = this;

        // Transform attribute parser
        var str = this._elem.getAttribute('transform');

        if (!str) {
          return;
        } // TODO: Add skew support in future


        var re = /\s*((scale|matrix|rotate|translate)\s*\(.*?\))\s*,?\s*/; // const re = /\s*(?<xform>(?:scale|matrix|rotate|translate)\s*\(.*?\))\s*,?\s*/;

        var m = true;

        while (m) {
          m = str.match(re);
          str = str.replace(re, '');

          if (m && m[1]) {
            (function () {
              var x = m[1];
              var bits = x.split(/\s*\(/);
              var name = bits[0];
              var valBits = bits[1].match(/\s*(.*?)\s*\)/);
              valBits[1] = valBits[1].replace(/(\d)-/g, '$1 -');
              var valArr = valBits[1].split(/[, ]+/);
              var letters = 'abcdef'.split('');
              /*
              if (m && m.groups.xform) {
              const x = m.groups.xform;
              const [name, bits] = x.split(/\s*\(/);
              const valBits = bits.match(/\s*(?<nonWhitespace>.*?)\s*\)/);
              valBits.groups.nonWhitespace = valBits.groups.nonWhitespace.replace(
                /(?<digit>\d)-/g, '$<digit> -'
              );
              const valArr = valBits.groups.nonWhitespace.split(/[, ]+/);
              const letters = [...'abcdef'];
              */

              var mtx = svgroot.createSVGMatrix();
              Object.values(valArr).forEach(function (item, i) {
                valArr[i] = Number.parseFloat(item);

                if (name === 'matrix') {
                  mtx[letters[i]] = valArr[i];
                }
              });
              var xform = svgroot.createSVGTransform();
              var fname = 'set' + name.charAt(0).toUpperCase() + name.slice(1);
              var values = name === 'matrix' ? [mtx] : valArr;

              if (name === 'scale' && values.length === 1) {
                values.push(values[0]);
              } else if (name === 'translate' && values.length === 1) {
                values.push(0);
              } else if (name === 'rotate' && values.length === 1) {
                values.push(0, 0);
              }

              xform[fname].apply(xform, _toConsumableArray(values));

              _this._list.appendItem(xform);
            })();
          }
        }
      };

      this._removeFromOtherLists = function (item) {
        if (item) {
          // Check if this transform is already in a transformlist, and
          // remove it if so.
          Object.values(listMap_).some(function (tl) {
            for (var i = 0, len = tl._xforms.length; i < len; ++i) {
              if (tl._xforms[i] === item) {
                tl.removeItem(i);
                return true;
              }
            }

            return false;
          });
        }
      };

      this.numberOfItems = 0;
    }
    /**
    * @returns {void}
    */


    _createClass(SVGTransformList, [{
      key: "clear",
      value: function clear() {
        this.numberOfItems = 0;
        this._xforms = [];
      }
      /**
      * @param {SVGTransform} newItem
      * @returns {void}
      */

    }, {
      key: "initialize",
      value: function initialize(newItem) {
        this.numberOfItems = 1;

        this._removeFromOtherLists(newItem);

        this._xforms = [newItem];
      }
      /**
      * @param {Integer} index unsigned long
      * @throws {Error}
      * @returns {SVGTransform}
      */

    }, {
      key: "getItem",
      value: function getItem(index) {
        if (index < this.numberOfItems && index >= 0) {
          return this._xforms[index];
        }

        var err = new Error('DOMException with code=INDEX_SIZE_ERR');
        err.code = 1;
        throw err;
      }
      /**
      * @param {SVGTransform} newItem
      * @param {Integer} index unsigned long
      * @returns {SVGTransform}
      */

    }, {
      key: "insertItemBefore",
      value: function insertItemBefore(newItem, index) {
        var retValue = null;

        if (index >= 0) {
          if (index < this.numberOfItems) {
            this._removeFromOtherLists(newItem);

            var newxforms = new Array(this.numberOfItems + 1); // TODO: use array copying and slicing

            var i;

            for (i = 0; i < index; ++i) {
              newxforms[i] = this._xforms[i];
            }

            newxforms[i] = newItem;

            for (var j = i + 1; i < this.numberOfItems; ++j, ++i) {
              newxforms[j] = this._xforms[i];
            }

            this.numberOfItems++;
            this._xforms = newxforms;
            retValue = newItem;

            this._list._update();
          } else {
            retValue = this._list.appendItem(newItem);
          }
        }

        return retValue;
      }
      /**
      * @param {SVGTransform} newItem
      * @param {Integer} index unsigned long
      * @returns {SVGTransform}
      */

    }, {
      key: "replaceItem",
      value: function replaceItem(newItem, index) {
        var retValue = null;

        if (index < this.numberOfItems && index >= 0) {
          this._removeFromOtherLists(newItem);

          this._xforms[index] = newItem;
          retValue = newItem;

          this._list._update();
        }

        return retValue;
      }
      /**
      * @param {Integer} index unsigned long
      * @throws {Error}
      * @returns {SVGTransform}
      */

    }, {
      key: "removeItem",
      value: function removeItem(index) {
        if (index < this.numberOfItems && index >= 0) {
          var retValue = this._xforms[index];
          var newxforms = new Array(this.numberOfItems - 1);
          var i;

          for (i = 0; i < index; ++i) {
            newxforms[i] = this._xforms[i];
          }

          for (var j = i; j < this.numberOfItems - 1; ++j, ++i) {
            newxforms[j] = this._xforms[i + 1];
          }

          this.numberOfItems--;
          this._xforms = newxforms;

          this._list._update();

          return retValue;
        }

        var err = new Error('DOMException with code=INDEX_SIZE_ERR');
        err.code = 1;
        throw err;
      }
      /**
      * @param {SVGTransform} newItem
      * @returns {SVGTransform}
      */

    }, {
      key: "appendItem",
      value: function appendItem(newItem) {
        this._removeFromOtherLists(newItem);

        this._xforms.push(newItem);

        this.numberOfItems++;

        this._list._update();

        return newItem;
      }
    }]);

    return SVGTransformList;
  }();
  /**
  * @function module:SVGTransformList.resetListMap
  * @returns {void}
  */

  var resetListMap = function resetListMap() {
    listMap_ = {};
  };
  /**
   * Removes transforms of the given element from the map.
   * @function module:SVGTransformList.removeElementFromListMap
   * @param {Element} elem - a DOM Element
   * @returns {void}
   */

  var removeElementFromListMap = function removeElementFromListMap(elem) {
    // eslint-disable-line import/no-mutable-exports
    if (elem.id && listMap_[elem.id]) {
      delete listMap_[elem.id];
    }
  };
  /**
  * Returns an object that behaves like a `SVGTransformList` for the given DOM element.
  * @function module:SVGTransformList.getTransformList
  * @param {Element} elem - DOM element to get a transformlist from
  * @todo The polyfill should have `SVGAnimatedTransformList` and this should use it
  * @returns {SVGAnimatedTransformList|SVGTransformList}
  */

  var getTransformList = function getTransformList(elem) {
    if (!supportsNativeTransformLists()) {
      var id = elem.id || 'temp';
      var t = listMap_[id];

      if (!t || id === 'temp') {
        listMap_[id] = new SVGTransformList(elem);

        listMap_[id]._init();

        t = listMap_[id];
      }

      return t;
    }

    if (elem.transform) {
      return elem.transform.baseVal;
    }

    if (elem.gradientTransform) {
      return elem.gradientTransform.baseVal;
    }

    if (elem.patternTransform) {
      return elem.patternTransform.baseVal;
    }

    return null;
  };

  /**
   * Tools for working with units.
   * @module units
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   */
  var wAttrs = ['x', 'x1', 'cx', 'rx', 'width'];
  var hAttrs = ['y', 'y1', 'cy', 'ry', 'height'];
  var unitAttrs = ['r', 'radius'].concat(wAttrs, hAttrs); // unused

  /*
  const unitNumMap = {
    '%': 2,
    em: 3,
    ex: 4,
    px: 5,
    cm: 6,
    mm: 7,
    in: 8,
    pt: 9,
    pc: 10
  };
  */
  // Container of elements.

  var elementContainer_; // Stores mapping of unit type to user coordinates.

  var typeMap_ = {};
  /**
   * @interface module:units.ElementContainer
   */

  /**
   * @function module:units.ElementContainer#getBaseUnit
   * @returns {string} The base unit type of the container ('em')
   */

  /**
   * @function module:units.ElementContainer#getElement
   * @returns {?Element} An element in the container given an id
   */

  /**
   * @function module:units.ElementContainer#getHeight
   * @returns {Float} The container's height
   */

  /**
   * @function module:units.ElementContainer#getWidth
   * @returns {Float} The container's width
   */

  /**
   * @function module:units.ElementContainer#getRoundDigits
   * @returns {Integer} The number of digits number should be rounded to
   */

  /* eslint-disable jsdoc/valid-types */

  /**
   * @typedef {PlainObject} module:units.TypeMap
   * @property {Float} em
   * @property {Float} ex
   * @property {Float} in
   * @property {Float} cm
   * @property {Float} mm
   * @property {Float} pt
   * @property {Float} pc
   * @property {Integer} px
   * @property {0} %
   */

  /* eslint-enable jsdoc/valid-types */

  /**
   * Initializes this module.
   *
   * @function module:units.init
   * @param {module:units.ElementContainer} elementContainer - An object implementing the ElementContainer interface.
   * @returns {void}
   */

  var init = function init(elementContainer) {
    elementContainer_ = elementContainer; // Get correct em/ex values by creating a temporary SVG.

    var svg = document.createElementNS(NS.SVG, 'svg');
    document.body.append(svg);
    var rect = document.createElementNS(NS.SVG, 'rect');
    rect.setAttribute('width', '1em');
    rect.setAttribute('height', '1ex');
    rect.setAttribute('x', '1in');
    svg.append(rect);
    var bb = rect.getBBox();
    svg.remove();
    var inch = bb.x;
    typeMap_ = {
      em: bb.width,
      ex: bb.height,
      "in": inch,
      cm: inch / 2.54,
      mm: inch / 25.4,
      pt: inch / 72,
      pc: inch / 6,
      px: 1,
      '%': 0
    };
  };
  /**
  * Group: Unit conversion functions.
  */

  /**
   * @function module:units.getTypeMap
   * @returns {module:units.TypeMap} The unit object with values for each unit
  */

  var getTypeMap = function getTypeMap() {
    return typeMap_;
  };
  /**
  * @typedef {GenericArray} module:units.CompareNumbers
  * @property {Integer} length 2
  * @property {Float} 0
  * @property {Float} 1
  */

  /**
  * Rounds a given value to a float with number of digits defined in
  * `round_digits` of `saveOptions`
  *
  * @function module:units.shortFloat
  * @param {string|Float|module:units.CompareNumbers} val - The value (or Array of two numbers) to be rounded
  * @returns {Float|string} If a string/number was given, returns a Float. If an array, return a string
  * with comma-separated floats
  */

  var shortFloat = function shortFloat(val) {
    var digits = elementContainer_.getRoundDigits();

    if (!isNaN(val)) {
      return Number(Number(val).toFixed(digits));
    }

    if (Array.isArray(val)) {
      return shortFloat(val[0]) + ',' + shortFloat(val[1]);
    }

    return Number.parseFloat(val).toFixed(digits) - 0;
  };
  /**
  * Converts the number to given unit or baseUnit.
  * @function module:units.convertUnit
  * @param {string|Float} val
  * @param {"em"|"ex"|"in"|"cm"|"mm"|"pt"|"pc"|"px"|"%"} [unit]
  * @returns {Float}
  */

  var convertUnit = function convertUnit(val, unit) {
    unit = unit || elementContainer_.getBaseUnit(); // baseVal.convertToSpecifiedUnits(unitNumMap[unit]);
    // const val = baseVal.valueInSpecifiedUnits;
    // baseVal.convertToSpecifiedUnits(1);

    return shortFloat(val / typeMap_[unit]);
  };
  /**
  * Sets an element's attribute based on the unit in its current value.
  *
  * @function module:units.setUnitAttr
  * @param {Element} elem - DOM element to be changed
  * @param {string} attr - Name of the attribute associated with the value
  * @param {string} val - Attribute value to convert
  * @returns {void}
  */

  var setUnitAttr = function setUnitAttr(elem, attr, val) {
    //  if (!isNaN(val)) {
    // New value is a number, so check currently used unit
    // const oldVal = elem.getAttribute(attr);
    // Enable this for alternate mode
    // if (oldVal !== null && (isNaN(oldVal) || elementContainer_.getBaseUnit() !== 'px')) {
    //   // Old value was a number, so get unit, then convert
    //   let unit;
    //   if (oldVal.substr(-1) === '%') {
    //     const res = getResolution();
    //     unit = '%';
    //     val *= 100;
    //     if (wAttrs.includes(attr)) {
    //       val = val / res.w;
    //     } else if (hAttrs.includes(attr)) {
    //       val = val / res.h;
    //     } else {
    //       return val / Math.sqrt((res.w*res.w) + (res.h*res.h))/Math.sqrt(2);
    //     }
    //   } else {
    //     if (elementContainer_.getBaseUnit() !== 'px') {
    //       unit = elementContainer_.getBaseUnit();
    //     } else {
    //       unit = oldVal.substr(-2);
    //     }
    //     val = val / typeMap_[unit];
    //   }
    //
    // val += unit;
    // }
    // }
    elem.setAttribute(attr, val);
  };
  /**
  * Converts given values to numbers. Attributes must be supplied in
  * case a percentage is given.
  *
  * @function module:units.convertToNum
  * @param {string} attr - Name of the attribute associated with the value
  * @param {string} val - Attribute value to convert
  * @returns {Float} The converted number
  */

  var convertToNum = function convertToNum(attr, val) {
    // Return a number if that's what it already is
    if (!isNaN(val)) {
      return val - 0;
    }

    if (val.substr(-1) === '%') {
      // Deal with percentage, depends on attribute
      var _num = val.substr(0, val.length - 1) / 100;

      var width = elementContainer_.getWidth();
      var height = elementContainer_.getHeight();

      if (wAttrs.includes(attr)) {
        return _num * width;
      }

      if (hAttrs.includes(attr)) {
        return _num * height;
      }

      return _num * Math.sqrt(width * width + height * height) / Math.sqrt(2);
    }

    var unit = val.substr(-2);
    var num = val.substr(0, val.length - 2); // Note that this multiplication turns the string into a number

    return num * typeMap_[unit];
  };
  /**
  * Check if an attribute's value is in a valid format.
  * @function module:units.isValidUnit
  * @param {string} attr - The name of the attribute associated with the value
  * @param {string} val - The attribute value to check
  * @param {Element} selectedElement
  * @returns {boolean} Whether the unit is valid
  */

  var isValidUnit = function isValidUnit(attr, val, selectedElement) {
    if (unitAttrs.includes(attr)) {
      // True if it's just a number
      if (!isNaN(val)) {
        return true;
      } // Not a number, check if it has a valid unit


      val = val.toLowerCase();
      return Object.keys(typeMap_).some(function (unit) {
        var re = new RegExp('^-?[\\d\\.]+' + unit + '$');
        return re.test(val);
      });
    }

    if (attr === 'id') {
      // if we're trying to change the id, make sure it's not already present in the doc
      // and the id value is valid.
      var result = false; // because getElem() can throw an exception in the case of an invalid id
      // (according to https://www.w3.org/TR/xml-id/ IDs must be a NCName)
      // we wrap it in an exception and only return true if the ID was valid and
      // not already present

      try {
        var elem = elementContainer_.getElement(val);
        result = !elem || elem === selectedElement;
      } catch (e) {}

      return result;
    }

    return true;
  };

  /**
   * Mathematical utilities.
   * @module math
   * @license MIT
   *
   * @copyright 2010 Alexis Deveria, 2010 Jeff Schiller
   */

  var NEAR_ZERO = 1e-14; // Throw away SVGSVGElement used for creating matrices/transforms.

  var svg$1 = document.createElementNS(NS.SVG, 'svg');
  /**
   * A (hopefully) quicker function to transform a point by a matrix
   * (this function avoids any DOM calls and just does the math).
   * @function module:math.transformPoint
   * @param {Float} x - Float representing the x coordinate
   * @param {Float} y - Float representing the y coordinate
   * @param {SVGMatrix} m - Matrix object to transform the point with
   * @returns {module:math.XYObject} An x, y object representing the transformed point
  */

  var transformPoint = function transformPoint(x, y, m) {
    return {
      x: m.a * x + m.c * y + m.e,
      y: m.b * x + m.d * y + m.f
    };
  };
  /**
   * Helper function to check if the matrix performs no actual transform
   * (i.e. exists for identity purposes).
   * @function module:math.isIdentity
   * @param {SVGMatrix} m - The matrix object to check
   * @returns {boolean} Indicates whether or not the matrix is 1,0,0,1,0,0
  */

  var isIdentity = function isIdentity(m) {
    return m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && m.e === 0 && m.f === 0;
  };
  /**
   * This function tries to return a `SVGMatrix` that is the multiplication `m1 * m2`.
   * We also round to zero when it's near zero.
   * @function module:math.matrixMultiply
   * @param {...SVGMatrix} args - Matrix objects to multiply
   * @returns {SVGMatrix} The matrix object resulting from the calculation
  */

  var matrixMultiply = function matrixMultiply() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var m = args.reduceRight(function (prev, m1) {
      return m1.multiply(prev);
    });

    if (Math.abs(m.a) < NEAR_ZERO) {
      m.a = 0;
    }

    if (Math.abs(m.b) < NEAR_ZERO) {
      m.b = 0;
    }

    if (Math.abs(m.c) < NEAR_ZERO) {
      m.c = 0;
    }

    if (Math.abs(m.d) < NEAR_ZERO) {
      m.d = 0;
    }

    if (Math.abs(m.e) < NEAR_ZERO) {
      m.e = 0;
    }

    if (Math.abs(m.f) < NEAR_ZERO) {
      m.f = 0;
    }

    return m;
  };
  /**
   * See if the given transformlist includes a non-indentity matrix transform.
   * @function module:math.hasMatrixTransform
   * @param {SVGTransformList} [tlist] - The transformlist to check
   * @returns {boolean} Whether or not a matrix transform was found
  */

  var hasMatrixTransform = function hasMatrixTransform(tlist) {
    if (!tlist) {
      return false;
    }

    var num = tlist.numberOfItems;

    while (num--) {
      var xform = tlist.getItem(num);

      if (xform.type === 1 && !isIdentity(xform.matrix)) {
        return true;
      }
    }

    return false;
  };
  /**
  * @typedef {PlainObject} module:math.TransformedBox An object with the following values
  * @property {module:math.XYObject} tl - The top left coordinate
  * @property {module:math.XYObject} tr - The top right coordinate
  * @property {module:math.XYObject} bl - The bottom left coordinate
  * @property {module:math.XYObject} br - The bottom right coordinate
  * @property {PlainObject} aabox - Object with the following values:
  * @property {Float} aabox.x - Float with the axis-aligned x coordinate
  * @property {Float} aabox.y - Float with the axis-aligned y coordinate
  * @property {Float} aabox.width - Float with the axis-aligned width coordinate
  * @property {Float} aabox.height - Float with the axis-aligned height coordinate
  */

  /**
   * Transforms a rectangle based on the given matrix.
   * @function module:math.transformBox
   * @param {Float} l - Float with the box's left coordinate
   * @param {Float} t - Float with the box's top coordinate
   * @param {Float} w - Float with the box width
   * @param {Float} h - Float with the box height
   * @param {SVGMatrix} m - Matrix object to transform the box by
   * @returns {module:math.TransformedBox}
  */

  var transformBox = function transformBox(l, t, w, h, m) {
    var tl = transformPoint(l, t, m),
        tr = transformPoint(l + w, t, m),
        bl = transformPoint(l, t + h, m),
        br = transformPoint(l + w, t + h, m),
        minx = Math.min(tl.x, tr.x, bl.x, br.x),
        maxx = Math.max(tl.x, tr.x, bl.x, br.x),
        miny = Math.min(tl.y, tr.y, bl.y, br.y),
        maxy = Math.max(tl.y, tr.y, bl.y, br.y);
    return {
      tl: tl,
      tr: tr,
      bl: bl,
      br: br,
      aabox: {
        x: minx,
        y: miny,
        width: maxx - minx,
        height: maxy - miny
      }
    };
  };
  /**
   * This returns a single matrix Transform for a given Transform List
   * (this is the equivalent of `SVGTransformList.consolidate()` but unlike
   * that method, this one does not modify the actual `SVGTransformList`).
   * This function is very liberal with its `min`, `max` arguments.
   * @function module:math.transformListToTransform
   * @param {SVGTransformList} tlist - The transformlist object
   * @param {Integer} [min=0] - Optional integer indicating start transform position
   * @param {Integer} [max] - Optional integer indicating end transform position;
   *   defaults to one less than the tlist's `numberOfItems`
   * @returns {SVGTransform} A single matrix transform object
  */

  var transformListToTransform = function transformListToTransform(tlist, min, max) {
    if (!tlist) {
      // Or should tlist = null have been prevented before this?
      return svg$1.createSVGTransformFromMatrix(svg$1.createSVGMatrix());
    }

    min = min || 0;
    max = max || tlist.numberOfItems - 1;
    min = Number.parseInt(min);
    max = Number.parseInt(max);

    if (min > max) {
      var temp = max;
      max = min;
      min = temp;
    }

    var m = svg$1.createSVGMatrix();

    for (var i = min; i <= max; ++i) {
      // if our indices are out of range, just use a harmless identity matrix
      var mtom = i >= 0 && i < tlist.numberOfItems ? tlist.getItem(i).matrix : svg$1.createSVGMatrix();
      m = matrixMultiply(m, mtom);
    }

    return svg$1.createSVGTransformFromMatrix(m);
  };
  /**
   * Get the matrix object for a given element.
   * @function module:math.getMatrix
   * @param {Element} elem - The DOM element to check
   * @returns {SVGMatrix} The matrix object associated with the element's transformlist
  */

  var getMatrix = function getMatrix(elem) {
    var tlist = getTransformList(elem);
    return transformListToTransform(tlist).matrix;
  };
  /**
   * Returns a 45 degree angle coordinate associated with the two given
   * coordinates.
   * @function module:math.snapToAngle
   * @param {Integer} x1 - First coordinate's x value
   * @param {Integer} y1 - First coordinate's y value
   * @param {Integer} x2 - Second coordinate's x value
   * @param {Integer} y2 - Second coordinate's y value
   * @returns {module:math.AngleCoord45}
  */

  var snapToAngle = function snapToAngle(x1, y1, x2, y2) {
    var snap = Math.PI / 4; // 45 degrees

    var dx = x2 - x1;
    var dy = y2 - y1;
    var angle = Math.atan2(dy, dx);
    var dist = Math.sqrt(dx * dx + dy * dy);
    var snapangle = Math.round(angle / snap) * snap;
    return {
      x: x1 + dist * Math.cos(snapangle),
      y: y1 + dist * Math.sin(snapangle),
      a: snapangle
    };
  };
  /**
   * Check if two rectangles (BBoxes objects) intersect each other.
   * @function module:math.rectsIntersect
   * @param {SVGRect} r1 - The first BBox-like object
   * @param {SVGRect} r2 - The second BBox-like object
   * @returns {boolean} True if rectangles intersect
   */

  var rectsIntersect = function rectsIntersect(r1, r2) {
    return r2.x < r1.x + r1.width && r2.x + r2.width > r1.x && r2.y < r1.y + r1.height && r2.y + r2.height > r1.y;
  };

  var $$1 = jQueryPluginSVG(jQuery); // String used to encode base64.

  var KEYSTR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; // Much faster than running getBBox() every time

  var visElems = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use,clipPath';
  var visElemsArr = visElems.split(','); // const hidElems = 'defs,desc,feGaussianBlur,filter,linearGradient,marker,mask,metadata,pattern,radialGradient,stop,switch,symbol,title,textPath';

  var editorContext_ = null;
  var domdoc_ = null;
  var domcontainer_ = null;
  var svgroot_ = null;
  /**
  * Object with the following keys/values.
  * @typedef {PlainObject} module:utilities.SVGElementJSON
  * @property {string} element - Tag name of the SVG element to create
  * @property {PlainObject<string, string>} attr - Has key-value attributes to assign to the new element. An `id` should be set so that {@link module:utilities.EditorContext#addSVGElementFromJson} can later re-identify the element for modification or replacement.
  * @property {boolean} [curStyles=false] - Indicates whether current style attributes should be applied first
  * @property {module:utilities.SVGElementJSON[]} [children] - Data objects to be added recursively as children
  * @property {string} [namespace="http://www.w3.org/2000/svg"] - Indicate a (non-SVG) namespace
  */

  /**
   * An object that creates SVG elements for the canvas.
   *
   * @interface module:utilities.EditorContext
   * @property {module:path.pathActions} pathActions
   */

  /**
   * @function module:utilities.EditorContext#getSVGContent
   * @returns {SVGSVGElement}
   */

  /**
   * Create a new SVG element based on the given object keys/values and add it
   * to the current layer.
   * The element will be run through `cleanupElement` before being returned.
   * @function module:utilities.EditorContext#addSVGElementFromJson
   * @param {module:utilities.SVGElementJSON} data
   * @returns {Element} The new element
  */

  /**
   * @function module:utilities.EditorContext#getSelectedElements
   * @returns {Element[]} the array with selected DOM elements
  */

  /**
   * @function module:utilities.EditorContext#getDOMDocument
   * @returns {HTMLDocument}
  */

  /**
   * @function module:utilities.EditorContext#getDOMContainer
   * @returns {HTMLElement}
  */

  /**
   * @function module:utilities.EditorContext#getSVGRoot
   * @returns {SVGSVGElement}
  */

  /**
   * @function module:utilities.EditorContext#getBaseUnit
   * @returns {string}
  */

  /**
   * @function module:utilities.EditorContext#getSnappingStep
   * @returns {Float|string}
  */

  /**
  * @function module:utilities.init
  * @param {module:utilities.EditorContext} editorContext
  * @returns {void}
  */

  var init$1 = function init(editorContext) {
    editorContext_ = editorContext;
    domdoc_ = editorContext.getDOMDocument();
    domcontainer_ = editorContext.getDOMContainer();
    svgroot_ = editorContext.getSVGRoot();
  };
  /**
   * Used to prevent the [Billion laughs attack]{@link https://en.wikipedia.org/wiki/Billion_laughs_attack}.
   * @function module:utilities.dropXMLInternalSubset
   * @param {string} str String to be processed
   * @returns {string} The string with entity declarations in the internal subset removed
   * @todo This might be needed in other places `parseFromString` is used even without LGTM flagging
   */

  var dropXMLInternalSubset = function dropXMLInternalSubset(str) {
    return str.replace(/(<!DOCTYPE\s+\w*\s*\[).*(\?]>)/, '$1$2'); // return str.replace(/(?<doctypeOpen><!DOCTYPE\s+\w*\s*\[).*(?<doctypeClose>\?\]>)/, '$<doctypeOpen>$<doctypeClose>');
  };
  /**
  * Converts characters in a string to XML-friendly entities.
  * @function module:utilities.toXml
  * @example `&` becomes `&amp;`
  * @param {string} str - The string to be converted
  * @returns {string} The converted string
  */

  var toXml = function toXml(str) {
    // &apos; is ok in XML, but not HTML
    // &gt; does not normally need escaping, though it can if within a CDATA expression (and preceded by "]]")
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;'); // Note: `&apos;` is XML only
  };
  // public domain.  It would be nice if you left this header intact.
  // Base64 code from Tyler Akins -- http://rumkin.com
  // schiller: Removed string concatenation in favour of Array.join() optimization,
  //        also precalculate the size of the array needed.

  /**
  * Converts a string to base64.
  * @function module:utilities.encode64
  * @param {string} input
  * @returns {string} Base64 output
  */

  function encode64(input) {
    // base64 strings are 4/3 larger than the original string
    input = encodeUTF8(input); // convert non-ASCII characters
    // input = convertToXMLReferences(input);

    if (window.btoa) {
      return window.btoa(input); // Use native if available
    }

    var output = new Array(Math.floor((input.length + 2) / 3) * 4);
    var i = 0,
        p = 0;

    do {
      var chr1 = input.charCodeAt(i++);
      var chr2 = input.charCodeAt(i++);
      var chr3 = input.charCodeAt(i++);
      /* eslint-disable no-bitwise */

      var enc1 = chr1 >> 2;
      var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      var enc4 = chr3 & 63;
      /* eslint-enable no-bitwise */

      if (Number.isNaN(chr2)) {
        enc3 = 64;
        enc4 = 64;
      } else if (Number.isNaN(chr3)) {
        enc4 = 64;
      }

      output[p++] = KEYSTR.charAt(enc1);
      output[p++] = KEYSTR.charAt(enc2);
      output[p++] = KEYSTR.charAt(enc3);
      output[p++] = KEYSTR.charAt(enc4);
    } while (i < input.length);

    return output.join('');
  }
  /**
  * Converts a string from base64.
  * @function module:utilities.decode64
  * @param {string} input Base64-encoded input
  * @returns {string} Decoded output
  */

  function decode64(input) {
    if (window.atob) {
      return decodeUTF8(window.atob(input));
    } // remove all characters that are not A-Z, a-z, 0-9, +, /, or =


    input = input.replace(/[^A-Za-z\d+/=]/g, '');
    var output = '';
    var i = 0;

    do {
      var enc1 = KEYSTR.indexOf(input.charAt(i++));
      var enc2 = KEYSTR.indexOf(input.charAt(i++));
      var enc3 = KEYSTR.indexOf(input.charAt(i++));
      var enc4 = KEYSTR.indexOf(input.charAt(i++));
      /* eslint-disable no-bitwise */

      var chr1 = enc1 << 2 | enc2 >> 4;
      var chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      var chr3 = (enc3 & 3) << 6 | enc4;
      /* eslint-enable no-bitwise */

      output += String.fromCharCode(chr1);

      if (enc3 !== 64) {
        output += String.fromCharCode(chr2);
      }

      if (enc4 !== 64) {
        output += String.fromCharCode(chr3);
      }
    } while (i < input.length);

    return decodeUTF8(output);
  }
  /**
  * @function module:utilities.decodeUTF8
  * @param {string} argString
  * @returns {string}
  */

  function decodeUTF8(argString) {
    return decodeURIComponent(escape(argString));
  } // codedread:does not seem to work with webkit-based browsers on OSX // Brettz9: please test again as function upgraded

  /**
  * @function module:utilities.encodeUTF8
  * @param {string} argString
  * @returns {string}
  */

  var encodeUTF8 = function encodeUTF8(argString) {
    return unescape(encodeURIComponent(argString));
  };
  /**
   * Convert dataURL to object URL.
   * @function module:utilities.dataURLToObjectURL
   * @param {string} dataurl
   * @returns {string} object URL or empty string
   */

  var dataURLToObjectURL = function dataURLToObjectURL(dataurl) {
    if (typeof Uint8Array === 'undefined' || typeof Blob === 'undefined' || typeof URL === 'undefined' || !URL.createObjectURL) {
      return '';
    }

    var arr = dataurl.split(','),
        mime = arr[0].match(/:(.*?);/)[1],
        bstr = atob(arr[1]);
    /*
    const [prefix, suffix] = dataurl.split(','),
      {groups: {mime}} = prefix.match(/:(?<mime>.*?);/),
      bstr = atob(suffix);
    */

    var n = bstr.length;
    var u8arr = new Uint8Array(n);

    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }

    var blob = new Blob([u8arr], {
      type: mime
    });
    return URL.createObjectURL(blob);
  };
  /**
   * Get object URL for a blob object.
   * @function module:utilities.createObjectURL
   * @param {Blob} blob A Blob object or File object
   * @returns {string} object URL or empty string
   */

  var createObjectURL = function createObjectURL(blob) {
    if (!blob || typeof URL === 'undefined' || !URL.createObjectURL) {
      return '';
    }

    return URL.createObjectURL(blob);
  };
  /**
   * @property {string} blankPageObjectURL
   */

  var blankPageObjectURL = function () {
    if (typeof Blob === 'undefined') {
      return '';
    }

    var blob = new Blob(['<html><head><title>SVG-edit</title></head><body>&nbsp;</body></html>'], {
      type: 'text/html'
    });
    return createObjectURL(blob);
  }();
  /**
  * Cross-browser compatible method of converting a string to an XML tree.
  * Found this function [here]{@link http://groups.google.com/group/jquery-dev/browse_thread/thread/c6d11387c580a77f}.
  * @function module:utilities.text2xml
  * @param {string} sXML
  * @throws {Error}
  * @returns {XMLDocument}
  */

  var text2xml = function text2xml(sXML) {
    if (sXML.includes('<svg:svg')) {
      sXML = sXML.replace(/<(\/?)svg:/g, '<$1').replace('xmlns:svg', 'xmlns');
    }

    var out, dXML;

    try {
      dXML = window.DOMParser ? new DOMParser() : new window.ActiveXObject('Microsoft.XMLDOM');
      dXML.async = false;
    } catch (e) {
      throw new Error('XML Parser could not be instantiated');
    }

    try {
      if (dXML.loadXML) {
        out = dXML.loadXML(sXML) ? dXML : false;
      } else {
        out = dXML.parseFromString(sXML, 'text/xml');
      }
    } catch (e2) {
      throw new Error('Error parsing XML string');
    }

    return out;
  };
  /**
  * @typedef {PlainObject} module:utilities.BBoxObject (like `DOMRect`)
  * @property {Float} x
  * @property {Float} y
  * @property {Float} width
  * @property {Float} height
  */

  /**
  * Converts a `SVGRect` into an object.
  * @function module:utilities.bboxToObj
  * @param {SVGRect} bbox - a SVGRect
  * @returns {module:utilities.BBoxObject} An object with properties names x, y, width, height.
  */

  var bboxToObj = function bboxToObj(_ref) {
    var x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height;
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };
  /**
  * @callback module:utilities.TreeWalker
  * @param {Element} elem - DOM element being traversed
  * @returns {void}
  */

  /**
  * Walks the tree and executes the callback on each element in a top-down fashion.
  * @function module:utilities.walkTree
  * @param {Element} elem - DOM element to traverse
  * @param {module:utilities.TreeWalker} cbFn - Callback function to run on each element
  * @returns {void}
  */

  var walkTree = function walkTree(elem, cbFn) {
    if (elem && elem.nodeType === 1) {
      cbFn(elem);
      var i = elem.childNodes.length;

      while (i--) {
        walkTree(elem.childNodes.item(i), cbFn);
      }
    }
  };
  /**
  * Walks the tree and executes the callback on each element in a depth-first fashion.
  * @function module:utilities.walkTreePost
  * @todo Shouldn't this be calling walkTreePost?
  * @param {Element} elem - DOM element to traverse
  * @param {module:utilities.TreeWalker} cbFn - Callback function to run on each element
  * @returns {void}
  */

  var walkTreePost = function walkTreePost(elem, cbFn) {
    if (elem && elem.nodeType === 1) {
      var i = elem.childNodes.length;

      while (i--) {
        walkTree(elem.childNodes.item(i), cbFn);
      }

      cbFn(elem);
    }
  };
  /**
  * Extracts the URL from the `url(...)` syntax of some attributes.
  * Three variants:
  *  - `<circle fill="url(someFile.svg#foo)" />`
  *  - `<circle fill="url('someFile.svg#foo')" />`
  *  - `<circle fill='url("someFile.svg#foo")' />`
  * @function module:utilities.getUrlFromAttr
  * @param {string} attrVal The attribute value as a string
  * @returns {string} String with just the URL, like "someFile.svg#foo"
  */

  var getUrlFromAttr = function getUrlFromAttr(attrVal) {
    if (attrVal) {
      // url('#somegrad')
      if (attrVal.startsWith('url("')) {
        return attrVal.substring(5, attrVal.indexOf('"', 6));
      } // url('#somegrad')


      if (attrVal.startsWith("url('")) {
        return attrVal.substring(5, attrVal.indexOf("'", 6));
      }

      if (attrVal.startsWith('url(')) {
        return attrVal.substring(4, attrVal.indexOf(')'));
      }
    }

    return null;
  };
  /**
  * @function module:utilities.getHref
  * @param {Element} elem
  * @returns {string} The given element's `xlink:href` value
  */

  var getHref = function getHref(elem) {
    // eslint-disable-line import/no-mutable-exports
    return elem.getAttributeNS(NS.XLINK, 'href');
  };
  /**
  * Sets the given element's `xlink:href` value.
  * @function module:utilities.setHref
  * @param {Element} elem
  * @param {string} val
  * @returns {void}
  */

  var setHref = function setHref(elem, val) {
    // eslint-disable-line import/no-mutable-exports
    elem.setAttributeNS(NS.XLINK, 'xlink:href', val);
  };
  /**
  * @function module:utilities.findDefs
  * @returns {SVGDefsElement} The document's `<defs>` element, creating it first if necessary
  */

  var findDefs = function findDefs() {
    var svgElement = editorContext_.getSVGContent();
    var defs = svgElement.getElementsByTagNameNS(NS.SVG, 'defs');

    if (defs.length > 0) {
      defs = defs[0];
    } else {
      defs = svgElement.ownerDocument.createElementNS(NS.SVG, 'defs');

      if (svgElement.firstChild) {
        // first child is a comment, so call nextSibling
        svgElement.insertBefore(defs, svgElement.firstChild.nextSibling); // svgElement.firstChild.nextSibling.before(defs); // Not safe
      } else {
        svgElement.append(defs);
      }
    }

    return defs;
  }; // TODO(codedread): Consider moving the next to functions to bbox.js

  /**
  * Get correct BBox for a path in Webkit.
  * Converted from code found [here]{@link http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html}.
  * @function module:utilities.getPathBBox
  * @param {SVGPathElement} path - The path DOM element to get the BBox for
  * @returns {module:utilities.BBoxObject} A BBox-like object
  */

  var getPathBBox = function getPathBBox(path) {
    var seglist = path.pathSegList;
    var tot = seglist.numberOfItems;
    var bounds = [[], []];
    var start = seglist.getItem(0);
    var P0 = [start.x, start.y];

    var getCalc = function getCalc(j, P1, P2, P3) {
      return function (t) {
        return 1 - Math.pow(t, 3) * P0[j] + 3 * 1 - Math.pow(t, 2) * t * P1[j] + 3 * (1 - t) * Math.pow(t, 2) * P2[j] + Math.pow(t, 3) * P3[j];
      };
    };

    for (var i = 0; i < tot; i++) {
      var seg = seglist.getItem(i);

      if (seg.x === undefined) {
        continue;
      } // Add actual points to limits


      bounds[0].push(P0[0]);
      bounds[1].push(P0[1]);

      if (seg.x1) {
        var P1 = [seg.x1, seg.y1],
            P2 = [seg.x2, seg.y2],
            P3 = [seg.x, seg.y];

        for (var j = 0; j < 2; j++) {
          var calc = getCalc(j, P1, P2, P3);
          var b = 6 * P0[j] - 12 * P1[j] + 6 * P2[j];
          var a = -3 * P0[j] + 9 * P1[j] - 9 * P2[j] + 3 * P3[j];
          var c = 3 * P1[j] - 3 * P0[j];

          if (a === 0) {
            if (b === 0) {
              continue;
            }

            var t = -c / b;

            if (t > 0 && t < 1) {
              bounds[j].push(calc(t));
            }

            continue;
          }

          var b2ac = Math.pow(b, 2) - 4 * c * a;

          if (b2ac < 0) {
            continue;
          }

          var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);

          if (t1 > 0 && t1 < 1) {
            bounds[j].push(calc(t1));
          }

          var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);

          if (t2 > 0 && t2 < 1) {
            bounds[j].push(calc(t2));
          }
        }

        P0 = P3;
      } else {
        bounds[0].push(seg.x);
        bounds[1].push(seg.y);
      }
    }

    var x = Math.min.apply(null, bounds[0]);
    var w = Math.max.apply(null, bounds[0]) - x;
    var y = Math.min.apply(null, bounds[1]);
    var h = Math.max.apply(null, bounds[1]) - y;
    return {
      x: x,
      y: y,
      width: w,
      height: h
    };
  };
  /**
  * Get the given/selected element's bounding box object, checking for
  * horizontal/vertical lines (see issue 717)
  * Note that performance is currently terrible, so some way to improve would
  * be great.
  * @param {Element} selected - Container or `<use>` DOM element
  * @returns {DOMRect} Bounding box object
  */

  function groupBBFix(selected) {
    if (supportsHVLineContainerBBox()) {
      try {
        return selected.getBBox();
      } catch (e) {}
    }

    var ref = $$1.data(selected, 'ref');
    var matched = null;
    var ret, copy;

    if (ref) {
      copy = $$1(ref).children().clone().attr('visibility', 'hidden');
      $$1(svgroot_).append(copy);
      matched = copy.filter('line, path');
    } else {
      matched = $$1(selected).find('line, path');
    }

    var issue = false;

    if (matched.length) {
      matched.each(function () {
        var bb = this.getBBox();

        if (!bb.width || !bb.height) {
          issue = true;
        }
      });

      if (issue) {
        var elems = ref ? copy : $$1(selected).children();
        ret = getStrokedBBox(elems);
      } else {
        ret = selected.getBBox();
      }
    } else {
      ret = selected.getBBox();
    }

    if (ref) {
      copy.remove();
    }

    return ret;
  }
  /**
  * Get the given/selected element's bounding box object, convert it to be more
  * usable when necessary.
  * @function module:utilities.getBBox
  * @param {Element} elem - Optional DOM element to get the BBox for
  * @returns {module:utilities.BBoxObject} Bounding box object
  */


  var getBBox = function getBBox(elem) {
    var selected = elem || editorContext_.geSelectedElements()[0];

    if (elem.nodeType !== 1) {
      return null;
    }

    var elname = selected.nodeName;
    var ret = null;

    switch (elname) {
      case 'text':
        if (selected.textContent === '') {
          selected.textContent = 'a'; // Some character needed for the selector to use.

          ret = selected.getBBox();
          selected.textContent = '';
        } else if (selected.getBBox) {
          ret = selected.getBBox();
        }

        break;

      case 'path':
        if (!supportsPathBBox()) {
          ret = getPathBBox(selected);
        } else if (selected.getBBox) {
          ret = selected.getBBox();
        }

        break;

      case 'g':
      case 'a':
        ret = groupBBFix(selected);
        break;

      default:
        if (elname === 'use') {
          ret = groupBBFix(selected); // , true);
        }

        if (elname === 'use' || elname === 'foreignObject' && isWebkit()) {
          if (!ret) {
            ret = selected.getBBox();
          } // This is resolved in later versions of webkit, perhaps we should
          // have a featured detection for correct 'use' behavior?
          // ——————————


          if (!isWebkit()) {
            var _ret = ret,
                x = _ret.x,
                y = _ret.y,
                width = _ret.width,
                height = _ret.height;
            var bb = {
              width: width,
              height: height,
              x: x + Number.parseFloat(selected.getAttribute('x') || 0),
              y: y + Number.parseFloat(selected.getAttribute('y') || 0)
            };
            ret = bb;
          }
        } else if (visElemsArr.includes(elname)) {
          if (selected) {
            try {
              ret = selected.getBBox();
            } catch (err) {
              // tspan (and textPath apparently) have no `getBBox` in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=937268
              // Re: Chrome returning bbox for containing text element, see: https://bugs.chromium.org/p/chromium/issues/detail?id=349835
              var extent = selected.getExtentOfChar(0); // pos+dimensions of the first glyph

              var _width = selected.getComputedTextLength(); // width of the tspan


              ret = {
                x: extent.x,
                y: extent.y,
                width: _width,
                height: extent.height
              };
            }
          } else {
            // Check if element is child of a foreignObject
            var fo = $$1(selected).closest('foreignObject');

            if (fo.length) {
              if (fo[0].getBBox) {
                ret = fo[0].getBBox();
              }
            }
          }
        }

    }

    if (ret) {
      ret = bboxToObj(ret);
    } // get the bounding box from the DOM (which is in that element's coordinate system)


    return ret;
  };
  /**
  * @typedef {GenericArray} module:utilities.PathSegmentArray
  * @property {Integer} length 2
  * @property {"M"|"L"|"C"|"Z"} 0
  * @property {Float[]} 1
  */

  /**
  * Create a path 'd' attribute from path segments.
  * Each segment is an array of the form: `[singleChar, [x,y, x,y, ...]]`
  * @function module:utilities.getPathDFromSegments
  * @param {module:utilities.PathSegmentArray[]} pathSegments - An array of path segments to be converted
  * @returns {string} The converted path d attribute.
  */

  var getPathDFromSegments = function getPathDFromSegments(pathSegments) {
    var d = '';
    $$1.each(pathSegments, function (j, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          singleChar = _ref3[0],
          pts = _ref3[1];

      d += singleChar;

      for (var i = 0; i < pts.length; i += 2) {
        d += pts[i] + ',' + pts[i + 1] + ' ';
      }
    });
    return d;
  };
  /**
  * Make a path 'd' attribute from a simple SVG element shape.
  * @function module:utilities.getPathDFromElement
  * @param {Element} elem - The element to be converted
  * @returns {string} The path d attribute or `undefined` if the element type is unknown.
  */

  var getPathDFromElement = function getPathDFromElement(elem) {
    // Possibly the cubed root of 6, but 1.81 works best
    var num = 1.81;
    var d, a, rx, ry;

    switch (elem.tagName) {
      case 'ellipse':
      case 'circle':
        {
          a = $$1(elem).attr(['rx', 'ry', 'cx', 'cy']);
          var _a = a,
              cx = _a.cx,
              cy = _a.cy;
          var _a2 = a;
          rx = _a2.rx;
          ry = _a2.ry;

          if (elem.tagName === 'circle') {
            ry = $$1(elem).attr('r');
            rx = ry;
          }

          d = getPathDFromSegments([['M', [cx - rx, cy]], ['C', [cx - rx, cy - ry / num, cx - rx / num, cy - ry, cx, cy - ry]], ['C', [cx + rx / num, cy - ry, cx + rx, cy - ry / num, cx + rx, cy]], ['C', [cx + rx, cy + ry / num, cx + rx / num, cy + ry, cx, cy + ry]], ['C', [cx - rx / num, cy + ry, cx - rx, cy + ry / num, cx - rx, cy]], ['Z', []]]);
          break;
        }

      case 'path':
        d = elem.getAttribute('d');
        break;

      case 'line':
        a = $$1(elem).attr(['x1', 'y1', 'x2', 'y2']);
        d = 'M' + a.x1 + ',' + a.y1 + 'L' + a.x2 + ',' + a.y2;
        break;

      case 'polyline':
        d = 'M' + elem.getAttribute('points');
        break;

      case 'polygon':
        d = 'M' + elem.getAttribute('points') + ' Z';
        break;

      case 'rect':
        {
          var r = $$1(elem).attr(['rx', 'ry']);
          rx = r.rx;
          ry = r.ry;
          var b = elem.getBBox();
          var x = b.x,
              y = b.y,
              w = b.width,
              h = b.height;
          num = 4 - num; // Why? Because!

          if (!rx && !ry) {
            // Regular rect
            d = getPathDFromSegments([['M', [x, y]], ['L', [x + w, y]], ['L', [x + w, y + h]], ['L', [x, y + h]], ['L', [x, y]], ['Z', []]]);
          } else {
            d = getPathDFromSegments([['M', [x, y + ry]], ['C', [x, y + ry / num, x + rx / num, y, x + rx, y]], ['L', [x + w - rx, y]], ['C', [x + w - rx / num, y, x + w, y + ry / num, x + w, y + ry]], ['L', [x + w, y + h - ry]], ['C', [x + w, y + h - ry / num, x + w - rx / num, y + h, x + w - rx, y + h]], ['L', [x + rx, y + h]], ['C', [x + rx / num, y + h, x, y + h - ry / num, x, y + h - ry]], ['L', [x, y + ry]], ['Z', []]]);
          }

          break;
        }
    }

    return d;
  };
  /**
  * Get a set of attributes from an element that is useful for convertToPath.
  * @function module:utilities.getExtraAttributesForConvertToPath
  * @param {Element} elem - The element to be probed
  * @returns {PlainObject<"marker-start"|"marker-end"|"marker-mid"|"filter"|"clip-path", string>} An object with attributes.
  */

  var getExtraAttributesForConvertToPath = function getExtraAttributesForConvertToPath(elem) {
    var attrs = {}; // TODO: make this list global so that we can properly maintain it
    // TODO: what about @transform, @clip-rule, @fill-rule, etc?

    $$1.each(['marker-start', 'marker-end', 'marker-mid', 'filter', 'clip-path'], function () {
      var a = elem.getAttribute(this);

      if (a) {
        attrs[this] = a;
      }
    });
    return attrs;
  };
  /**
  * Get the BBox of an element-as-path.
  * @function module:utilities.getBBoxOfElementAsPath
  * @param {Element} elem - The DOM element to be probed
  * @param {module:utilities.EditorContext#addSVGElementFromJson} addSVGElementFromJson - Function to add the path element to the current layer. See canvas.addSVGElementFromJson
  * @param {module:path.pathActions} pathActions - If a transform exists, `pathActions.resetOrientation()` is used. See: canvas.pathActions.
  * @returns {DOMRect|false} The resulting path's bounding box object.
  */

  var getBBoxOfElementAsPath = function getBBoxOfElementAsPath(elem, addSVGElementFromJson, pathActions) {
    var path = addSVGElementFromJson({
      element: 'path',
      attr: getExtraAttributesForConvertToPath(elem)
    });
    var eltrans = elem.getAttribute('transform');

    if (eltrans) {
      path.setAttribute('transform', eltrans);
    }

    var parentNode = elem.parentNode;

    if (elem.nextSibling) {
      elem.before(path);
    } else {
      parentNode.append(path);
    }

    var d = getPathDFromElement(elem);

    if (d) {
      path.setAttribute('d', d);
    } else {
      path.remove();
    } // Get the correct BBox of the new path, then discard it


    pathActions.resetOrientation(path);
    var bb = false;

    try {
      bb = path.getBBox();
    } catch (e) {// Firefox fails
    }

    path.remove();
    return bb;
  };
  /**
  * Convert selected element to a path.
  * @function module:utilities.convertToPath
  * @param {Element} elem - The DOM element to be converted
  * @param {module:utilities.SVGElementJSON} attrs - Apply attributes to new path. see canvas.convertToPath
  * @param {module:utilities.EditorContext#addSVGElementFromJson} addSVGElementFromJson - Function to add the path element to the current layer. See canvas.addSVGElementFromJson
  * @param {module:path.pathActions} pathActions - If a transform exists, pathActions.resetOrientation() is used. See: canvas.pathActions.
  * @param {module:draw.DrawCanvasInit#clearSelection|module:path.EditorContext#clearSelection} clearSelection - see [canvas.clearSelection]{@link module:svgcanvas.SvgCanvas#clearSelection}
  * @param {module:path.EditorContext#addToSelection} addToSelection - see [canvas.addToSelection]{@link module:svgcanvas.SvgCanvas#addToSelection}
  * @param {module:history} hstry - see history module
  * @param {module:path.EditorContext#addCommandToHistory|module:draw.DrawCanvasInit#addCommandToHistory} addCommandToHistory - see [canvas.addCommandToHistory]{@link module:svgcanvas~addCommandToHistory}
  * @returns {SVGPathElement|null} The converted path element or null if the DOM element was not recognized.
  */

  var convertToPath = function convertToPath(elem, attrs, addSVGElementFromJson, pathActions, clearSelection, addToSelection, hstry, addCommandToHistory) {
    var batchCmd = new hstry.BatchCommand('Convert element to Path'); // Any attribute on the element not covered by the passed-in attributes

    attrs = $$1.extend({}, attrs, getExtraAttributesForConvertToPath(elem));
    var path = addSVGElementFromJson({
      element: 'path',
      attr: attrs
    });
    var eltrans = elem.getAttribute('transform');

    if (eltrans) {
      path.setAttribute('transform', eltrans);
    }

    var id = elem.id;
    var parentNode = elem.parentNode;

    if (elem.nextSibling) {
      elem.before(path);
    } else {
      parentNode.append(path);
    }

    var d = getPathDFromElement(elem);

    if (d) {
      path.setAttribute('d', d); // Replace the current element with the converted one
      // Reorient if it has a matrix

      if (eltrans) {
        var tlist = getTransformList(path);

        if (hasMatrixTransform(tlist)) {
          pathActions.resetOrientation(path);
        }
      }

      var nextSibling = elem.nextSibling;
      batchCmd.addSubCommand(new hstry.RemoveElementCommand(elem, nextSibling, parent));
      batchCmd.addSubCommand(new hstry.InsertElementCommand(path));
      clearSelection();
      elem.remove();
      path.setAttribute('id', id);
      path.removeAttribute('visibility');
      addToSelection([path], true);
      addCommandToHistory(batchCmd);
      return path;
    } // the elem.tagName was not recognized, so no "d" attribute. Remove it, so we've haven't changed anything.


    path.remove();
    return null;
  };
  /**
  * Can the bbox be optimized over the native getBBox? The optimized bbox is the same as the native getBBox when
  * the rotation angle is a multiple of 90 degrees and there are no complex transforms.
  * Getting an optimized bbox can be dramatically slower, so we want to make sure it's worth it.
  *
  * The best example for this is a circle rotate 45 degrees. The circle doesn't get wider or taller when rotated
  * about it's center.
  *
  * The standard, unoptimized technique gets the native bbox of the circle, rotates the box 45 degrees, uses
  * that width and height, and applies any transforms to get the final bbox. This means the calculated bbox
  * is much wider than the original circle. If the angle had been 0, 90, 180, etc. both techniques render the
  * same bbox.
  *
  * The optimization is not needed if the rotation is a multiple 90 degrees. The default technique is to call
  * getBBox then apply the angle and any transforms.
  *
  * @param {Float} angle - The rotation angle in degrees
  * @param {boolean} hasAMatrixTransform - True if there is a matrix transform
  * @returns {boolean} True if the bbox can be optimized.
  */

  function bBoxCanBeOptimizedOverNativeGetBBox(angle, hasAMatrixTransform) {
    var angleModulo90 = angle % 90;
    var closeTo90 = angleModulo90 < -89.99 || angleModulo90 > 89.99;
    var closeTo0 = angleModulo90 > -0.001 && angleModulo90 < 0.001;
    return hasAMatrixTransform || !(closeTo0 || closeTo90);
  }
  /**
  * Get bounding box that includes any transforms.
  * @function module:utilities.getBBoxWithTransform
  * @param {Element} elem - The DOM element to be converted
  * @param {module:utilities.EditorContext#addSVGElementFromJson} addSVGElementFromJson - Function to add the path element to the current layer. See canvas.addSVGElementFromJson
  * @param {module:path.pathActions} pathActions - If a transform exists, pathActions.resetOrientation() is used. See: canvas.pathActions.
  * @returns {module:utilities.BBoxObject|module:math.TransformedBox|DOMRect} A single bounding box object
  */


  var getBBoxWithTransform = function getBBoxWithTransform(elem, addSVGElementFromJson, pathActions) {
    // TODO: Fix issue with rotated groups. Currently they work
    // fine in FF, but not in other browsers (same problem mentioned
    // in Issue 339 comment #2).
    var bb = getBBox(elem);

    if (!bb) {
      return null;
    }

    var tlist = getTransformList(elem);
    var angle = getRotationAngleFromTransformList(tlist);
    var hasMatrixXForm = hasMatrixTransform(tlist);

    if (angle || hasMatrixXForm) {
      var goodBb = false;

      if (bBoxCanBeOptimizedOverNativeGetBBox(angle, hasMatrixXForm)) {
        // Get the BBox from the raw path for these elements
        // TODO: why ellipse and not circle
        var elemNames = ['ellipse', 'path', 'line', 'polyline', 'polygon'];

        if (elemNames.includes(elem.tagName)) {
          goodBb = getBBoxOfElementAsPath(elem, addSVGElementFromJson, pathActions);
          bb = goodBb;
        } else if (elem.tagName === 'rect') {
          // Look for radius
          var rx = elem.getAttribute('rx');
          var ry = elem.getAttribute('ry');

          if (rx || ry) {
            goodBb = getBBoxOfElementAsPath(elem, addSVGElementFromJson, pathActions);
            bb = goodBb;
          }
        }
      }

      if (!goodBb) {
        var _transformListToTrans = transformListToTransform(tlist),
            matrix = _transformListToTrans.matrix;

        bb = transformBox(bb.x, bb.y, bb.width, bb.height, matrix).aabox; // Old technique that was exceedingly slow with large documents.
        //
        // Accurate way to get BBox of rotated element in Firefox:
        // Put element in group and get its BBox
        //
        // Must use clone else FF freaks out
        // const clone = elem.cloneNode(true);
        // const g = document.createElementNS(NS.SVG, 'g');
        // const parent = elem.parentNode;
        // parent.append(g);
        // g.append(clone);
        // const bb2 = bboxToObj(g.getBBox());
        // g.remove();
      }
    }

    return bb;
  };
  /**
   * @param {Element} elem
   * @returns {Float}
   * @todo This is problematic with large stroke-width and, for example, a single
   * horizontal line. The calculated BBox extends way beyond left and right sides.
   */

  function getStrokeOffsetForBBox(elem) {
    var sw = elem.getAttribute('stroke-width');
    return !isNaN(sw) && elem.getAttribute('stroke') !== 'none' ? sw / 2 : 0;
  }
  /**
   * @typedef {PlainObject} BBox
   * @property {Integer} x The x value
   * @property {Integer} y The y value
   * @property {Float} width
   * @property {Float} height
   */

  /**
  * Get the bounding box for one or more stroked and/or transformed elements.
  * @function module:utilities.getStrokedBBox
  * @param {Element[]} elems - Array with DOM elements to check
  * @param {module:utilities.EditorContext#addSVGElementFromJson} addSVGElementFromJson - Function to add the path element to the current layer. See canvas.addSVGElementFromJson
  * @param {module:path.pathActions} pathActions - If a transform exists, pathActions.resetOrientation() is used. See: canvas.pathActions.
  * @returns {module:utilities.BBoxObject|module:math.TransformedBox|DOMRect} A single bounding box object
  */


  var getStrokedBBox = function getStrokedBBox(elems, addSVGElementFromJson, pathActions) {
    if (!elems || !elems.length) {
      return false;
    }

    var fullBb;
    $$1.each(elems, function () {
      if (fullBb) {
        return;
      }

      if (!this.parentNode) {
        return;
      }

      fullBb = getBBoxWithTransform(this, addSVGElementFromJson, pathActions);
    }); // This shouldn't ever happen...

    if (fullBb === undefined) {
      return null;
    } // fullBb doesn't include the stoke, so this does no good!
    // if (elems.length == 1) return fullBb;


    var maxX = fullBb.x + fullBb.width;
    var maxY = fullBb.y + fullBb.height;
    var minX = fullBb.x;
    var minY = fullBb.y; // If only one elem, don't call the potentially slow getBBoxWithTransform method again.

    if (elems.length === 1) {
      var offset = getStrokeOffsetForBBox(elems[0]);
      minX -= offset;
      minY -= offset;
      maxX += offset;
      maxY += offset;
    } else {
      $$1.each(elems, function (i, elem) {
        var curBb = getBBoxWithTransform(elem, addSVGElementFromJson, pathActions);

        if (curBb) {
          var _offset = getStrokeOffsetForBBox(elem);

          minX = Math.min(minX, curBb.x - _offset);
          minY = Math.min(minY, curBb.y - _offset); // TODO: The old code had this test for max, but not min. I suspect this test should be for both min and max

          if (elem.nodeType === 1) {
            maxX = Math.max(maxX, curBb.x + curBb.width + _offset);
            maxY = Math.max(maxY, curBb.y + curBb.height + _offset);
          }
        }
      });
    }

    fullBb.x = minX;
    fullBb.y = minY;
    fullBb.width = maxX - minX;
    fullBb.height = maxY - minY;
    return fullBb;
  };
  /**
  * Get all elements that have a BBox (excludes `<defs>`, `<title>`, etc).
  * Note that 0-opacity, off-screen etc elements are still considered "visible"
  * for this function.
  * @function module:utilities.getVisibleElements
  * @param {Element} parentElement - The parent DOM element to search within
  * @returns {Element[]} All "visible" elements.
  */

  var getVisibleElements = function getVisibleElements(parentElement) {
    if (!parentElement) {
      parentElement = $$1(editorContext_.getSVGContent()).children(); // Prevent layers from being included
    }

    var contentElems = [];
    $$1(parentElement).children().each(function (i, elem) {
      if (elem.getBBox) {
        contentElems.push(elem);
      }
    });
    return contentElems.reverse();
  };
  /**
  * Get the bounding box for one or more stroked and/or transformed elements.
  * @function module:utilities.getStrokedBBoxDefaultVisible
  * @param {Element[]} elems - Array with DOM elements to check
  * @returns {module:utilities.BBoxObject} A single bounding box object
  */

  var getStrokedBBoxDefaultVisible = function getStrokedBBoxDefaultVisible(elems) {
    if (!elems) {
      elems = getVisibleElements();
    }

    return getStrokedBBox(elems, editorContext_.addSVGElementFromJson, editorContext_.pathActions);
  };
  /**
  * Get the rotation angle of the given transform list.
  * @function module:utilities.getRotationAngleFromTransformList
  * @param {SVGTransformList} tlist - List of transforms
  * @param {boolean} toRad - When true returns the value in radians rather than degrees
  * @returns {Float} The angle in degrees or radians
  */

  var getRotationAngleFromTransformList = function getRotationAngleFromTransformList(tlist, toRad) {
    if (!tlist) {
      return 0;
    } // <svg> elements have no tlist


    var N = tlist.numberOfItems;

    for (var i = 0; i < N; ++i) {
      var xform = tlist.getItem(i);

      if (xform.type === 4) {
        return toRad ? xform.angle * Math.PI / 180.0 : xform.angle;
      }
    }

    return 0.0;
  };
  /**
  * Get the rotation angle of the given/selected DOM element.
  * @function module:utilities.getRotationAngle
  * @param {Element} [elem] - DOM element to get the angle for. Default to first of selected elements.
  * @param {boolean} [toRad=false] - When true returns the value in radians rather than degrees
  * @returns {Float} The angle in degrees or radians
  */

  var getRotationAngle = function getRotationAngle(elem, toRad) {
    // eslint-disable-line import/no-mutable-exports
    var selected = elem || editorContext_.getSelectedElements()[0]; // find the rotation transform (if any) and set it

    var tlist = getTransformList(selected);
    return getRotationAngleFromTransformList(tlist, toRad);
  };
  /**
  * Get the reference element associated with the given attribute value.
  * @function module:utilities.getRefElem
  * @param {string} attrVal - The attribute value as a string
  * @returns {Element} Reference element
  */

  var getRefElem = function getRefElem(attrVal) {
    return getElem(getUrlFromAttr(attrVal).substr(1));
  };
  /**
  * Get a DOM element by ID within the SVG root element.
  * @function module:utilities.getElem
  * @param {string} id - String with the element's new ID
  * @returns {?Element}
  */

  var getElem = supportsSelectors() ? function (id) {
    // querySelector lookup
    return svgroot_.querySelector('#' + id);
  } : supportsXpath() ? function (id) {
    // xpath lookup
    return domdoc_.evaluate('svg:svg[@id="svgroot"]//svg:*[@id="' + id + '"]', domcontainer_, function () {
      return NS.SVG;
    }, 9, null).singleNodeValue;
  } : function (id) {
    // jQuery lookup: twice as slow as xpath in FF
    return $$1(svgroot_).find("[id=".concat(id, "]"))[0];
  };
  /**
  * Assigns multiple attributes to an element.
  * @function module:utilities.assignAttributes
  * @param {Element} elem - DOM element to apply new attribute values to
  * @param {PlainObject<string, string>} attrs - Object with attribute keys/values
  * @param {Integer} [suspendLength] - Milliseconds to suspend redraw
  * @param {boolean} [unitCheck=false] - Boolean to indicate the need to use units.setUnitAttr
  * @returns {void}
  */

  var assignAttributes = function assignAttributes(elem, attrs, suspendLength, unitCheck) {
    for (var _i = 0, _Object$entries = Object.entries(attrs); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      var ns = key.substr(0, 4) === 'xml:' ? NS.XML : key.substr(0, 6) === 'xlink:' ? NS.XLINK : null;

      if (isNullish(value)) {
        if (ns) {
          elem.removeAttributeNS(ns, key);
        } else {
          elem.removeAttribute(key);
        }

        continue;
      }

      if (ns) {
        elem.setAttributeNS(ns, key, value);
      } else if (!unitCheck) {
        elem.setAttribute(key, value);
      } else {
        setUnitAttr(elem, key, value);
      }
    }
  };
  /**
  * Remove unneeded (default) attributes, making resulting SVG smaller.
  * @function module:utilities.cleanupElement
  * @param {Element} element - DOM element to clean up
  * @returns {void}
  */

  var cleanupElement = function cleanupElement(element) {
    var defaults = {
      'fill-opacity': 1,
      'stop-opacity': 1,
      opacity: 1,
      stroke: 'none',
      'stroke-dasharray': 'none',
      'stroke-linejoin': 'miter',
      'stroke-linecap': 'butt',
      'stroke-opacity': 1,
      'stroke-width': 1,
      rx: 0,
      ry: 0
    };

    if (element.nodeName === 'ellipse') {
      // Ellipse elements require rx and ry attributes
      delete defaults.rx;
      delete defaults.ry;
    }

    Object.entries(defaults).forEach(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          attr = _ref5[0],
          val = _ref5[1];

      if (element.getAttribute(attr) === String(val)) {
        element.removeAttribute(attr);
      }
    });
  };
  /**
  * Round value to for snapping.
  * @function module:utilities.snapToGrid
  * @param {Float} value
  * @returns {Integer}
  */

  var snapToGrid = function snapToGrid(value) {
    var unit = editorContext_.getBaseUnit();
    var stepSize = editorContext_.getSnappingStep();

    if (unit !== 'px') {
      stepSize *= getTypeMap()[unit];
    }

    value = Math.round(value / stepSize) * stepSize;
    return value;
  };
  /**
  * Escapes special characters in a regular expression.
  * @function module:utilities.regexEscape
  * @param {string} str
  * @returns {string}
  */

  var regexEscape = function regexEscape(str) {
    // Originally from: http://phpjs.org/functions
    return String(str).replace(/[.\\+*?[^\]$(){}=!<>|:-]/g, '\\$&');
  };
  /**
   * Prevents default browser click behaviour on the given element.
   * @function module:utilities.preventClickDefault
   * @param {Element} img - The DOM element to prevent the click on
   * @returns {void}
   */

  var preventClickDefault = function preventClickDefault(img) {
    $$1(img).click(function (e) {
      e.preventDefault();
    });
  };
  /**
   * @callback module:utilities.GetNextID
   * @returns {string} The ID
   */

  /**
   * Whether a value is `null` or `undefined`.
   * @param {any} val
   * @returns {boolean}
   */

  var isNullish = function isNullish(val) {
    return val === null || val === undefined;
  };
  var $q = function $q(sel) {
    return document.querySelector(sel);
  };

  /* globals jQuery */

  /**
   * Adds context menu functionality.
   * @module contextmenu
   * @license Apache-2.0
   * @author Adam Bender
   */
  // Dependencies:
  // 1) jQuery (for dom injection of context menus)
  var $$2 = jQuery;
  var contextMenuExtensions = {};
  /**
  * @function module:contextmenu.hasCustomHandler
  * @param {string} handlerKey
  * @returns {boolean}
  */

  var hasCustomHandler = function hasCustomHandler(handlerKey) {
    return Boolean(contextMenuExtensions[handlerKey]);
  };
  /**
  * @function module:contextmenu.getCustomHandler
  * @param {string} handlerKey
  * @returns {module:contextmenu.MenuItemAction}
  */

  var getCustomHandler = function getCustomHandler(handlerKey) {
    return contextMenuExtensions[handlerKey].action;
  };
  /**
  * @param {module:contextmenu.MenuItem} menuItem
  * @returns {void}
  */

  var injectExtendedContextMenuItemIntoDom = function injectExtendedContextMenuItemIntoDom(menuItem) {
    if (!Object.keys(contextMenuExtensions).length) {
      // all menuItems appear at the bottom of the menu in their own container.
      // if this is the first extension menu we need to add the separator.
      $$2('#cmenu_canvas').append("<li class='separator'>");
    }

    var shortcut = menuItem.shortcut || '';
    $$2('#cmenu_canvas').append("<li class='disabled'><a href='#" + menuItem.id + "'>" + menuItem.label + "<span class='shortcut'>" + shortcut + '</span></a></li>');
  };
  /**
  * @function module:contextmenu.injectExtendedContextMenuItemsIntoDom
  * @returns {void}
  */


  var injectExtendedContextMenuItemsIntoDom = function injectExtendedContextMenuItemsIntoDom() {
    Object.values(contextMenuExtensions).forEach(function (menuItem) {
      injectExtendedContextMenuItemIntoDom(menuItem);
    });
  };

  /**
   * Created by alexey2baranov on 28.01.17.
   */

  /*
   An extraction of the deparam method from Ben Alman's jQuery BBQ
   http://benalman.com/projects/jquery-bbq-plugin/
   */
  var coerce_types = {
    'true': !0,
    'false': !1,
    'null': null
  };

  function deparam(params, coerce) {
    // console.log(params)
    var obj = {}; // Iterate over all name=value pairs.

    params.replace(/\+/g, ' ').split('&').forEach(function (v) {
      var param = v.split('=');
      var key = decodeURIComponent(param[0]),
          // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
      // into its component parts.
      keys = key.split(']['),
          keys_last = keys.length - 1; // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.

      if (/\[/.test(keys[0]) && /\]$/.test(keys[keys_last])) {
        // Remove the trailing ] from the last keys part.
        keys[keys_last] = keys[keys_last].replace(/\]$/, ''); // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.

        keys = keys.shift().split('[').concat(keys);
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      } // Are we dealing with a name=value pair, or just a name?


      if (param.length >= 2) {
        var val = decodeURIComponent(param.slice(1).join('=')); // Coerce values.

        if (coerce) {
          val = val && !isNaN(val) ? +val // number
          : val === 'undefined' ? undefined // undefined
          : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
          : val; // string
        }

        if (keys_last) {
          var cur = obj; // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.

          for (var i = 0; i <= keys_last; i++) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : []) : val;
          }
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          if (Array.isArray(obj[key])) {
            // val is already an array, so push on the next value.
            obj[key].push(val);
          } else if (obj[key] !== undefined) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [obj[key], val];
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
      } else if (key) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce ? undefined : '';
      }
    });
    return obj;
  }

  /**
   * @module jQueryPluginDBox
   */

  /**
  * @param {external:jQuery} $
  * @param {PlainObject} [strings]
  * @param {PlainObject} [strings.ok]
  * @param {PlainObject} [strings.cancel]
  * @returns {external:jQuery}
  */
  function jQueryPluginDBox($) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$ok = _ref.ok,
        okString = _ref$ok === void 0 ? 'Ok' : _ref$ok,
        _ref$cancel = _ref.cancel,
        cancelString = _ref$cancel === void 0 ? 'Cancel' : _ref$cancel;

    // This sets up alternative dialog boxes. They mostly work the same way as
    // their UI counterparts, expect instead of returning the result, a callback
    // needs to be included that returns the result as its first parameter.
    // In the future we may want to add additional types of dialog boxes, since
    // they should be easy to handle this way.
    $('#dialog_container').draggable({
      cancel: '#dialog_content, #dialog_buttons *',
      containment: 'window'
    }).css('position', 'absolute');
    var box = $('#dialog_box'),
        btnHolder = $('#dialog_buttons'),
        dialogContent = $('#dialog_content');
    /**
    * @typedef {PlainObject} module:jQueryPluginDBox.PromiseResultObject
    * @property {string|true} response
    * @property {boolean} checked
    */

    /**
    * Resolves to `false` (if cancelled), for prompts and selects
    * without checkboxes, it resolves to the value of the form control. For other
    * types without checkboxes, it resolves to `true`. For checkboxes, it resolves
    * to an object with the `response` key containing the same value as the previous
    * mentioned (string or `true`) and a `checked` (boolean) property.
    * @typedef {Promise<boolean|string|module:jQueryPluginDBox.PromiseResultObject>} module:jQueryPluginDBox.ResultPromise
    */

    /**
    * @typedef {PlainObject} module:jQueryPluginDBox.SelectOption
    * @property {string} text
    * @property {string} value
    */

    /**
    * @typedef {PlainObject} module:jQueryPluginDBox.CheckboxInfo
    * @property {string} label Label for the checkbox
    * @property {string} value Value of the checkbox
    * @property {string} tooltip Tooltip on the checkbox label
    * @property {boolean} checked Whether the checkbox is checked by default
    */

    /**
     * Triggered upon a change of value for the select pull-down.
     * @callback module:jQueryPluginDBox.SelectChangeListener
     * @returns {void}
     */

    /**
     * Creates a dialog of the specified type with a given message
     *  and any defaults and type-specific metadata. Returns a `Promise`
     *  which resolves differently depending on whether the dialog
     *  was cancelled or okayed (with the response and any checked state).
     * @param {"alert"|"prompt"|"select"|"process"} type
     * @param {string} msg
     * @param {string} [defaultVal]
     * @param {module:jQueryPluginDBox.SelectOption[]} [opts]
     * @param {module:jQueryPluginDBox.SelectChangeListener} [changeListener]
     * @param {module:jQueryPluginDBox.CheckboxInfo} [checkbox]
     * @returns {jQueryPluginDBox.ResultPromise}
    */

    function dbox(type, msg, defaultVal, opts, changeListener, checkbox) {
      dialogContent.html('<p>' + msg.replace(/\n/g, '</p><p>') + '</p>').toggleClass('prompt', type === 'prompt');
      btnHolder.empty();
      var ok = $('<input type="button" data-ok="" value="' + okString + '">').appendTo(btnHolder);
      return new Promise(function (resolve, reject) {
        // eslint-disable-line promise/avoid-new
        if (type !== 'alert') {
          $('<input type="button" value="' + cancelString + '">').appendTo(btnHolder).click(function () {
            box.hide();
            resolve(false);
          });
        }

        var ctrl, chkbx;

        if (type === 'prompt') {
          ctrl = $('<input type="text">').prependTo(btnHolder);
          ctrl.val(defaultVal || '');
          ctrl.bind('keydown', 'return', function () {
            ok.click();
          });
        } else if (type === 'select') {
          var div = $('<div style="text-align:center;">');
          ctrl = $("<select aria-label=\"".concat(msg, "\">")).appendTo(div);

          if (checkbox) {
            var label = $('<label>').text(checkbox.label);
            chkbx = $('<input type="checkbox">').appendTo(label);
            chkbx.val(checkbox.value);

            if (checkbox.tooltip) {
              label.attr('title', checkbox.tooltip);
            }

            chkbx.prop('checked', Boolean(checkbox.checked));
            div.append($('<div>').append(label));
          }

          $.each(opts || [], function (opt, val) {
            if (_typeof(val) === 'object') {
              ctrl.append($('<option>').val(val.value).html(val.text));
            } else {
              ctrl.append($('<option>').html(val));
            }
          });
          dialogContent.append(div);

          if (defaultVal) {
            ctrl.val(defaultVal);
          }

          if (changeListener) {
            ctrl.bind('change', 'return', changeListener);
          }

          ctrl.bind('keydown', 'return', function () {
            ok.click();
          });
        } else if (type === 'process') {
          ok.hide();
        }

        box.show();
        ok.click(function () {
          box.hide();
          var response = type === 'prompt' || type === 'select' ? ctrl.val() : true;

          if (chkbx) {
            resolve({
              response: response,
              checked: chkbx.prop('checked')
            });
            return;
          }

          resolve(response);
        }).focus();

        if (type === 'prompt' || type === 'select') {
          ctrl.focus();
        }
      });
    }
    /**
    * @param {string} msg Message to alert
    * @returns {jQueryPluginDBox.ResultPromise}
    */


    $.alert = function (msg) {
      return dbox('alert', msg);
    };
    /**
    * @param {string} msg Message for which to ask confirmation
    * @returns {jQueryPluginDBox.ResultPromise}
    */


    $.confirm = function (msg) {
      return dbox('confirm', msg);
    };
    /**
    * @param {string} msg Message to indicate upon cancelable indicator
    * @returns {jQueryPluginDBox.ResultPromise}
    */


    $.process_cancel = function (msg) {
      return dbox('process', msg);
    };
    /**
    * @param {string} msg Message to accompany the prompt
    * @param {string} [defaultText=''] The default text to show for the prompt
    * @returns {jQueryPluginDBox.ResultPromise}
    */


    $.prompt = function (msg) {
      var defaultText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return dbox('prompt', msg, defaultText);
    };

    $.select = function (msg, opts, changeListener, txt, checkbox) {
      return dbox('select', msg, txt, opts, changeListener, checkbox);
    };

    return $;
  }

  /**
  * Group: Undo/Redo history management.
  */

  var HistoryEventTypes = {
    BEFORE_APPLY: 'before_apply',
    AFTER_APPLY: 'after_apply',
    BEFORE_UNAPPLY: 'before_unapply',
    AFTER_UNAPPLY: 'after_unapply'
  };
  /**
  * Base class for commands.
  */

  var Command = /*#__PURE__*/function () {
    function Command() {
      _classCallCheck(this, Command);
    }

    _createClass(Command, [{
      key: "getText",

      /**
      * @returns {string}
      */
      value: function getText() {
        return this.text;
      }
      /**
       * @param {module:history.HistoryEventHandler} handler
       * @param {callback} applyFunction
       * @returns {void}
      */

    }, {
      key: "apply",
      value: function apply(handler, applyFunction) {
        handler && handler.handleHistoryEvent(HistoryEventTypes.BEFORE_APPLY, this);
        applyFunction(handler);
        handler && handler.handleHistoryEvent(HistoryEventTypes.AFTER_APPLY, this);
      }
      /**
       * @param {module:history.HistoryEventHandler} handler
       * @param {callback} unapplyFunction
       * @returns {void}
      */

    }, {
      key: "unapply",
      value: function unapply(handler, unapplyFunction) {
        handler && handler.handleHistoryEvent(HistoryEventTypes.BEFORE_UNAPPLY, this);
        unapplyFunction();
        handler && handler.handleHistoryEvent(HistoryEventTypes.AFTER_UNAPPLY, this);
      }
      /**
       * @returns {Element[]} Array with element associated with this command
       * This function needs to be surcharged if multiple elements are returned.
      */

    }, {
      key: "elements",
      value: function elements() {
        return [this.elem];
      }
      /**
        * @returns {string} String with element associated with this command
      */

    }, {
      key: "type",
      value: function type() {
        return this.constructor.name;
      }
    }]);

    return Command;
  }(); // Todo: Figure out why the interface members aren't showing
  //   up (with or without modules applied), despite our apparently following
  //   http://usejsdoc.org/tags-interface.html#virtual-comments

  /**
   * An interface that all command objects must implement.
   * @interface module:history.HistoryCommand
  */

  /**
   * Applies.
   *
   * @function module:history.HistoryCommand#apply
   * @param {module:history.HistoryEventHandler} handler
   * @fires module:history~Command#event:history
   * @returns {void|true}
   */

  /**
   *
   * Unapplies.
   * @function module:history.HistoryCommand#unapply
   * @param {module:history.HistoryEventHandler} handler
   * @fires module:history~Command#event:history
   * @returns {void|true}
   */

  /**
   * Returns the elements.
   * @function module:history.HistoryCommand#elements
   * @returns {Element[]}
   */

  /**
   * Gets the text.
   * @function module:history.HistoryCommand#getText
   * @returns {string}
   */

  /**
   * Gives the type.
   * @function module:history.HistoryCommand.type
   * @returns {string}
   */

  /**
   * @event module:history~Command#event:history
   * @type {module:history.HistoryCommand}
   */

  /**
   * An interface for objects that will handle history events.
   * @interface module:history.HistoryEventHandler
   */

  /**
   *
   * @function module:history.HistoryEventHandler#handleHistoryEvent
   * @param {string} eventType One of the HistoryEvent types
   * @param {module:history~Command#event:history} command
   * @listens module:history~Command#event:history
   * @returns {void}
   *
   */

  /**
   * History command for an element that had its DOM position changed.
   * @implements {module:history.HistoryCommand}
  */

  var MoveElementCommand = /*#__PURE__*/function (_Command) {
    _inherits(MoveElementCommand, _Command);

    var _super = _createSuper(MoveElementCommand);

    /**
    * @param {Element} elem - The DOM element that was moved
    * @param {Element} oldNextSibling - The element's next sibling before it was moved
    * @param {Element} oldParent - The element's parent before it was moved
    * @param {string} [text] - An optional string visible to user related to this change
    */
    function MoveElementCommand(elem, oldNextSibling, oldParent, text) {
      var _this;

      _classCallCheck(this, MoveElementCommand);

      _this = _super.call(this);
      _this.elem = elem;
      _this.text = text ? 'Move ' + elem.tagName + ' to ' + text : 'Move ' + elem.tagName;
      _this.oldNextSibling = oldNextSibling;
      _this.oldParent = oldParent;
      _this.newNextSibling = elem.nextSibling;
      _this.newParent = elem.parentNode;
      return _this;
    }
    /**
     * Re-positions the element.
     * @param {module:history.HistoryEventHandler} handler
     * @fires module:history~Command#event:history
     * @returns {void}
    */


    _createClass(MoveElementCommand, [{
      key: "apply",
      value: function apply(handler) {
        var _this2 = this;

        _get(_getPrototypeOf(MoveElementCommand.prototype), "apply", this).call(this, handler, function () {
          _this2.elem = _this2.newParent.insertBefore(_this2.elem, _this2.newNextSibling);
        });
      }
      /**
       * Positions the element back to its original location.
       * @param {module:history.HistoryEventHandler} handler
       * @fires module:history~Command#event:history
       * @returns {void}
      */

    }, {
      key: "unapply",
      value: function unapply(handler) {
        var _this3 = this;

        _get(_getPrototypeOf(MoveElementCommand.prototype), "unapply", this).call(this, handler, function () {
          _this3.elem = _this3.oldParent.insertBefore(_this3.elem, _this3.oldNextSibling);
        });
      }
    }]);

    return MoveElementCommand;
  }(Command);
  /**
  * History command for an element that was added to the DOM.
  * @implements {module:history.HistoryCommand}
  */

  var InsertElementCommand = /*#__PURE__*/function (_Command2) {
    _inherits(InsertElementCommand, _Command2);

    var _super2 = _createSuper(InsertElementCommand);

    /**
     * @param {Element} elem - The newly added DOM element
     * @param {string} text - An optional string visible to user related to this change
    */
    function InsertElementCommand(elem, text) {
      var _this4;

      _classCallCheck(this, InsertElementCommand);

      _this4 = _super2.call(this);
      _this4.elem = elem;
      _this4.text = text || 'Create ' + elem.tagName;
      _this4.parent = elem.parentNode;
      _this4.nextSibling = _this4.elem.nextSibling;
      return _this4;
    }
    /**
    * Re-inserts the new element.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */


    _createClass(InsertElementCommand, [{
      key: "apply",
      value: function apply(handler) {
        var _this5 = this;

        _get(_getPrototypeOf(InsertElementCommand.prototype), "apply", this).call(this, handler, function () {
          _this5.elem = _this5.parent.insertBefore(_this5.elem, _this5.nextSibling);
        });
      }
      /**
      * Removes the element.
      * @param {module:history.HistoryEventHandler} handler
      * @fires module:history~Command#event:history
      * @returns {void}
      */

    }, {
      key: "unapply",
      value: function unapply(handler) {
        var _this6 = this;

        _get(_getPrototypeOf(InsertElementCommand.prototype), "unapply", this).call(this, handler, function () {
          _this6.parent = _this6.elem.parentNode;

          _this6.elem.remove();
        });
      }
    }]);

    return InsertElementCommand;
  }(Command);
  /**
  * History command for an element removed from the DOM.
  * @implements {module:history.HistoryCommand}
  */

  var RemoveElementCommand = /*#__PURE__*/function (_Command3) {
    _inherits(RemoveElementCommand, _Command3);

    var _super3 = _createSuper(RemoveElementCommand);

    /**
    * @param {Element} elem - The removed DOM element
    * @param {Node} oldNextSibling - The DOM element's nextSibling when it was in the DOM
    * @param {Element} oldParent - The DOM element's parent
    * @param {string} [text] - An optional string visible to user related to this change
    */
    function RemoveElementCommand(elem, oldNextSibling, oldParent, text) {
      var _this7;

      _classCallCheck(this, RemoveElementCommand);

      _this7 = _super3.call(this);
      _this7.elem = elem;
      _this7.text = text || 'Delete ' + elem.tagName;
      _this7.nextSibling = oldNextSibling;
      _this7.parent = oldParent; // special hack for webkit: remove this element's entry in the svgTransformLists map

      removeElementFromListMap(elem);
      return _this7;
    }
    /**
    * Re-removes the new element.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */


    _createClass(RemoveElementCommand, [{
      key: "apply",
      value: function apply(handler) {
        var _this8 = this;

        _get(_getPrototypeOf(RemoveElementCommand.prototype), "apply", this).call(this, handler, function () {
          removeElementFromListMap(_this8.elem);
          _this8.parent = _this8.elem.parentNode;

          _this8.elem.remove();
        });
      }
      /**
      * Re-adds the new element.
      * @param {module:history.HistoryEventHandler} handler
      * @fires module:history~Command#event:history
      * @returns {void}
      */

    }, {
      key: "unapply",
      value: function unapply(handler) {
        var _this9 = this;

        _get(_getPrototypeOf(RemoveElementCommand.prototype), "unapply", this).call(this, handler, function () {
          removeElementFromListMap(_this9.elem);

          if (isNullish(_this9.nextSibling)) {
            if (window.console) {
              console.error('Reference element was lost');
            }
          }

          _this9.parent.insertBefore(_this9.elem, _this9.nextSibling); // Don't use `before` or `prepend` as `this.nextSibling` may be `null`

        });
      }
    }]);

    return RemoveElementCommand;
  }(Command);
  /**
  * @typedef {"#text"|"#href"|string} module:history.CommandAttributeName
  */

  /**
  * @typedef {PlainObject<module:history.CommandAttributeName, string>} module:history.CommandAttributes
  */

  /**
  * History command to make a change to an element.
  * Usually an attribute change, but can also be textcontent.
  * @implements {module:history.HistoryCommand}
  */

  var ChangeElementCommand = /*#__PURE__*/function (_Command4) {
    _inherits(ChangeElementCommand, _Command4);

    var _super4 = _createSuper(ChangeElementCommand);

    /**
    * @param {Element} elem - The DOM element that was changed
    * @param {module:history.CommandAttributes} attrs - Attributes to be changed with the values they had *before* the change
    * @param {string} text - An optional string visible to user related to this change
     */
    function ChangeElementCommand(elem, attrs, text) {
      var _this10;

      _classCallCheck(this, ChangeElementCommand);

      _this10 = _super4.call(this);
      _this10.elem = elem;
      _this10.text = text ? 'Change ' + elem.tagName + ' ' + text : 'Change ' + elem.tagName;
      _this10.newValues = {};
      _this10.oldValues = attrs;

      for (var attr in attrs) {
        if (attr === '#text') {
          _this10.newValues[attr] = elem.textContent;
        } else if (attr === '#href') {
          _this10.newValues[attr] = getHref(elem);
        } else {
          _this10.newValues[attr] = elem.getAttribute(attr);
        }
      }

      return _this10;
    }
    /**
    * Performs the stored change action.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */


    _createClass(ChangeElementCommand, [{
      key: "apply",
      value: function apply(handler) {
        var _this11 = this;

        _get(_getPrototypeOf(ChangeElementCommand.prototype), "apply", this).call(this, handler, function () {
          var bChangedTransform = false;
          Object.entries(_this11.newValues).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                attr = _ref2[0],
                value = _ref2[1];

            if (value) {
              if (attr === '#text') {
                _this11.elem.textContent = value;
              } else if (attr === '#href') {
                setHref(_this11.elem, value);
              } else {
                _this11.elem.setAttribute(attr, value);
              }
            } else if (attr === '#text') {
              _this11.elem.textContent = '';
            } else {
              _this11.elem.setAttribute(attr, '');

              _this11.elem.removeAttribute(attr);
            }

            if (attr === 'transform') {
              bChangedTransform = true;
            }
          }); // relocate rotational transform, if necessary

          if (!bChangedTransform) {
            var angle = getRotationAngle(_this11.elem);

            if (angle) {
              var bbox = _this11.elem.getBBox();

              var cx = bbox.x + bbox.width / 2;
              var cy = bbox.y + bbox.height / 2;
              var rotate = ['rotate(', angle, ' ', cx, ',', cy, ')'].join('');

              if (rotate !== _this11.elem.getAttribute('transform')) {
                _this11.elem.setAttribute('transform', rotate);
              }
            }
          }
        });
      }
      /**
      * Reverses the stored change action.
      * @param {module:history.HistoryEventHandler} handler
      * @fires module:history~Command#event:history
      * @returns {void}
      */

    }, {
      key: "unapply",
      value: function unapply(handler) {
        var _this12 = this;

        _get(_getPrototypeOf(ChangeElementCommand.prototype), "unapply", this).call(this, handler, function () {
          var bChangedTransform = false;
          Object.entries(_this12.oldValues).forEach(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                attr = _ref4[0],
                value = _ref4[1];

            if (value) {
              if (attr === '#text') {
                _this12.elem.textContent = value;
              } else if (attr === '#href') {
                setHref(_this12.elem, value);
              } else {
                _this12.elem.setAttribute(attr, value);
              }
            } else if (attr === '#text') {
              _this12.elem.textContent = '';
            } else {
              _this12.elem.removeAttribute(attr);
            }

            if (attr === 'transform') {
              bChangedTransform = true;
            }
          }); // relocate rotational transform, if necessary

          if (!bChangedTransform) {
            var angle = getRotationAngle(_this12.elem);

            if (angle) {
              var bbox = _this12.elem.getBBox();

              var cx = bbox.x + bbox.width / 2,
                  cy = bbox.y + bbox.height / 2;
              var rotate = ['rotate(', angle, ' ', cx, ',', cy, ')'].join('');

              if (rotate !== _this12.elem.getAttribute('transform')) {
                _this12.elem.setAttribute('transform', rotate);
              }
            }
          } // Remove transformlist to prevent confusion that causes bugs like 575.


          removeElementFromListMap(_this12.elem);
        });
      }
    }]);

    return ChangeElementCommand;
  }(Command); // TODO: create a 'typing' command object that tracks changes in text
  // if a new Typing command is created and the top command on the stack is also a Typing
  // and they both affect the same element, then collapse the two commands into one

  /**
  * History command that can contain/execute multiple other commands.
  * @implements {module:history.HistoryCommand}
  */

  var BatchCommand = /*#__PURE__*/function (_Command5) {
    _inherits(BatchCommand, _Command5);

    var _super5 = _createSuper(BatchCommand);

    /**
    * @param {string} [text] - An optional string visible to user related to this change
    */
    function BatchCommand(text) {
      var _this13;

      _classCallCheck(this, BatchCommand);

      _this13 = _super5.call(this);
      _this13.text = text || 'Batch Command';
      _this13.stack = [];
      return _this13;
    }
    /**
    * Runs "apply" on all subcommands.
    * @param {module:history.HistoryEventHandler} handler
    * @fires module:history~Command#event:history
    * @returns {void}
    */


    _createClass(BatchCommand, [{
      key: "apply",
      value: function apply(handler) {
        var _this14 = this;

        _get(_getPrototypeOf(BatchCommand.prototype), "apply", this).call(this, handler, function () {
          _this14.stack.forEach(function (stackItem) {
            console.assert(stackItem, 'stack item should not be null');
            stackItem && stackItem.apply(handler);
          });
        });
      }
      /**
      * Runs "unapply" on all subcommands.
      * @param {module:history.HistoryEventHandler} handler
      * @fires module:history~Command#event:history
      * @returns {void}
      */

    }, {
      key: "unapply",
      value: function unapply(handler) {
        var _this15 = this;

        _get(_getPrototypeOf(BatchCommand.prototype), "unapply", this).call(this, handler, function () {
          _this15.stack.reverse().forEach(function (stackItem) {
            console.assert(stackItem, 'stack item should not be null');
            stackItem && stackItem.unapply(handler);
          });
        });
      }
      /**
      * Iterate through all our subcommands.
      * @returns {Element[]} All the elements we are changing
      */

    }, {
      key: "elements",
      value: function elements() {
        var elems = [];
        var cmd = this.stack.length;

        while (cmd--) {
          if (!this.stack[cmd]) continue;
          var thisElems = this.stack[cmd].elements();
          var elem = thisElems.length;

          while (elem--) {
            if (!elems.includes(thisElems[elem])) {
              elems.push(thisElems[elem]);
            }
          }
        }

        return elems;
      }
      /**
      * Adds a given command to the history stack.
      * @param {Command} cmd - The undo command object to add
      * @returns {void}
      */

    }, {
      key: "addSubCommand",
      value: function addSubCommand(cmd) {
        console.assert(cmd !== null, 'cmd should not be null');
        this.stack.push(cmd);
      }
      /**
      * @returns {boolean} Indicates whether or not the batch command is empty
      */

    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return !this.stack.length;
      }
    }]);

    return BatchCommand;
  }(Command);
  /**
  *
  */

  var UndoManager = /*#__PURE__*/function () {
    /**
    * @param {module:history.HistoryEventHandler} historyEventHandler
    */
    function UndoManager(historyEventHandler) {
      _classCallCheck(this, UndoManager);

      this.handler_ = historyEventHandler || null;
      this.undoStackPointer = 0;
      this.undoStack = []; // this is the stack that stores the original values, the elements and
      // the attribute name for begin/finish

      this.undoChangeStackPointer = -1;
      this.undoableChangeStack = [];
    }
    /**
    * Resets the undo stack, effectively clearing the undo/redo history.
    * @returns {void}
    */


    _createClass(UndoManager, [{
      key: "resetUndoStack",
      value: function resetUndoStack() {
        this.undoStack = [];
        this.undoStackPointer = 0;
      }
      /**
      * @returns {Integer} Current size of the undo history stack
      */

    }, {
      key: "getUndoStackSize",
      value: function getUndoStackSize() {
        return this.undoStackPointer;
      }
      /**
      * @returns {Integer} Current size of the redo history stack
      */

    }, {
      key: "getRedoStackSize",
      value: function getRedoStackSize() {
        return this.undoStack.length - this.undoStackPointer;
      }
      /**
      * @returns {string} String associated with the next undo command
      */

    }, {
      key: "getNextUndoCommandText",
      value: function getNextUndoCommandText() {
        return this.undoStackPointer > 0 ? this.undoStack[this.undoStackPointer - 1].getText() : '';
      }
      /**
      * @returns {string} String associated with the next redo command
      */

    }, {
      key: "getNextRedoCommandText",
      value: function getNextRedoCommandText() {
        return this.undoStackPointer < this.undoStack.length ? this.undoStack[this.undoStackPointer].getText() : '';
      }
      /**
      * Performs an undo step.
      * @returns {void}
      */

    }, {
      key: "undo",
      value: function undo() {
        if (this.undoStackPointer > 0) {
          var cmd = this.undoStack[--this.undoStackPointer];
          cmd.unapply(this.handler_);
        }
      }
      /**
      * Performs a redo step.
      * @returns {void}
      */

    }, {
      key: "redo",
      value: function redo() {
        if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0) {
          var cmd = this.undoStack[this.undoStackPointer++];
          cmd.apply(this.handler_);
        }
      }
      /**
      * Adds a command object to the undo history stack.
      * @param {Command} cmd - The command object to add
      * @returns {void}
      */

    }, {
      key: "addCommandToHistory",
      value: function addCommandToHistory(cmd) {
        // TODO: we MUST compress consecutive text changes to the same element
        // (right now each keystroke is saved as a separate command that includes the
        // entire text contents of the text element)
        // TODO: consider limiting the history that we store here (need to do some slicing)
        // if our stack pointer is not at the end, then we have to remove
        // all commands after the pointer and insert the new command
        if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0) {
          this.undoStack = this.undoStack.splice(0, this.undoStackPointer);
        }

        this.undoStack.push(cmd);
        this.undoStackPointer = this.undoStack.length;
      }
      /**
      * This function tells the canvas to remember the old values of the
      * `attrName` attribute for each element sent in.  The elements and values
      * are stored on a stack, so the next call to `finishUndoableChange()` will
      * pop the elements and old values off the stack, gets the current values
      * from the DOM and uses all of these to construct the undo-able command.
      * @param {string} attrName - The name of the attribute being changed
      * @param {Element[]} elems - Array of DOM elements being changed
      * @returns {void}
      */

    }, {
      key: "beginUndoableChange",
      value: function beginUndoableChange(attrName, elems) {
        var p = ++this.undoChangeStackPointer;
        var i = elems.length;
        var oldValues = new Array(i),
            elements = new Array(i);

        while (i--) {
          var elem = elems[i];

          if (isNullish(elem)) {
            continue;
          }

          elements[i] = elem;
          oldValues[i] = elem.getAttribute(attrName);
        }

        this.undoableChangeStack[p] = {
          attrName: attrName,
          oldValues: oldValues,
          elements: elements
        };
      }
      /**
      * This function returns a `BatchCommand` object which summarizes the
      * change since `beginUndoableChange` was called.  The command can then
      * be added to the command history.
      * @returns {BatchCommand} Batch command object with resulting changes
      */

    }, {
      key: "finishUndoableChange",
      value: function finishUndoableChange() {
        var p = this.undoChangeStackPointer--;
        var changeset = this.undoableChangeStack[p];
        var attrName = changeset.attrName;
        var batchCmd = new BatchCommand('Change ' + attrName);
        var i = changeset.elements.length;

        while (i--) {
          var elem = changeset.elements[i];

          if (isNullish(elem)) {
            continue;
          }

          var changes = {};
          changes[attrName] = changeset.oldValues[i];

          if (changes[attrName] !== elem.getAttribute(attrName)) {
            batchCmd.addSubCommand(new ChangeElementCommand(elem, changes, attrName));
          }
        }

        this.undoableChangeStack[p] = null;
        return batchCmd;
      }
    }]);

    return UndoManager;
  }();

  var hstry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    HistoryEventTypes: HistoryEventTypes,
    Command: Command,
    MoveElementCommand: MoveElementCommand,
    InsertElementCommand: InsertElementCommand,
    RemoveElementCommand: RemoveElementCommand,
    ChangeElementCommand: ChangeElementCommand,
    BatchCommand: BatchCommand,
    UndoManager: UndoManager
  });

  var $$3 = jQuery;
  var segData = {
    2: ['x', 'y'],
    // PATHSEG_MOVETO_ABS
    4: ['x', 'y'],
    // PATHSEG_LINETO_ABS
    6: ['x', 'y', 'x1', 'y1', 'x2', 'y2'],
    // PATHSEG_CURVETO_CUBIC_ABS
    8: ['x', 'y', 'x1', 'y1'],
    // PATHSEG_CURVETO_QUADRATIC_ABS
    10: ['x', 'y', 'r1', 'r2', 'angle', 'largeArcFlag', 'sweepFlag'],
    // PATHSEG_ARC_ABS
    12: ['x'],
    // PATHSEG_LINETO_HORIZONTAL_ABS
    14: ['y'],
    // PATHSEG_LINETO_VERTICAL_ABS
    16: ['x', 'y', 'x2', 'y2'],
    // PATHSEG_CURVETO_CUBIC_SMOOTH_ABS
    18: ['x', 'y'] // PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS

  };
  /**
   * @tutorial LocaleDocs
   * @typedef {module:locale.LocaleStrings|PlainObject} module:path.uiStrings
   * @property {PlainObject<string, string>} ui
  */

  var uiStrings = {};
  /**
  * @function module:path.setUiStrings
  * @param {module:path.uiStrings} strs
  * @returns {void}
  */

  var setUiStrings = function setUiStrings(strs) {
    Object.assign(uiStrings, strs.ui);
  };
  var pathFuncs = [];
  var linkControlPts = true; // Stores references to paths via IDs.
  // TODO: Make this cross-document happy.

  var pathData = {};
  /**
  * @function module:path.setLinkControlPoints
  * @param {boolean} lcp
  * @returns {void}
  */

  var setLinkControlPoints = function setLinkControlPoints(lcp) {
    linkControlPts = lcp;
  };
  /**
   * @name module:path.path
   * @type {null|module:path.Path}
   * @memberof module:path
  */

  var path$1 = null; // eslint-disable-line import/no-mutable-exports

  var editorContext_$1 = null;
  /**
  * @external MouseEvent
  */

  /**
  * Object with the following keys/values.
  * @typedef {PlainObject} module:path.SVGElementJSON
  * @property {string} element - Tag name of the SVG element to create
  * @property {PlainObject<string, string>} attr - Has key-value attributes to assign to the new element. An `id` should be set so that {@link module:utilities.EditorContext#addSVGElementFromJson} can later re-identify the element for modification or replacement.
  * @property {boolean} [curStyles=false] - Indicates whether current style attributes should be applied first
  * @property {module:path.SVGElementJSON[]} [children] - Data objects to be added recursively as children
  * @property {string} [namespace="http://www.w3.org/2000/svg"] - Indicate a (non-SVG) namespace
  */

  /**
   * @interface module:path.EditorContext
   * @property {module:select.SelectorManager} selectorManager
   * @property {module:svgcanvas.SvgCanvas} canvas
   */

  /**
   * @function module:path.EditorContext#call
   * @param {"selected"|"changed"} ev - String with the event name
   * @param {module:svgcanvas.SvgCanvas#event:selected|module:svgcanvas.SvgCanvas#event:changed} arg - Argument to pass through to the callback function. If the event is "changed", an array of `Element`s is passed; if "selected", a single-item array of `Element` is passed.
   * @returns {void}
   */

  /**
   * @function module:path.EditorContext#resetD
   * @param {SVGPathElement} p
   * @returns {void}
  */

  /**
   * Note: This doesn't round to an integer necessarily.
   * @function module:path.EditorContext#round
   * @param {Float} val
   * @returns {Float} Rounded value to nearest value based on `currentZoom`
   */

  /**
   * @function module:path.EditorContext#clearSelection
   * @param {boolean} [noCall] - When `true`, does not call the "selected" handler
   * @returns {void}
  */

  /**
   * @function module:path.EditorContext#addToSelection
   * @param {Element[]} elemsToAdd - An array of DOM elements to add to the selection
   * @param {boolean} showGrips - Indicates whether the resize grips should be shown
   * @returns {void}
  */

  /**
   * @function module:path.EditorContext#addCommandToHistory
   * @param {Command} cmd
   * @returns {void}
   */

  /**
   * @function module:path.EditorContext#remapElement
   * @param {Element} selected - DOM element to be changed
   * @param {PlainObject<string, string>} changes - Object with changes to be remapped
   * @param {SVGMatrix} m - Matrix object to use for remapping coordinates
   * @returns {void}
   */

  /**
   * @function module:path.EditorContext#addSVGElementFromJson
   * @param {module:path.SVGElementJSON} data
   * @returns {Element} The new element
  */

  /**
   * @function module:path.EditorContext#getGridSnapping
   * @returns {boolean}
   */

  /**
   * @function module:path.EditorContext#getOpacity
   * @returns {Float}
   */

  /**
   * @function module:path.EditorContext#getSelectedElements
   * @returns {Element[]} the array with selected DOM elements
  */

  /**
   * @function module:path.EditorContext#getContainer
   * @returns {Element}
   */

  /**
   * @function module:path.EditorContext#setStarted
   * @param {boolean} s
   * @returns {void}
   */

  /**
   * @function module:path.EditorContext#getRubberBox
   * @returns {SVGRectElement}
  */

  /**
   * @function module:path.EditorContext#setRubberBox
   * @param {SVGRectElement} rb
   * @returns {SVGRectElement} Same as parameter passed in
   */

  /**
   * @function module:path.EditorContext#addPtsToSelection
   * @param {PlainObject} cfg
   * @param {boolean} cfg.closedSubpath
   * @param {SVGCircleElement[]} cfg.grips
   * @returns {void}
   */

  /**
   * @function module:path.EditorContext#endChanges
   * @param {PlainObject} cfg
   * @param {string} cfg.cmd
   * @param {Element} cfg.elem
   * @returns {void}
  */

  /**
   * @function module:path.EditorContext#getCurrentZoom
   * @returns {Float} The current zoom level
   */

  /**
   * Returns the last created DOM element ID string.
   * @function module:path.EditorContext#getId
   * @returns {string}
   */

  /**
   * Creates and returns a unique ID string for a DOM element.
   * @function module:path.EditorContext#getNextId
   * @returns {string}
  */

  /**
   * Gets the desired element from a mouse event.
   * @function module:path.EditorContext#getMouseTarget
   * @param {external:MouseEvent} evt - Event object from the mouse event
   * @returns {Element} DOM element we want
   */

  /**
   * @function module:path.EditorContext#getCurrentMode
   * @returns {string}
   */

  /**
   * @function module:path.EditorContext#setCurrentMode
   * @param {string} cm The mode
   * @returns {string} The same mode as passed in
  */

  /**
   * @function module:path.EditorContext#getDrawnPath
   * @returns {SVGPathElement|null}
   */

  /**
   * @function module:path.EditorContext#setDrawnPath
   * @param {SVGPathElement|null} dp
   * @returns {SVGPathElement|null} The same value as passed in
   */

  /**
   * @function module:path.EditorContext#getSVGRoot
   * @returns {SVGSVGElement}
  */

  /**
  * @function module:path.init
  * @param {module:path.EditorContext} editorContext
  * @returns {void}
  */

  var init$2 = function init(editorContext) {
    editorContext_$1 = editorContext;
    pathFuncs = [0, 'ClosePath'];
    var pathFuncsStrs = ['Moveto', 'Lineto', 'CurvetoCubic', 'CurvetoQuadratic', 'Arc', 'LinetoHorizontal', 'LinetoVertical', 'CurvetoCubicSmooth', 'CurvetoQuadraticSmooth'];
    $$3.each(pathFuncsStrs, function (i, s) {
      pathFuncs.push(s + 'Abs');
      pathFuncs.push(s + 'Rel');
    });
  };
  /**
  * @function module:path.insertItemBefore
  * @param {Element} elem
  * @param {Segment} newseg
  * @param {Integer} index
  * @returns {void}
  */

  var insertItemBefore = function insertItemBefore(elem, newseg, index) {
    // Support insertItemBefore on paths for FF2
    var list = elem.pathSegList;

    if (supportsPathInsertItemBefore()) {
      list.insertItemBefore(newseg, index);
      return;
    }

    var len = list.numberOfItems;
    var arr = [];

    for (var i = 0; i < len; i++) {
      var curSeg = list.getItem(i);
      arr.push(curSeg);
    }

    list.clear();

    for (var _i = 0; _i < len; _i++) {
      if (_i === index) {
        // index + 1
        list.appendItem(newseg);
      }

      list.appendItem(arr[_i]);
    }
  };
  /**
  * @function module:path.ptObjToArr
  * @todo See if this should just live in `replacePathSeg`
  * @param {string} type
  * @param {SVGPathSegMovetoAbs|SVGPathSegLinetoAbs|SVGPathSegCurvetoCubicAbs|SVGPathSegCurvetoQuadraticAbs|SVGPathSegArcAbs|SVGPathSegLinetoHorizontalAbs|SVGPathSegLinetoVerticalAbs|SVGPathSegCurvetoCubicSmoothAbs|SVGPathSegCurvetoQuadraticSmoothAbs} segItem
  * @returns {ArgumentsArray}
  */

  var ptObjToArr = function ptObjToArr(type, segItem) {
    var props = segData[type];
    return props.map(function (prop) {
      return segItem[prop];
    });
  };
  /**
  * @function module:path.getGripPt
  * @param {Segment} seg
  * @param {module:math.XYObject} altPt
  * @returns {module:math.XYObject}
  */

  var getGripPt = function getGripPt(seg, altPt) {
    var pth = seg.path;
    var out = {
      x: altPt ? altPt.x : seg.item.x,
      y: altPt ? altPt.y : seg.item.y
    };

    if (pth.matrix) {
      var pt = transformPoint(out.x, out.y, pth.matrix);
      out = pt;
    }

    var currentZoom = editorContext_$1.getCurrentZoom();
    out.x *= currentZoom;
    out.y *= currentZoom;
    return out;
  };
  /**
  * @function module:path.getPointFromGrip
  * @param {module:math.XYObject} pt
  * @param {module:path.Path} pth
  * @returns {module:math.XYObject}
  */

  var getPointFromGrip = function getPointFromGrip(pt, pth) {
    var out = {
      x: pt.x,
      y: pt.y
    };

    if (pth.matrix) {
      pt = transformPoint(out.x, out.y, pth.imatrix);
      out.x = pt.x;
      out.y = pt.y;
    }

    var currentZoom = editorContext_$1.getCurrentZoom();
    out.x /= currentZoom;
    out.y /= currentZoom;
    return out;
  };
  /**
  * Requires prior call to `setUiStrings` if `xlink:title`
  *    to be set on the grip.
  * @function module:path.addPointGrip
  * @param {Integer} index
  * @param {Integer} x
  * @param {Integer} y
  * @returns {SVGCircleElement}
  */

  var addPointGrip = function addPointGrip(index, x, y) {
    // create the container of all the point grips
    var pointGripContainer = getGripContainer();
    var pointGrip = getElem('pathpointgrip_' + index); // create it

    if (!pointGrip) {
      pointGrip = document.createElementNS(NS.SVG, 'circle');
      var atts = {
        id: 'pathpointgrip_' + index,
        display: 'none',
        r: 4,
        fill: '#0FF',
        stroke: '#00F',
        'stroke-width': 2,
        cursor: 'move',
        style: 'pointer-events:all'
      };

      if ('pathNodeTooltip' in uiStrings) {
        // May be empty if running path.js without svg-editor
        atts['xlink:title'] = uiStrings.pathNodeTooltip;
      }

      assignAttributes(pointGrip, atts);
      pointGrip = pointGripContainer.appendChild(pointGrip);
      var grip = $$3('#pathpointgrip_' + index);
      grip.dblclick(function () {
        if (path$1) {
          path$1.setSegType();
        }
      });
    }

    if (x && y) {
      // set up the point grip element and display it
      assignAttributes(pointGrip, {
        cx: x,
        cy: y,
        display: 'inline'
      });
    }

    return pointGrip;
  };
  /**
  * @function module:path.getGripContainer
  * @returns {Element}
  */

  var getGripContainer = function getGripContainer() {
    var c = getElem('pathpointgrip_container');

    if (!c) {
      var parentElement = getElem('selectorParentGroup');
      c = parentElement.appendChild(document.createElementNS(NS.SVG, 'g'));
      c.id = 'pathpointgrip_container';
    }

    return c;
  };
  /**
  * Requires prior call to `setUiStrings` if `xlink:title`
  *    to be set on the grip.
  * @function module:path.addCtrlGrip
  * @param {string} id
  * @returns {SVGCircleElement}
  */

  var addCtrlGrip = function addCtrlGrip(id) {
    var pointGrip = getElem('ctrlpointgrip_' + id);

    if (pointGrip) {
      return pointGrip;
    }

    pointGrip = document.createElementNS(NS.SVG, 'circle');
    var atts = {
      id: 'ctrlpointgrip_' + id,
      display: 'none',
      r: 4,
      fill: '#0FF',
      stroke: '#55F',
      'stroke-width': 1,
      cursor: 'move',
      style: 'pointer-events:all'
    };

    if ('pathCtrlPtTooltip' in uiStrings) {
      // May be empty if running path.js without svg-editor
      atts['xlink:title'] = uiStrings.pathCtrlPtTooltip;
    }

    assignAttributes(pointGrip, atts);
    getGripContainer().append(pointGrip);
    return pointGrip;
  };
  /**
  * @function module:path.getCtrlLine
  * @param {string} id
  * @returns {SVGLineElement}
  */

  var getCtrlLine = function getCtrlLine(id) {
    var ctrlLine = getElem('ctrlLine_' + id);

    if (ctrlLine) {
      return ctrlLine;
    }

    ctrlLine = document.createElementNS(NS.SVG, 'line');
    assignAttributes(ctrlLine, {
      id: 'ctrlLine_' + id,
      stroke: '#555',
      'stroke-width': 1,
      style: 'pointer-events:none'
    });
    getGripContainer().append(ctrlLine);
    return ctrlLine;
  };
  /**
  * @function module:path.getPointGrip
  * @param {Segment} seg
  * @param {boolean} update
  * @returns {SVGCircleElement}
  */

  var getPointGrip = function getPointGrip(seg, update) {
    var index = seg.index;
    var pointGrip = addPointGrip(index);

    if (update) {
      var pt = getGripPt(seg);
      assignAttributes(pointGrip, {
        cx: pt.x,
        cy: pt.y,
        display: 'inline'
      });
    }

    return pointGrip;
  };
  /**
  * @function module:path.getControlPoints
  * @param {Segment} seg
  * @returns {PlainObject<string, SVGLineElement|SVGCircleElement>}
  */

  var getControlPoints = function getControlPoints(seg) {
    var item = seg.item,
        index = seg.index;

    if (!('x1' in item) || !('x2' in item)) {
      return null;
    }

    var cpt = {};
    /* const pointGripContainer = */

    getGripContainer(); // Note that this is intentionally not seg.prev.item

    var prev = path$1.segs[index - 1].item;
    var segItems = [prev, item];

    for (var i = 1; i < 3; i++) {
      var id = index + 'c' + i;
      var ctrlLine = cpt['c' + i + '_line'] = getCtrlLine(id);
      var pt = getGripPt(seg, {
        x: item['x' + i],
        y: item['y' + i]
      });
      var gpt = getGripPt(seg, {
        x: segItems[i - 1].x,
        y: segItems[i - 1].y
      });
      assignAttributes(ctrlLine, {
        x1: pt.x,
        y1: pt.y,
        x2: gpt.x,
        y2: gpt.y,
        display: 'inline'
      });
      cpt['c' + i + '_line'] = ctrlLine; // create it

      var pointGrip = cpt['c' + i] = addCtrlGrip(id);
      assignAttributes(pointGrip, {
        cx: pt.x,
        cy: pt.y,
        display: 'inline'
      });
      cpt['c' + i] = pointGrip;
    }

    return cpt;
  };
  /**
  * This replaces the segment at the given index. Type is given as number.
  * @function module:path.replacePathSeg
  * @param {Integer} type Possible values set during {@link module:path.init}
  * @param {Integer} index
  * @param {ArgumentsArray} pts
  * @param {SVGPathElement} elem
  * @returns {void}
  */

  var replacePathSeg = function replacePathSeg(type, index, pts, elem) {
    var pth = elem || path$1.elem;
    var func = 'createSVGPathSeg' + pathFuncs[type];
    var seg = pth[func].apply(pth, _toConsumableArray(pts));

    if (supportsPathReplaceItem()) {
      pth.pathSegList.replaceItem(seg, index);
    } else {
      var segList = pth.pathSegList;
      var len = segList.numberOfItems;
      var arr = [];

      for (var i = 0; i < len; i++) {
        var curSeg = segList.getItem(i);
        arr.push(curSeg);
      }

      segList.clear();

      for (var _i2 = 0; _i2 < len; _i2++) {
        if (_i2 === index) {
          segList.appendItem(seg);
        } else {
          segList.appendItem(arr[_i2]);
        }
      }
    }
  };
  /**
  * @function module:path.getSegSelector
  * @param {Segment} seg
  * @param {boolean} update
  * @returns {SVGPathElement}
  */

  var getSegSelector = function getSegSelector(seg, update) {
    var index = seg.index;
    var segLine = getElem('segline_' + index);

    if (!segLine) {
      var pointGripContainer = getGripContainer(); // create segline

      segLine = document.createElementNS(NS.SVG, 'path');
      assignAttributes(segLine, {
        id: 'segline_' + index,
        display: 'none',
        fill: 'none',
        stroke: '#0FF',
        'stroke-width': 2,
        style: 'pointer-events:none',
        d: 'M0,0 0,0'
      });
      pointGripContainer.append(segLine);
    }

    if (update) {
      var prev = seg.prev;

      if (!prev) {
        segLine.setAttribute('display', 'none');
        return segLine;
      }

      var pt = getGripPt(prev); // Set start point

      replacePathSeg(2, 0, [pt.x, pt.y], segLine);
      var pts = ptObjToArr(seg.type, seg.item); // , true);

      for (var i = 0; i < pts.length; i += 2) {
        var point = getGripPt(seg, {
          x: pts[i],
          y: pts[i + 1]
        });
        pts[i] = point.x;
        pts[i + 1] = point.y;
      }

      replacePathSeg(seg.type, 1, pts, segLine);
    }

    return segLine;
  };
  /**
   * @typedef {PlainObject} Point
   * @property {Integer} x The x value
   * @property {Integer} y The y value
   */

  /**
  * Takes three points and creates a smoother line based on them.
  * @function module:path.smoothControlPoints
  * @param {Point} ct1 - Object with x and y values (first control point)
  * @param {Point} ct2 - Object with x and y values (second control point)
  * @param {Point} pt - Object with x and y values (third point)
  * @returns {Point[]} Array of two "smoothed" point objects
  */

  var smoothControlPoints = function smoothControlPoints(ct1, ct2, pt) {
    // each point must not be the origin
    var x1 = ct1.x - pt.x,
        y1 = ct1.y - pt.y,
        x2 = ct2.x - pt.x,
        y2 = ct2.y - pt.y;

    if ((x1 !== 0 || y1 !== 0) && (x2 !== 0 || y2 !== 0)) {
      var r1 = Math.sqrt(x1 * x1 + y1 * y1),
          r2 = Math.sqrt(x2 * x2 + y2 * y2),
          nct1 = editorContext_$1.getSVGRoot().createSVGPoint(),
          nct2 = editorContext_$1.getSVGRoot().createSVGPoint();
      var anglea = Math.atan2(y1, x1),
          angleb = Math.atan2(y2, x2);

      if (anglea < 0) {
        anglea += 2 * Math.PI;
      }

      if (angleb < 0) {
        angleb += 2 * Math.PI;
      }

      var angleBetween = Math.abs(anglea - angleb),
          angleDiff = Math.abs(Math.PI - angleBetween) / 2;
      var newAnglea, newAngleb;

      if (anglea - angleb > 0) {
        newAnglea = angleBetween < Math.PI ? anglea + angleDiff : anglea - angleDiff;
        newAngleb = angleBetween < Math.PI ? angleb - angleDiff : angleb + angleDiff;
      } else {
        newAnglea = angleBetween < Math.PI ? anglea - angleDiff : anglea + angleDiff;
        newAngleb = angleBetween < Math.PI ? angleb + angleDiff : angleb - angleDiff;
      } // rotate the points


      nct1.x = r1 * Math.cos(newAnglea) + pt.x;
      nct1.y = r1 * Math.sin(newAnglea) + pt.y;
      nct2.x = r2 * Math.cos(newAngleb) + pt.x;
      nct2.y = r2 * Math.sin(newAngleb) + pt.y;
      return [nct1, nct2];
    }

    return undefined;
  };
  /**
  *
  */

  var Segment = /*#__PURE__*/function () {
    /**
    * @param {Integer} index
    * @param {SVGPathSeg} item
    * @todo Is `item` be more constrained here?
    */
    function Segment(index, item) {
      _classCallCheck(this, Segment);

      this.selected = false;
      this.index = index;
      this.item = item;
      this.type = item.pathSegType;
      this.ctrlpts = [];
      this.ptgrip = null;
      this.segsel = null;
    }
    /**
     * @param {boolean} y
     * @returns {void}
     */


    _createClass(Segment, [{
      key: "showCtrlPts",
      value: function showCtrlPts(y) {
        for (var i in this.ctrlpts) {
          if ({}.hasOwnProperty.call(this.ctrlpts, i)) {
            this.ctrlpts[i].setAttribute('display', y ? 'inline' : 'none');
          }
        }
      }
      /**
       * @param {boolean} y
       * @returns {void}
       */

    }, {
      key: "selectCtrls",
      value: function selectCtrls(y) {
        $$3('#ctrlpointgrip_' + this.index + 'c1, #ctrlpointgrip_' + this.index + 'c2').attr('fill', y ? '#0FF' : '#EEE');
      }
      /**
       * @param {boolean} y
       * @returns {void}
       */

    }, {
      key: "show",
      value: function show(y) {
        if (this.ptgrip) {
          this.ptgrip.setAttribute('display', y ? 'inline' : 'none');
          this.segsel.setAttribute('display', y ? 'inline' : 'none'); // Show/hide all control points if available

          this.showCtrlPts(y);
        }
      }
      /**
       * @param {boolean} y
       * @returns {void}
       */

    }, {
      key: "select",
      value: function select(y) {
        if (this.ptgrip) {
          this.ptgrip.setAttribute('stroke', y ? '#0FF' : '#00F');
          this.segsel.setAttribute('display', y ? 'inline' : 'none');

          if (this.ctrlpts) {
            this.selectCtrls(y);
          }

          this.selected = y;
        }
      }
      /**
       * @returns {void}
       */

    }, {
      key: "addGrip",
      value: function addGrip() {
        this.ptgrip = getPointGrip(this, true);
        this.ctrlpts = getControlPoints(this); // , true);

        this.segsel = getSegSelector(this, true);
      }
      /**
       * @param {boolean} full
       * @returns {void}
       */

    }, {
      key: "update",
      value: function update(full) {
        if (this.ptgrip) {
          var pt = getGripPt(this);
          assignAttributes(this.ptgrip, {
            cx: pt.x,
            cy: pt.y
          });
          getSegSelector(this, true);

          if (this.ctrlpts) {
            if (full) {
              this.item = path$1.elem.pathSegList.getItem(this.index);
              this.type = this.item.pathSegType;
            }

            getControlPoints(this);
          } // this.segsel.setAttribute('display', y ? 'inline' : 'none');

        }
      }
      /**
       * @param {Integer} dx
       * @param {Integer} dy
       * @returns {void}
       */

    }, {
      key: "move",
      value: function move(dx, dy) {
        var item = this.item;
        var curPts = this.ctrlpts ? [item.x += dx, item.y += dy, item.x1, item.y1, item.x2 += dx, item.y2 += dy] : [item.x += dx, item.y += dy];
        replacePathSeg(this.type, this.index, // type 10 means ARC
        this.type === 10 ? ptObjToArr(this.type, item) : curPts);

        if (this.next && this.next.ctrlpts) {
          var next = this.next.item;
          var nextPts = [next.x, next.y, next.x1 += dx, next.y1 += dy, next.x2, next.y2];
          replacePathSeg(this.next.type, this.next.index, nextPts);
        }

        if (this.mate) {
          // The last point of a closed subpath has a 'mate',
          // which is the 'M' segment of the subpath
          var itm = this.mate.item;
          var pts = [itm.x += dx, itm.y += dy];
          replacePathSeg(this.mate.type, this.mate.index, pts); // Has no grip, so does not need 'updating'?
        }

        this.update(true);

        if (this.next) {
          this.next.update(true);
        }
      }
      /**
       * @param {Integer} num
       * @returns {void}
       */

    }, {
      key: "setLinked",
      value: function setLinked(num) {
        var seg, anum, pt;

        if (num === 2) {
          anum = 1;
          seg = this.next;

          if (!seg) {
            return;
          }

          pt = this.item;
        } else {
          anum = 2;
          seg = this.prev;

          if (!seg) {
            return;
          }

          pt = seg.item;
        }

        var _seg = seg,
            item = _seg.item;
        item['x' + anum] = pt.x + (pt.x - this.item['x' + num]);
        item['y' + anum] = pt.y + (pt.y - this.item['y' + num]);
        var pts = [item.x, item.y, item.x1, item.y1, item.x2, item.y2];
        replacePathSeg(seg.type, seg.index, pts);
        seg.update(true);
      }
      /**
       * @param {Integer} num
       * @param {Integer} dx
       * @param {Integer} dy
       * @returns {void}
       */

    }, {
      key: "moveCtrl",
      value: function moveCtrl(num, dx, dy) {
        var item = this.item;
        item['x' + num] += dx;
        item['y' + num] += dy;
        var pts = [item.x, item.y, item.x1, item.y1, item.x2, item.y2];
        replacePathSeg(this.type, this.index, pts);
        this.update(true);
      }
      /**
       * @param {Integer} newType Possible values set during {@link module:path.init}
       * @param {ArgumentsArray} pts
       * @returns {void}
       */

    }, {
      key: "setType",
      value: function setType(newType, pts) {
        replacePathSeg(newType, this.index, pts);
        this.type = newType;
        this.item = path$1.elem.pathSegList.getItem(this.index);
        this.showCtrlPts(newType === 6);
        this.ctrlpts = getControlPoints(this);
        this.update(true);
      }
    }]);

    return Segment;
  }();
  /**
  *
  */

  var Path = /*#__PURE__*/function () {
    /**
    * @param {SVGPathElement} elem
    * @throws {Error} If constructed without a path element
    */
    function Path(elem) {
      _classCallCheck(this, Path);

      if (!elem || elem.tagName !== 'path') {
        throw new Error('svgedit.path.Path constructed without a <path> element');
      }

      this.elem = elem;
      this.segs = [];
      this.selected_pts = [];
      path$1 = this;
      this.init();
    }
    /**
    * Reset path data.
    * @returns {module:path.Path}
    */


    _createClass(Path, [{
      key: "init",
      value: function init() {
        // Hide all grips, etc
        // fixed, needed to work on all found elements, not just first
        $$3(getGripContainer()).find('*').each(function () {
          $$3(this).attr('display', 'none');
        });
        var segList = this.elem.pathSegList;
        var len = segList.numberOfItems;
        this.segs = [];
        this.selected_pts = [];
        this.first_seg = null; // Set up segs array

        for (var i = 0; i < len; i++) {
          var item = segList.getItem(i);
          var segment = new Segment(i, item);
          segment.path = this;
          this.segs.push(segment);
        }

        var segs = this.segs;
        var startI = null;

        for (var _i3 = 0; _i3 < len; _i3++) {
          var seg = segs[_i3];
          var nextSeg = _i3 + 1 >= len ? null : segs[_i3 + 1];
          var prevSeg = _i3 - 1 < 0 ? null : segs[_i3 - 1];

          if (seg.type === 2) {
            if (prevSeg && prevSeg.type !== 1) {
              // New sub-path, last one is open,
              // so add a grip to last sub-path's first point
              var startSeg = segs[startI];
              startSeg.next = segs[startI + 1];
              startSeg.next.prev = startSeg;
              startSeg.addGrip();
            } // Remember that this is a starter seg


            startI = _i3;
          } else if (nextSeg && nextSeg.type === 1) {
            // This is the last real segment of a closed sub-path
            // Next is first seg after "M"
            seg.next = segs[startI + 1]; // First seg after "M"'s prev is this

            seg.next.prev = seg;
            seg.mate = segs[startI];
            seg.addGrip();

            if (isNullish(this.first_seg)) {
              this.first_seg = seg;
            }
          } else if (!nextSeg) {
            if (seg.type !== 1) {
              // Last seg, doesn't close so add a grip
              // to last sub-path's first point
              var _startSeg = segs[startI];
              _startSeg.next = segs[startI + 1];
              _startSeg.next.prev = _startSeg;

              _startSeg.addGrip();

              seg.addGrip();

              if (!this.first_seg) {
                // Open path, so set first as real first and add grip
                this.first_seg = segs[startI];
              }
            }
          } else if (seg.type !== 1) {
            // Regular segment, so add grip and its "next"
            seg.addGrip(); // Don't set its "next" if it's an "M"

            if (nextSeg && nextSeg.type !== 2) {
              seg.next = nextSeg;
              seg.next.prev = seg;
            }
          }
        }

        return this;
      }
      /**
      * @callback module:path.PathEachSegCallback
      * @this module:path.Segment
      * @param {Integer} i The index of the seg being iterated
      * @returns {boolean|void} Will stop execution of `eachSeg` if returns `false`
      */

      /**
      * @param {module:path.PathEachSegCallback} fn
      * @returns {void}
      */

    }, {
      key: "eachSeg",
      value: function eachSeg(fn) {
        var len = this.segs.length;

        for (var i = 0; i < len; i++) {
          var ret = fn.call(this.segs[i], i);

          if (ret === false) {
            break;
          }
        }
      }
      /**
      * @param {Integer} index
      * @returns {void}
      */

    }, {
      key: "addSeg",
      value: function addSeg(index) {
        // Adds a new segment
        var seg = this.segs[index];

        if (!seg.prev) {
          return;
        }

        var prev = seg.prev;
        var newseg, newX, newY;

        switch (seg.item.pathSegType) {
          case 4:
            {
              newX = (seg.item.x + prev.item.x) / 2;
              newY = (seg.item.y + prev.item.y) / 2;
              newseg = this.elem.createSVGPathSegLinetoAbs(newX, newY);
              break;
            }

          case 6:
            {
              // make it a curved segment to preserve the shape (WRS)
              // https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm#Geometric_interpretation
              var p0x = (prev.item.x + seg.item.x1) / 2;
              var p1x = (seg.item.x1 + seg.item.x2) / 2;
              var p2x = (seg.item.x2 + seg.item.x) / 2;
              var p01x = (p0x + p1x) / 2;
              var p12x = (p1x + p2x) / 2;
              newX = (p01x + p12x) / 2;
              var p0y = (prev.item.y + seg.item.y1) / 2;
              var p1y = (seg.item.y1 + seg.item.y2) / 2;
              var p2y = (seg.item.y2 + seg.item.y) / 2;
              var p01y = (p0y + p1y) / 2;
              var p12y = (p1y + p2y) / 2;
              newY = (p01y + p12y) / 2;
              newseg = this.elem.createSVGPathSegCurvetoCubicAbs(newX, newY, p0x, p0y, p01x, p01y);
              var pts = [seg.item.x, seg.item.y, p12x, p12y, p2x, p2y];
              replacePathSeg(seg.type, index, pts);
              break;
            }
        }

        insertItemBefore(this.elem, newseg, index);
      }
      /**
      * @param {Integer} index
      * @returns {void}
      */

    }, {
      key: "deleteSeg",
      value: function deleteSeg(index) {
        var seg = this.segs[index];
        var list = this.elem.pathSegList;
        seg.show(false);
        var next = seg.next;

        if (seg.mate) {
          // Make the next point be the "M" point
          var pt = [next.item.x, next.item.y];
          replacePathSeg(2, next.index, pt); // Reposition last node

          replacePathSeg(4, seg.index, pt);
          list.removeItem(seg.mate.index);
        } else if (!seg.prev) {
          // First node of open path, make next point the M
          // const {item} = seg;
          var _pt = [next.item.x, next.item.y];
          replacePathSeg(2, seg.next.index, _pt);
          list.removeItem(index);
        } else {
          list.removeItem(index);
        }
      }
      /**
      * @param {Integer} index
      * @returns {void}
      */

    }, {
      key: "removePtFromSelection",
      value: function removePtFromSelection(index) {
        var pos = this.selected_pts.indexOf(index);

        if (pos === -1) {
          return;
        }

        this.segs[index].select(false);
        this.selected_pts.splice(pos, 1);
      }
      /**
      * @returns {void}
      */

    }, {
      key: "clearSelection",
      value: function clearSelection() {
        this.eachSeg(function () {
          // 'this' is the segment here
          this.select(false);
        });
        this.selected_pts = [];
      }
      /**
      * @returns {void}
      */

    }, {
      key: "storeD",
      value: function storeD() {
        this.last_d = this.elem.getAttribute('d');
      }
      /**
      * @param {Integer} y
      * @returns {Path}
      */

    }, {
      key: "show",
      value: function show(y) {
        // Shows this path's segment grips
        this.eachSeg(function () {
          // 'this' is the segment here
          this.show(y);
        });

        if (y) {
          this.selectPt(this.first_seg.index);
        }

        return this;
      }
      /**
      * Move selected points.
      * @param {Integer} dx
      * @param {Integer} dy
      * @returns {void}
      */

    }, {
      key: "movePts",
      value: function movePts(dx, dy) {
        var i = this.selected_pts.length;

        while (i--) {
          var seg = this.segs[this.selected_pts[i]];
          seg.move(dx, dy);
        }
      }
      /**
      * @param {Integer} dx
      * @param {Integer} dy
      * @returns {void}
      */

    }, {
      key: "moveCtrl",
      value: function moveCtrl(dx, dy) {
        var seg = this.segs[this.selected_pts[0]];
        seg.moveCtrl(this.dragctrl, dx, dy);

        if (linkControlPts) {
          seg.setLinked(this.dragctrl);
        }
      }
      /**
      * @param {?Integer} newType See {@link https://www.w3.org/TR/SVG/single-page.html#paths-InterfaceSVGPathSeg}
      * @returns {void}
      */

    }, {
      key: "setSegType",
      value: function setSegType(newType) {
        this.storeD();
        var i = this.selected_pts.length;
        var text;

        while (i--) {
          var selPt = this.selected_pts[i]; // Selected seg

          var cur = this.segs[selPt];
          var prev = cur.prev;

          if (!prev) {
            continue;
          }

          if (!newType) {
            // double-click, so just toggle
            text = 'Toggle Path Segment Type'; // Toggle segment to curve/straight line

            var oldType = cur.type;
            newType = oldType === 6 ? 4 : 6;
          }

          newType = Number(newType);
          var curX = cur.item.x;
          var curY = cur.item.y;
          var prevX = prev.item.x;
          var prevY = prev.item.y;
          var points = void 0;

          switch (newType) {
            case 6:
              {
                if (cur.olditem) {
                  var old = cur.olditem;
                  points = [curX, curY, old.x1, old.y1, old.x2, old.y2];
                } else {
                  var diffX = curX - prevX;
                  var diffY = curY - prevY; // get control points from straight line segment

                  /*
                  const ct1x = (prevX + (diffY/2));
                  const ct1y = (prevY - (diffX/2));
                  const ct2x = (curX + (diffY/2));
                  const ct2y = (curY - (diffX/2));
                  */
                  // create control points on the line to preserve the shape (WRS)

                  var ct1x = prevX + diffX / 3;
                  var ct1y = prevY + diffY / 3;
                  var ct2x = curX - diffX / 3;
                  var ct2y = curY - diffY / 3;
                  points = [curX, curY, ct1x, ct1y, ct2x, ct2y];
                }

                break;
              }

            case 4:
              {
                points = [curX, curY]; // Store original prevve segment nums

                cur.olditem = cur.item;
                break;
              }
          }

          cur.setType(newType, points);
        }

        path$1.endChanges(text);
      }
      /**
      * @param {Integer} pt
      * @param {Integer} ctrlNum
      * @returns {void}
      */

    }, {
      key: "selectPt",
      value: function selectPt(pt, ctrlNum) {
        this.clearSelection();

        if (isNullish(pt)) {
          this.eachSeg(function (i) {
            // 'this' is the segment here.
            if (this.prev) {
              pt = i;
            }
          });
        }

        this.addPtsToSelection(pt);

        if (ctrlNum) {
          this.dragctrl = ctrlNum;

          if (linkControlPts) {
            this.segs[pt].setLinked(ctrlNum);
          }
        }
      }
      /**
      * Update position of all points.
      * @returns {Path}
      */

    }, {
      key: "update",
      value: function update() {
        var elem = this.elem;

        if (getRotationAngle(elem)) {
          this.matrix = getMatrix(elem);
          this.imatrix = this.matrix.inverse();
        } else {
          this.matrix = null;
          this.imatrix = null;
        }

        this.eachSeg(function (i) {
          this.item = elem.pathSegList.getItem(i);
          this.update();
        });
        return this;
      }
      /**
      * @param {string} text
      * @returns {void}
      */

    }, {
      key: "endChanges",
      value: function endChanges(text) {
        if (isWebkit()) {
          editorContext_$1.resetD(this.elem);
        }

        var cmd = new ChangeElementCommand(this.elem, {
          d: this.last_d
        }, text);
        editorContext_$1.endChanges({
          cmd: cmd,
          elem: this.elem
        });
      }
      /**
      * @param {Integer|Integer[]} indexes
      * @returns {void}
      */

    }, {
      key: "addPtsToSelection",
      value: function addPtsToSelection(indexes) {
        var _this = this;

        if (!Array.isArray(indexes)) {
          indexes = [indexes];
        }

        indexes.forEach(function (index) {
          var seg = _this.segs[index];

          if (seg.ptgrip) {
            if (!_this.selected_pts.includes(index) && index >= 0) {
              _this.selected_pts.push(index);
            }
          }
        });
        this.selected_pts.sort();
        var i = this.selected_pts.length;
        var grips = [];
        grips.length = i; // Loop through points to be selected and highlight each

        while (i--) {
          var pt = this.selected_pts[i];
          var seg = this.segs[pt];
          seg.select(true);
          grips[i] = seg.ptgrip;
        }

        var closedSubpath = Path.subpathIsClosed(this.selected_pts[0]);
        editorContext_$1.addPtsToSelection({
          grips: grips,
          closedSubpath: closedSubpath
        });
      } // STATIC

      /**
      * @param {Integer} index
      * @returns {boolean}
      */

    }], [{
      key: "subpathIsClosed",
      value: function subpathIsClosed(index) {
        var clsd = false; // Check if subpath is already open

        path$1.eachSeg(function (i) {
          if (i <= index) {
            return true;
          }

          if (this.type === 2) {
            // Found M first, so open
            return false;
          }

          if (this.type === 1) {
            // Found Z first, so closed
            clsd = true;
            return false;
          }

          return true;
        });
        return clsd;
      }
    }]);

    return Path;
  }();
  /**
  * @function module:path.getPath_
  * @param {SVGPathElement} elem
  * @returns {module:path.Path}
  */

  var getPath_ = function getPath_(elem) {
    var p = pathData[elem.id];

    if (!p) {
      p = pathData[elem.id] = new Path(elem);
    }

    return p;
  };
  /**
  * @function module:path.removePath_
  * @param {string} id
  * @returns {void}
  */

  var removePath_ = function removePath_(id) {
    if (id in pathData) {
      delete pathData[id];
    }
  };
  var newcx, newcy, oldcx, oldcy, angle;

  var getRotVals = function getRotVals(x, y) {
    var dx = x - oldcx;
    var dy = y - oldcy; // rotate the point around the old center

    var r = Math.sqrt(dx * dx + dy * dy);
    var theta = Math.atan2(dy, dx) + angle;
    dx = r * Math.cos(theta) + oldcx;
    dy = r * Math.sin(theta) + oldcy; // dx,dy should now hold the actual coordinates of each
    // point after being rotated
    // now we want to rotate them around the new center in the reverse direction

    dx -= newcx;
    dy -= newcy;
    r = Math.sqrt(dx * dx + dy * dy);
    theta = Math.atan2(dy, dx) - angle;
    return {
      x: r * Math.cos(theta) + newcx,
      y: r * Math.sin(theta) + newcy
    };
  }; // If the path was rotated, we must now pay the piper:
  // Every path point must be rotated into the rotated coordinate system of
  // its old center, then determine the new center, then rotate it back
  // This is because we want the path to remember its rotation

  /**
  * @function module:path.recalcRotatedPath
  * @todo This is still using ye olde transform methods, can probably
  * be optimized or even taken care of by `recalculateDimensions`
  * @returns {void}
  */


  var recalcRotatedPath = function recalcRotatedPath() {
    var currentPath = path$1.elem;
    angle = getRotationAngle(currentPath, true);

    if (!angle) {
      return;
    } // selectedBBoxes[0] = path.oldbbox;


    var oldbox = path$1.oldbbox; // selectedBBoxes[0],

    oldcx = oldbox.x + oldbox.width / 2;
    oldcy = oldbox.y + oldbox.height / 2;
    var box = getBBox(currentPath);
    newcx = box.x + box.width / 2;
    newcy = box.y + box.height / 2; // un-rotate the new center to the proper position

    var dx = newcx - oldcx,
        dy = newcy - oldcy,
        r = Math.sqrt(dx * dx + dy * dy),
        theta = Math.atan2(dy, dx) + angle;
    newcx = r * Math.cos(theta) + oldcx;
    newcy = r * Math.sin(theta) + oldcy;
    var list = currentPath.pathSegList;
    var i = list.numberOfItems;

    while (i) {
      i -= 1;
      var seg = list.getItem(i),
          type = seg.pathSegType;

      if (type === 1) {
        continue;
      }

      var rvals = getRotVals(seg.x, seg.y),
          points = [rvals.x, rvals.y];

      if (!isNullish(seg.x1) && !isNullish(seg.x2)) {
        var cVals1 = getRotVals(seg.x1, seg.y1);
        var cVals2 = getRotVals(seg.x2, seg.y2);
        points.splice(points.length, 0, cVals1.x, cVals1.y, cVals2.x, cVals2.y);
      }

      replacePathSeg(type, i, points);
    } // loop for each point

    /* box = */


    getBBox(currentPath); // selectedBBoxes[0].x = box.x; selectedBBoxes[0].y = box.y;
    // selectedBBoxes[0].width = box.width; selectedBBoxes[0].height = box.height;
    // now we must set the new transform to be rotated around the new center

    var Rnc = editorContext_$1.getSVGRoot().createSVGTransform(),
        tlist = getTransformList(currentPath);
    Rnc.setRotate(angle * 180.0 / Math.PI, newcx, newcy);
    tlist.replaceItem(Rnc, 0);
  }; // ====================================
  // Public API starts here

  /**
  * @function module:path.clearData
  * @returns {void}
  */

  var clearData = function clearData() {
    pathData = {};
  }; // Making public for mocking

  /**
  * @function module:path.reorientGrads
  * @param {Element} elem
  * @param {SVGMatrix} m
  * @returns {void}
  */

  var reorientGrads = function reorientGrads(elem, m) {
    var bb = getBBox(elem);

    for (var i = 0; i < 2; i++) {
      var type = i === 0 ? 'fill' : 'stroke';
      var attrVal = elem.getAttribute(type);

      if (attrVal && attrVal.startsWith('url(')) {
        var grad = getRefElem(attrVal);

        if (grad.tagName === 'linearGradient') {
          var x1 = grad.getAttribute('x1') || 0;
          var y1 = grad.getAttribute('y1') || 0;
          var x2 = grad.getAttribute('x2') || 1;
          var y2 = grad.getAttribute('y2') || 0; // Convert to USOU points

          x1 = bb.width * x1 + bb.x;
          y1 = bb.height * y1 + bb.y;
          x2 = bb.width * x2 + bb.x;
          y2 = bb.height * y2 + bb.y; // Transform those points

          var pt1 = transformPoint(x1, y1, m);
          var pt2 = transformPoint(x2, y2, m); // Convert back to BB points

          var gCoords = {
            x1: (pt1.x - bb.x) / bb.width,
            y1: (pt1.y - bb.y) / bb.height,
            x2: (pt2.x - bb.x) / bb.width,
            y2: (pt2.y - bb.y) / bb.height
          };
          var newgrad = grad.cloneNode(true);
          $$3(newgrad).attr(gCoords);
          newgrad.id = editorContext_$1.getNextId();
          findDefs().append(newgrad);
          elem.setAttribute(type, 'url(#' + newgrad.id + ')');
        }
      }
    }
  };
  /**
  * This is how we map paths to our preferred relative segment types.
  * @name module:path.pathMap
  * @type {GenericArray}
  */

  var pathMap = [0, 'z', 'M', 'm', 'L', 'l', 'C', 'c', 'Q', 'q', 'A', 'a', 'H', 'h', 'V', 'v', 'S', 's', 'T', 't'];
  /**
   * Convert a path to one with only absolute or relative values.
   * @todo move to pathActions.js
   * @function module:path.convertPath
   * @param {SVGPathElement} pth - the path to convert
   * @param {boolean} toRel - true of convert to relative
   * @returns {string}
   */

  var convertPath = function convertPath(pth, toRel) {
    var pathSegList = pth.pathSegList;
    var len = pathSegList.numberOfItems;
    var curx = 0,
        cury = 0;
    var d = '';
    var lastM = null;

    for (var i = 0; i < len; ++i) {
      var seg = pathSegList.getItem(i); // if these properties are not in the segment, set them to zero

      var x = seg.x || 0,
          y = seg.y || 0,
          x1 = seg.x1 || 0,
          y1 = seg.y1 || 0,
          x2 = seg.x2 || 0,
          y2 = seg.y2 || 0;
      var type = seg.pathSegType;
      var letter = pathMap[type][toRel ? 'toLowerCase' : 'toUpperCase']();

      switch (type) {
        case 1:
          // z,Z closepath (Z/z)
          d += 'z';

          if (lastM && !toRel) {
            curx = lastM[0];
            cury = lastM[1];
          }

          break;

        case 12:
          // absolute horizontal line (H)
          x -= curx;
        // Fallthrough

        case 13:
          // relative horizontal line (h)
          if (toRel) {
            y = 0;
            curx += x;
            letter = 'l';
          } else {
            y = cury;
            x += curx;
            curx = x;
            letter = 'L';
          } // Convert to "line" for easier editing


          d += pathDSegment(letter, [[x, y]]);
          break;

        case 14:
          // absolute vertical line (V)
          y -= cury;
        // Fallthrough

        case 15:
          // relative vertical line (v)
          if (toRel) {
            x = 0;
            cury += y;
            letter = 'l';
          } else {
            x = curx;
            y += cury;
            cury = y;
            letter = 'L';
          } // Convert to "line" for easier editing


          d += pathDSegment(letter, [[x, y]]);
          break;

        case 2: // absolute move (M)

        case 4: // absolute line (L)

        case 18:
          // absolute smooth quad (T)
          x -= curx;
          y -= cury;
        // Fallthrough

        case 5: // relative line (l)

        case 3: // relative move (m)

        case 19:
          // relative smooth quad (t)
          if (toRel) {
            curx += x;
            cury += y;
          } else {
            x += curx;
            y += cury;
            curx = x;
            cury = y;
          }

          if (type === 2 || type === 3) {
            lastM = [curx, cury];
          }

          d += pathDSegment(letter, [[x, y]]);
          break;

        case 6:
          // absolute cubic (C)
          x -= curx;
          x1 -= curx;
          x2 -= curx;
          y -= cury;
          y1 -= cury;
          y2 -= cury;
        // Fallthrough

        case 7:
          // relative cubic (c)
          if (toRel) {
            curx += x;
            cury += y;
          } else {
            x += curx;
            x1 += curx;
            x2 += curx;
            y += cury;
            y1 += cury;
            y2 += cury;
            curx = x;
            cury = y;
          }

          d += pathDSegment(letter, [[x1, y1], [x2, y2], [x, y]]);
          break;

        case 8:
          // absolute quad (Q)
          x -= curx;
          x1 -= curx;
          y -= cury;
          y1 -= cury;
        // Fallthrough

        case 9:
          // relative quad (q)
          if (toRel) {
            curx += x;
            cury += y;
          } else {
            x += curx;
            x1 += curx;
            y += cury;
            y1 += cury;
            curx = x;
            cury = y;
          }

          d += pathDSegment(letter, [[x1, y1], [x, y]]);
          break;
        // eslint-disable-next-line sonarjs/no-duplicated-branches

        case 10:
          // absolute elliptical arc (A)
          x -= curx;
          y -= cury;
        // Fallthrough

        case 11:
          // relative elliptical arc (a)
          if (toRel) {
            curx += x;
            cury += y;
          } else {
            x += curx;
            y += cury;
            curx = x;
            cury = y;
          }

          d += pathDSegment(letter, [[seg.r1, seg.r2]], [seg.angle, seg.largeArcFlag ? 1 : 0, seg.sweepFlag ? 1 : 0], [x, y]);
          break;

        case 16:
          // absolute smooth cubic (S)
          x -= curx;
          x2 -= curx;
          y -= cury;
          y2 -= cury;
        // Fallthrough

        case 17:
          // relative smooth cubic (s)
          if (toRel) {
            curx += x;
            cury += y;
          } else {
            x += curx;
            x2 += curx;
            y += cury;
            y2 += cury;
            curx = x;
            cury = y;
          }

          d += pathDSegment(letter, [[x2, y2], [x, y]]);
          break;
      } // switch on path segment type

    } // for each segment


    return d;
  };
  /**
   * TODO: refactor callers in `convertPath` to use `getPathDFromSegments` instead of this function.
   * Legacy code refactored from `svgcanvas.pathActions.convertPath`.
   * @param {string} letter - path segment command (letter in potentially either case from {@link module:path.pathMap}; see [SVGPathSeg#pathSegTypeAsLetter]{@link https://www.w3.org/TR/SVG/single-page.html#paths-__svg__SVGPathSeg__pathSegTypeAsLetter})
   * @param {GenericArray<GenericArray<Integer>>} points - x,y points
   * @param {GenericArray<GenericArray<Integer>>} [morePoints] - x,y points
   * @param {Integer[]} [lastPoint] - x,y point
   * @returns {string}
   */

  function pathDSegment(letter, points, morePoints, lastPoint) {
    $$3.each(points, function (i, pnt) {
      points[i] = shortFloat(pnt);
    });
    var segment = letter + points.join(' ');

    if (morePoints) {
      segment += ' ' + morePoints.join(' ');
    }

    if (lastPoint) {
      segment += ' ' + shortFloat(lastPoint);
    }

    return segment;
  }
  /* eslint-disable jsdoc/require-property */

  /**
  * Group: Path edit functions.
  * Functions relating to editing path elements.
  * @namespace {PlainObject} pathActions
  * @memberof module:path
  */


  var pathActions = function () {
    /* eslint-enable jsdoc/require-property */
    var subpath = false;
    var newPoint, firstCtrl;
    var currentPath = null;
    var hasMoved = false; // No `editorContext_` yet but should be ok as is `null` by default
    // editorContext_.setDrawnPath(null);

    /**
    * This function converts a polyline (created by the fh_path tool) into
    * a path element and coverts every three line segments into a single bezier
    * curve in an attempt to smooth out the free-hand.
    * @function smoothPolylineIntoPath
    * @param {Element} element
    * @returns {Element}
    */

    var smoothPolylineIntoPath = function smoothPolylineIntoPath(element) {
      var i;
      var _element = element,
          points = _element.points;
      var N = points.numberOfItems;

      if (N >= 4) {
        // loop through every 3 points and convert to a cubic bezier curve segment
        //
        // NOTE: this is cheating, it means that every 3 points has the potential to
        // be a corner instead of treating each point in an equal manner. In general,
        // this technique does not look that good.
        //
        // I am open to better ideas!
        //
        // Reading:
        // - http://www.efg2.com/Lab/Graphics/Jean-YvesQueinecBezierCurves.htm
        // - https://www.codeproject.com/KB/graphics/BezierSpline.aspx?msg=2956963
        // - https://www.ian-ko.com/ET_GeoWizards/UserGuide/smooth.htm
        // - https://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-der.html
        var curpos = points.getItem(0),
            prevCtlPt = null;
        var d = [];
        d.push(['M', curpos.x, ',', curpos.y, ' C'].join(''));

        for (i = 1; i <= N - 4; i += 3) {
          var ct1 = points.getItem(i);
          var ct2 = points.getItem(i + 1);
          var end = points.getItem(i + 2); // if the previous segment had a control point, we want to smooth out
          // the control points on both sides

          if (prevCtlPt) {
            var newpts = smoothControlPoints(prevCtlPt, ct1, curpos);

            if (newpts && newpts.length === 2) {
              var prevArr = d[d.length - 1].split(',');
              prevArr[2] = newpts[0].x;
              prevArr[3] = newpts[0].y;
              d[d.length - 1] = prevArr.join(',');
              ct1 = newpts[1];
            }
          }

          d.push([ct1.x, ct1.y, ct2.x, ct2.y, end.x, end.y].join(','));
          curpos = end;
          prevCtlPt = ct2;
        } // handle remaining line segments


        d.push('L');

        while (i < N) {
          var pt = points.getItem(i);
          d.push([pt.x, pt.y].join(','));
          i++;
        }

        d = d.join(' '); // create new path element

        element = editorContext_$1.addSVGElementFromJson({
          element: 'path',
          curStyles: true,
          attr: {
            id: editorContext_$1.getId(),
            d: d,
            fill: 'none'
          }
        }); // No need to call "changed", as this is already done under mouseUp
      }

      return element;
    };

    return (
      /** @lends module:path.pathActions */
      {
        /**
        * @param {MouseEvent} evt
        * @param {Element} mouseTarget
        * @param {Float} startX
        * @param {Float} startY
        * @returns {boolean|void}
        */
        mouseDown: function mouseDown(evt, mouseTarget, startX, startY) {
          var id;

          if (editorContext_$1.getCurrentMode() === 'path') {
            var mouseX = startX; // Was this meant to work with the other `mouseX`? (was defined globally so adding `let` to at least avoid a global)

            var mouseY = startY; // Was this meant to work with the other `mouseY`? (was defined globally so adding `let` to at least avoid a global)

            var currentZoom = editorContext_$1.getCurrentZoom();
            var x = mouseX / currentZoom,
                y = mouseY / currentZoom,
                stretchy = getElem('path_stretch_line');
            newPoint = [x, y];

            if (editorContext_$1.getGridSnapping()) {
              x = snapToGrid(x);
              y = snapToGrid(y);
              mouseX = snapToGrid(mouseX);
              mouseY = snapToGrid(mouseY);
            }

            if (!stretchy) {
              stretchy = document.createElementNS(NS.SVG, 'path');
              assignAttributes(stretchy, {
                id: 'path_stretch_line',
                stroke: '#22C',
                'stroke-width': '0.5',
                fill: 'none'
              });
              stretchy = getElem('selectorParentGroup').appendChild(stretchy);
            }

            stretchy.setAttribute('display', 'inline');
            var keep = null;
            var index; // if pts array is empty, create path element with M at current point

            var drawnPath = editorContext_$1.getDrawnPath();

            if (!drawnPath) {
              var dAttr = 'M' + x + ',' + y + ' '; // Was this meant to work with the other `dAttr`? (was defined globally so adding `var` to at least avoid a global)

              /* drawnPath = */

              editorContext_$1.setDrawnPath(editorContext_$1.addSVGElementFromJson({
                element: 'path',
                curStyles: true,
                attr: {
                  d: dAttr,
                  id: editorContext_$1.getNextId(),
                  opacity: editorContext_$1.getOpacity() / 2
                }
              })); // set stretchy line to first point

              stretchy.setAttribute('d', ['M', mouseX, mouseY, mouseX, mouseY].join(' '));
              index = subpath ? path$1.segs.length : 0;
              addPointGrip(index, mouseX, mouseY);
            } else {
              // determine if we clicked on an existing point
              var seglist = drawnPath.pathSegList;
              var i = seglist.numberOfItems;
              var FUZZ = 6 / currentZoom;
              var clickOnPoint = false;

              while (i) {
                i--;
                var item = seglist.getItem(i);
                var px = item.x,
                    py = item.y; // found a matching point

                if (x >= px - FUZZ && x <= px + FUZZ && y >= py - FUZZ && y <= py + FUZZ) {
                  clickOnPoint = true;
                  break;
                }
              } // get path element that we are in the process of creating


              id = editorContext_$1.getId(); // Remove previous path object if previously created

              removePath_(id);
              var newpath = getElem(id);
              var newseg;
              var sSeg;
              var len = seglist.numberOfItems; // if we clicked on an existing point, then we are done this path, commit it
              // (i, i+1) are the x,y that were clicked on

              if (clickOnPoint) {
                // if clicked on any other point but the first OR
                // the first point was clicked on and there are less than 3 points
                // then leave the path open
                // otherwise, close the path
                if (i <= 1 && len >= 2) {
                  // Create end segment
                  var absX = seglist.getItem(0).x;
                  var absY = seglist.getItem(0).y;
                  sSeg = stretchy.pathSegList.getItem(1);

                  if (sSeg.pathSegType === 4) {
                    newseg = drawnPath.createSVGPathSegLinetoAbs(absX, absY);
                  } else {
                    newseg = drawnPath.createSVGPathSegCurvetoCubicAbs(absX, absY, sSeg.x1 / currentZoom, sSeg.y1 / currentZoom, absX, absY);
                  }

                  var endseg = drawnPath.createSVGPathSegClosePath();
                  seglist.appendItem(newseg);
                  seglist.appendItem(endseg);
                } else if (len < 3) {
                  keep = false;
                  return keep;
                }

                $$3(stretchy).remove(); // This will signal to commit the path
                // const element = newpath; // Other event handlers define own `element`, so this was probably not meant to interact with them or one which shares state (as there were none); I therefore adding a missing `var` to avoid a global

                /* drawnPath = */

                editorContext_$1.setDrawnPath(null);
                editorContext_$1.setStarted(false);

                if (subpath) {
                  if (path$1.matrix) {
                    editorContext_$1.remapElement(newpath, {}, path$1.matrix.inverse());
                  }

                  var newD = newpath.getAttribute('d');
                  var origD = $$3(path$1.elem).attr('d');
                  $$3(path$1.elem).attr('d', origD + newD);
                  $$3(newpath).remove();

                  if (path$1.matrix) {
                    recalcRotatedPath();
                  }

                  init$2();
                  pathActions.toEditMode(path$1.elem);
                  path$1.selectPt();
                  return false;
                } // else, create a new point, update path element

              } else {
                // Checks if current target or parents are #svgcontent
                if (!$$3.contains(editorContext_$1.getContainer(), editorContext_$1.getMouseTarget(evt))) {
                  // Clicked outside canvas, so don't make point
                  // console.log('Clicked outside canvas');
                  return false;
                }

                var num = drawnPath.pathSegList.numberOfItems;
                var last = drawnPath.pathSegList.getItem(num - 1);
                var lastx = last.x,
                    lasty = last.y;

                if (evt.shiftKey) {
                  var xya = snapToAngle(lastx, lasty, x, y);
                  x = xya.x;
                  y = xya.y;
                } // Use the segment defined by stretchy


                sSeg = stretchy.pathSegList.getItem(1);

                if (sSeg.pathSegType === 4) {
                  newseg = drawnPath.createSVGPathSegLinetoAbs(editorContext_$1.round(x), editorContext_$1.round(y));
                } else {
                  newseg = drawnPath.createSVGPathSegCurvetoCubicAbs(editorContext_$1.round(x), editorContext_$1.round(y), sSeg.x1 / currentZoom, sSeg.y1 / currentZoom, sSeg.x2 / currentZoom, sSeg.y2 / currentZoom);
                }

                drawnPath.pathSegList.appendItem(newseg);
                x *= currentZoom;
                y *= currentZoom; // set stretchy line to latest point

                stretchy.setAttribute('d', ['M', x, y, x, y].join(' '));
                index = num;

                if (subpath) {
                  index += path$1.segs.length;
                }

                addPointGrip(index, x, y);
              } // keep = true;

            }

            return undefined;
          } // TODO: Make sure currentPath isn't null at this point


          if (!path$1) {
            return undefined;
          }

          path$1.storeD();
          id = evt.target.id;
          var curPt;

          if (id.substr(0, 14) === 'pathpointgrip_') {
            // Select this point
            curPt = path$1.cur_pt = Number.parseInt(id.substr(14));
            path$1.dragging = [startX, startY];
            var seg = path$1.segs[curPt]; // only clear selection if shift is not pressed (otherwise, add
            // node to selection)

            if (!evt.shiftKey) {
              if (path$1.selected_pts.length <= 1 || !seg.selected) {
                path$1.clearSelection();
              }

              path$1.addPtsToSelection(curPt);
            } else if (seg.selected) {
              path$1.removePtFromSelection(curPt);
            } else {
              path$1.addPtsToSelection(curPt);
            }
          } else if (id.startsWith('ctrlpointgrip_')) {
            path$1.dragging = [startX, startY];
            var parts = id.split('_')[1].split('c');
            curPt = Number(parts[0]);
            var ctrlNum = Number(parts[1]);
            path$1.selectPt(curPt, ctrlNum);
          } // Start selection box


          if (!path$1.dragging) {
            var rubberBox = editorContext_$1.getRubberBox();

            if (isNullish(rubberBox)) {
              rubberBox = editorContext_$1.setRubberBox(editorContext_$1.selectorManager.getRubberBandBox());
            }

            var currentZoom = editorContext_$1.getCurrentZoom();
            assignAttributes(rubberBox, {
              x: startX * currentZoom,
              y: startY * currentZoom,
              width: 0,
              height: 0,
              display: 'inline'
            });
          }

          return undefined;
        },

        /**
        * @param {Float} mouseX
        * @param {Float} mouseY
        * @returns {void}
        */
        mouseMove: function mouseMove(mouseX, mouseY) {
          var currentZoom = editorContext_$1.getCurrentZoom();
          hasMoved = true;
          var drawnPath = editorContext_$1.getDrawnPath();

          if (editorContext_$1.getCurrentMode() === 'path') {
            if (!drawnPath) {
              return;
            }

            var seglist = drawnPath.pathSegList;
            var index = seglist.numberOfItems - 1;

            if (newPoint) {
              // First point
              // if (!index) { return; }
              // Set control points
              var pointGrip1 = addCtrlGrip('1c1');
              var pointGrip2 = addCtrlGrip('0c2'); // dragging pointGrip1

              pointGrip1.setAttribute('cx', mouseX);
              pointGrip1.setAttribute('cy', mouseY);
              pointGrip1.setAttribute('display', 'inline');
              var ptX = newPoint[0];
              var ptY = newPoint[1]; // set curve
              // const seg = seglist.getItem(index);

              var curX = mouseX / currentZoom;
              var curY = mouseY / currentZoom;
              var altX = ptX + (ptX - curX);
              var altY = ptY + (ptY - curY);
              pointGrip2.setAttribute('cx', altX * currentZoom);
              pointGrip2.setAttribute('cy', altY * currentZoom);
              pointGrip2.setAttribute('display', 'inline');
              var ctrlLine = getCtrlLine(1);
              assignAttributes(ctrlLine, {
                x1: mouseX,
                y1: mouseY,
                x2: altX * currentZoom,
                y2: altY * currentZoom,
                display: 'inline'
              });

              if (index === 0) {
                firstCtrl = [mouseX, mouseY];
              } else {
                var last = seglist.getItem(index - 1);
                var lastX = last.x;
                var lastY = last.y;

                if (last.pathSegType === 6) {
                  lastX += lastX - last.x2;
                  lastY += lastY - last.y2;
                } else if (firstCtrl) {
                  lastX = firstCtrl[0] / currentZoom;
                  lastY = firstCtrl[1] / currentZoom;
                }

                replacePathSeg(6, index, [ptX, ptY, lastX, lastY, altX, altY], drawnPath);
              }
            } else {
              var stretchy = getElem('path_stretch_line');

              if (stretchy) {
                var prev = seglist.getItem(index);

                if (prev.pathSegType === 6) {
                  var prevX = prev.x + (prev.x - prev.x2);
                  var prevY = prev.y + (prev.y - prev.y2);
                  replacePathSeg(6, 1, [mouseX, mouseY, prevX * currentZoom, prevY * currentZoom, mouseX, mouseY], stretchy);
                } else if (firstCtrl) {
                  replacePathSeg(6, 1, [mouseX, mouseY, firstCtrl[0], firstCtrl[1], mouseX, mouseY], stretchy);
                } else {
                  replacePathSeg(4, 1, [mouseX, mouseY], stretchy);
                }
              }
            }

            return;
          } // if we are dragging a point, let's move it


          if (path$1.dragging) {
            var pt = getPointFromGrip({
              x: path$1.dragging[0],
              y: path$1.dragging[1]
            }, path$1);
            var mpt = getPointFromGrip({
              x: mouseX,
              y: mouseY
            }, path$1);
            var diffX = mpt.x - pt.x;
            var diffY = mpt.y - pt.y;
            path$1.dragging = [mouseX, mouseY];

            if (path$1.dragctrl) {
              path$1.moveCtrl(diffX, diffY);
            } else {
              path$1.movePts(diffX, diffY);
            }
          } else {
            path$1.selected_pts = [];
            path$1.eachSeg(function (i) {
              var seg = this;

              if (!seg.next && !seg.prev) {
                return;
              } // const {item} = seg;


              var rubberBox = editorContext_$1.getRubberBox();
              var rbb = rubberBox.getBBox();
              var pt = getGripPt(seg);
              var ptBb = {
                x: pt.x,
                y: pt.y,
                width: 0,
                height: 0
              };
              var sel = rectsIntersect(rbb, ptBb);
              this.select(sel); // Note that addPtsToSelection is not being run

              if (sel) {
                path$1.selected_pts.push(seg.index);
              }
            });
          }
        },

        /**
         * @typedef module:path.keepElement
         * @type {PlainObject}
         * @property {boolean} keep
         * @property {Element} element
         */

        /**
        * @param {Event} evt
        * @param {Element} element
        * @param {Float} mouseX
        * @param {Float} mouseY
        * @returns {module:path.keepElement|void}
        */
        mouseUp: function mouseUp(evt, element, mouseX, mouseY) {
          var drawnPath = editorContext_$1.getDrawnPath(); // Create mode

          if (editorContext_$1.getCurrentMode() === 'path') {
            newPoint = null;

            if (!drawnPath) {
              element = getElem(editorContext_$1.getId());
              editorContext_$1.setStarted(false);
              firstCtrl = null;
            }

            return {
              keep: true,
              element: element
            };
          } // Edit mode


          var rubberBox = editorContext_$1.getRubberBox();

          if (path$1.dragging) {
            var lastPt = path$1.cur_pt;
            path$1.dragging = false;
            path$1.dragctrl = false;
            path$1.update();

            if (hasMoved) {
              path$1.endChanges('Move path point(s)');
            }

            if (!evt.shiftKey && !hasMoved) {
              path$1.selectPt(lastPt);
            }
          } else if (rubberBox && rubberBox.getAttribute('display') !== 'none') {
            // Done with multi-node-select
            rubberBox.setAttribute('display', 'none');

            if (rubberBox.getAttribute('width') <= 2 && rubberBox.getAttribute('height') <= 2) {
              pathActions.toSelectMode(evt.target);
            } // else, move back to select mode

          } else {
            pathActions.toSelectMode(evt.target);
          }

          hasMoved = false;
          return undefined;
        },

        /**
        * @param {Element} element
        * @returns {void}
        */
        toEditMode: function toEditMode(element) {
          path$1 = getPath_(element);
          editorContext_$1.setCurrentMode('pathedit');
          editorContext_$1.clearSelection();
          path$1.show(true).update();
          path$1.oldbbox = getBBox(path$1.elem);
          subpath = false;
        },

        /**
        * @param {Element} elem
        * @fires module:svgcanvas.SvgCanvas#event:selected
        * @returns {void}
        */
        toSelectMode: function toSelectMode(elem) {
          var selPath = elem === path$1.elem;
          editorContext_$1.setCurrentMode('select');
          path$1.show(false);
          currentPath = false;
          editorContext_$1.clearSelection();

          if (path$1.matrix) {
            // Rotated, so may need to re-calculate the center
            recalcRotatedPath();
          }

          if (selPath) {
            editorContext_$1.call('selected', [elem]);
            editorContext_$1.addToSelection([elem], true);
          }
        },

        /**
        * @param {boolean} on
        * @returns {void}
        */
        addSubPath: function addSubPath(on) {
          if (on) {
            // Internally we go into "path" mode, but in the UI it will
            // still appear as if in "pathedit" mode.
            editorContext_$1.setCurrentMode('path');
            subpath = true;
          } else {
            pathActions.clear(true);
            pathActions.toEditMode(path$1.elem);
          }
        },

        /**
        * @param {Element} target
        * @returns {void}
        */
        select: function select(target) {
          if (currentPath === target) {
            pathActions.toEditMode(target);
            editorContext_$1.setCurrentMode('pathedit'); // going into pathedit mode
          } else {
            currentPath = target;
          }
        },

        /**
        * @fires module:svgcanvas.SvgCanvas#event:changed
        * @returns {void}
        */
        reorient: function reorient() {
          var elem = editorContext_$1.getSelectedElements()[0];

          if (!elem) {
            return;
          }

          var angl = getRotationAngle(elem);

          if (angl === 0) {
            return;
          }

          var batchCmd = new BatchCommand('Reorient path');
          var changes = {
            d: elem.getAttribute('d'),
            transform: elem.getAttribute('transform')
          };
          batchCmd.addSubCommand(new ChangeElementCommand(elem, changes));
          editorContext_$1.clearSelection();
          this.resetOrientation(elem);
          editorContext_$1.addCommandToHistory(batchCmd); // Set matrix to null

          getPath_(elem).show(false).matrix = null;
          this.clear();
          editorContext_$1.addToSelection([elem], true);
          editorContext_$1.call('changed', editorContext_$1.getSelectedElements());
        },

        /**
        * @param {boolean} remove Not in use
        * @returns {void}
        */
        clear: function clear(remove) {
          var drawnPath = editorContext_$1.getDrawnPath();
          currentPath = null;

          if (drawnPath) {
            var elem = getElem(editorContext_$1.getId());
            $$3(getElem('path_stretch_line')).remove();
            $$3(elem).remove();
            $$3(getElem('pathpointgrip_container')).find('*').attr('display', 'none');
            firstCtrl = null;
            editorContext_$1.setDrawnPath(null);
            editorContext_$1.setStarted(false);
          } else if (editorContext_$1.getCurrentMode() === 'pathedit') {
            this.toSelectMode();
          }

          if (path$1) {
            path$1.init().show(false);
          }
        },

        /**
        * @param {?(Element|SVGPathElement)} pth
        * @returns {false|void}
        */
        resetOrientation: function resetOrientation(pth) {
          if (isNullish(pth) || pth.nodeName !== 'path') {
            return false;
          }

          var tlist = getTransformList(pth);
          var m = transformListToTransform(tlist).matrix;
          tlist.clear();
          pth.removeAttribute('transform');
          var segList = pth.pathSegList; // Opera/win/non-EN throws an error here.
          // TODO: Find out why!
          // Presumed fixed in Opera 10.5, so commented out for now
          // try {

          var len = segList.numberOfItems; // } catch(err) {
          //   const fixed_d = pathActions.convertPath(pth);
          //   pth.setAttribute('d', fixed_d);
          //   segList = pth.pathSegList;
          //   const len = segList.numberOfItems;
          // }
          // let lastX, lastY;

          var _loop = function _loop(i) {
            var seg = segList.getItem(i);
            var type = seg.pathSegType;

            if (type === 1) {
              return "continue";
            }

            var pts = [];
            $$3.each(['', 1, 2], function (j, n) {
              var x = seg['x' + n],
                  y = seg['y' + n];

              if (x !== undefined && y !== undefined) {
                var pt = transformPoint(x, y, m);
                pts.splice(pts.length, 0, pt.x, pt.y);
              }
            });
            replacePathSeg(type, i, pts, pth);
          };

          for (var i = 0; i < len; ++i) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          }

          reorientGrads(pth, m);
          return undefined;
        },

        /**
        * @returns {void}
        */
        zoomChange: function zoomChange() {
          if (editorContext_$1.getCurrentMode() === 'pathedit') {
            path$1.update();
          }
        },

        /**
        * @typedef {PlainObject} module:path.NodePoint
        * @property {Float} x
        * @property {Float} y
        * @property {Integer} type
        */

        /**
        * @returns {module:path.NodePoint}
        */
        getNodePoint: function getNodePoint() {
          var selPt = path$1.selected_pts.length ? path$1.selected_pts[0] : 1;
          var seg = path$1.segs[selPt];
          return {
            x: seg.item.x,
            y: seg.item.y,
            type: seg.type
          };
        },

        /**
        * @param {boolean} linkPoints
        * @returns {void}
        */
        linkControlPoints: function linkControlPoints(linkPoints) {
          setLinkControlPoints(linkPoints);
        },

        /**
        * @returns {void}
        */
        clonePathNode: function clonePathNode() {
          path$1.storeD();
          var selPts = path$1.selected_pts; // const {segs} = path;

          var i = selPts.length;
          var nums = [];

          while (i--) {
            var pt = selPts[i];
            path$1.addSeg(pt);
            nums.push(pt + i);
            nums.push(pt + i + 1);
          }

          path$1.init().addPtsToSelection(nums);
          path$1.endChanges('Clone path node(s)');
        },

        /**
        * @returns {void}
        */
        opencloseSubPath: function opencloseSubPath() {
          var selPts = path$1.selected_pts; // Only allow one selected node for now

          if (selPts.length !== 1) {
            return;
          }

          var _path = path$1,
              elem = _path.elem;
          var list = elem.pathSegList; // const len = list.numberOfItems;

          var index = selPts[0];
          var openPt = null;
          var startItem = null; // Check if subpath is already open

          path$1.eachSeg(function (i) {
            if (this.type === 2 && i <= index) {
              startItem = this.item;
            }

            if (i <= index) {
              return true;
            }

            if (this.type === 2) {
              // Found M first, so open
              openPt = i;
              return false;
            }

            if (this.type === 1) {
              // Found Z first, so closed
              openPt = false;
              return false;
            }

            return true;
          });

          if (isNullish(openPt)) {
            // Single path, so close last seg
            openPt = path$1.segs.length - 1;
          }

          if (openPt !== false) {
            // Close this path
            // Create a line going to the previous "M"
            var newseg = elem.createSVGPathSegLinetoAbs(startItem.x, startItem.y);
            var closer = elem.createSVGPathSegClosePath();

            if (openPt === path$1.segs.length - 1) {
              list.appendItem(newseg);
              list.appendItem(closer);
            } else {
              insertItemBefore(elem, closer, openPt);
              insertItemBefore(elem, newseg, openPt);
            }

            path$1.init().selectPt(openPt + 1);
            return;
          } // M 1,1 L 2,2 L 3,3 L 1,1 z // open at 2,2
          // M 2,2 L 3,3 L 1,1
          // M 1,1 L 2,2 L 1,1 z M 4,4 L 5,5 L6,6 L 5,5 z
          // M 1,1 L 2,2 L 1,1 z [M 4,4] L 5,5 L(M)6,6 L 5,5 z


          var seg = path$1.segs[index];

          if (seg.mate) {
            list.removeItem(index); // Removes last "L"

            list.removeItem(index); // Removes the "Z"

            path$1.init().selectPt(index - 1);
            return;
          }

          var lastM, zSeg; // Find this sub-path's closing point and remove

          for (var i = 0; i < list.numberOfItems; i++) {
            var item = list.getItem(i);

            if (item.pathSegType === 2) {
              // Find the preceding M
              lastM = i;
            } else if (i === index) {
              // Remove it
              list.removeItem(lastM); // index--;
            } else if (item.pathSegType === 1 && index < i) {
              // Remove the closing seg of this subpath
              zSeg = i - 1;
              list.removeItem(i);
              break;
            }
          }

          var num = index - lastM - 1;

          while (num--) {
            insertItemBefore(elem, list.getItem(lastM), zSeg);
          }

          var pt = list.getItem(lastM); // Make this point the new "M"

          replacePathSeg(2, lastM, [pt.x, pt.y]); // i = index; // i is local here, so has no effect; what was the intent for this?

          path$1.init().selectPt(0);
        },

        /**
        * @returns {void}
        */
        deletePathNode: function deletePathNode() {
          if (!pathActions.canDeleteNodes) {
            return;
          }

          path$1.storeD();
          var selPts = path$1.selected_pts;
          var i = selPts.length;

          while (i--) {
            var pt = selPts[i];
            path$1.deleteSeg(pt);
          } // Cleanup


          var cleanup = function cleanup() {
            var segList = path$1.elem.pathSegList;
            var len = segList.numberOfItems;

            var remItems = function remItems(pos, count) {
              while (count--) {
                segList.removeItem(pos);
              }
            };

            if (len <= 1) {
              return true;
            }

            while (len--) {
              var item = segList.getItem(len);

              if (item.pathSegType === 1) {
                var prev = segList.getItem(len - 1);
                var nprev = segList.getItem(len - 2);

                if (prev.pathSegType === 2) {
                  remItems(len - 1, 2);
                  cleanup();
                  break;
                } else if (nprev.pathSegType === 2) {
                  remItems(len - 2, 3);
                  cleanup();
                  break;
                }
              } else if (item.pathSegType === 2) {
                if (len > 0) {
                  var prevType = segList.getItem(len - 1).pathSegType; // Path has M M

                  if (prevType === 2) {
                    remItems(len - 1, 1);
                    cleanup();
                    break; // Entire path ends with Z M
                  } else if (prevType === 1 && segList.numberOfItems - 1 === len) {
                    remItems(len, 1);
                    cleanup();
                    break;
                  }
                }
              }
            }

            return false;
          };

          cleanup(); // Completely delete a path with 1 or 0 segments

          if (path$1.elem.pathSegList.numberOfItems <= 1) {
            pathActions.toSelectMode(path$1.elem);
            editorContext_$1.canvas.deleteSelectedElements();
            return;
          }

          path$1.init();
          path$1.clearSelection(); // TODO: Find right way to select point now
          // path.selectPt(selPt);

          if (window.opera) {
            // Opera repaints incorrectly
            var cp = $$3(path$1.elem);
            cp.attr('d', cp.attr('d'));
          }

          path$1.endChanges('Delete path node(s)');
        },

        /* eslint-disable jsdoc/require-returns */
        // Can't seem to use `@borrows` here, so using `@see`

        /**
        * Smooth polyline into path.
        * @function module:path.pathActions.smoothPolylineIntoPath
        * @see module:path~smoothPolylineIntoPath
        */
        smoothPolylineIntoPath: smoothPolylineIntoPath,

        /* eslint-enable jsdoc/require-returns */

        /**
        * @param {?Integer} v See {@link https://www.w3.org/TR/SVG/single-page.html#paths-InterfaceSVGPathSeg}
        * @returns {void}
        */
        setSegType: function setSegType(v) {
          path$1.setSegType(v);
        },

        /**
        * @param {string} attr
        * @param {Float} newValue
        * @returns {void}
        */
        moveNode: function moveNode(attr, newValue) {
          var selPts = path$1.selected_pts;

          if (!selPts.length) {
            return;
          }

          path$1.storeD(); // Get first selected point

          var seg = path$1.segs[selPts[0]];
          var diff = {
            x: 0,
            y: 0
          };
          diff[attr] = newValue - seg.item[attr];
          seg.move(diff.x, diff.y);
          path$1.endChanges('Move path point');
        },

        /**
        * @param {Element} elem
        * @returns {void}
        */
        fixEnd: function fixEnd(elem) {
          // Adds an extra segment if the last seg before a Z doesn't end
          // at its M point
          // M0,0 L0,100 L100,100 z
          var segList = elem.pathSegList;
          var len = segList.numberOfItems;
          var lastM;

          for (var i = 0; i < len; ++i) {
            var item = segList.getItem(i);

            if (item.pathSegType === 2) {
              lastM = item;
            }

            if (item.pathSegType === 1) {
              var prev = segList.getItem(i - 1);

              if (prev.x !== lastM.x || prev.y !== lastM.y) {
                // Add an L segment here
                var newseg = elem.createSVGPathSegLinetoAbs(lastM.x, lastM.y);
                insertItemBefore(elem, newseg, i); // Can this be done better?

                pathActions.fixEnd(elem);
                break;
              }
            }
          }

          if (isWebkit()) {
            editorContext_$1.resetD(elem);
          }
        },

        /* eslint-disable jsdoc/require-returns */
        // Can't seem to use `@borrows` here, so using `@see`

        /**
        * Convert a path to one with only absolute or relative values.
        * @function module:path.pathActions.convertPath
        * @see module:path.convertPath
        */
        convertPath: convertPath
        /* eslint-enable jsdoc/require-returns */

      }
    );
  }(); // end pathActions

  var $$4 = jQuery;
  /**
   * This class encapsulates the concept of a layer in the drawing. It can be constructed with
   * an existing group element or, with three parameters, will create a new layer group element.
   *
   * @example
   * const l1 = new Layer('name', group); // Use the existing group for this layer.
   * const l2 = new Layer('name', group, svgElem); // Create a new group and add it to the DOM after group.
   * const l3 = new Layer('name', null, svgElem); // Create a new group and add it to the DOM as the last layer.
   * @memberof module:layer
   */

  var Layer = /*#__PURE__*/function () {
    /**
    * @param {string} name - Layer name
    * @param {SVGGElement|null} group - An existing SVG group element or null.
    *     If group and no svgElem, use group for this layer.
    *     If group and svgElem, create a new group element and insert it in the DOM after group.
    *     If no group and svgElem, create a new group element and insert it in the DOM as the last layer.
    * @param {SVGGElement} [svgElem] - The SVG DOM element. If defined, use this to add
    *     a new layer to the document.
    */
    function Layer(name, group, svgElem) {
      _classCallCheck(this, Layer);

      this.name_ = name;
      this.group_ = svgElem ? null : group;

      if (svgElem) {
        // Create a group element with title and add it to the DOM.
        var svgdoc = svgElem.ownerDocument;
        this.group_ = svgdoc.createElementNS(NS.SVG, 'g');
        var layerTitle = svgdoc.createElementNS(NS.SVG, 'title');
        layerTitle.textContent = name;
        this.group_.append(layerTitle);

        if (group) {
          $$4(group).after(this.group_);
        } else {
          svgElem.append(this.group_);
        }
      }

      addLayerClass(this.group_);
      walkTree(this.group_, function (e) {
        e.setAttribute('style', 'pointer-events:inherit');
      });
      this.group_.setAttribute('style', svgElem ? 'pointer-events:all' : 'pointer-events:none');
    }
    /**
     * Get the layer's name.
     * @returns {string} The layer name
     */


    _createClass(Layer, [{
      key: "getName",
      value: function getName() {
        return this.name_;
      }
      /**
       * Get the group element for this layer.
       * @returns {SVGGElement} The layer SVG group
       */

    }, {
      key: "getGroup",
      value: function getGroup() {
        return this.group_;
      }
      /**
       * Active this layer so it takes pointer events.
       * @returns {void}
       */

    }, {
      key: "activate",
      value: function activate() {
        this.group_.setAttribute('style', 'pointer-events:all');
      }
      /**
       * Deactive this layer so it does NOT take pointer events.
       * @returns {void}
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        this.group_.setAttribute('style', 'pointer-events:none');
      }
      /**
       * Set this layer visible or hidden based on 'visible' parameter.
       * @param {boolean} visible - If true, make visible; otherwise, hide it.
       * @returns {void}
       */

    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        var expected = visible === undefined || visible ? 'inline' : 'none';
        var oldDisplay = this.group_.getAttribute('display');

        if (oldDisplay !== expected) {
          this.group_.setAttribute('display', expected);
        }
      }
      /**
       * Is this layer visible?
       * @returns {boolean} True if visible.
       */

    }, {
      key: "isVisible",
      value: function isVisible() {
        return this.group_.getAttribute('display') !== 'none';
      }
      /**
       * Get layer opacity.
       * @returns {Float} Opacity value.
       */

    }, {
      key: "getOpacity",
      value: function getOpacity() {
        var opacity = this.group_.getAttribute('opacity');

        if (isNullish(opacity)) {
          return 1;
        }

        return Number.parseFloat(opacity);
      }
      /**
       * Sets the opacity of this layer. If opacity is not a value between 0.0 and 1.0,
       * nothing happens.
       * @param {Float} opacity - A float value in the range 0.0-1.0
       * @returns {void}
       */

    }, {
      key: "setOpacity",
      value: function setOpacity(opacity) {
        if (typeof opacity === 'number' && opacity >= 0.0 && opacity <= 1.0) {
          this.group_.setAttribute('opacity', opacity);
        }
      }
      /**
       * Append children to this layer.
       * @param {SVGGElement} children - The children to append to this layer.
       * @returns {void}
       */

    }, {
      key: "appendChildren",
      value: function appendChildren(children) {
        var _iterator = _createForOfIteratorHelper(children),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            this.group_.append(child);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      /**
      * @returns {SVGTitleElement|null}
      */

    }, {
      key: "getTitleElement",
      value: function getTitleElement() {
        var len = this.group_.childNodes.length;

        for (var i = 0; i < len; ++i) {
          var child = this.group_.childNodes.item(i);

          if (child && child.tagName === 'title') {
            return child;
          }
        }

        return null;
      }
      /**
       * Set the name of this layer.
       * @param {string} name - The new name.
       * @param {module:history.HistoryRecordingService} hrService - History recording service
       * @returns {string|null} The new name if changed; otherwise, null.
       */

    }, {
      key: "setName",
      value: function setName(name, hrService) {
        var previousName = this.name_;
        name = toXml(name); // now change the underlying title element contents

        var title = this.getTitleElement();

        if (title) {
          $$4(title).empty();
          title.textContent = name;
          this.name_ = name;

          if (hrService) {
            hrService.changeElement(title, {
              '#text': previousName
            });
          }

          return this.name_;
        }

        return null;
      }
      /**
       * Remove this layer's group from the DOM. No more functions on group can be called after this.
       * @returns {SVGGElement} The layer SVG group that was just removed.
       */

    }, {
      key: "removeGroup",
      value: function removeGroup() {
        var group = this.group_;
        this.group_.remove();
        this.group_ = undefined;
        return group;
      }
    }]);

    return Layer;
  }();
  /**
   * @property {string} CLASS_NAME - class attribute assigned to all layer groups.
   */


  Layer.CLASS_NAME = 'layer';
  /**
   * @property {RegExp} CLASS_REGEX - Used to test presence of class Layer.CLASS_NAME
   */

  Layer.CLASS_REGEX = new RegExp('(\\s|^)' + Layer.CLASS_NAME + '(\\s|$)');
  /**
   * Add class `Layer.CLASS_NAME` to the element (usually `class='layer'`).
   *
   * @param {SVGGElement} elem - The SVG element to update
   * @returns {void}
   */

  function addLayerClass(elem) {
    var classes = elem.getAttribute('class');

    if (isNullish(classes) || !classes.length) {
      elem.setAttribute('class', Layer.CLASS_NAME);
    } else if (!Layer.CLASS_REGEX.test(classes)) {
      elem.setAttribute('class', classes + ' ' + Layer.CLASS_NAME);
    }
  }

  /**
   * History recording service.
   *
   * A self-contained service interface for recording history. Once injected, no other dependencies
   * or globals are required (example: UndoManager, command types, etc.). Easy to mock for unit tests.
   * Built on top of history classes in history.js.
   *
   * There is a simple start/end interface for batch commands.
   *
   * HistoryRecordingService.NO_HISTORY is a singleton that can be passed in to functions
   * that record history. This helps when the caller requires that no history be recorded.
   *
   * The following will record history: insert, batch, insert.
   * @example
   * hrService = new HistoryRecordingService(this.undoMgr);
   * hrService.insertElement(elem, text); // add simple command to history.
   * hrService.startBatchCommand('create two elements');
   * hrService.changeElement(elem, attrs, text); // add to batchCommand
   * hrService.changeElement(elem, attrs2, text); // add to batchCommand
   * hrService.endBatchCommand(); // add batch command with two change commands to history.
   * hrService.insertElement(elem, text); // add simple command to history.
   *
   * @example
   * // Note that all functions return this, so commands can be chained, like so:
   * hrService
   *   .startBatchCommand('create two elements')
   *   .insertElement(elem, text)
   *   .changeElement(elem, attrs, text)
   *   .endBatchCommand();
   *
   * @memberof module:history
   */

  var HistoryRecordingService = /*#__PURE__*/function () {
    /**
    * @param {history.UndoManager|null} undoManager - The undo manager.
    *     A value of `null` is valid for cases where no history recording is required.
    *     See singleton: {@link module:history.HistoryRecordingService.HistoryRecordingService.NO_HISTORY}
    */
    function HistoryRecordingService(undoManager) {
      _classCallCheck(this, HistoryRecordingService);

      this.undoManager_ = undoManager;
      this.currentBatchCommand_ = null;
      this.batchCommandStack_ = [];
    }
    /**
     * Start a batch command so multiple commands can recorded as a single history command.
     * Requires a corresponding call to endBatchCommand. Start and end commands can be nested.
     *
     * @param {string} text - Optional string describing the batch command.
     * @returns {module:history.HistoryRecordingService}
     */


    _createClass(HistoryRecordingService, [{
      key: "startBatchCommand",
      value: function startBatchCommand(text) {
        if (!this.undoManager_) {
          return this;
        }

        this.currentBatchCommand_ = new BatchCommand(text);
        this.batchCommandStack_.push(this.currentBatchCommand_);
        return this;
      }
      /**
       * End a batch command and add it to the history or a parent batch command.
       * @returns {module:history.HistoryRecordingService}
       */

    }, {
      key: "endBatchCommand",
      value: function endBatchCommand() {
        if (!this.undoManager_) {
          return this;
        }

        if (this.currentBatchCommand_) {
          var batchCommand = this.currentBatchCommand_;
          this.batchCommandStack_.pop();
          var len = this.batchCommandStack_.length;
          this.currentBatchCommand_ = len ? this.batchCommandStack_[len - 1] : null;
          this.addCommand_(batchCommand);
        }

        return this;
      }
      /**
       * Add a `MoveElementCommand` to the history or current batch command.
       * @param {Element} elem - The DOM element that was moved
       * @param {Element} oldNextSibling - The element's next sibling before it was moved
       * @param {Element} oldParent - The element's parent before it was moved
       * @param {string} [text] - An optional string visible to user related to this change
       * @returns {module:history.HistoryRecordingService}
       */

    }, {
      key: "moveElement",
      value: function moveElement(elem, oldNextSibling, oldParent, text) {
        if (!this.undoManager_) {
          return this;
        }

        this.addCommand_(new MoveElementCommand(elem, oldNextSibling, oldParent, text));
        return this;
      }
      /**
       * Add an `InsertElementCommand` to the history or current batch command.
       * @param {Element} elem - The DOM element that was added
       * @param {string} [text] - An optional string visible to user related to this change
       * @returns {module:history.HistoryRecordingService}
       */

    }, {
      key: "insertElement",
      value: function insertElement(elem, text) {
        if (!this.undoManager_) {
          return this;
        }

        this.addCommand_(new InsertElementCommand(elem, text));
        return this;
      }
      /**
       * Add a `RemoveElementCommand` to the history or current batch command.
       * @param {Element} elem - The DOM element that was removed
       * @param {Element} oldNextSibling - The element's next sibling before it was removed
       * @param {Element} oldParent - The element's parent before it was removed
       * @param {string} [text] - An optional string visible to user related to this change
       * @returns {module:history.HistoryRecordingService}
       */

    }, {
      key: "removeElement",
      value: function removeElement(elem, oldNextSibling, oldParent, text) {
        if (!this.undoManager_) {
          return this;
        }

        this.addCommand_(new RemoveElementCommand(elem, oldNextSibling, oldParent, text));
        return this;
      }
      /**
       * Add a `ChangeElementCommand` to the history or current batch command.
       * @param {Element} elem - The DOM element that was changed
       * @param {module:history.CommandAttributes} attrs - An object with the attributes to be changed and the values they had *before* the change
       * @param {string} [text] - An optional string visible to user related to this change
       * @returns {module:history.HistoryRecordingService}
       */

    }, {
      key: "changeElement",
      value: function changeElement(elem, attrs, text) {
        if (!this.undoManager_) {
          return this;
        }

        this.addCommand_(new ChangeElementCommand(elem, attrs, text));
        return this;
      }
      /**
       * Private function to add a command to the history or current batch command.
       * @private
       * @param {Command} cmd
       * @returns {module:history.HistoryRecordingService|void}
       */

    }, {
      key: "addCommand_",
      value: function addCommand_(cmd) {
        if (!this.undoManager_) {
          return this;
        }

        if (this.currentBatchCommand_) {
          this.currentBatchCommand_.addSubCommand(cmd);
        } else {
          this.undoManager_.addCommandToHistory(cmd);
        }

        return undefined;
      }
    }]);

    return HistoryRecordingService;
  }();
  /**
   * @memberof module:history.HistoryRecordingService
   * @property {module:history.HistoryRecordingService} NO_HISTORY - Singleton that can be passed to functions that record history, but the caller requires that no history be recorded.
   */


  HistoryRecordingService.NO_HISTORY = new HistoryRecordingService();

  /* globals jQuery */

  var $$5 = jQueryPluginSVG(jQuery);
  /**
   * Create a clone of an element, updating its ID and its children's IDs when needed.
   * @function module:utilities.copyElem
   * @param {Element} el - DOM element to clone
   * @param {module:utilities.GetNextID} getNextId - The getter of the next unique ID.
   * @returns {Element} The cloned element
   */

  var copyElem = function copyElem(el, getNextId) {
    // manually create a copy of the element
    var newEl = document.createElementNS(el.namespaceURI, el.nodeName);
    $$5.each(el.attributes, function (i, attr) {
      if (attr.localName !== '-moz-math-font-style') {
        newEl.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.value);
      }
    }); // set the copied element's new id

    newEl.removeAttribute('id');
    newEl.id = getNextId(); // Opera's "d" value needs to be reset for Opera/Win/non-EN
    // Also needed for webkit (else does not keep curved segments on clone)

    if (isWebkit() && el.nodeName === 'path') {
      var fixedD = convertPath(el);
      newEl.setAttribute('d', fixedD);
    } // now create copies of all children


    $$5.each(el.childNodes, function (i, child) {
      switch (child.nodeType) {
        case 1:
          // element node
          newEl.append(copyElem(child, getNextId));
          break;

        case 3:
          // text node
          newEl.textContent = child.nodeValue;
          break;
      }
    });

    if ($$5(el).data('gsvg')) {
      $$5(newEl).data('gsvg', newEl.firstChild);
    } else if ($$5(el).data('symbol')) {
      var ref = $$5(el).data('symbol');
      $$5(newEl).data('ref', ref).data('symbol', ref);
    } else if (newEl.tagName === 'image') {
      preventClickDefault(newEl);
    }

    return newEl;
  };

  var $$6 = jQuery;
  var visElems$1 = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use'.split(',');
  var RandomizeModes = {
    LET_DOCUMENT_DECIDE: 0,
    ALWAYS_RANDOMIZE: 1,
    NEVER_RANDOMIZE: 2
  };
  var randIds = RandomizeModes.LET_DOCUMENT_DECIDE; // Array with current disabled elements (for in-group editing)

  var disabledElems = [];
  /**
   * Get a HistoryRecordingService.
   * @param {module:history.HistoryRecordingService} [hrService] - if exists, return it instead of creating a new service.
   * @returns {module:history.HistoryRecordingService}
   */

  function historyRecordingService(hrService) {
    return hrService || new HistoryRecordingService(canvas_.undoMgr);
  }
  /**
   * Find the layer name in a group element.
   * @param {Element} group The group element to search in.
   * @returns {string} The layer name or empty string.
   */


  function findLayerNameInGroup(group) {
    return $$6('title', group).text() || (isOpera() && group.querySelectorAll // Hack for Opera 10.60
    ? $$6(group.querySelectorAll('title')).text() : '');
  }
  /**
   * Given a set of names, return a new unique name.
   * @param {string[]} existingLayerNames - Existing layer names.
   * @returns {string} - The new name.
   */


  function getNewLayerName(existingLayerNames) {
    var i = 1; // TODO(codedread): What about internationalization of "Layer"?

    while (existingLayerNames.includes('Layer ' + i)) {
      i++;
    }

    return 'Layer ' + i;
  }
  /**
   * This class encapsulates the concept of a SVG-edit drawing.
   */


  var Drawing = /*#__PURE__*/function () {
    /**
    * @param {SVGSVGElement} svgElem - The SVG DOM Element that this JS object
    *     encapsulates.  If the svgElem has a se:nonce attribute on it, then
    *     IDs will use the nonce as they are generated.
    * @param {string} [optIdPrefix=svg_] - The ID prefix to use.
    * @throws {Error} If not initialized with an SVG element
    */
    function Drawing(svgElem, optIdPrefix) {
      _classCallCheck(this, Drawing);

      if (!svgElem || !svgElem.tagName || !svgElem.namespaceURI || svgElem.tagName !== 'svg' || svgElem.namespaceURI !== NS.SVG) {
        throw new Error('Error: svgedit.draw.Drawing instance initialized without a <svg> element');
      }
      /**
      * The SVG DOM Element that represents this drawing.
      * @type {SVGSVGElement}
      */


      this.svgElem_ = svgElem;
      /**
      * The latest object number used in this drawing.
      * @type {Integer}
      */

      this.obj_num = 0;
      /**
      * The prefix to prepend to each element id in the drawing.
      * @type {string}
      */

      this.idPrefix = optIdPrefix || 'svg_';
      /**
      * An array of released element ids to immediately reuse.
      * @type {Integer[]}
      */

      this.releasedNums = [];
      /**
      * The z-ordered array of Layer objects. Each layer has a name
      * and group element.
      * The first layer is the one at the bottom of the rendering.
      * @type {Layer[]}
      */

      this.all_layers = [];
      /**
      * Map of all_layers by name.
      *
      * Note: Layers are ordered, but referenced externally by name; so, we need both container
      * types depending on which function is called (i.e. all_layers and layer_map).
      *
      * @type {PlainObject<string, Layer>}
      */

      this.layer_map = {};
      /**
      * The current layer being used.
      * @type {Layer}
      */

      this.current_layer = null;
      /**
      * The nonce to use to uniquely identify elements across drawings.
      * @type {!string}
      */

      this.nonce_ = '';
      var n = this.svgElem_.getAttributeNS(NS.SE, 'nonce'); // If already set in the DOM, use the nonce throughout the document
      // else, if randomizeIds(true) has been called, create and set the nonce.

      if (n && randIds !== RandomizeModes.NEVER_RANDOMIZE) {
        this.nonce_ = n;
      } else if (randIds === RandomizeModes.ALWAYS_RANDOMIZE) {
        this.setNonce(Math.floor(Math.random() * 100001));
      }
    }
    /**
     * @param {string} id Element ID to retrieve
     * @returns {Element} SVG element within the root SVGSVGElement
    */


    _createClass(Drawing, [{
      key: "getElem_",
      value: function getElem_(id) {
        if (this.svgElem_.querySelector) {
          // querySelector lookup
          return this.svgElem_.querySelector('#' + id);
        } // jQuery lookup: twice as slow as xpath in FF


        return $$6(this.svgElem_).find('[id=' + id + ']')[0];
      }
      /**
       * @returns {SVGSVGElement}
       */

    }, {
      key: "getSvgElem",
      value: function getSvgElem() {
        return this.svgElem_;
      }
      /**
       * @returns {!(string|Integer)} The previously set nonce
       */

    }, {
      key: "getNonce",
      value: function getNonce() {
        return this.nonce_;
      }
      /**
       * @param {!(string|Integer)} n The nonce to set
       * @returns {void}
       */

    }, {
      key: "setNonce",
      value: function setNonce(n) {
        this.svgElem_.setAttributeNS(NS.XMLNS, 'xmlns:se', NS.SE);
        this.svgElem_.setAttributeNS(NS.SE, 'se:nonce', n);
        this.nonce_ = n;
      }
      /**
       * Clears any previously set nonce.
       * @returns {void}
       */

    }, {
      key: "clearNonce",
      value: function clearNonce() {
        // We deliberately leave any se:nonce attributes alone,
        // we just don't use it to randomize ids.
        this.nonce_ = '';
      }
      /**
       * Returns the latest object id as a string.
       * @returns {string} The latest object Id.
       */

    }, {
      key: "getId",
      value: function getId() {
        return this.nonce_ ? this.idPrefix + this.nonce_ + '_' + this.obj_num : this.idPrefix + this.obj_num;
      }
      /**
       * Returns the next object Id as a string.
       * @returns {string} The next object Id to use.
       */

    }, {
      key: "getNextId",
      value: function getNextId() {
        var oldObjNum = this.obj_num;
        var restoreOldObjNum = false; // If there are any released numbers in the release stack,
        // use the last one instead of the next obj_num.
        // We need to temporarily use obj_num as that is what getId() depends on.

        if (this.releasedNums.length > 0) {
          this.obj_num = this.releasedNums.pop();
          restoreOldObjNum = true;
        } else {
          // If we are not using a released id, then increment the obj_num.
          this.obj_num++;
        } // Ensure the ID does not exist.


        var id = this.getId();

        while (this.getElem_(id)) {
          if (restoreOldObjNum) {
            this.obj_num = oldObjNum;
            restoreOldObjNum = false;
          }

          this.obj_num++;
          id = this.getId();
        } // Restore the old object number if required.


        if (restoreOldObjNum) {
          this.obj_num = oldObjNum;
        }

        return id;
      }
      /**
       * Releases the object Id, letting it be used as the next id in getNextId().
       * This method DOES NOT remove any elements from the DOM, it is expected
       * that client code will do this.
       * @param {string} id - The id to release.
       * @returns {boolean} True if the id was valid to be released, false otherwise.
      */

    }, {
      key: "releaseId",
      value: function releaseId(id) {
        // confirm if this is a valid id for this Document, else return false
        var front = this.idPrefix + (this.nonce_ ? this.nonce_ + '_' : '');

        if (typeof id !== 'string' || !id.startsWith(front)) {
          return false;
        } // extract the obj_num of this id


        var num = Number.parseInt(id.substr(front.length)); // if we didn't get a positive number or we already released this number
        // then return false.

        if (typeof num !== 'number' || num <= 0 || this.releasedNums.includes(num)) {
          return false;
        } // push the released number into the released queue


        this.releasedNums.push(num);
        return true;
      }
      /**
       * Returns the number of layers in the current drawing.
       * @returns {Integer} The number of layers in the current drawing.
      */

    }, {
      key: "getNumLayers",
      value: function getNumLayers() {
        return this.all_layers.length;
      }
      /**
       * Check if layer with given name already exists.
       * @param {string} name - The layer name to check
       * @returns {boolean}
      */

    }, {
      key: "hasLayer",
      value: function hasLayer(name) {
        return this.layer_map[name] !== undefined;
      }
      /**
       * Returns the name of the ith layer. If the index is out of range, an empty string is returned.
       * @param {Integer} i - The zero-based index of the layer you are querying.
       * @returns {string} The name of the ith layer (or the empty string if none found)
      */

    }, {
      key: "getLayerName",
      value: function getLayerName(i) {
        return i >= 0 && i < this.getNumLayers() ? this.all_layers[i].getName() : '';
      }
      /**
       * @returns {SVGGElement|null} The SVGGElement representing the current layer.
       */

    }, {
      key: "getCurrentLayer",
      value: function getCurrentLayer() {
        return this.current_layer ? this.current_layer.getGroup() : null;
      }
      /**
       * Get a layer by name.
       * @param {string} name
       * @returns {SVGGElement} The SVGGElement representing the named layer or null.
       */

    }, {
      key: "getLayerByName",
      value: function getLayerByName(name) {
        var layer = this.layer_map[name];
        return layer ? layer.getGroup() : null;
      }
      /**
       * Returns the name of the currently selected layer. If an error occurs, an empty string
       * is returned.
       * @returns {string} The name of the currently active layer (or the empty string if none found).
      */

    }, {
      key: "getCurrentLayerName",
      value: function getCurrentLayerName() {
        return this.current_layer ? this.current_layer.getName() : '';
      }
      /**
       * Set the current layer's name.
       * @param {string} name - The new name.
       * @param {module:history.HistoryRecordingService} hrService - History recording service
       * @returns {string|null} The new name if changed; otherwise, null.
       */

    }, {
      key: "setCurrentLayerName",
      value: function setCurrentLayerName(name, hrService) {
        var finalName = null;

        if (this.current_layer) {
          var oldName = this.current_layer.getName();
          finalName = this.current_layer.setName(name, hrService);

          if (finalName) {
            delete this.layer_map[oldName];
            this.layer_map[finalName] = this.current_layer;
          }
        }

        return finalName;
      }
      /**
       * Set the current layer's position.
       * @param {Integer} newpos - The zero-based index of the new position of the layer. Range should be 0 to layers-1
       * @returns {{title: SVGGElement, previousName: string}|null} If the name was changed, returns {title:SVGGElement, previousName:string}; otherwise null.
       */

    }, {
      key: "setCurrentLayerPosition",
      value: function setCurrentLayerPosition(newpos) {
        var layerCount = this.getNumLayers();

        if (!this.current_layer || newpos < 0 || newpos >= layerCount) {
          return null;
        }

        var oldpos;

        for (oldpos = 0; oldpos < layerCount; ++oldpos) {
          if (this.all_layers[oldpos] === this.current_layer) {
            break;
          }
        } // some unknown error condition (current_layer not in all_layers)


        if (oldpos === layerCount) {
          return null;
        }

        if (oldpos !== newpos) {
          // if our new position is below us, we need to insert before the node after newpos
          var currentGroup = this.current_layer.getGroup();
          var oldNextSibling = currentGroup.nextSibling;
          var refGroup = null;

          if (newpos > oldpos) {
            if (newpos < layerCount - 1) {
              refGroup = this.all_layers[newpos + 1].getGroup();
            } // if our new position is above us, we need to insert before the node at newpos

          } else {
            refGroup = this.all_layers[newpos].getGroup();
          }

          this.svgElem_.insertBefore(currentGroup, refGroup); // Ok to replace with `refGroup.before(currentGroup);`?

          this.identifyLayers();
          this.setCurrentLayer(this.getLayerName(newpos));
          return {
            currentGroup: currentGroup,
            oldNextSibling: oldNextSibling
          };
        }

        return null;
      }
      /**
      * @param {module:history.HistoryRecordingService} hrService
      * @returns {void}
      */

    }, {
      key: "mergeLayer",
      value: function mergeLayer(hrService) {
        var currentGroup = this.current_layer.getGroup();
        var prevGroup = $$6(currentGroup).prev()[0];

        if (!prevGroup) {
          return;
        }

        hrService.startBatchCommand('Merge Layer');
        var layerNextSibling = currentGroup.nextSibling;
        hrService.removeElement(currentGroup, layerNextSibling, this.svgElem_);

        while (currentGroup.firstChild) {
          var child = currentGroup.firstChild;

          if (child.localName === 'title') {
            hrService.removeElement(child, child.nextSibling, currentGroup);
            child.remove();
            continue;
          }

          var oldNextSibling = child.nextSibling;
          prevGroup.append(child);
          hrService.moveElement(child, oldNextSibling, currentGroup);
        } // Remove current layer's group


        this.current_layer.removeGroup(); // Remove the current layer and set the previous layer as the new current layer

        var index = this.all_layers.indexOf(this.current_layer);

        if (index > 0) {
          var _name = this.current_layer.getName();

          this.current_layer = this.all_layers[index - 1];
          this.all_layers.splice(index, 1);
          delete this.layer_map[_name];
        }

        hrService.endBatchCommand();
      }
      /**
      * @param {module:history.HistoryRecordingService} hrService
      * @returns {void}
      */

    }, {
      key: "mergeAllLayers",
      value: function mergeAllLayers(hrService) {
        // Set the current layer to the last layer.
        this.current_layer = this.all_layers[this.all_layers.length - 1];
        hrService.startBatchCommand('Merge all Layers');

        while (this.all_layers.length > 1) {
          this.mergeLayer(hrService);
        }

        hrService.endBatchCommand();
      }
      /**
       * Sets the current layer. If the name is not a valid layer name, then this
       * function returns `false`. Otherwise it returns `true`. This is not an
       * undo-able action.
       * @param {string} name - The name of the layer you want to switch to.
       * @returns {boolean} `true` if the current layer was switched, otherwise `false`
       */

    }, {
      key: "setCurrentLayer",
      value: function setCurrentLayer(name) {
        var layer = this.layer_map[name];

        if (layer) {
          if (this.current_layer) {
            this.current_layer.deactivate();
          }

          this.current_layer = layer;
          this.current_layer.activate();
          return true;
        }

        return false;
      }
      /**
       * Deletes the current layer from the drawing and then clears the selection.
       * This function then calls the 'changed' handler.  This is an undoable action.
       * @todo Does this actually call the 'changed' handler?
       * @returns {SVGGElement} The SVGGElement of the layer removed or null.
       */

    }, {
      key: "deleteCurrentLayer",
      value: function deleteCurrentLayer() {
        if (this.current_layer && this.getNumLayers() > 1) {
          var oldLayerGroup = this.current_layer.removeGroup();
          this.identifyLayers();
          return oldLayerGroup;
        }

        return null;
      }
      /**
       * Updates layer system and sets the current layer to the
       * top-most layer (last `<g>` child of this drawing).
       * @returns {void}
      */

    }, {
      key: "identifyLayers",
      value: function identifyLayers() {
        this.all_layers = [];
        this.layer_map = {};
        var numchildren = this.svgElem_.childNodes.length; // loop through all children of SVG element

        var orphans = [],
            layernames = [];
        var layer = null;
        var childgroups = false;

        for (var i = 0; i < numchildren; ++i) {
          var child = this.svgElem_.childNodes.item(i); // for each g, find its layer name

          if (child && child.nodeType === 1) {
            if (child.tagName === 'g') {
              childgroups = true;

              var _name2 = findLayerNameInGroup(child);

              if (_name2) {
                layernames.push(_name2);
                layer = new Layer(_name2, child);
                this.all_layers.push(layer);
                this.layer_map[_name2] = layer;
              } else {
                // if group did not have a name, it is an orphan
                orphans.push(child);
              }
            } else if (visElems$1.includes(child.nodeName)) {
              // Child is "visible" (i.e. not a <title> or <defs> element), so it is an orphan
              orphans.push(child);
            }
          }
        } // If orphans or no layers found, create a new layer and add all the orphans to it


        if (orphans.length > 0 || !childgroups) {
          layer = new Layer(getNewLayerName(layernames), null, this.svgElem_);
          layer.appendChildren(orphans);
          this.all_layers.push(layer);
          this.layer_map[name] = layer;
        } else {
          layer.activate();
        }

        this.current_layer = layer;
      }
      /**
       * Creates a new top-level layer in the drawing with the given name and
       * makes it the current layer.
       * @param {string} name - The given name. If the layer name exists, a new name will be generated.
       * @param {module:history.HistoryRecordingService} hrService - History recording service
       * @returns {SVGGElement} The SVGGElement of the new layer, which is
       *     also the current layer of this drawing.
      */

    }, {
      key: "createLayer",
      value: function createLayer(name, hrService) {
        if (this.current_layer) {
          this.current_layer.deactivate();
        } // Check for duplicate name.


        if (name === undefined || name === null || name === '' || this.layer_map[name]) {
          name = getNewLayerName(Object.keys(this.layer_map));
        } // Crate new layer and add to DOM as last layer


        var layer = new Layer(name, null, this.svgElem_); // Like to assume hrService exists, but this is backwards compatible with old version of createLayer.

        if (hrService) {
          hrService.startBatchCommand('Create Layer');
          hrService.insertElement(layer.getGroup());
          hrService.endBatchCommand();
        }

        this.all_layers.push(layer);
        this.layer_map[name] = layer;
        this.current_layer = layer;
        return layer.getGroup();
      }
      /**
       * Creates a copy of the current layer with the given name and makes it the current layer.
       * @param {string} name - The given name. If the layer name exists, a new name will be generated.
       * @param {module:history.HistoryRecordingService} hrService - History recording service
       * @returns {SVGGElement} The SVGGElement of the new layer, which is
       *     also the current layer of this drawing.
      */

    }, {
      key: "cloneLayer",
      value: function cloneLayer(name, hrService) {
        var _this = this;

        if (!this.current_layer) {
          return null;
        }

        this.current_layer.deactivate(); // Check for duplicate name.

        if (name === undefined || name === null || name === '' || this.layer_map[name]) {
          name = getNewLayerName(Object.keys(this.layer_map));
        } // Create new group and add to DOM just after current_layer


        var currentGroup = this.current_layer.getGroup();
        var layer = new Layer(name, currentGroup, this.svgElem_);
        var group = layer.getGroup(); // Clone children

        var children = _toConsumableArray(currentGroup.childNodes);

        children.forEach(function (child) {
          if (child.localName === 'title') {
            return;
          }

          group.append(_this.copyElem(child));
        });

        if (hrService) {
          hrService.startBatchCommand('Duplicate Layer');
          hrService.insertElement(group);
          hrService.endBatchCommand();
        } // Update layer containers and current_layer.


        var index = this.all_layers.indexOf(this.current_layer);

        if (index >= 0) {
          this.all_layers.splice(index + 1, 0, layer);
        } else {
          this.all_layers.push(layer);
        }

        this.layer_map[name] = layer;
        this.current_layer = layer;
        return group;
      }
      /**
       * Returns whether the layer is visible.  If the layer name is not valid,
       * then this function returns `false`.
       * @param {string} layerName - The name of the layer which you want to query.
       * @returns {boolean} The visibility state of the layer, or `false` if the layer name was invalid.
      */

    }, {
      key: "getLayerVisibility",
      value: function getLayerVisibility(layerName) {
        var layer = this.layer_map[layerName];
        return layer ? layer.isVisible() : false;
      }
      /**
       * Sets the visibility of the layer. If the layer name is not valid, this
       * function returns `null`, otherwise it returns the `SVGElement` representing
       * the layer. This is an undo-able action.
       * @param {string} layerName - The name of the layer to change the visibility
       * @param {boolean} bVisible - Whether the layer should be visible
       * @returns {?SVGGElement} The SVGGElement representing the layer if the
       *   `layerName` was valid, otherwise `null`.
      */

    }, {
      key: "setLayerVisibility",
      value: function setLayerVisibility(layerName, bVisible) {
        if (typeof bVisible !== 'boolean') {
          return null;
        }

        var layer = this.layer_map[layerName];

        if (!layer) {
          return null;
        }

        layer.setVisible(bVisible);
        return layer.getGroup();
      }
      /**
       * Returns the opacity of the given layer.  If the input name is not a layer, `null` is returned.
       * @param {string} layerName - name of the layer on which to get the opacity
       * @returns {?Float} The opacity value of the given layer.  This will be a value between 0.0 and 1.0, or `null`
       * if `layerName` is not a valid layer
      */

    }, {
      key: "getLayerOpacity",
      value: function getLayerOpacity(layerName) {
        var layer = this.layer_map[layerName];

        if (!layer) {
          return null;
        }

        return layer.getOpacity();
      }
      /**
       * Sets the opacity of the given layer.  If the input name is not a layer,
       * nothing happens. If opacity is not a value between 0.0 and 1.0, then
       * nothing happens.
       * NOTE: this function exists solely to apply a highlighting/de-emphasis
       * effect to a layer. When it is possible for a user to affect the opacity
       * of a layer, we will need to allow this function to produce an undo-able
       * action.
       * @param {string} layerName - Name of the layer on which to set the opacity
       * @param {Float} opacity - A float value in the range 0.0-1.0
       * @returns {void}
      */

    }, {
      key: "setLayerOpacity",
      value: function setLayerOpacity(layerName, opacity) {
        if (typeof opacity !== 'number' || opacity < 0.0 || opacity > 1.0) {
          return;
        }

        var layer = this.layer_map[layerName];

        if (layer) {
          layer.setOpacity(opacity);
        }
      }
      /**
       * Create a clone of an element, updating its ID and its children's IDs when needed.
       * @param {Element} el - DOM element to clone
       * @returns {Element}
       */

    }, {
      key: "copyElem",
      value: function copyElem$1(el) {
        var that = this;

        var getNextIdClosure = function getNextIdClosure() {
          return that.getNextId();
        };

        return copyElem(el, getNextIdClosure);
      }
    }]);

    return Drawing;
  }();
  /**
   * Called to ensure that drawings will or will not have randomized ids.
   * The currentDrawing will have its nonce set if it doesn't already.
   * @function module:draw.randomizeIds
   * @param {boolean} enableRandomization - flag indicating if documents should have randomized ids
   * @param {draw.Drawing} currentDrawing
   * @returns {void}
   */

  var randomizeIds = function randomizeIds(enableRandomization, currentDrawing) {
    randIds = enableRandomization === false ? RandomizeModes.NEVER_RANDOMIZE : RandomizeModes.ALWAYS_RANDOMIZE;

    if (randIds === RandomizeModes.ALWAYS_RANDOMIZE && !currentDrawing.getNonce()) {
      currentDrawing.setNonce(Math.floor(Math.random() * 100001));
    } else if (randIds === RandomizeModes.NEVER_RANDOMIZE && currentDrawing.getNonce()) {
      currentDrawing.clearNonce();
    }
  }; // Layer API Functions

  /**
  * Group: Layers.
  */

  /**
   * @see {@link https://api.jquery.com/jQuery.data/}
   * @name external:jQuery.data
   */

  /**
   * @interface module:draw.DrawCanvasInit
   * @property {module:path.pathActions} pathActions
   * @property {external:jQuery.data} elData
   * @property {module:history.UndoManager} undoMgr
   */

  /**
   * @function module:draw.DrawCanvasInit#getCurrentGroup
   * @returns {Element}
   */

  /**
   * @function module:draw.DrawCanvasInit#setCurrentGroup
   * @param {Element} cg
   * @returns {void}
  */

  /**
   * @function module:draw.DrawCanvasInit#getSelectedElements
   * @returns {Element[]} the array with selected DOM elements
  */

  /**
   * @function module:draw.DrawCanvasInit#getSVGContent
   * @returns {SVGSVGElement}
   */

  /**
   * @function module:draw.DrawCanvasInit#getCurrentDrawing
   * @returns {module:draw.Drawing}
   */

  /**
   * @function module:draw.DrawCanvasInit#clearSelection
   * @param {boolean} [noCall] - When `true`, does not call the "selected" handler
   * @returns {void}
  */

  /**
   * Run the callback function associated with the given event.
   * @function module:draw.DrawCanvasInit#call
   * @param {"changed"|"contextset"} ev - String with the event name
   * @param {module:svgcanvas.SvgCanvas#event:changed|module:svgcanvas.SvgCanvas#event:contextset} arg - Argument to pass through to the callback
   * function. If the event is "changed", a (single-item) array of `Element`s is
   * passed. If the event is "contextset", the arg is `null` or `Element`.
   * @returns {void}
   */

  /**
   * @function module:draw.DrawCanvasInit#addCommandToHistory
   * @param {Command} cmd
   * @returns {void}
  */

  /**
   * @function module:draw.DrawCanvasInit#changeSVGContent
   * @returns {void}
   */

  var canvas_;
  /**
  * @function module:draw.init
  * @param {module:draw.DrawCanvasInit} canvas
  * @returns {void}
  */

  var init$3 = function init(canvas) {
    canvas_ = canvas;
  };
  /**
  * Updates layer system.
  * @function module:draw.identifyLayers
  * @returns {void}
  */

  var identifyLayers = function identifyLayers() {
    leaveContext();
    canvas_.getCurrentDrawing().identifyLayers();
  };
  /**
  * Creates a new top-level layer in the drawing with the given name, sets the current layer
  * to it, and then clears the selection. This function then calls the 'changed' handler.
  * This is an undoable action.
  * @function module:draw.createLayer
  * @param {string} name - The given name
  * @param {module:history.HistoryRecordingService} hrService
  * @fires module:svgcanvas.SvgCanvas#event:changed
  * @returns {void}
  */

  var createLayer = function createLayer(name, hrService) {
    var newLayer = canvas_.getCurrentDrawing().createLayer(name, historyRecordingService(hrService));
    canvas_.clearSelection();
    canvas_.call('changed', [newLayer]);
  };
  /**
   * Creates a new top-level layer in the drawing with the given name, copies all the current layer's contents
   * to it, and then clears the selection. This function then calls the 'changed' handler.
   * This is an undoable action.
   * @function module:draw.cloneLayer
   * @param {string} name - The given name. If the layer name exists, a new name will be generated.
   * @param {module:history.HistoryRecordingService} hrService - History recording service
   * @fires module:svgcanvas.SvgCanvas#event:changed
   * @returns {void}
   */

  var cloneLayer = function cloneLayer(name, hrService) {
    // Clone the current layer and make the cloned layer the new current layer
    var newLayer = canvas_.getCurrentDrawing().cloneLayer(name, historyRecordingService(hrService));
    canvas_.clearSelection();
    leaveContext();
    canvas_.call('changed', [newLayer]);
  };
  /**
  * Deletes the current layer from the drawing and then clears the selection. This function
  * then calls the 'changed' handler. This is an undoable action.
  * @function module:draw.deleteCurrentLayer
  * @fires module:svgcanvas.SvgCanvas#event:changed
  * @returns {boolean} `true` if an old layer group was found to delete
  */

  var deleteCurrentLayer = function deleteCurrentLayer() {
    var currentLayer = canvas_.getCurrentDrawing().getCurrentLayer();
    var _currentLayer = currentLayer,
        nextSibling = _currentLayer.nextSibling;
    var parent = currentLayer.parentNode;
    currentLayer = canvas_.getCurrentDrawing().deleteCurrentLayer();

    if (currentLayer) {
      var batchCmd = new BatchCommand('Delete Layer'); // store in our Undo History

      batchCmd.addSubCommand(new RemoveElementCommand(currentLayer, nextSibling, parent));
      canvas_.addCommandToHistory(batchCmd);
      canvas_.clearSelection();
      canvas_.call('changed', [parent]);
      return true;
    }

    return false;
  };
  /**
  * Sets the current layer. If the name is not a valid layer name, then this function returns
  * false. Otherwise it returns true. This is not an undo-able action.
  * @function module:draw.setCurrentLayer
  * @param {string} name - The name of the layer you want to switch to.
  * @returns {boolean} true if the current layer was switched, otherwise false
  */

  var setCurrentLayer = function setCurrentLayer(name) {
    var result = canvas_.getCurrentDrawing().setCurrentLayer(toXml(name));

    if (result) {
      canvas_.clearSelection();
    }

    return result;
  };
  /**
  * Renames the current layer. If the layer name is not valid (i.e. unique), then this function
  * does nothing and returns `false`, otherwise it returns `true`. This is an undo-able action.
  * @function module:draw.renameCurrentLayer
  * @param {string} newName - the new name you want to give the current layer. This name must
  * be unique among all layer names.
  * @fires module:svgcanvas.SvgCanvas#event:changed
  * @returns {boolean} Whether the rename succeeded
  */

  var renameCurrentLayer = function renameCurrentLayer(newName) {
    var drawing = canvas_.getCurrentDrawing();
    var layer = drawing.getCurrentLayer();

    if (layer) {
      var result = drawing.setCurrentLayerName(newName, historyRecordingService());

      if (result) {
        canvas_.call('changed', [layer]);
        return true;
      }
    }

    return false;
  };
  /**
  * Changes the position of the current layer to the new value. If the new index is not valid,
  * this function does nothing and returns false, otherwise it returns true. This is an
  * undo-able action.
  * @function module:draw.setCurrentLayerPosition
  * @param {Integer} newPos - The zero-based index of the new position of the layer. This should be between
  * 0 and (number of layers - 1)
  * @returns {boolean} `true` if the current layer position was changed, `false` otherwise.
  */

  var setCurrentLayerPosition = function setCurrentLayerPosition(newPos) {
    var drawing = canvas_.getCurrentDrawing();
    var result = drawing.setCurrentLayerPosition(newPos);

    if (result) {
      canvas_.addCommandToHistory(new MoveElementCommand(result.currentGroup, result.oldNextSibling, canvas_.getSVGContent()));
      return true;
    }

    return false;
  };
  /**
  * Sets the visibility of the layer. If the layer name is not valid, this function return
  * `false`, otherwise it returns `true`. This is an undo-able action.
  * @function module:draw.setLayerVisibility
  * @param {string} layerName - The name of the layer to change the visibility
  * @param {boolean} bVisible - Whether the layer should be visible
  * @returns {boolean} true if the layer's visibility was set, false otherwise
  */

  var setLayerVisibility = function setLayerVisibility(layerName, bVisible) {
    var drawing = canvas_.getCurrentDrawing();
    var prevVisibility = drawing.getLayerVisibility(layerName);
    var layer = drawing.setLayerVisibility(layerName, bVisible);

    if (layer) {
      var oldDisplay = prevVisibility ? 'inline' : 'none';
      canvas_.addCommandToHistory(new ChangeElementCommand(layer, {
        display: oldDisplay
      }, 'Layer Visibility'));
    } else {
      return false;
    }

    if (layer === drawing.getCurrentLayer()) {
      canvas_.clearSelection();
      canvas_.pathActions.clear();
    } // call('changed', [selected]);


    return true;
  };
  /**
  * Moves the selected elements to layerName. If the name is not a valid layer name, then `false`
  * is returned. Otherwise it returns `true`. This is an undo-able action.
  * @function module:draw.moveSelectedToLayer
  * @param {string} layerName - The name of the layer you want to which you want to move the selected elements
  * @returns {boolean} Whether the selected elements were moved to the layer.
  */

  var moveSelectedToLayer = function moveSelectedToLayer(layerName) {
    // find the layer
    var drawing = canvas_.getCurrentDrawing();
    var layer = drawing.getLayerByName(layerName);

    if (!layer) {
      return false;
    }

    var batchCmd = new BatchCommand('Move Elements to Layer'); // loop for each selected element and move it

    var selElems = canvas_.getSelectedElements();
    var i = selElems.length;

    while (i--) {
      var elem = selElems[i];

      if (!elem) {
        continue;
      }

      var oldNextSibling = elem.nextSibling; // TODO: this is pretty brittle!

      var oldLayer = elem.parentNode;
      layer.append(elem);
      batchCmd.addSubCommand(new MoveElementCommand(elem, oldNextSibling, oldLayer));
    }

    canvas_.addCommandToHistory(batchCmd);
    return true;
  };
  /**
  * @function module:draw.mergeLayer
  * @param {module:history.HistoryRecordingService} hrService
  * @returns {void}
  */

  var mergeLayer = function mergeLayer(hrService) {
    canvas_.getCurrentDrawing().mergeLayer(historyRecordingService(hrService));
    canvas_.clearSelection();
    leaveContext();
    canvas_.changeSVGContent();
  };
  /**
  * @function module:draw.mergeAllLayers
  * @param {module:history.HistoryRecordingService} hrService
  * @returns {void}
  */

  var mergeAllLayers = function mergeAllLayers(hrService) {
    canvas_.getCurrentDrawing().mergeAllLayers(historyRecordingService(hrService));
    canvas_.clearSelection();
    leaveContext();
    canvas_.changeSVGContent();
  };
  /**
  * Return from a group context to the regular kind, make any previously
  * disabled elements enabled again.
  * @function module:draw.leaveContext
  * @fires module:svgcanvas.SvgCanvas#event:contextset
  * @returns {void}
  */

  var leaveContext = function leaveContext() {
    var len = disabledElems.length;

    if (len) {
      for (var i = 0; i < len; i++) {
        var elem = disabledElems[i];
        var orig = canvas_.elData(elem, 'orig_opac');

        if (orig !== 1) {
          elem.setAttribute('opacity', orig);
        } else {
          elem.removeAttribute('opacity');
        }

        elem.setAttribute('style', 'pointer-events: inherit');
      }

      disabledElems = [];
      canvas_.clearSelection(true);
      canvas_.call('contextset', null);
    }

    canvas_.setCurrentGroup(null);
  };
  /**
  * Set the current context (for in-group editing).
  * @function module:draw.setContext
  * @param {Element} elem
  * @fires module:svgcanvas.SvgCanvas#event:contextset
  * @returns {void}
  */

  var setContext = function setContext(elem) {
    leaveContext();

    if (typeof elem === 'string') {
      elem = getElem(elem);
    } // Edit inside this group


    canvas_.setCurrentGroup(elem); // Disable other elements

    $$6(elem).parentsUntil('#svgcontent').andSelf().siblings().each(function () {
      var opac = this.getAttribute('opacity') || 1; // Store the original's opacity

      canvas_.elData(this, 'orig_opac', opac);
      this.setAttribute('opacity', opac * 0.33);
      this.setAttribute('style', 'pointer-events: none');
      disabledElems.push(this);
    });
    canvas_.clearSelection();
    canvas_.call('contextset', canvas_.getCurrentGroup());
  };

  var REVERSE_NS = getReverseNS(); // Todo: Split out into core attributes, presentation attributes, etc. so consistent

  /**
   * This defines which elements and attributes that we support (or at least
   * don't remove).
   * @type {PlainObject}
   */

  /* eslint-disable max-len */

  var svgWhiteList_ = {
    // SVG Elements
    a: ['class', 'clip-path', 'clip-rule', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'id', 'mask', 'opacity', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform', 'xlink:href', 'xlink:title'],
    circle: ['class', 'clip-path', 'clip-rule', 'cx', 'cy', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'id', 'mask', 'opacity', 'r', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform'],
    clipPath: ['class', 'clipPathUnits', 'id'],
    defs: [],
    style: ['type'],
    desc: [],
    ellipse: ['class', 'clip-path', 'clip-rule', 'cx', 'cy', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'id', 'mask', 'opacity', 'requiredFeatures', 'rx', 'ry', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform'],
    feGaussianBlur: ['class', 'color-interpolation-filters', 'id', 'requiredFeatures', 'stdDeviation'],
    feMorphology: ['class', 'in', 'operator', 'radius'],
    filter: ['class', 'color-interpolation-filters', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'requiredFeatures', 'width', 'x', 'xlink:href', 'y'],
    foreignObject: ['class', 'font-size', 'height', 'id', 'opacity', 'requiredFeatures', 'style', 'transform', 'width', 'x', 'y'],
    g: ['class', 'clip-path', 'clip-rule', 'id', 'display', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'mask', 'opacity', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform', 'font-family', 'font-size', 'font-style', 'font-weight', 'text-anchor'],
    image: ['class', 'clip-path', 'clip-rule', 'filter', 'height', 'id', 'mask', 'opacity', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:href', 'xlink:title', 'y'],
    line: ['class', 'clip-path', 'clip-rule', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'id', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'y1', 'y2'],
    linearGradient: ['class', 'id', 'gradientTransform', 'gradientUnits', 'requiredFeatures', 'spreadMethod', 'systemLanguage', 'x1', 'x2', 'xlink:href', 'y1', 'y2'],
    marker: ['id', 'class', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'systemLanguage', 'viewBox'],
    mask: ['class', 'height', 'id', 'maskContentUnits', 'maskUnits', 'width', 'x', 'y'],
    metadata: ['class', 'id'],
    path: ['class', 'clip-path', 'clip-rule', 'd', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'id', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform'],
    pattern: ['class', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:href', 'y'],
    polygon: ['class', 'clip-path', 'clip-rule', 'id', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'id', 'class', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'points', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform'],
    polyline: ['class', 'clip-path', 'clip-rule', 'id', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'points', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform'],
    radialGradient: ['class', 'cx', 'cy', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'requiredFeatures', 'spreadMethod', 'systemLanguage', 'xlink:href'],
    rect: ['class', 'clip-path', 'clip-rule', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'height', 'id', 'mask', 'opacity', 'requiredFeatures', 'rx', 'ry', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform', 'width', 'x', 'y'],
    stop: ['class', 'id', 'offset', 'requiredFeatures', 'stop-color', 'stop-opacity', 'style', 'systemLanguage'],
    svg: ['class', 'clip-path', 'clip-rule', 'filter', 'id', 'height', 'mask', 'preserveAspectRatio', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xmlns', 'xmlns:se', 'xmlns:xlink', 'y'],
    "switch": ['class', 'id', 'requiredFeatures', 'systemLanguage'],
    symbol: ['class', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'font-family', 'font-size', 'font-style', 'font-weight', 'id', 'opacity', 'preserveAspectRatio', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'transform', 'viewBox'],
    text: ['class', 'clip-path', 'clip-rule', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'font-family', 'font-size', 'font-style', 'font-weight', 'id', 'mask', 'opacity', 'requiredFeatures', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'text-anchor', 'transform', 'x', 'xml:space', 'y'],
    textPath: ['class', 'id', 'method', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'transform', 'xlink:href'],
    title: [],
    tspan: ['class', 'clip-path', 'clip-rule', 'dx', 'dy', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'font-family', 'font-size', 'font-style', 'font-weight', 'id', 'mask', 'opacity', 'requiredFeatures', 'rotate', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'systemLanguage', 'text-anchor', 'textLength', 'transform', 'x', 'xml:space', 'y'],
    use: ['class', 'clip-path', 'clip-rule', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'height', 'id', 'mask', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'style', 'transform', 'width', 'x', 'xlink:href', 'y'],
    // MathML Elements
    annotation: ['encoding'],
    'annotation-xml': ['encoding'],
    maction: ['actiontype', 'other', 'selection'],
    math: ['class', 'id', 'display', 'xmlns'],
    menclose: ['notation'],
    merror: [],
    mfrac: ['linethickness'],
    mi: ['mathvariant'],
    mmultiscripts: [],
    mn: [],
    mo: ['fence', 'lspace', 'maxsize', 'minsize', 'rspace', 'stretchy'],
    mover: [],
    mpadded: ['lspace', 'width', 'height', 'depth', 'voffset'],
    mphantom: [],
    mprescripts: [],
    mroot: [],
    mrow: ['xlink:href', 'xlink:type', 'xmlns:xlink'],
    mspace: ['depth', 'height', 'width'],
    msqrt: [],
    mstyle: ['displaystyle', 'mathbackground', 'mathcolor', 'mathvariant', 'scriptlevel'],
    msub: [],
    msubsup: [],
    msup: [],
    mtable: ['align', 'columnalign', 'columnlines', 'columnspacing', 'displaystyle', 'equalcolumns', 'equalrows', 'frame', 'rowalign', 'rowlines', 'rowspacing', 'width'],
    mtd: ['columnalign', 'columnspan', 'rowalign', 'rowspan'],
    mtext: [],
    mtr: ['columnalign', 'rowalign'],
    munder: [],
    munderover: [],
    none: [],
    semantics: []
  };
  /* eslint-enable max-len */
  // Produce a Namespace-aware version of svgWhitelist

  var svgWhiteListNS_ = {};
  Object.entries(svgWhiteList_).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        elt = _ref2[0],
        atts = _ref2[1];

    var attNS = {};
    Object.entries(atts).forEach(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          i = _ref4[0],
          att = _ref4[1];

      if (att.includes(':')) {
        var v = att.split(':');
        attNS[v[1]] = NS[v[0].toUpperCase()];
      } else {
        attNS[att] = att === 'xmlns' ? NS.XMLNS : null;
      }
    });
    svgWhiteListNS_[elt] = attNS;
  });
  /**
  * Sanitizes the input node and its children.
  * It only keeps what is allowed from our whitelist defined above.
  * @function module:sanitize.sanitizeSvg
  * @param {Text|Element} node - The DOM element to be checked (we'll also check its children) or text node to be cleaned up
  * @returns {void}
  */

  var sanitizeSvg = function sanitizeSvg(node) {
    // Cleanup text nodes
    if (node.nodeType === 3) {
      // 3 === TEXT_NODE
      // Trim whitespace
      node.nodeValue = node.nodeValue.replace(/^\s+|\s+$/g, ''); // Remove if empty

      if (!node.nodeValue.length) {
        node.remove();
      }
    } // We only care about element nodes.
    // Automatically return for all non-element nodes, such as comments, etc.


    if (node.nodeType !== 1) {
      // 1 == ELEMENT_NODE
      return;
    }

    var doc = node.ownerDocument;
    var parent = node.parentNode; // can parent ever be null here?  I think the root node's parent is the document...

    if (!doc || !parent) {
      return;
    }

    var allowedAttrs = svgWhiteList_[node.nodeName];
    var allowedAttrsNS = svgWhiteListNS_[node.nodeName]; // if this element is supported, sanitize it

    if (typeof allowedAttrs !== 'undefined') {
      var seAttrs = [];
      var i = node.attributes.length;

      while (i--) {
        // if the attribute is not in our whitelist, then remove it
        // could use jQuery's inArray(), but I don't know if that's any better
        var attr = node.attributes.item(i);
        var attrName = attr.nodeName;
        var attrLocalName = attr.localName;
        var attrNsURI = attr.namespaceURI; // Check that an attribute with the correct localName in the correct namespace is on
        // our whitelist or is a namespace declaration for one of our allowed namespaces

        if (!({}.hasOwnProperty.call(allowedAttrsNS, attrLocalName) && attrNsURI === allowedAttrsNS[attrLocalName] && attrNsURI !== NS.XMLNS) && !(attrNsURI === NS.XMLNS && REVERSE_NS[attr.value])) {
          // TODO(codedread): Programmatically add the se: attributes to the NS-aware whitelist.
          // Bypassing the whitelist to allow se: prefixes.
          // Is there a more appropriate way to do this?
          if (attrName.startsWith('se:') || attrName.startsWith('data-')) {
            seAttrs.push([attrName, attr.value]);
          }

          node.removeAttributeNS(attrNsURI, attrLocalName);
        } // Add spaces before negative signs where necessary


        if (isGecko()) {
          switch (attrName) {
            case 'transform':
            case 'gradientTransform':
            case 'patternTransform':
              {
                var val = attr.value.replace(/(\d)-/g, '$1 -'); // const val = attr.value.replace(/(?<digit>\d)-/g, '$<digit> -');

                node.setAttribute(attrName, val);
                break;
              }
          }
        } // For the style attribute, rewrite it in terms of XML presentational attributes


        if (attrName === 'style') {
          var props = attr.value.split(';');
          var p = props.length;

          while (p--) {
            var _props$p$split = props[p].split(':'),
                _props$p$split2 = _slicedToArray(_props$p$split, 2),
                name = _props$p$split2[0],
                _val = _props$p$split2[1];

            var styleAttrName = (name || '').trim();

            var styleAttrVal = (_val || '').trim(); // Now check that this attribute is supported


            if (allowedAttrs.includes(styleAttrName)) {
              node.setAttribute(styleAttrName, styleAttrVal);
            }
          }

          node.removeAttribute('style');
        }
      }

      Object.values(seAttrs).forEach(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            att = _ref6[0],
            val = _ref6[1];

        node.setAttributeNS(NS.SE, att, val);
      }); // for some elements that have a xlink:href, ensure the URI refers to a local element
      // (but not for links)

      var href = getHref(node);

      if (href && ['filter', 'linearGradient', 'pattern', 'radialGradient', 'textPath', 'use'].includes(node.nodeName)) {
        // TODO: we simply check if the first character is a #, is this bullet-proof?
        if (href[0] !== '#') {
          // remove the attribute (but keep the element)
          setHref(node, '');
          node.removeAttributeNS(NS.XLINK, 'href');
        }
      } // Safari crashes on a <use> without a xlink:href, so we just remove the node here


      if (node.nodeName === 'use' && !getHref(node)) {
        node.remove();
        return;
      } // if the element has attributes pointing to a non-local reference,
      // need to remove the attribute


      Object.values(['clip-path', 'fill', 'filter', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'stroke'], function (attr) {
        var val = node.getAttribute(attr);

        if (val) {
          val = getUrlFromAttr(val); // simply check for first character being a '#'

          if (val && val[0] !== '#') {
            node.setAttribute(attr, '');
            node.removeAttribute(attr);
          }
        }
      }); // recurse to children

      i = node.childNodes.length;

      while (i--) {
        sanitizeSvg(node.childNodes.item(i));
      } // else (element not supported), remove it

    } else {
      // remove all children from this node and insert them before this node
      // TODO: in the case of animation elements this will hardly ever be correct
      var children = [];

      while (node.hasChildNodes()) {
        children.push(parent.insertBefore(node.firstChild, node));
      } // remove this node from the document altogether


      node.remove(); // call sanitizeSvg on each of those children

      var _i = children.length;

      while (_i--) {
        sanitizeSvg(children[_i]);
      }
    }
  };

  var $$7 = jQuery; // this is how we map paths to our preferred relative segment types

  var pathMap$1 = [0, 'z', 'M', 'm', 'L', 'l', 'C', 'c', 'Q', 'q', 'A', 'a', 'H', 'h', 'V', 'v', 'S', 's', 'T', 't'];
  /**
   * @interface module:coords.EditorContext
   */

  /**
   * @function module:coords.EditorContext#getGridSnapping
   * @returns {boolean}
   */

  /**
   * @function module:coords.EditorContext#getDrawing
   * @returns {module:draw.Drawing}
  */

  /**
   * @function module:coords.EditorContext#getSVGRoot
   * @returns {SVGSVGElement}
  */

  var editorContext_$2 = null;
  /**
  * @function module:coords.init
  * @param {module:svgcanvas.SvgCanvas#event:pointsAdded} editorContext
  * @returns {void}
  */

  var init$4 = function init(editorContext) {
    editorContext_$2 = editorContext;
  };
  /**
   * Applies coordinate changes to an element based on the given matrix.
   * @name module:coords.remapElement
   * @type {module:path.EditorContext#remapElement}
  */

  var remapElement = function remapElement(selected, changes, m) {
    var remap = function remap(x, y) {
      return transformPoint(x, y, m);
    },
        scalew = function scalew(w) {
      return m.a * w;
    },
        scaleh = function scaleh(h) {
      return m.d * h;
    },
        doSnapping = editorContext_$2.getGridSnapping() && selected.parentNode.parentNode.localName === 'svg',
        finishUp = function finishUp() {
      if (doSnapping) {
        Object.entries(changes).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              o = _ref2[0],
              value = _ref2[1];

          changes[o] = snapToGrid(value);
        });
      }

      assignAttributes(selected, changes, 1000, true);
    },
        box = getBBox(selected);

    for (var i = 0; i < 2; i++) {
      var type = i === 0 ? 'fill' : 'stroke';
      var attrVal = selected.getAttribute(type);

      if (attrVal && attrVal.startsWith('url(')) {
        if (m.a < 0 || m.d < 0) {
          var grad = getRefElem(attrVal);
          var newgrad = grad.cloneNode(true);

          if (m.a < 0) {
            // flip x
            var x1 = newgrad.getAttribute('x1');
            var x2 = newgrad.getAttribute('x2');
            newgrad.setAttribute('x1', -(x1 - 1));
            newgrad.setAttribute('x2', -(x2 - 1));
          }

          if (m.d < 0) {
            // flip y
            var y1 = newgrad.getAttribute('y1');
            var y2 = newgrad.getAttribute('y2');
            newgrad.setAttribute('y1', -(y1 - 1));
            newgrad.setAttribute('y2', -(y2 - 1));
          }

          newgrad.id = editorContext_$2.getDrawing().getNextId();
          findDefs().append(newgrad);
          selected.setAttribute(type, 'url(#' + newgrad.id + ')');
        } // Not really working :(
        // if (selected.tagName === 'path') {
        //   reorientGrads(selected, m);
        // }

      }
    }

    var elName = selected.tagName;

    if (elName === 'g' || elName === 'text' || elName === 'tspan' || elName === 'use') {
      // if it was a translate, then just update x,y
      if (m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && (m.e !== 0 || m.f !== 0)) {
        // [T][M] = [M][T']
        // therefore [T'] = [M_inv][T][M]
        var existing = transformListToTransform(selected).matrix,
            tNew = matrixMultiply(existing.inverse(), m, existing);
        changes.x = Number.parseFloat(changes.x) + tNew.e;
        changes.y = Number.parseFloat(changes.y) + tNew.f;
      } else {
        // we just absorb all matrices into the element and don't do any remapping
        var chlist = getTransformList(selected);
        var mt = editorContext_$2.getSVGRoot().createSVGTransform();
        mt.setMatrix(matrixMultiply(transformListToTransform(chlist).matrix, m));
        chlist.clear();
        chlist.appendItem(mt);
      }
    } // now we have a set of changes and an applied reduced transform list
    // we apply the changes directly to the DOM


    switch (elName) {
      case 'foreignObject':
      case 'rect':
      case 'image':
        {
          // Allow images to be inverted (give them matrix when flipped)
          if (elName === 'image' && (m.a < 0 || m.d < 0)) {
            // Convert to matrix
            var _chlist = getTransformList(selected);

            var _mt = editorContext_$2.getSVGRoot().createSVGTransform();

            _mt.setMatrix(matrixMultiply(transformListToTransform(_chlist).matrix, m));

            _chlist.clear();

            _chlist.appendItem(_mt);
          } else {
            var pt1 = remap(changes.x, changes.y);
            changes.width = scalew(changes.width);
            changes.height = scaleh(changes.height);
            changes.x = pt1.x + Math.min(0, changes.width);
            changes.y = pt1.y + Math.min(0, changes.height);
            changes.width = Math.abs(changes.width);
            changes.height = Math.abs(changes.height);
          }

          finishUp();
          break;
        }

      case 'ellipse':
        {
          var c = remap(changes.cx, changes.cy);
          changes.cx = c.x;
          changes.cy = c.y;
          changes.rx = scalew(changes.rx);
          changes.ry = scaleh(changes.ry);
          changes.rx = Math.abs(changes.rx);
          changes.ry = Math.abs(changes.ry);
          finishUp();
          break;
        }

      case 'circle':
        {
          var _c = remap(changes.cx, changes.cy);

          changes.cx = _c.x;
          changes.cy = _c.y; // take the minimum of the new selected box's dimensions for the new circle radius

          var tbox = transformBox(box.x, box.y, box.width, box.height, m);
          var w = tbox.tr.x - tbox.tl.x,
              h = tbox.bl.y - tbox.tl.y;
          changes.r = Math.min(w / 2, h / 2);

          if (changes.r) {
            changes.r = Math.abs(changes.r);
          }

          finishUp();
          break;
        }

      case 'line':
        {
          var _pt = remap(changes.x1, changes.y1);

          var pt2 = remap(changes.x2, changes.y2);
          changes.x1 = _pt.x;
          changes.y1 = _pt.y;
          changes.x2 = pt2.x;
          changes.y2 = pt2.y;
        }
      // Fallthrough

      case 'text':
      case 'tspan':
      case 'use':
        {
          finishUp();
          break;
        }

      case 'g':
        {
          var gsvg = $$7(selected).data('gsvg');

          if (gsvg) {
            assignAttributes(gsvg, changes, 1000, true);
          }

          break;
        }

      case 'polyline':
      case 'polygon':
        {
          var len = changes.points.length;

          for (var _i = 0; _i < len; ++_i) {
            var pt = changes.points[_i];

            var _remap = remap(pt.x, pt.y),
                x = _remap.x,
                y = _remap.y;

            changes.points[_i].x = x;
            changes.points[_i].y = y;
          } // const len = changes.points.length;


          var pstr = '';

          for (var _i2 = 0; _i2 < len; ++_i2) {
            var _pt2 = changes.points[_i2];
            pstr += _pt2.x + ',' + _pt2.y + ' ';
          }

          selected.setAttribute('points', pstr);
          break;
        }

      case 'path':
        {
          var segList = selected.pathSegList;
          var _len = segList.numberOfItems;
          changes.d = [];

          for (var _i3 = 0; _i3 < _len; ++_i3) {
            var seg = segList.getItem(_i3);
            changes.d[_i3] = {
              type: seg.pathSegType,
              x: seg.x,
              y: seg.y,
              x1: seg.x1,
              y1: seg.y1,
              x2: seg.x2,
              y2: seg.y2,
              r1: seg.r1,
              r2: seg.r2,
              angle: seg.angle,
              largeArcFlag: seg.largeArcFlag,
              sweepFlag: seg.sweepFlag
            };
          }

          _len = changes.d.length;
          var firstseg = changes.d[0],
              currentpt = remap(firstseg.x, firstseg.y);
          changes.d[0].x = currentpt.x;
          changes.d[0].y = currentpt.y;

          for (var _i4 = 1; _i4 < _len; ++_i4) {
            var _seg = changes.d[_i4];
            var _type = _seg.type; // if absolute or first segment, we want to remap x, y, x1, y1, x2, y2
            // if relative, we want to scalew, scaleh

            if (_type % 2 === 0) {
              // absolute
              var thisx = _seg.x !== undefined ? _seg.x : currentpt.x,
                  // for V commands
              thisy = _seg.y !== undefined ? _seg.y : currentpt.y; // for H commands

              var _pt3 = remap(thisx, thisy);

              var _pt4 = remap(_seg.x1, _seg.y1);

              var _pt5 = remap(_seg.x2, _seg.y2);

              _seg.x = _pt3.x;
              _seg.y = _pt3.y;
              _seg.x1 = _pt4.x;
              _seg.y1 = _pt4.y;
              _seg.x2 = _pt5.x;
              _seg.y2 = _pt5.y;
              _seg.r1 = scalew(_seg.r1);
              _seg.r2 = scaleh(_seg.r2);
            } else {
              // relative
              _seg.x = scalew(_seg.x);
              _seg.y = scaleh(_seg.y);
              _seg.x1 = scalew(_seg.x1);
              _seg.y1 = scaleh(_seg.y1);
              _seg.x2 = scalew(_seg.x2);
              _seg.y2 = scaleh(_seg.y2);
              _seg.r1 = scalew(_seg.r1);
              _seg.r2 = scaleh(_seg.r2);
            }
          } // for each segment


          var dstr = '';
          _len = changes.d.length;

          for (var _i5 = 0; _i5 < _len; ++_i5) {
            var _seg2 = changes.d[_i5];
            var _type2 = _seg2.type;
            dstr += pathMap$1[_type2];

            switch (_type2) {
              case 13: // relative horizontal line (h)

              case 12:
                // absolute horizontal line (H)
                dstr += _seg2.x + ' ';
                break;

              case 15: // relative vertical line (v)

              case 14:
                // absolute vertical line (V)
                dstr += _seg2.y + ' ';
                break;

              case 3: // relative move (m)

              case 5: // relative line (l)

              case 19: // relative smooth quad (t)

              case 2: // absolute move (M)

              case 4: // absolute line (L)

              case 18:
                // absolute smooth quad (T)
                dstr += _seg2.x + ',' + _seg2.y + ' ';
                break;

              case 7: // relative cubic (c)

              case 6:
                // absolute cubic (C)
                dstr += _seg2.x1 + ',' + _seg2.y1 + ' ' + _seg2.x2 + ',' + _seg2.y2 + ' ' + _seg2.x + ',' + _seg2.y + ' ';
                break;

              case 9: // relative quad (q)

              case 8:
                // absolute quad (Q)
                dstr += _seg2.x1 + ',' + _seg2.y1 + ' ' + _seg2.x + ',' + _seg2.y + ' ';
                break;

              case 11: // relative elliptical arc (a)

              case 10:
                // absolute elliptical arc (A)
                dstr += _seg2.r1 + ',' + _seg2.r2 + ' ' + _seg2.angle + ' ' + Number(_seg2.largeArcFlag) + ' ' + Number(_seg2.sweepFlag) + ' ' + _seg2.x + ',' + _seg2.y + ' ';
                break;

              case 17: // relative smooth cubic (s)

              case 16:
                // absolute smooth cubic (S)
                dstr += _seg2.x2 + ',' + _seg2.y2 + ' ' + _seg2.x + ',' + _seg2.y + ' ';
                break;
            }
          }

          selected.setAttribute('d', dstr);
          break;
        }
    }
  };

  /* globals jQuery */
  var $$8 = jQueryPluginSVG(jQuery);
  var context_;
  /**
  * @interface module:recalculate.EditorContext
  */

  /**
   * @function module:recalculate.EditorContext#getSVGRoot
   * @returns {SVGSVGElement} The root DOM element
   */

  /**
   * @function module:recalculate.EditorContext#getStartTransform
   * @returns {string}
  */

  /**
   * @function module:recalculate.EditorContext#setStartTransform
   * @param {string} transform
   * @returns {void}
   */

  /**
  * @function module:recalculate.init
  * @param {module:recalculate.EditorContext} editorContext
  * @returns {void}
  */

  var init$5 = function init(editorContext) {
    context_ = editorContext;
  };
  /**
  * Updates a `<clipPath>`s values based on the given translation of an element.
  * @function module:recalculate.updateClipPath
  * @param {string} attr - The clip-path attribute value with the clipPath's ID
  * @param {Float} tx - The translation's x value
  * @param {Float} ty - The translation's y value
  * @returns {void}
  */

  var updateClipPath = function updateClipPath(attr, tx, ty) {
    var path = getRefElem(attr).firstChild;
    var cpXform = getTransformList(path);
    var newxlate = context_.getSVGRoot().createSVGTransform();
    newxlate.setTranslate(tx, ty);
    cpXform.appendItem(newxlate); // Update clipPath's dimensions

    recalculateDimensions(path);
  };
  /**
  * Decides the course of action based on the element's transform list.
  * @function module:recalculate.recalculateDimensions
  * @param {Element} selected - The DOM element to recalculate
  * @returns {Command} Undo command object with the resulting change
  */

  var recalculateDimensions = function recalculateDimensions(selected) {
    if (isNullish(selected)) {
      return null;
    } // Firefox Issue - 1081


    if (selected.nodeName === 'svg' && navigator.userAgent.includes('Firefox/20')) {
      return null;
    }

    var svgroot = context_.getSVGRoot();
    var tlist = getTransformList(selected); // remove any unnecessary transforms

    if (tlist && tlist.numberOfItems > 0) {
      var k = tlist.numberOfItems;
      var noi = k;

      while (k--) {
        var xform = tlist.getItem(k);

        if (xform.type === 0) {
          tlist.removeItem(k); // remove identity matrices
        } else if (xform.type === 1) {
          if (isIdentity(xform.matrix)) {
            if (noi === 1) {
              // Overcome Chrome bug (though only when noi is 1) with
              //    `removeItem` preventing `removeAttribute` from
              //    subsequently working
              // See https://bugs.chromium.org/p/chromium/issues/detail?id=843901
              selected.removeAttribute('transform');
              return null;
            }

            tlist.removeItem(k);
          } // remove zero-degree rotations

        } else if (xform.type === 4) {
          if (xform.angle === 0) {
            tlist.removeItem(k);
          }
        }
      } // End here if all it has is a rotation


      if (tlist.numberOfItems === 1 && getRotationAngle(selected)) {
        return null;
      }
    } // if this element had no transforms, we are done


    if (!tlist || tlist.numberOfItems === 0) {
      // Chrome apparently had a bug that requires clearing the attribute first.
      selected.setAttribute('transform', ''); // However, this still next line currently doesn't work at all in Chrome

      selected.removeAttribute('transform'); // selected.transform.baseVal.clear(); // Didn't help for Chrome bug

      return null;
    } // TODO: Make this work for more than 2


    if (tlist) {
      var mxs = [];
      var _k = tlist.numberOfItems;

      while (_k--) {
        var _xform = tlist.getItem(_k);

        if (_xform.type === 1) {
          mxs.push([_xform.matrix, _k]);
        } else if (mxs.length) {
          mxs = [];
        }
      }

      if (mxs.length === 2) {
        var mNew = svgroot.createSVGTransformFromMatrix(matrixMultiply(mxs[1][0], mxs[0][0]));
        tlist.removeItem(mxs[0][1]);
        tlist.removeItem(mxs[1][1]);
        tlist.insertItemBefore(mNew, mxs[1][1]);
      } // combine matrix + translate


      _k = tlist.numberOfItems;

      if (_k >= 2 && tlist.getItem(_k - 2).type === 1 && tlist.getItem(_k - 1).type === 2) {
        var mt = svgroot.createSVGTransform();
        var m = matrixMultiply(tlist.getItem(_k - 2).matrix, tlist.getItem(_k - 1).matrix);
        mt.setMatrix(m);
        tlist.removeItem(_k - 2);
        tlist.removeItem(_k - 2);
        tlist.appendItem(mt);
      }
    } // If it still has a single [M] or [R][M], return null too (prevents BatchCommand from being returned).


    switch (selected.tagName) {
      // Ignore these elements, as they can absorb the [M]
      case 'line':
      case 'polyline':
      case 'polygon':
      case 'path':
        break;

      default:
        if (tlist.numberOfItems === 1 && tlist.getItem(0).type === 1 || tlist.numberOfItems === 2 && tlist.getItem(0).type === 1 && tlist.getItem(0).type === 4) {
          return null;
        }

    } // Grouped SVG element


    var gsvg = $$8(selected).data('gsvg'); // we know we have some transforms, so set up return variable

    var batchCmd = new BatchCommand('Transform'); // store initial values that will be affected by reducing the transform list

    var changes = {};
    var initial = null;
    var attrs = [];

    switch (selected.tagName) {
      case 'line':
        attrs = ['x1', 'y1', 'x2', 'y2'];
        break;

      case 'circle':
        attrs = ['cx', 'cy', 'r'];
        break;

      case 'ellipse':
        attrs = ['cx', 'cy', 'rx', 'ry'];
        break;

      case 'foreignObject':
      case 'rect':
      case 'image':
        attrs = ['width', 'height', 'x', 'y'];
        break;

      case 'use':
      case 'text':
      case 'tspan':
        attrs = ['x', 'y'];
        break;

      case 'polygon':
      case 'polyline':
        {
          initial = {};
          initial.points = selected.getAttribute('points');
          var list = selected.points;
          var len = list.numberOfItems;
          changes.points = new Array(len);

          for (var i = 0; i < len; ++i) {
            var pt = list.getItem(i);
            changes.points[i] = {
              x: pt.x,
              y: pt.y
            };
          }

          break;
        }

      case 'path':
        initial = {};
        initial.d = selected.getAttribute('d');
        changes.d = selected.getAttribute('d');
        break;
    } // switch on element type to get initial values


    if (attrs.length) {
      changes = $$8(selected).attr(attrs);
      $$8.each(changes, function (attr, val) {
        changes[attr] = convertToNum(attr, val);
      });
    } else if (gsvg) {
      // GSVG exception
      changes = {
        x: $$8(gsvg).attr('x') || 0,
        y: $$8(gsvg).attr('y') || 0
      };
    } // if we haven't created an initial array in polygon/polyline/path, then
    // make a copy of initial values and include the transform


    if (isNullish(initial)) {
      initial = $$8.extend(true, {}, changes);
      $$8.each(initial, function (attr, val) {
        initial[attr] = convertToNum(attr, val);
      });
    } // save the start transform value too


    initial.transform = context_.getStartTransform() || '';
    var oldcenter, newcenter; // if it's a regular group, we have special processing to flatten transforms

    if (selected.tagName === 'g' && !gsvg || selected.tagName === 'a') {
      var box = getBBox(selected);
      oldcenter = {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2
      };
      newcenter = transformPoint(box.x + box.width / 2, box.y + box.height / 2, transformListToTransform(tlist).matrix); // let m = svgroot.createSVGMatrix();
      // temporarily strip off the rotate and save the old center

      var gangle = getRotationAngle(selected);

      if (gangle) {
        var a = gangle * Math.PI / 180;
        var s;

        if (Math.abs(a) > 1.0e-10) {
          s = Math.sin(a) / (1 - Math.cos(a));
        } else {
          // TODO: This blows up if the angle is exactly 0!
          s = 2 / a;
        }

        for (var _i = 0; _i < tlist.numberOfItems; ++_i) {
          var _xform2 = tlist.getItem(_i);

          if (_xform2.type === 4) {
            // extract old center through mystical arts
            var rm = _xform2.matrix;
            oldcenter.y = (s * rm.e + rm.f) / 2;
            oldcenter.x = (rm.e - s * rm.f) / 2;
            tlist.removeItem(_i);
            break;
          }
        }
      }

      var N = tlist.numberOfItems;
      var tx = 0,
          ty = 0,
          operation = 0;
      var firstM;

      if (N) {
        firstM = tlist.getItem(0).matrix;
      }

      var oldStartTransform; // first, if it was a scale then the second-last transform will be it

      if (N >= 3 && tlist.getItem(N - 2).type === 3 && tlist.getItem(N - 3).type === 2 && tlist.getItem(N - 1).type === 2) {
        operation = 3; // scale
        // if the children are unrotated, pass the scale down directly
        // otherwise pass the equivalent matrix() down directly

        var tm = tlist.getItem(N - 3).matrix,
            sm = tlist.getItem(N - 2).matrix,
            tmn = tlist.getItem(N - 1).matrix;
        var children = selected.childNodes;
        var c = children.length;

        while (c--) {
          var child = children.item(c);
          tx = 0;
          ty = 0;

          if (child.nodeType === 1) {
            var childTlist = getTransformList(child); // some children might not have a transform (<metadata>, <defs>, etc)

            if (!childTlist) {
              continue;
            }

            var _m = transformListToTransform(childTlist).matrix; // Convert a matrix to a scale if applicable
            // if (hasMatrixTransform(childTlist) && childTlist.numberOfItems == 1) {
            //   if (m.b==0 && m.c==0 && m.e==0 && m.f==0) {
            //     childTlist.removeItem(0);
            //     const translateOrigin = svgroot.createSVGTransform(),
            //       scale = svgroot.createSVGTransform(),
            //       translateBack = svgroot.createSVGTransform();
            //     translateOrigin.setTranslate(0, 0);
            //     scale.setScale(m.a, m.d);
            //     translateBack.setTranslate(0, 0);
            //     childTlist.appendItem(translateBack);
            //     childTlist.appendItem(scale);
            //     childTlist.appendItem(translateOrigin);
            //   }
            // }

            var angle = getRotationAngle(child);
            oldStartTransform = context_.getStartTransform(); // const childxforms = [];

            context_.setStartTransform(child.getAttribute('transform'));

            if (angle || hasMatrixTransform(childTlist)) {
              var e2t = svgroot.createSVGTransform();
              e2t.setMatrix(matrixMultiply(tm, sm, tmn, _m));
              childTlist.clear();
              childTlist.appendItem(e2t); // childxforms.push(e2t);
              // if not rotated or skewed, push the [T][S][-T] down to the child
            } else {
              // update the transform list with translate,scale,translate
              // slide the [T][S][-T] from the front to the back
              // [T][S][-T][M] = [M][T2][S2][-T2]
              // (only bringing [-T] to the right of [M])
              // [T][S][-T][M] = [T][S][M][-T2]
              // [-T2] = [M_inv][-T][M]
              var t2n = matrixMultiply(_m.inverse(), tmn, _m); // [T2] is always negative translation of [-T2]

              var t2 = svgroot.createSVGMatrix();
              t2.e = -t2n.e;
              t2.f = -t2n.f; // [T][S][-T][M] = [M][T2][S2][-T2]
              // [S2] = [T2_inv][M_inv][T][S][-T][M][-T2_inv]

              var s2 = matrixMultiply(t2.inverse(), _m.inverse(), tm, sm, tmn, _m, t2n.inverse());
              var translateOrigin = svgroot.createSVGTransform(),
                  scale = svgroot.createSVGTransform(),
                  translateBack = svgroot.createSVGTransform();
              translateOrigin.setTranslate(t2n.e, t2n.f);
              scale.setScale(s2.a, s2.d);
              translateBack.setTranslate(t2.e, t2.f);
              childTlist.appendItem(translateBack);
              childTlist.appendItem(scale);
              childTlist.appendItem(translateOrigin); // childxforms.push(translateBack);
              // childxforms.push(scale);
              // childxforms.push(translateOrigin);
              // logMatrix(translateBack.matrix);
              // logMatrix(scale.matrix);
            } // not rotated


            batchCmd.addSubCommand(recalculateDimensions(child)); // TODO: If any <use> have this group as a parent and are
            // referencing this child, then we need to impose a reverse
            // scale on it so that when it won't get double-translated
            // const uses = selected.getElementsByTagNameNS(NS.SVG, 'use');
            // const href = '#' + child.id;
            // let u = uses.length;
            // while (u--) {
            //   const useElem = uses.item(u);
            //   if (href == getHref(useElem)) {
            //     const usexlate = svgroot.createSVGTransform();
            //     usexlate.setTranslate(-tx,-ty);
            //     getTransformList(useElem).insertItemBefore(usexlate,0);
            //     batchCmd.addSubCommand( recalculateDimensions(useElem) );
            //   }
            // }

            context_.setStartTransform(oldStartTransform);
          } // element

        } // for each child
        // Remove these transforms from group


        tlist.removeItem(N - 1);
        tlist.removeItem(N - 2);
        tlist.removeItem(N - 3);
      } else if (N >= 3 && tlist.getItem(N - 1).type === 1) {
        operation = 3; // scale

        var _m2 = transformListToTransform(tlist).matrix;

        var _e2t = svgroot.createSVGTransform();

        _e2t.setMatrix(_m2);

        tlist.clear();
        tlist.appendItem(_e2t); // next, check if the first transform was a translate
        // if we had [ T1 ] [ M ] we want to transform this into [ M ] [ T2 ]
        // therefore [ T2 ] = [ M_inv ] [ T1 ] [ M ]
      } else if ((N === 1 || N > 1 && tlist.getItem(1).type !== 3) && tlist.getItem(0).type === 2) {
        operation = 2; // translate

        var T_M = transformListToTransform(tlist).matrix;
        tlist.removeItem(0);
        var mInv = transformListToTransform(tlist).matrix.inverse();
        var M2 = matrixMultiply(mInv, T_M);
        tx = M2.e;
        ty = M2.f;

        if (tx !== 0 || ty !== 0) {
          // we pass the translates down to the individual children
          var _children = selected.childNodes;
          var _c = _children.length;
          var clipPathsDone = [];

          while (_c--) {
            var _child = _children.item(_c);

            if (_child.nodeType === 1) {
              // Check if child has clip-path
              if (_child.getAttribute('clip-path')) {
                // tx, ty
                var attr = _child.getAttribute('clip-path');

                if (!clipPathsDone.includes(attr)) {
                  updateClipPath(attr, tx, ty);
                  clipPathsDone.push(attr);
                }
              }

              oldStartTransform = context_.getStartTransform();
              context_.setStartTransform(_child.getAttribute('transform'));

              var _childTlist = getTransformList(_child); // some children might not have a transform (<metadata>, <defs>, etc)


              if (_childTlist) {
                var newxlate = svgroot.createSVGTransform();
                newxlate.setTranslate(tx, ty);

                if (_childTlist.numberOfItems) {
                  _childTlist.insertItemBefore(newxlate, 0);
                } else {
                  _childTlist.appendItem(newxlate);
                }

                batchCmd.addSubCommand(recalculateDimensions(_child)); // If any <use> have this group as a parent and are
                // referencing this child, then impose a reverse translate on it
                // so that when it won't get double-translated

                var uses = selected.getElementsByTagNameNS(NS.SVG, 'use');
                var href = '#' + _child.id;
                var u = uses.length;

                while (u--) {
                  var useElem = uses.item(u);

                  if (href === getHref(useElem)) {
                    var usexlate = svgroot.createSVGTransform();
                    usexlate.setTranslate(-tx, -ty);
                    getTransformList(useElem).insertItemBefore(usexlate, 0);
                    batchCmd.addSubCommand(recalculateDimensions(useElem));
                  }
                }

                context_.setStartTransform(oldStartTransform);
              }
            }
          }

          context_.setStartTransform(oldStartTransform);
        } // else, a matrix imposition from a parent group
        // keep pushing it down to the children

      } else if (N === 1 && tlist.getItem(0).type === 1 && !gangle) {
        operation = 1;
        var _m3 = tlist.getItem(0).matrix,
            _children2 = selected.childNodes;
        var _c2 = _children2.length;

        while (_c2--) {
          var _child2 = _children2.item(_c2);

          if (_child2.nodeType === 1) {
            oldStartTransform = context_.getStartTransform();
            context_.setStartTransform(_child2.getAttribute('transform'));

            var _childTlist2 = getTransformList(_child2);

            if (!_childTlist2) {
              continue;
            }

            var em = matrixMultiply(_m3, transformListToTransform(_childTlist2).matrix);
            var e2m = svgroot.createSVGTransform();
            e2m.setMatrix(em);

            _childTlist2.clear();

            _childTlist2.appendItem(e2m, 0);

            batchCmd.addSubCommand(recalculateDimensions(_child2));
            context_.setStartTransform(oldStartTransform); // Convert stroke
            // TODO: Find out if this should actually happen somewhere else

            var sw = _child2.getAttribute('stroke-width');

            if (_child2.getAttribute('stroke') !== 'none' && !isNaN(sw)) {
              var avg = (Math.abs(em.a) + Math.abs(em.d)) / 2;

              _child2.setAttribute('stroke-width', sw * avg);
            }
          }
        }

        tlist.clear(); // else it was just a rotate
      } else {
        if (gangle) {
          var newRot = svgroot.createSVGTransform();
          newRot.setRotate(gangle, newcenter.x, newcenter.y);

          if (tlist.numberOfItems) {
            tlist.insertItemBefore(newRot, 0);
          } else {
            tlist.appendItem(newRot);
          }
        }

        if (tlist.numberOfItems === 0) {
          selected.removeAttribute('transform');
        }

        return null;
      } // if it was a translate, put back the rotate at the new center


      if (operation === 2) {
        if (gangle) {
          newcenter = {
            x: oldcenter.x + firstM.e,
            y: oldcenter.y + firstM.f
          };

          var _newRot = svgroot.createSVGTransform();

          _newRot.setRotate(gangle, newcenter.x, newcenter.y);

          if (tlist.numberOfItems) {
            tlist.insertItemBefore(_newRot, 0);
          } else {
            tlist.appendItem(_newRot);
          }
        } // if it was a resize

      } else if (operation === 3) {
        var _m4 = transformListToTransform(tlist).matrix;
        var roldt = svgroot.createSVGTransform();
        roldt.setRotate(gangle, oldcenter.x, oldcenter.y);
        var rold = roldt.matrix;
        var rnew = svgroot.createSVGTransform();
        rnew.setRotate(gangle, newcenter.x, newcenter.y);

        var rnewInv = rnew.matrix.inverse(),
            _mInv = _m4.inverse(),
            extrat = matrixMultiply(_mInv, rnewInv, rold, _m4);

        tx = extrat.e;
        ty = extrat.f;

        if (tx !== 0 || ty !== 0) {
          // now push this transform down to the children
          // we pass the translates down to the individual children
          var _children3 = selected.childNodes;
          var _c3 = _children3.length;

          while (_c3--) {
            var _child3 = _children3.item(_c3);

            if (_child3.nodeType === 1) {
              oldStartTransform = context_.getStartTransform();
              context_.setStartTransform(_child3.getAttribute('transform'));

              var _childTlist3 = getTransformList(_child3);

              var _newxlate = svgroot.createSVGTransform();

              _newxlate.setTranslate(tx, ty);

              if (_childTlist3.numberOfItems) {
                _childTlist3.insertItemBefore(_newxlate, 0);
              } else {
                _childTlist3.appendItem(_newxlate);
              }

              batchCmd.addSubCommand(recalculateDimensions(_child3));
              context_.setStartTransform(oldStartTransform);
            }
          }
        }

        if (gangle) {
          if (tlist.numberOfItems) {
            tlist.insertItemBefore(rnew, 0);
          } else {
            tlist.appendItem(rnew);
          }
        }
      } // else, it's a non-group

    } else {
      // TODO: box might be null for some elements (<metadata> etc), need to handle this
      var _box = getBBox(selected); // Paths (and possbly other shapes) will have no BBox while still in <defs>,
      // but we still may need to recalculate them (see issue 595).
      // TODO: Figure out how to get BBox from these elements in case they
      // have a rotation transform


      if (!_box && selected.tagName !== 'path') return null;

      var _m5; // = svgroot.createSVGMatrix();
      // temporarily strip off the rotate and save the old center


      var _angle = getRotationAngle(selected);

      if (_angle) {
        oldcenter = {
          x: _box.x + _box.width / 2,
          y: _box.y + _box.height / 2
        };
        newcenter = transformPoint(_box.x + _box.width / 2, _box.y + _box.height / 2, transformListToTransform(tlist).matrix);

        var _a = _angle * Math.PI / 180;

        var _s = Math.abs(_a) > 1.0e-10 ? Math.sin(_a) / (1 - Math.cos(_a)) // TODO: This blows up if the angle is exactly 0!
        : 2 / _a;

        for (var _i2 = 0; _i2 < tlist.numberOfItems; ++_i2) {
          var _xform3 = tlist.getItem(_i2);

          if (_xform3.type === 4) {
            // extract old center through mystical arts
            var _rm = _xform3.matrix;
            oldcenter.y = (_s * _rm.e + _rm.f) / 2;
            oldcenter.x = (_rm.e - _s * _rm.f) / 2;
            tlist.removeItem(_i2);
            break;
          }
        }
      } // 2 = translate, 3 = scale, 4 = rotate, 1 = matrix imposition


      var _operation = 0;
      var _N = tlist.numberOfItems; // Check if it has a gradient with userSpaceOnUse, in which case
      // adjust it by recalculating the matrix transform.
      // TODO: Make this work in Webkit using transformlist.SVGTransformList

      if (!isWebkit()) {
        var fill = selected.getAttribute('fill');

        if (fill && fill.startsWith('url(')) {
          var paint = getRefElem(fill);
          var type = 'pattern';
          if (paint.tagName !== type) type = 'gradient';
          var attrVal = paint.getAttribute(type + 'Units');

          if (attrVal === 'userSpaceOnUse') {
            // Update the userSpaceOnUse element
            _m5 = transformListToTransform(tlist).matrix;
            var gtlist = getTransformList(paint);
            var gmatrix = transformListToTransform(gtlist).matrix;
            _m5 = matrixMultiply(_m5, gmatrix);
            var mStr = 'matrix(' + [_m5.a, _m5.b, _m5.c, _m5.d, _m5.e, _m5.f].join(',') + ')';
            paint.setAttribute(type + 'Transform', mStr);
          }
        }
      } // first, if it was a scale of a non-skewed element, then the second-last
      // transform will be the [S]
      // if we had [M][T][S][T] we want to extract the matrix equivalent of
      // [T][S][T] and push it down to the element


      if (_N >= 3 && tlist.getItem(_N - 2).type === 3 && tlist.getItem(_N - 3).type === 2 && tlist.getItem(_N - 1).type === 2) {
        // Removed this so a <use> with a given [T][S][T] would convert to a matrix.
        // Is that bad?
        //  && selected.nodeName != 'use'
        _operation = 3; // scale

        _m5 = transformListToTransform(tlist, _N - 3, _N - 1).matrix;
        tlist.removeItem(_N - 1);
        tlist.removeItem(_N - 2);
        tlist.removeItem(_N - 3); // if we had [T][S][-T][M], then this was a skewed element being resized
        // Thus, we simply combine it all into one matrix
      } else if (_N === 4 && tlist.getItem(_N - 1).type === 1) {
        _operation = 3; // scale

        _m5 = transformListToTransform(tlist).matrix;

        var _e2t2 = svgroot.createSVGTransform();

        _e2t2.setMatrix(_m5);

        tlist.clear();
        tlist.appendItem(_e2t2); // reset the matrix so that the element is not re-mapped

        _m5 = svgroot.createSVGMatrix(); // if we had [R][T][S][-T][M], then this was a rotated matrix-element
        // if we had [T1][M] we want to transform this into [M][T2]
        // therefore [ T2 ] = [ M_inv ] [ T1 ] [ M ] and we can push [T2]
        // down to the element
      } else if ((_N === 1 || _N > 1 && tlist.getItem(1).type !== 3) && tlist.getItem(0).type === 2) {
        _operation = 2; // translate

        var oldxlate = tlist.getItem(0).matrix,
            meq = transformListToTransform(tlist, 1).matrix,
            meqInv = meq.inverse();
        _m5 = matrixMultiply(meqInv, oldxlate, meq);
        tlist.removeItem(0); // else if this child now has a matrix imposition (from a parent group)
        // we might be able to simplify
      } else if (_N === 1 && tlist.getItem(0).type === 1 && !_angle) {
        // Remap all point-based elements
        _m5 = transformListToTransform(tlist).matrix;

        switch (selected.tagName) {
          case 'line':
            changes = $$8(selected).attr(['x1', 'y1', 'x2', 'y2']);
          // Fallthrough

          case 'polyline':
          case 'polygon':
            changes.points = selected.getAttribute('points');

            if (changes.points) {
              var _list = selected.points;
              var _len = _list.numberOfItems;
              changes.points = new Array(_len);

              for (var _i3 = 0; _i3 < _len; ++_i3) {
                var _pt = _list.getItem(_i3);

                changes.points[_i3] = {
                  x: _pt.x,
                  y: _pt.y
                };
              }
            }

          // Fallthrough

          case 'path':
            changes.d = selected.getAttribute('d');
            _operation = 1;
            tlist.clear();
            break;
        } // if it was a rotation, put the rotate back and return without a command
        // (this function has zero work to do for a rotate())

      } else {
        // operation = 4; // rotation
        if (_angle) {
          var _newRot2 = svgroot.createSVGTransform();

          _newRot2.setRotate(_angle, newcenter.x, newcenter.y);

          if (tlist.numberOfItems) {
            tlist.insertItemBefore(_newRot2, 0);
          } else {
            tlist.appendItem(_newRot2);
          }
        }

        if (tlist.numberOfItems === 0) {
          selected.removeAttribute('transform');
        }

        return null;
      } // if it was a translate or resize, we need to remap the element and absorb the xform


      if (_operation === 1 || _operation === 2 || _operation === 3) {
        remapElement(selected, changes, _m5);
      } // if we are remapping
      // if it was a translate, put back the rotate at the new center


      if (_operation === 2) {
        if (_angle) {
          if (!hasMatrixTransform(tlist)) {
            newcenter = {
              x: oldcenter.x + _m5.e,
              y: oldcenter.y + _m5.f
            };
          }

          var _newRot3 = svgroot.createSVGTransform();

          _newRot3.setRotate(_angle, newcenter.x, newcenter.y);

          if (tlist.numberOfItems) {
            tlist.insertItemBefore(_newRot3, 0);
          } else {
            tlist.appendItem(_newRot3);
          }
        } // We have special processing for tspans:  Tspans are not transformable
        // but they can have x,y coordinates (sigh).  Thus, if this was a translate,
        // on a text element, also translate any tspan children.


        if (selected.tagName === 'text') {
          var _children4 = selected.childNodes;
          var _c4 = _children4.length;

          while (_c4--) {
            var _child4 = _children4.item(_c4);

            if (_child4.tagName === 'tspan') {
              var tspanChanges = {
                x: $$8(_child4).attr('x') || 0,
                y: $$8(_child4).attr('y') || 0
              };
              remapElement(_child4, tspanChanges, _m5);
            }
          }
        } // [Rold][M][T][S][-T] became [Rold][M]
        // we want it to be [Rnew][M][Tr] where Tr is the
        // translation required to re-center it
        // Therefore, [Tr] = [M_inv][Rnew_inv][Rold][M]

      } else if (_operation === 3 && _angle) {
        var _transformListToTrans = transformListToTransform(tlist),
            matrix = _transformListToTrans.matrix;

        var _roldt = svgroot.createSVGTransform();

        _roldt.setRotate(_angle, oldcenter.x, oldcenter.y);

        var _rold = _roldt.matrix;

        var _rnew = svgroot.createSVGTransform();

        _rnew.setRotate(_angle, newcenter.x, newcenter.y);

        var _rnewInv = _rnew.matrix.inverse();

        var _mInv2 = matrix.inverse();

        var _extrat = matrixMultiply(_mInv2, _rnewInv, _rold, matrix);

        remapElement(selected, changes, _extrat);

        if (_angle) {
          if (tlist.numberOfItems) {
            tlist.insertItemBefore(_rnew, 0);
          } else {
            tlist.appendItem(_rnew);
          }
        }
      }
    } // a non-group
    // if the transform list has been emptied, remove it


    if (tlist.numberOfItems === 0) {
      selected.removeAttribute('transform');
    }

    batchCmd.addSubCommand(new ChangeElementCommand(selected, initial));
    return batchCmd;
  };

  var $$9 = jQuery;
  var svgFactory_;
  var config_;
  var selectorManager_; // A Singleton

  var gripRadius = isTouch() ? 10 : 4;
  /**
  * Private class for DOM element selection boxes.
  */

  var Selector = /*#__PURE__*/function () {
    /**
    * @param {Integer} id - Internally identify the selector
    * @param {Element} elem - DOM element associated with this selector
    * @param {module:utilities.BBoxObject} [bbox] - Optional bbox to use for initialization (prevents duplicate `getBBox` call).
    */
    function Selector(id, elem, bbox) {
      _classCallCheck(this, Selector);

      // this is the selector's unique number
      this.id = id; // this holds a reference to the element for which this selector is being used

      this.selectedElement = elem; // this is a flag used internally to track whether the selector is being used or not

      this.locked = true; // this holds a reference to the <g> element that holds all visual elements of the selector

      this.selectorGroup = svgFactory_.createSVGElement({
        element: 'g',
        attr: {
          id: 'selectorGroup' + this.id
        }
      }); // this holds a reference to the path rect

      this.selectorRect = this.selectorGroup.appendChild(svgFactory_.createSVGElement({
        element: 'path',
        attr: {
          id: 'selectedBox' + this.id,
          fill: 'none',
          stroke: '#22C',
          'stroke-width': '1',
          'stroke-dasharray': '5,5',
          // need to specify this so that the rect is not selectable
          style: 'pointer-events:none'
        }
      })); // this holds a reference to the grip coordinates for this selector

      this.gripCoords = {
        nw: null,
        n: null,
        ne: null,
        e: null,
        se: null,
        s: null,
        sw: null,
        w: null
      };
      this.reset(this.selectedElement, bbox);
    }
    /**
    * Used to reset the id and element that the selector is attached to.
    * @param {Element} e - DOM element associated with this selector
    * @param {module:utilities.BBoxObject} bbox - Optional bbox to use for reset (prevents duplicate getBBox call).
    * @returns {void}
    */


    _createClass(Selector, [{
      key: "reset",
      value: function reset(e, bbox) {
        this.locked = true;
        this.selectedElement = e;
        this.resize(bbox);
        this.selectorGroup.setAttribute('display', 'inline');
      }
      /**
      * Show the resize grips of this selector.
      * @param {boolean} show - Indicates whether grips should be shown or not
      * @returns {void}
      */

    }, {
      key: "showGrips",
      value: function showGrips(show) {
        var bShow = show ? 'inline' : 'none';
        selectorManager_.selectorGripsGroup.setAttribute('display', bShow);
        var elem = this.selectedElement;
        this.hasGrips = show;

        if (elem && show) {
          this.selectorGroup.append(selectorManager_.selectorGripsGroup);
          Selector.updateGripCursors(getRotationAngle(elem));
        }
      }
      /**
      * Updates the selector to match the element's size.
      * @param {module:utilities.BBoxObject} [bbox] - BBox to use for resize (prevents duplicate getBBox call).
      * @returns {void}
      */

    }, {
      key: "resize",
      value: function resize(bbox) {
        var selectedBox = this.selectorRect,
            mgr = selectorManager_,
            selectedGrips = mgr.selectorGrips,
            selected = this.selectedElement,
            sw = selected.getAttribute('stroke-width'),
            currentZoom = svgFactory_.getCurrentZoom();
        var offset = 1 / currentZoom;

        if (selected.getAttribute('stroke') !== 'none' && !isNaN(sw)) {
          offset += sw / 2;
        }

        var tagName = selected.tagName;

        if (tagName === 'text') {
          offset += 2 / currentZoom;
        } // loop and transform our bounding box until we reach our first rotation


        var tlist = getTransformList(selected);
        var m = transformListToTransform(tlist).matrix; // This should probably be handled somewhere else, but for now
        // it keeps the selection box correctly positioned when zoomed

        m.e *= currentZoom;
        m.f *= currentZoom;

        if (!bbox) {
          bbox = getBBox(selected);
        } // TODO: getBBox (previous line) already knows to call getStrokedBBox when tagName === 'g'. Remove this?
        // TODO: getBBox doesn't exclude 'gsvg' and calls getStrokedBBox for any 'g'. Should getBBox be updated?


        if (tagName === 'g' && !$$9.data(selected, 'gsvg')) {
          // The bbox for a group does not include stroke vals, so we
          // get the bbox based on its children.
          var strokedBbox = getStrokedBBox([selected.childNodes]);

          if (strokedBbox) {
            bbox = strokedBbox;
          }
        } // apply the transforms


        var l = bbox.x,
            t = bbox.y,
            w = bbox.width,
            h = bbox.height; // bbox = {x: l, y: t, width: w, height: h}; // Not in use
        // we need to handle temporary transforms too
        // if skewed, get its transformed box, then find its axis-aligned bbox
        // *

        offset *= currentZoom;
        var nbox = transformBox(l * currentZoom, t * currentZoom, w * currentZoom, h * currentZoom, m),
            aabox = nbox.aabox;
        var nbax = aabox.x - offset,
            nbay = aabox.y - offset,
            nbaw = aabox.width + offset * 2,
            nbah = aabox.height + offset * 2; // now if the shape is rotated, un-rotate it

        var cx = nbax + nbaw / 2,
            cy = nbay + nbah / 2;
        var angle = getRotationAngle(selected);

        if (angle) {
          var rot = svgFactory_.svgRoot().createSVGTransform();
          rot.setRotate(-angle, cx, cy);
          var rotm = rot.matrix;
          nbox.tl = transformPoint(nbox.tl.x, nbox.tl.y, rotm);
          nbox.tr = transformPoint(nbox.tr.x, nbox.tr.y, rotm);
          nbox.bl = transformPoint(nbox.bl.x, nbox.bl.y, rotm);
          nbox.br = transformPoint(nbox.br.x, nbox.br.y, rotm); // calculate the axis-aligned bbox

          var tl = nbox.tl;
          var minx = tl.x,
              miny = tl.y,
              maxx = tl.x,
              maxy = tl.y;
          var min = Math.min,
              max = Math.max;
          minx = min(minx, min(nbox.tr.x, min(nbox.bl.x, nbox.br.x))) - offset;
          miny = min(miny, min(nbox.tr.y, min(nbox.bl.y, nbox.br.y))) - offset;
          maxx = max(maxx, max(nbox.tr.x, max(nbox.bl.x, nbox.br.x))) + offset;
          maxy = max(maxy, max(nbox.tr.y, max(nbox.bl.y, nbox.br.y))) + offset;
          nbax = minx;
          nbay = miny;
          nbaw = maxx - minx;
          nbah = maxy - miny;
        }

        var dstr = 'M' + nbax + ',' + nbay + ' L' + (nbax + nbaw) + ',' + nbay + ' ' + (nbax + nbaw) + ',' + (nbay + nbah) + ' ' + nbax + ',' + (nbay + nbah) + 'z';
        selectedBox.setAttribute('d', dstr);
        var xform = angle ? 'rotate(' + [angle, cx, cy].join(',') + ')' : '';
        this.selectorGroup.setAttribute('transform', xform); // TODO(codedread): Is this needed?
        //  if (selected === selectedElements[0]) {

        this.gripCoords = {
          nw: [nbax, nbay],
          ne: [nbax + nbaw, nbay],
          sw: [nbax, nbay + nbah],
          se: [nbax + nbaw, nbay + nbah],
          n: [nbax + nbaw / 2, nbay],
          w: [nbax, nbay + nbah / 2],
          e: [nbax + nbaw, nbay + nbah / 2],
          s: [nbax + nbaw / 2, nbay + nbah]
        };
        Object.entries(this.gripCoords).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              dir = _ref2[0],
              coords = _ref2[1];

          selectedGrips[dir].setAttribute('cx', coords[0]);
          selectedGrips[dir].setAttribute('cy', coords[1]);
        }); // we want to go 20 pixels in the negative transformed y direction, ignoring scale

        mgr.rotateGripConnector.setAttribute('x1', nbax + nbaw / 2);
        mgr.rotateGripConnector.setAttribute('y1', nbay);
        mgr.rotateGripConnector.setAttribute('x2', nbax + nbaw / 2);
        mgr.rotateGripConnector.setAttribute('y2', nbay - gripRadius * 5);
        mgr.rotateGrip.setAttribute('cx', nbax + nbaw / 2);
        mgr.rotateGrip.setAttribute('cy', nbay - gripRadius * 5); // }
      } // STATIC methods

      /**
      * Updates cursors for corner grips on rotation so arrows point the right way.
      * @param {Float} angle - Current rotation angle in degrees
      * @returns {void}
      */

    }], [{
      key: "updateGripCursors",
      value: function updateGripCursors(angle) {
        var dirArr = Object.keys(selectorManager_.selectorGrips);
        var steps = Math.round(angle / 45);

        if (steps < 0) {
          steps += 8;
        }

        while (steps > 0) {
          dirArr.push(dirArr.shift());
          steps--;
        }

        Object.values(selectorManager_.selectorGrips).forEach(function (gripElement, i) {
          gripElement.setAttribute('style', 'cursor:' + dirArr[i] + '-resize');
        });
      }
    }]);

    return Selector;
  }();
  /**
  * Manage all selector objects (selection boxes).
  */

  var SelectorManager = /*#__PURE__*/function () {
    /**
     * Sets up properties and calls `initGroup`.
     */
    function SelectorManager() {
      _classCallCheck(this, SelectorManager);

      // this will hold the <g> element that contains all selector rects/grips
      this.selectorParentGroup = null; // this is a special rect that is used for multi-select

      this.rubberBandBox = null; // this will hold objects of type Selector (see above)

      this.selectors = []; // this holds a map of SVG elements to their Selector object

      this.selectorMap = {}; // this holds a reference to the grip elements

      this.selectorGrips = {
        nw: null,
        n: null,
        ne: null,
        e: null,
        se: null,
        s: null,
        sw: null,
        w: null
      };
      this.selectorGripsGroup = null;
      this.rotateGripConnector = null;
      this.rotateGrip = null;
      this.initGroup();
    }
    /**
    * Resets the parent selector group element.
    * @returns {void}
    */


    _createClass(SelectorManager, [{
      key: "initGroup",
      value: function initGroup() {
        var _this = this;

        // remove old selector parent group if it existed
        if (this.selectorParentGroup && this.selectorParentGroup.parentNode) {
          this.selectorParentGroup.remove();
        } // create parent selector group and add it to svgroot


        this.selectorParentGroup = svgFactory_.createSVGElement({
          element: 'g',
          attr: {
            id: 'selectorParentGroup'
          }
        });
        this.selectorGripsGroup = svgFactory_.createSVGElement({
          element: 'g',
          attr: {
            display: 'none'
          }
        });
        this.selectorParentGroup.append(this.selectorGripsGroup);
        svgFactory_.svgRoot().append(this.selectorParentGroup);
        this.selectorMap = {};
        this.selectors = [];
        this.rubberBandBox = null; // add the corner grips

        Object.keys(this.selectorGrips).forEach(function (dir) {
          var grip = svgFactory_.createSVGElement({
            element: 'circle',
            attr: {
              id: 'selectorGrip_resize_' + dir,
              fill: '#22C',
              r: gripRadius,
              style: 'cursor:' + dir + '-resize',
              // This expands the mouse-able area of the grips making them
              // easier to grab with the mouse.
              // This works in Opera and WebKit, but does not work in Firefox
              // see https://bugzilla.mozilla.org/show_bug.cgi?id=500174
              'stroke-width': 2,
              'pointer-events': 'all'
            }
          });
          $$9.data(grip, 'dir', dir);
          $$9.data(grip, 'type', 'resize');
          _this.selectorGrips[dir] = _this.selectorGripsGroup.appendChild(grip);
        }); // add rotator elems

        this.rotateGripConnector = this.selectorGripsGroup.appendChild(svgFactory_.createSVGElement({
          element: 'line',
          attr: {
            id: 'selectorGrip_rotateconnector',
            stroke: '#22C',
            'stroke-width': '1'
          }
        }));
        this.rotateGrip = this.selectorGripsGroup.appendChild(svgFactory_.createSVGElement({
          element: 'circle',
          attr: {
            id: 'selectorGrip_rotate',
            fill: 'lime',
            r: gripRadius,
            stroke: '#22C',
            'stroke-width': 2,
            style: 'cursor:url(' + config_.imgPath + 'rotate.png) 12 12, auto;'
          }
        }));
        $$9.data(this.rotateGrip, 'type', 'rotate');

        if ($$9('#canvasBackground').length) {
          return;
        }

        var _config_$dimensions = _slicedToArray(config_.dimensions, 2),
            width = _config_$dimensions[0],
            height = _config_$dimensions[1];

        var canvasbg = svgFactory_.createSVGElement({
          element: 'svg',
          attr: {
            id: 'canvasBackground',
            width: width,
            height: height,
            x: 0,
            y: 0,
            overflow: isWebkit() ? 'none' : 'visible',
            // Chrome 7 has a problem with this when zooming out
            style: 'pointer-events:none'
          }
        });
        var rect = svgFactory_.createSVGElement({
          element: 'rect',
          attr: {
            width: '100%',
            height: '100%',
            x: 0,
            y: 0,
            'stroke-width': 1,
            stroke: '#000',
            fill: '#FFF',
            style: 'pointer-events:none'
          }
        }); // Both Firefox and WebKit are too slow with this filter region (especially at higher
        // zoom levels) and Opera has at least one bug
        // if (!isOpera()) rect.setAttribute('filter', 'url(#canvashadow)');

        canvasbg.append(rect);
        svgFactory_.svgRoot().insertBefore(canvasbg, svgFactory_.svgContent()); // Ok to replace above with `svgFactory_.svgContent().before(canvasbg);`?
      }
      /**
      *
      * @param {Element} elem - DOM element to get the selector for
      * @param {module:utilities.BBoxObject} [bbox] - Optional bbox to use for reset (prevents duplicate getBBox call).
      * @returns {Selector} The selector based on the given element
      */

    }, {
      key: "requestSelector",
      value: function requestSelector(elem, bbox) {
        if (isNullish(elem)) {
          return null;
        }

        var N = this.selectors.length; // If we've already acquired one for this element, return it.

        if (_typeof(this.selectorMap[elem.id]) === 'object') {
          this.selectorMap[elem.id].locked = true;
          return this.selectorMap[elem.id];
        }

        for (var i = 0; i < N; ++i) {
          if (this.selectors[i] && !this.selectors[i].locked) {
            this.selectors[i].locked = true;
            this.selectors[i].reset(elem, bbox);
            this.selectorMap[elem.id] = this.selectors[i];
            return this.selectors[i];
          }
        } // if we reached here, no available selectors were found, we create one


        this.selectors[N] = new Selector(N, elem, bbox);
        this.selectorParentGroup.append(this.selectors[N].selectorGroup);
        this.selectorMap[elem.id] = this.selectors[N];
        return this.selectors[N];
      }
      /**
      * Removes the selector of the given element (hides selection box).
      *
      * @param {Element} elem - DOM element to remove the selector for
      * @returns {void}
      */

    }, {
      key: "releaseSelector",
      value: function releaseSelector(elem) {
        if (isNullish(elem)) {
          return;
        }

        var N = this.selectors.length,
            sel = this.selectorMap[elem.id];

        if (!sel.locked) {
          // TODO(codedread): Ensure this exists in this module.
          console.log('WARNING! selector was released but was already unlocked'); // eslint-disable-line no-console
        }

        for (var i = 0; i < N; ++i) {
          if (this.selectors[i] && this.selectors[i] === sel) {
            delete this.selectorMap[elem.id];
            sel.locked = false;
            sel.selectedElement = null;
            sel.showGrips(false); // remove from DOM and store reference in JS but only if it exists in the DOM

            try {
              sel.selectorGroup.setAttribute('display', 'none');
            } catch (e) {}

            break;
          }
        }
      }
      /**
      * @returns {SVGRectElement} The rubberBandBox DOM element. This is the rectangle drawn by
      * the user for selecting/zooming
      */

    }, {
      key: "getRubberBandBox",
      value: function getRubberBandBox() {
        if (!this.rubberBandBox) {
          this.rubberBandBox = this.selectorParentGroup.appendChild(svgFactory_.createSVGElement({
            element: 'rect',
            attr: {
              id: 'selectorRubberBand',
              fill: '#22C',
              'fill-opacity': 0.15,
              stroke: '#22C',
              'stroke-width': 0.5,
              display: 'none',
              style: 'pointer-events:none'
            }
          }));
        }

        return this.rubberBandBox;
      }
    }]);

    return SelectorManager;
  }();
  /**
   * An object that creates SVG elements for the canvas.
   *
   * @interface module:select.SVGFactory
   */

  /**
   * @function module:select.SVGFactory#createSVGElement
   * @param {module:utilities.EditorContext#addSVGElementFromJson} jsonMap
   * @returns {SVGElement}
   */

  /**
   * @function module:select.SVGFactory#svgRoot
   * @returns {SVGSVGElement}
   */

  /**
   * @function module:select.SVGFactory#svgContent
   * @returns {SVGSVGElement}
   */

  /**
   * @function module:select.SVGFactory#getCurrentZoom
   * @returns {Float} The current zoom level
   */

  /**
   * @typedef {GenericArray} module:select.Dimensions
   * @property {Integer} length 2
   * @property {Float} 0 Width
   * @property {Float} 1 Height
   */

  /**
   * @typedef {PlainObject} module:select.Config
   * @property {string} imgPath
   * @property {module:select.Dimensions} dimensions
   */

  /**
   * Initializes this module.
   * @function module:select.init
   * @param {module:select.Config} config - An object containing configurable parameters (imgPath)
   * @param {module:select.SVGFactory} svgFactory - An object implementing the SVGFactory interface.
   * @returns {void}
   */

  var init$6 = function init(config, svgFactory) {
    config_ = config;
    svgFactory_ = svgFactory;
    selectorManager_ = new SelectorManager();
  };
  /**
   * @function module:select.getSelectorManager
   * @returns {module:select.SelectorManager} The SelectorManager instance.
   */

  var getSelectorManager = function getSelectorManager() {
    return selectorManager_;
  };

  var $$a = jQueryPluginSVG(jQuery);
  var MoveElementCommand$1 = MoveElementCommand,
      InsertElementCommand$1 = InsertElementCommand,
      RemoveElementCommand$1 = RemoveElementCommand,
      ChangeElementCommand$1 = ChangeElementCommand,
      BatchCommand$1 = BatchCommand,
      UndoManager$1 = UndoManager,
      HistoryEventTypes$1 = HistoryEventTypes;

  if (!window.console) {
    window.console = {};

    window.console.log = function (str) {
      /* */
    };

    window.console.dir = function (str) {
      /* */
    };
  }

  if (window.opera) {
    window.console.log = function (str) {
      window.opera.postError(str);
    };

    window.console.dir = function (str) {
      /* */
    };
  } // Reenable after fixing eslint-plugin-jsdoc to handle

  /**
  * The main SvgCanvas class that manages all SVG-related functions.
  * @memberof module:svgcanvas
  *
  * @borrows module:coords.remapElement as #remapElement
  * @borrows module:recalculate.recalculateDimensions as #recalculateDimensions
  *
  * @borrows module:utilities.cleanupElement as #cleanupElement
  * @borrows module:utilities.getStrokedBBoxDefaultVisible as #getStrokedBBox
  * @borrows module:utilities.getVisibleElements as #getVisibleElements
  * @borrows module:utilities.findDefs as #findDefs
  * @borrows module:utilities.getUrlFromAttr as #getUrlFromAttr
  * @borrows module:utilities.getHref as #getHref
  * @borrows module:utilities.setHref as #setHref
  * @borrows module:utilities.getRotationAngle as #getRotationAngle
  * @borrows module:utilities.getBBox as #getBBox
  * @borrows module:utilities.getElem as #getElem
  * @borrows module:utilities.getRefElem as #getRefElem
  * @borrows module:utilities.assignAttributes as #assignAttributes
  *
  * @borrows module:SVGTransformList.getTransformList as #getTransformList
  * @borrows module:math.matrixMultiply as #matrixMultiply
  * @borrows module:math.hasMatrixTransform as #hasMatrixTransform
  * @borrows module:math.transformListToTransform as #transformListToTransform
  * @borrows module:units.convertToNum as #convertToNum
  * @borrows module:sanitize.sanitizeSvg as #sanitizeSvg
  * @borrows module:path.pathActions.linkControlPoints as #linkControlPoints
  */


  var SvgCanvas =
  /**
  * @param {HTMLElement} container - The container HTML element that should hold the SVG root element
  * @param {module:SVGEditor.curConfig} config - An object that contains configuration data
  */
  function SvgCanvas(container, config) {
    _classCallCheck(this, SvgCanvas);

    // Alias Namespace constants
    // Default configuration options
    var curConfig = {
      show_outside_canvas: true,
      selectNew: true,
      dimensions: [640, 480]
    }; // Update config with new one if given

    if (config) {
      $$a.extend(curConfig, config);
    } // Array with width/height of canvas


    var dimensions = curConfig.dimensions;
    var canvas = this; // "document" element associated with the container (same as window.document using default svg-editor.js)
    // NOTE: This is not actually a SVG document, but an HTML document.

    var svgdoc = container.ownerDocument; // This is a container for the document being edited, not the document itself.

    /**
     * @name module:svgcanvas~svgroot
     * @type {SVGSVGElement}
     */

    var svgroot = svgdoc.importNode(text2xml('<svg id="svgroot" xmlns="' + NS.SVG + '" xlinkns="' + NS.XLINK + '" ' + 'width="' + dimensions[0] + '" height="' + dimensions[1] + '" x="' + dimensions[0] + '" y="' + dimensions[1] + '" overflow="visible">' + '<defs>' + '<filter id="canvashadow" filterUnits="objectBoundingBox">' + '<feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>' + '<feOffset in="blur" dx="5" dy="5" result="offsetBlur"/>' + '<feMerge>' + '<feMergeNode in="offsetBlur"/>' + '<feMergeNode in="SourceGraphic"/>' + '</feMerge>' + '</filter>' + '</defs>' + '</svg>').documentElement, true);
    container.append(svgroot);
    /**
     * The actual element that represents the final output SVG element.
     * @name module:svgcanvas~svgcontent
     * @type {SVGSVGElement}
     */

    var svgcontent = svgdoc.createElementNS(NS.SVG, 'svg');
    /**
    * This function resets the svgcontent element while keeping it in the DOM.
    * @function module:svgcanvas.SvgCanvas#clearSvgContentElement
    * @returns {void}
    */

    var clearSvgContentElement = canvas.clearSvgContentElement = function () {
      $$a(svgcontent).empty(); // TODO: Clear out all other attributes first?

      $$a(svgcontent).attr({
        id: 'svgcontent',
        width: dimensions[0],
        height: dimensions[1],
        x: dimensions[0],
        y: dimensions[1],
        overflow: curConfig.show_outside_canvas ? 'visible' : 'hidden',
        xmlns: NS.SVG,
        'xmlns:se': NS.SE,
        'xmlns:xlink': NS.XLINK
      }).appendTo(svgroot); // TODO: make this string optional and set by the client

      var comment = svgdoc.createComment(' Created with SVG-edit - https://github.com/SVG-Edit/svgedit');
      svgcontent.append(comment);
    };

    clearSvgContentElement(); // Prefix string for element IDs

    var idprefix = 'svg_';
    /**
    * Changes the ID prefix to the given value.
    * @function module:svgcanvas.SvgCanvas#setIdPrefix
    * @param {string} p - String with the new prefix
    * @returns {void}
    */

    canvas.setIdPrefix = function (p) {
      idprefix = p;
    };
    /**
    * Current `draw.Drawing` object.
    * @type {module:draw.Drawing}
    * @name module:svgcanvas.SvgCanvas#current_drawing_
    */


    canvas.current_drawing_ = new Drawing(svgcontent, idprefix);
    /**
    * Returns the current Drawing.
    * @name module:svgcanvas.SvgCanvas#getCurrentDrawing
    * @type {module:draw.DrawCanvasInit#getCurrentDrawing}
    */

    var getCurrentDrawing = canvas.getCurrentDrawing = function () {
      return canvas.current_drawing_;
    };
    /**
    * Float displaying the current zoom level (1 = 100%, .5 = 50%, etc.).
    * @type {Float}
    */


    var currentZoom = 1; // pointer to current group (for in-group editing)

    var currentGroup = null; // Object containing data for the currently selected styles

    var allProperties = {
      shape: {
        fill: (curConfig.initFill.color === 'none' ? '' : '#') + curConfig.initFill.color,
        fill_paint: null,
        fill_opacity: curConfig.initFill.opacity,
        stroke: '#' + curConfig.initStroke.color,
        stroke_paint: null,
        stroke_opacity: curConfig.initStroke.opacity,
        stroke_width: curConfig.initStroke.width,
        stroke_dasharray: 'none',
        stroke_linejoin: 'miter',
        stroke_linecap: 'butt',
        opacity: curConfig.initOpacity
      }
    };
    allProperties.text = $$a.extend(true, {}, allProperties.shape);
    $$a.extend(allProperties.text, {
      fill: '#000000',
      stroke_width: curConfig.text && curConfig.text.stroke_width,
      font_size: curConfig.text && curConfig.text.font_size,
      font_family: curConfig.text && curConfig.text.font_family
    }); // Current shape style properties

    var curShape = allProperties.shape; // Array with all the currently selected elements
    // default size of 1 until it needs to grow bigger

    var selectedElements = [];
    /**
    * @typedef {PlainObject} module:svgcanvas.SVGAsJSON
    * @property {string} element
    * @property {PlainObject<string, string>} attr
    * @property {module:svgcanvas.SVGAsJSON[]} children
    */

    /**
    * @function module:svgcanvas.SvgCanvas#getContentElem
    * @param {Text|Element} data
    * @returns {module:svgcanvas.SVGAsJSON}
    */

    var getJsonFromSvgElement = this.getJsonFromSvgElement = function (data) {
      // Text node
      if (data.nodeType === 3) return data.nodeValue;
      var retval = {
        element: data.tagName,
        // namespace: nsMap[data.namespaceURI],
        attr: {},
        children: []
      }; // Iterate attributes

      for (var i = 0, attr; attr = data.attributes[i]; i++) {
        retval.attr[attr.name] = attr.value;
      } // Iterate children


      for (var _i = 0, node; node = data.childNodes[_i]; _i++) {
        retval.children[_i] = getJsonFromSvgElement(node);
      }

      return retval;
    };
    /**
    * This should really be an intersection implementing all rather than a union.
    * @name module:svgcanvas.SvgCanvas#addSVGElementFromJson
    * @type {module:utilities.EditorContext#addSVGElementFromJson|module:path.EditorContext#addSVGElementFromJson}
    */


    var addSVGElementFromJson = this.addSVGElementFromJson = function (data) {
      if (typeof data === 'string') return svgdoc.createTextNode(data);
      var shape = getElem(data.attr.id); // if shape is a path but we need to create a rect/ellipse, then remove the path

      var currentLayer = getCurrentDrawing().getCurrentLayer();

      if (shape && data.element !== shape.tagName) {
        shape.remove();
        shape = null;
      }

      if (!shape) {
        var ns = data.namespace || NS.SVG;
        shape = svgdoc.createElementNS(ns, data.element);

        if (currentLayer) {
          (currentGroup || currentLayer).append(shape);
        }
      }

      if (data.curStyles) {
        assignAttributes(shape, {
          fill: curShape.fill,
          stroke: curShape.stroke,
          'stroke-width': curShape.stroke_width,
          'stroke-dasharray': curShape.stroke_dasharray,
          'stroke-linejoin': curShape.stroke_linejoin,
          'stroke-linecap': curShape.stroke_linecap,
          'stroke-opacity': curShape.stroke_opacity,
          'fill-opacity': curShape.fill_opacity,
          opacity: curShape.opacity / 2,
          style: 'pointer-events:inherit'
        });
      }

      assignAttributes(shape, data.attr);
      cleanupElement(shape); // Children

      if (data.children) {
        data.children.forEach(function (child) {
          shape.append(addSVGElementFromJson(child));
        });
      }

      return shape;
    };

    canvas.getTransformList = getTransformList;
    canvas.matrixMultiply = matrixMultiply;
    canvas.hasMatrixTransform = hasMatrixTransform;
    canvas.transformListToTransform = transformListToTransform;
    /**
    * @type {module:utilities.EditorContext#getBaseUnit}
    */

    var getBaseUnit = function getBaseUnit() {
      return curConfig.baseUnit;
    };
    /**
    * Initialize from units.js.
    * Send in an object implementing the ElementContainer interface (see units.js).
    */


    init(
    /**
    * @implements {module:units.ElementContainer}
    */
    {
      getBaseUnit: getBaseUnit,
      getElement: getElem,
      getHeight: function getHeight() {
        return svgcontent.getAttribute('height') / currentZoom;
      },
      getWidth: function getWidth() {
        return svgcontent.getAttribute('width') / currentZoom;
      },
      getRoundDigits: function getRoundDigits() {
        return saveOptions.round_digits;
      }
    });
    canvas.convertToNum = convertToNum;
    /**
    * This should really be an intersection implementing all rather than a union.
    * @type {module:draw.DrawCanvasInit#getSVGContent|module:utilities.EditorContext#getSVGContent}
    */

    var getSVGContent = function getSVGContent() {
      return svgcontent;
    };
    /**
    * Should really be an intersection with all needing to apply rather than a union.
    * @name module:svgcanvas.SvgCanvas#getSelectedElements
    * @type {module:utilities.EditorContext#getSelectedElements|module:draw.DrawCanvasInit#getSelectedElements|module:path.EditorContext#getSelectedElements}
    */


    var getSelectedElements = this.getSelectedElems = function () {
      return selectedElements;
    };

    var pathActions$1 = pathActions;
    /**
    * This should actually be an intersection as all interfaces should be met.
    * @type {module:utilities.EditorContext#getSVGRoot|module:recalculate.EditorContext#getSVGRoot|module:coords.EditorContext#getSVGRoot|module:path.EditorContext#getSVGRoot}
    */

    var getSVGRoot = function getSVGRoot() {
      return svgroot;
    };

    init$1(
    /**
    * @implements {module:utilities.EditorContext}
    */
    {
      pathActions: pathActions$1,
      // Ok since not modifying
      getSVGContent: getSVGContent,
      addSVGElementFromJson: addSVGElementFromJson,
      getSelectedElements: getSelectedElements,
      getDOMDocument: function getDOMDocument() {
        return svgdoc;
      },
      getDOMContainer: function getDOMContainer() {
        return container;
      },
      getSVGRoot: getSVGRoot,
      // TODO: replace this mostly with a way to get the current drawing.
      getBaseUnit: getBaseUnit,
      getSnappingStep: function getSnappingStep() {
        return curConfig.snappingStep;
      }
    });
    canvas.findDefs = findDefs;
    canvas.getUrlFromAttr = getUrlFromAttr;
    canvas.getHref = getHref;
    canvas.setHref = setHref;
    /* const getBBox = */

    canvas.getBBox = getBBox;
    canvas.getRotationAngle = getRotationAngle;
    canvas.getElem = getElem;
    canvas.getRefElem = getRefElem;
    canvas.assignAttributes = assignAttributes;
    this.cleanupElement = cleanupElement;
    /**
    * This should actually be an intersection not a union as all should apply.
    * @type {module:coords.EditorContext#getGridSnapping|module:path.EditorContext#getGridSnapping}
    */

    var getGridSnapping = function getGridSnapping() {
      return curConfig.gridSnapping;
    };

    init$4(
    /**
    * @implements {module:coords.EditorContext}
    */
    {
      getDrawing: function getDrawing() {
        return getCurrentDrawing();
      },
      getSVGRoot: getSVGRoot,
      getGridSnapping: getGridSnapping
    });
    this.remapElement = remapElement;
    init$5(
    /**
    * @implements {module:recalculate.EditorContext}
    */
    {
      getSVGRoot: getSVGRoot,
      getStartTransform: function getStartTransform() {
        return startTransform;
      },
      setStartTransform: function setStartTransform(transform) {
        startTransform = transform;
      }
    });
    this.recalculateDimensions = recalculateDimensions; // import from sanitize.js

    var nsMap = getReverseNS();
    canvas.sanitizeSvg = sanitizeSvg;
    /**
    * @name undoMgr
    * @memberof module:svgcanvas.SvgCanvas#
    * @type {module:history.HistoryEventHandler}
    */

    var undoMgr = canvas.undoMgr = new UndoManager$1({
      /**
       * @param {string} eventType One of the HistoryEvent types
       * @param {module:history.HistoryCommand} cmd Fulfills the HistoryCommand interface
       * @fires module:svgcanvas.SvgCanvas#event:changed
       * @returns {void}
       */
      handleHistoryEvent: function handleHistoryEvent(eventType, cmd) {
        var EventTypes = HistoryEventTypes$1; // TODO: handle setBlurOffsets.

        if (eventType === EventTypes.BEFORE_UNAPPLY || eventType === EventTypes.BEFORE_APPLY) {
          canvas.clearSelection();
        } else if (eventType === EventTypes.AFTER_APPLY || eventType === EventTypes.AFTER_UNAPPLY) {
          var elems = cmd.elements();
          canvas.pathActions.clear();
          call('changed', elems);
          var cmdType = cmd.type();
          var isApply = eventType === EventTypes.AFTER_APPLY;

          if (cmdType === 'MoveElementCommand') {
            var parent = isApply ? cmd.newParent : cmd.oldParent;

            if (parent === svgcontent) {
              identifyLayers();
            }
          } else if (cmdType === 'InsertElementCommand' || cmdType === 'RemoveElementCommand') {
            if (cmd.parent === svgcontent) {
              identifyLayers();
            }

            if (cmdType === 'InsertElementCommand') {
              if (isApply) {
                restoreRefElems(cmd.elem);
              }
            } else if (!isApply) {
              restoreRefElems(cmd.elem);
            }

            if (cmd.elem && cmd.elem.tagName === 'use') {
              setUseData(cmd.elem);
            }
          } else if (cmdType === 'ChangeElementCommand') {
            // if we are changing layer names, re-identify all layers
            if (cmd.elem.tagName === 'title' && cmd.elem.parentNode.parentNode === svgcontent) {
              identifyLayers();
            }

            var values = isApply ? cmd.newValues : cmd.oldValues; // If stdDeviation was changed, update the blur.

            if (values.stdDeviation) {
              canvas.setBlurOffsets(cmd.elem.parentNode, values.stdDeviation);
            } // This is resolved in later versions of webkit, perhaps we should
            // have a featured detection for correct 'use' behavior?
            // ——————————
            // Remove & Re-add hack for Webkit (issue 775)
            // if (cmd.elem.tagName === 'use' && isWebkit()) {
            //  const {elem} = cmd;
            //  if (!elem.getAttribute('x') && !elem.getAttribute('y')) {
            //    const parent = elem.parentNode;
            //    const sib = elem.nextSibling;
            //    elem.remove();
            //    parent.insertBefore(elem, sib);
            //    // Ok to replace above with this? `sib.before(elem);`
            //  }
            // }

          }
        }
      }
    });
    /**
    * This should really be an intersection applying to all types rather than a union.
    * @name module:svgcanvas~addCommandToHistory
    * @type {module:path.EditorContext#addCommandToHistory|module:draw.DrawCanvasInit#addCommandToHistory}
    */

    var addCommandToHistory = function addCommandToHistory(cmd) {
      canvas.undoMgr.addCommandToHistory(cmd);
    };
    /**
    * This should really be an intersection applying to all types rather than a union.
    * @name module:svgcanvas.SvgCanvas#getZoom
    * @type {module:path.EditorContext#getCurrentZoom|module:select.SVGFactory#getCurrentZoom}
    */


    var getCurrentZoom = this.getZoom = function () {
      return currentZoom;
    };
    /**
    * This method rounds the incoming value to the nearest value based on the `currentZoom`
    * @name module:svgcanvas.SvgCanvas#round
    * @type {module:path.EditorContext#round}
    */


    var round = this.round = function (val) {
      return Number.parseInt(val * currentZoom) / currentZoom;
    };

    init$6(curConfig,
    /**
    * Export to select.js.
    * @implements {module:select.SVGFactory}
    */
    {
      createSVGElement: function createSVGElement(jsonMap) {
        return canvas.addSVGElementFromJson(jsonMap);
      },
      svgRoot: function svgRoot() {
        return svgroot;
      },
      svgContent: function svgContent() {
        return svgcontent;
      },
      getCurrentZoom: getCurrentZoom
    });
    /**
    * This object manages selectors for us.
    * @name module:svgcanvas.SvgCanvas#selectorManager
    * @type {module:select.SelectorManager}
    */

    var selectorManager = this.selectorManager = getSelectorManager();
    /**
    * @name module:svgcanvas.SvgCanvas#getNextId
    * @type {module:path.EditorContext#getNextId}
    */

    var getNextId = canvas.getNextId = function () {
      return getCurrentDrawing().getNextId();
    };
    /**
    * @name module:svgcanvas.SvgCanvas#getId
    * @type {module:path.EditorContext#getId}
    */


    var getId = canvas.getId = function () {
      return getCurrentDrawing().getId();
    };
    /**
    * The "implements" should really be an intersection applying to all types rather than a union.
    * @name module:svgcanvas.SvgCanvas#call
    * @type {module:draw.DrawCanvasInit#call|module:path.EditorContext#call}
    */


    var call = function call(ev, arg) {
      if (events[ev]) {
        return events[ev](window, arg);
      }

      return undefined;
    };
    /**
    * Clears the selection. The 'selected' handler is then optionally called.
    * This should really be an intersection applying to all types rather than a union.
    * @name module:svgcanvas.SvgCanvas#clearSelection
    * @type {module:draw.DrawCanvasInit#clearSelection|module:path.EditorContext#clearSelection}
    * @fires module:svgcanvas.SvgCanvas#event:selected
    */


    var clearSelection = this.clearSelection = function (noCall) {
      selectedElements.forEach(function (elem) {
        if (isNullish(elem)) {
          return;
        }

        selectorManager.releaseSelector(elem);
      });
      selectedElements = [];

      if (!noCall) {
        call('selected', selectedElements);
      }
    };
    /**
    * Adds a list of elements to the selection. The 'selected' handler is then called.
    * @name module:svgcanvas.SvgCanvas#addToSelection
    * @type {module:path.EditorContext#addToSelection}
    * @fires module:svgcanvas.SvgCanvas#event:selected
    */


    var addToSelection = this.addToSelection = function (elemsToAdd, showGrips) {
      if (!elemsToAdd.length) {
        return;
      } // find the first null in our selectedElements array


      var j = 0;

      while (j < selectedElements.length) {
        if (isNullish(selectedElements[j])) {
          break;
        }

        ++j;
      } // now add each element consecutively


      var i = elemsToAdd.length;

      while (i--) {
        var elem = elemsToAdd[i];

        if (!elem) {
          continue;
        }

        var bbox = getBBox(elem);

        if (!bbox) {
          continue;
        }

        if (elem.tagName === 'a' && elem.childNodes.length === 1) {
          // Make "a" element's child be the selected element
          elem = elem.firstChild;
        } // if it's not already there, add it


        if (!selectedElements.includes(elem)) {
          selectedElements[j] = elem; // only the first selectedBBoxes element is ever used in the codebase these days
          // if (j === 0) selectedBBoxes[0] = utilsGetBBox(elem);

          j++;
          var sel = selectorManager.requestSelector(elem, bbox);

          if (selectedElements.length > 1) {
            sel.showGrips(false);
          }
        }
      }

      if (!selectedElements.length) {
        return;
      }

      call('selected', selectedElements);

      if (selectedElements.length === 1) {
        selectorManager.requestSelector(selectedElements[0]).showGrips(showGrips);
      } // make sure the elements are in the correct order
      // See: https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-compareDocumentPosition


      selectedElements.sort(function (a, b) {
        if (a && b && a.compareDocumentPosition) {
          return 3 - (b.compareDocumentPosition(a) & 6); // eslint-disable-line no-bitwise
        }

        if (isNullish(a)) {
          return 1;
        }

        return 0;
      }); // Make sure first elements are not null

      while (isNullish(selectedElements[0])) {
        selectedElements.shift(0);
      }
    };
    /**
    * @type {module:path.EditorContext#getOpacity}
    */


    var getOpacity = function getOpacity() {
      return curShape.opacity;
    };
    /**
    * @name module:svgcanvas.SvgCanvas#getMouseTarget
    * @type {module:path.EditorContext#getMouseTarget}
    */


    var getMouseTarget = this.getMouseTarget = function (evt) {
      if (isNullish(evt)) {
        return null;
      }

      var mouseTarget = evt.target; // if it was a <use>, Opera and WebKit return the SVGElementInstance

      if (mouseTarget.correspondingUseElement) {
        mouseTarget = mouseTarget.correspondingUseElement;
      } // for foreign content, go up until we find the foreignObject
      // WebKit browsers set the mouse target to the svgcanvas div


      if ([NS.MATH, NS.HTML].includes(mouseTarget.namespaceURI) && mouseTarget.id !== 'svgcanvas') {
        while (mouseTarget.nodeName !== 'foreignObject') {
          mouseTarget = mouseTarget.parentNode;

          if (!mouseTarget) {
            return svgroot;
          }
        }
      } // Get the desired mouseTarget with jQuery selector-fu
      // If it's root-like, select the root


      var currentLayer = getCurrentDrawing().getCurrentLayer();

      if ([svgroot, container, svgcontent, currentLayer].includes(mouseTarget)) {
        return svgroot;
      }

      var $target = $$a(mouseTarget); // If it's a selection grip, return the grip parent

      if ($target.closest('#selectorParentGroup').length) {
        // While we could instead have just returned mouseTarget,
        // this makes it easier to indentify as being a selector grip
        return selectorManager.selectorParentGroup;
      }

      while (mouseTarget.parentNode !== (currentGroup || currentLayer)) {
        mouseTarget = mouseTarget.parentNode;
      } //
      // // go up until we hit a child of a layer
      // while (mouseTarget.parentNode.parentNode.tagName == 'g') {
      //   mouseTarget = mouseTarget.parentNode;
      // }
      // Webkit bubbles the mouse event all the way up to the div, so we
      // set the mouseTarget to the svgroot like the other browsers
      // if (mouseTarget.nodeName.toLowerCase() == 'div') {
      //   mouseTarget = svgroot;
      // }


      return mouseTarget;
    };
    /**
    * @namespace {module:path.pathActions} pathActions
    * @memberof module:svgcanvas.SvgCanvas#
    * @see module:path.pathActions
    */


    canvas.pathActions = pathActions$1;
    /**
    * @type {module:path.EditorContext#resetD}
    */

    function resetD(p) {
      p.setAttribute('d', pathActions$1.convertPath(p));
    }

    init$2(
    /**
    * @implements {module:path.EditorContext}
    */
    {
      selectorManager: selectorManager,
      // Ok since not changing
      canvas: canvas,
      // Ok since not changing
      call: call,
      resetD: resetD,
      round: round,
      clearSelection: clearSelection,
      addToSelection: addToSelection,
      addCommandToHistory: addCommandToHistory,
      remapElement: remapElement,
      addSVGElementFromJson: addSVGElementFromJson,
      getGridSnapping: getGridSnapping,
      getOpacity: getOpacity,
      getSelectedElements: getSelectedElements,
      getContainer: function getContainer() {
        return container;
      },
      setStarted: function setStarted(s) {
        started = s;
      },
      getRubberBox: function getRubberBox() {
        return rubberBox;
      },
      setRubberBox: function setRubberBox(rb) {
        rubberBox = rb;
        return rubberBox;
      },

      /**
       * @param {PlainObject} ptsInfo
       * @param {boolean} ptsInfo.closedSubpath
       * @param {SVGCircleElement[]} ptsInfo.grips
       * @fires module:svgcanvas.SvgCanvas#event:pointsAdded
       * @fires module:svgcanvas.SvgCanvas#event:selected
       * @returns {void}
       */
      addPtsToSelection: function addPtsToSelection(_ref) {
        var closedSubpath = _ref.closedSubpath,
            grips = _ref.grips;
        // TODO: Correct this:
        pathActions$1.canDeleteNodes = true;
        pathActions$1.closed_subpath = closedSubpath;
        call('pointsAdded', {
          closedSubpath: closedSubpath,
          grips: grips
        });
        call('selected', grips);
      },

      /**
       * @param {PlainObject} changes
       * @param {ChangeElementCommand} changes.cmd
       * @param {SVGPathElement} changes.elem
       * @fires module:svgcanvas.SvgCanvas#event:changed
       * @returns {void}
       */
      endChanges: function endChanges(_ref2) {
        var cmd = _ref2.cmd,
            elem = _ref2.elem;
        addCommandToHistory(cmd);
        call('changed', [elem]);
      },
      getCurrentZoom: getCurrentZoom,
      getId: getId,
      getNextId: getNextId,
      getMouseTarget: getMouseTarget,
      getCurrentMode: function getCurrentMode() {
        return currentMode;
      },
      setCurrentMode: function setCurrentMode(cm) {
        currentMode = cm;
        return currentMode;
      },
      getDrawnPath: function getDrawnPath() {
        return drawnPath;
      },
      setDrawnPath: function setDrawnPath(dp) {
        drawnPath = dp;
        return drawnPath;
      },
      getSVGRoot: getSVGRoot
    }); // Interface strings, usually for title elements

    var uiStrings = {};
    var visElems = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use';
    var refAttrs = ['clip-path', 'fill', 'filter', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'stroke'];
    var elData = $$a.data; // Animation element to change the opacity of any newly created element

    var opacAni = document.createElementNS(NS.SVG, 'animate');
    $$a(opacAni).attr({
      attributeName: 'opacity',
      begin: 'indefinite',
      dur: 1,
      fill: 'freeze'
    }).appendTo(svgroot);

    var restoreRefElems = function restoreRefElems(elem) {
      // Look for missing reference elements, restore any found
      var attrs = $$a(elem).attr(refAttrs);
      Object.values(attrs).forEach(function (val) {
        if (val && val.startsWith('url(')) {
          var id = getUrlFromAttr(val).substr(1);
          var ref = getElem(id);

          if (!ref) {
            findDefs().append(removedElements[id]);
            delete removedElements[id];
          }
        }
      });
      var childs = elem.getElementsByTagName('*');

      if (childs.length) {
        for (var i = 0, l = childs.length; i < l; i++) {
          restoreRefElems(childs[i]);
        }
      }
    }; // (function () {
    // TODO For Issue 208: this is a start on a thumbnail
    //  const svgthumb = svgdoc.createElementNS(NS.SVG, 'use');
    //  svgthumb.setAttribute('width', '100');
    //  svgthumb.setAttribute('height', '100');
    //  setHref(svgthumb, '#svgcontent');
    //  svgroot.append(svgthumb);
    // }());

    /**
     * @typedef {PlainObject} module:svgcanvas.SaveOptions
     * @property {boolean} apply
     * @property {"embed"} [image]
     * @property {Integer} round_digits
     */
    // Object to contain image data for raster images that were found encodable


    var encodableImages = {},
        // Object with save options

    /**
     * @type {module:svgcanvas.SaveOptions}
     */
    saveOptions = {
      round_digits: 5
    },
        // Object with IDs for imported files, to see if one was already added
    importIds = {},
        // Current text style properties
    curText = allProperties.text,
        // Object to contain all included extensions
    extensions = {},
        // Map of deleted reference elements
    removedElements = {};
    var // String with image URL of last loadable image
    lastGoodImgUrl = curConfig.imgPath + 'logo.png',
        // Boolean indicating whether or not a draw action has been started
    started = false,
        // String with an element's initial transform attribute value
    startTransform = null,
        // String indicating the current editor mode
    currentMode = 'select',
        // String with the current direction in which an element is being resized
    currentResizeMode = 'none',
        // Current general properties
    curProperties = curShape,
        // Array with selected elements' Bounding box object
    // selectedBBoxes = new Array(1),
    // The DOM element that was just selected
    justSelected = null,
        // DOM element for selection rectangle drawn by the user
    rubberBox = null,
        // Array of current BBoxes, used in getIntersectionList().
    curBBoxes = [],
        // Canvas point for the most recent right click
    lastClickPoint = null;

    this.runExtension = function (name, action, vars) {
      return this.runExtensions(action, vars, false, function (n) {
        return n === name;
      });
    };
    /**
    * @typedef {module:svgcanvas.ExtensionMouseDownStatus|module:svgcanvas.ExtensionMouseUpStatus|module:svgcanvas.ExtensionIDsUpdatedStatus|module:locale.ExtensionLocaleData[]|void} module:svgcanvas.ExtensionStatus
    * @tutorial ExtensionDocs
    */

    /**
    * @callback module:svgcanvas.ExtensionVarBuilder
    * @param {string} name The name of the extension
    * @returns {module:svgcanvas.SvgCanvas#event:ext_addLangData}
    */

    /**
    * @callback module:svgcanvas.ExtensionNameFilter
    * @param {string} name
    * @returns {boolean}
    */

    /**
    * @todo Consider: Should this return an array by default, so extension results aren't overwritten?
    * @todo Would be easier to document if passing in object with key of action and vars as value; could then define an interface which tied both together
    * @function module:svgcanvas.SvgCanvas#runExtensions
    * @param {"mouseDown"|"mouseMove"|"mouseUp"|"zoomChanged"|"IDsUpdated"|"canvasUpdated"|"toolButtonStateUpdate"|"selectedChanged"|"elementTransition"|"elementChanged"|"langReady"|"langChanged"|"addLangData"|"onNewDocument"|"workareaResized"} action
    * @param {module:svgcanvas.SvgCanvas#event:ext_mouseDown|module:svgcanvas.SvgCanvas#event:ext_mouseMove|module:svgcanvas.SvgCanvas#event:ext_mouseUp|module:svgcanvas.SvgCanvas#event:ext_zoomChanged|module:svgcanvas.SvgCanvas#event:ext_IDsUpdated|module:svgcanvas.SvgCanvas#event:ext_canvasUpdated|module:svgcanvas.SvgCanvas#event:ext_toolButtonStateUpdate|module:svgcanvas.SvgCanvas#event:ext_selectedChanged|module:svgcanvas.SvgCanvas#event:ext_elementTransition|module:svgcanvas.SvgCanvas#event:ext_elementChanged|module:svgcanvas.SvgCanvas#event:ext_langReady|module:svgcanvas.SvgCanvas#event:ext_langChanged|module:svgcanvas.SvgCanvas#event:ext_addLangData|module:svgcanvas.SvgCanvas#event:ext_onNewDocument|module:svgcanvas.SvgCanvas#event:ext_workareaResized|module:svgcanvas.ExtensionVarBuilder} [vars]
    * @param {boolean} [returnArray]
    * @param {module:svgcanvas.ExtensionNameFilter} nameFilter
    * @returns {GenericArray<module:svgcanvas.ExtensionStatus>|module:svgcanvas.ExtensionStatus|false} See {@tutorial ExtensionDocs} on the ExtensionStatus.
    */


    var runExtensions = this.runExtensions = function (action, vars, returnArray, nameFilter) {
      var result = returnArray ? [] : false;
      $$a.each(extensions, function (name, ext) {
        if (nameFilter && !nameFilter(name)) {
          return;
        }

        if (ext && action in ext) {
          if (typeof vars === 'function') {
            vars = vars(name); // ext, action
          }

          if (returnArray) {
            result.push(ext[action](vars));
          } else {
            result = ext[action](vars);
          }
        }
      });
      return result;
    };
    /**
    * @typedef {PlainObject} module:svgcanvas.ExtensionMouseDownStatus
    * @property {boolean} started Indicates that creating/editing has started
    */

    /**
    * @typedef {PlainObject} module:svgcanvas.ExtensionMouseUpStatus
    * @property {boolean} keep Indicates if the current element should be kept
    * @property {boolean} started Indicates if editing should still be considered as "started"
    * @property {Element} element The element being affected
    */

    /**
    * @typedef {PlainObject} module:svgcanvas.ExtensionIDsUpdatedStatus
    * @property {string[]} remove Contains string IDs (used by `ext-connector.js`)
    */

    /**
     * @interface module:svgcanvas.ExtensionInitResponse
     * @property {module:SVGEditor.ContextTool[]|PlainObject<string, module:SVGEditor.ContextTool>} [context_tools]
     * @property {module:SVGEditor.Button[]|PlainObject<Integer, module:SVGEditor.Button>} [buttons]
     * @property {string} [svgicons] The location of a local SVG or SVGz file
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#mouseDown
     * @param {module:svgcanvas.SvgCanvas#event:ext_mouseDown} arg
     * @returns {void|module:svgcanvas.ExtensionMouseDownStatus}
     */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#mouseMove
     * @param {module:svgcanvas.SvgCanvas#event:ext_mouseMove} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#mouseUp
     * @param {module:svgcanvas.SvgCanvas#event:ext_mouseUp} arg
     * @returns {module:svgcanvas.ExtensionMouseUpStatus}
     */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#zoomChanged
     * @param {module:svgcanvas.SvgCanvas#event:ext_zoomChanged} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#IDsUpdated
     * @param {module:svgcanvas.SvgCanvas#event:ext_IDsUpdated} arg
     * @returns {module:svgcanvas.ExtensionIDsUpdatedStatus}
     */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#canvasUpdated
     * @param {module:svgcanvas.SvgCanvas#event:ext_canvasUpdated} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#toolButtonStateUpdate
     * @param {module:svgcanvas.SvgCanvas#event:ext_toolButtonStateUpdate} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#selectedChanged
     * @param {module:svgcanvas.SvgCanvas#event:ext_selectedChanged} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#elementTransition
     * @param {module:svgcanvas.SvgCanvas#event:ext_elementTransition} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#elementChanged
     * @param {module:svgcanvas.SvgCanvas#event:ext_elementChanged} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#langReady
     * @param {module:svgcanvas.SvgCanvas#event:ext_langReady} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#langChanged
     * @param {module:svgcanvas.SvgCanvas#event:ext_langChanged} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#addLangData
     * @param {module:svgcanvas.SvgCanvas#event:ext_addLangData} arg
     * @returns {Promise<module:locale.ExtensionLocaleData>} Resolves to {@link module:locale.ExtensionLocaleData}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#onNewDocument
     * @param {module:svgcanvas.SvgCanvas#event:ext_onNewDocument} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#workareaResized
     * @param {module:svgcanvas.SvgCanvas#event:ext_workareaResized} arg
     * @returns {void}
    */

    /**
     * @function module:svgcanvas.ExtensionInitResponse#callback
     * @this module:SVGEditor
     * @param {module:svgcanvas.SvgCanvas#event:ext_callback} arg
     * @returns {void}
    */

    /**
    * @callback module:svgcanvas.ExtensionInitCallback
    * @this module:SVGEditor
    * @param {module:svgcanvas.ExtensionArgumentObject} arg
    * @returns {Promise<module:svgcanvas.ExtensionInitResponse|void>} Resolves to [ExtensionInitResponse]{@link module:svgcanvas.ExtensionInitResponse} or `undefined`
    */

    /**
    * @typedef {PlainObject} module:svgcanvas.ExtensionInitArgs
    * @property {external:jQuery} $
    * @property {module:SVGEditor~ImportLocale} importLocale
    */

    /**
    * Add an extension to the editor.
    * @function module:svgcanvas.SvgCanvas#addExtension
    * @param {string} name - String with the ID of the extension. Used internally; no need for i18n.
    * @param {module:svgcanvas.ExtensionInitCallback} [extInitFunc] - Function supplied by the extension with its data
    * @param {module:svgcanvas.ExtensionInitArgs} initArgs
    * @fires module:svgcanvas.SvgCanvas#event:extension_added
    * @throws {TypeError|Error} `TypeError` if `extInitFunc` is not a function, `Error`
    *   if extension of supplied name already exists
    * @returns {Promise<void>} Resolves to `undefined`
    */


    this.addExtension = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name, extInitFunc, _ref3) {
        var jq, importLocale, argObj, extObj;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                jq = _ref3.$, importLocale = _ref3.importLocale;

                if (!(typeof extInitFunc !== 'function')) {
                  _context.next = 3;
                  break;
                }

                throw new TypeError('Function argument expected for `svgcanvas.addExtension`');

              case 3:
                if (!(name in extensions)) {
                  _context.next = 5;
                  break;
                }

                throw new Error('Cannot add extension "' + name + '", an extension by that name already exists.');

              case 5:
                // Provide private vars/funcs here. Is there a better way to do this?

                /**
                 * @typedef {module:svgcanvas.PrivateMethods} module:svgcanvas.ExtensionArgumentObject
                 * @property {SVGSVGElement} svgroot See {@link module:svgcanvas~svgroot}
                 * @property {SVGSVGElement} svgcontent See {@link module:svgcanvas~svgcontent}
                 * @property {!(string|Integer)} nonce See {@link module:draw.Drawing#getNonce}
                 * @property {module:select.SelectorManager} selectorManager
                 * @property {module:SVGEditor~ImportLocale} importLocale
                 */

                /**
                 * @type {module:svgcanvas.ExtensionArgumentObject}
                 * @see {@link module:svgcanvas.PrivateMethods} source for the other methods/properties
                 */
                argObj = $$a.extend(canvas.getPrivateMethods(), {
                  $: jq,
                  importLocale: importLocale,
                  svgroot: svgroot,
                  svgcontent: svgcontent,
                  nonce: getCurrentDrawing().getNonce(),
                  selectorManager: selectorManager
                });
                _context.next = 8;
                return extInitFunc(argObj);

              case 8:
                extObj = _context.sent;

                if (extObj) {
                  extObj.name = name;
                }

                extensions[name] = extObj;
                return _context.abrupt("return", call('extension_added', extObj));

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2, _x3) {
        return _ref4.apply(this, arguments);
      };
    }();
    /**
    * This method sends back an array or a NodeList full of elements that
    * intersect the multi-select rubber-band-box on the currentLayer only.
    *
    * We brute-force `getIntersectionList` for browsers that do not support it (Firefox).
    *
    * Reference:
    * Firefox does not implement `getIntersectionList()`, see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=501421}.
    * @function module:svgcanvas.SvgCanvas#getIntersectionList
    * @param {SVGRect} rect
    * @returns {Element[]|NodeList} Bbox elements
    */


    var getIntersectionList = this.getIntersectionList = function (rect) {
      if (isNullish(rubberBox)) {
        return null;
      }

      var parent = currentGroup || getCurrentDrawing().getCurrentLayer();
      var rubberBBox;

      if (!rect) {
        rubberBBox = rubberBox.getBBox();
        var bb = svgcontent.createSVGRect();
        ['x', 'y', 'width', 'height', 'top', 'right', 'bottom', 'left'].forEach(function (o) {
          bb[o] = rubberBBox[o] / currentZoom;
        });
        rubberBBox = bb;
      } else {
        rubberBBox = svgcontent.createSVGRect();
        rubberBBox.x = rect.x;
        rubberBBox.y = rect.y;
        rubberBBox.width = rect.width;
        rubberBBox.height = rect.height;
      }

      var resultList = null;

      if (!isIE()) {
        if (typeof svgroot.getIntersectionList === 'function') {
          // Offset the bbox of the rubber box by the offset of the svgcontent element.
          rubberBBox.x += Number.parseInt(svgcontent.getAttribute('x'));
          rubberBBox.y += Number.parseInt(svgcontent.getAttribute('y'));
          resultList = svgroot.getIntersectionList(rubberBBox, parent);
        }
      }

      if (isNullish(resultList) || typeof resultList.item !== 'function') {
        resultList = [];

        if (!curBBoxes.length) {
          // Cache all bboxes
          curBBoxes = getVisibleElementsAndBBoxes(parent);
        }

        var i = curBBoxes.length;

        while (i--) {
          if (!rubberBBox.width) {
            continue;
          }

          if (rectsIntersect(rubberBBox, curBBoxes[i].bbox)) {
            resultList.push(curBBoxes[i].elem);
          }
        }
      } // addToSelection expects an array, but it's ok to pass a NodeList
      // because using square-bracket notation is allowed:
      // https://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html


      return resultList;
    };

    this.getStrokedBBox = getStrokedBBoxDefaultVisible;
    this.getVisibleElements = getVisibleElements;
    /**
    * @typedef {PlainObject} ElementAndBBox
    * @property {Element} elem - The element
    * @property {module:utilities.BBoxObject} bbox - The element's BBox as retrieved from `getStrokedBBoxDefaultVisible`
    */

    /**
    * Get all elements that have a BBox (excludes `<defs>`, `<title>`, etc).
    * Note that 0-opacity, off-screen etc elements are still considered "visible"
    * for this function.
    * @function module:svgcanvas.SvgCanvas#getVisibleElementsAndBBoxes
    * @param {Element} parent - The parent DOM element to search within
    * @returns {ElementAndBBox[]} An array with objects that include:
    */

    var getVisibleElementsAndBBoxes = this.getVisibleElementsAndBBoxes = function (parent) {
      if (!parent) {
        parent = $$a(svgcontent).children(); // Prevent layers from being included
      }

      var contentElems = [];
      $$a(parent).children().each(function (i, elem) {
        if (elem.getBBox) {
          contentElems.push({
            elem: elem,
            bbox: getStrokedBBoxDefaultVisible([elem])
          });
        }
      });
      return contentElems.reverse();
    };
    /**
    * Wrap an SVG element into a group element, mark the group as 'gsvg'.
    * @function module:svgcanvas.SvgCanvas#groupSvgElem
    * @param {Element} elem - SVG element to wrap
    * @returns {void}
    */


    var groupSvgElem = this.groupSvgElem = function (elem) {
      var g = document.createElementNS(NS.SVG, 'g');
      elem.replaceWith(g);
      $$a(g).append(elem).data('gsvg', elem)[0].id = getNextId();
    }; // Set scope for these functions
    // Object to contain editor event names and callback functions


    var events = {};
    canvas.call = call;
    /**
     * Array of what was changed (elements, layers).
     * @event module:svgcanvas.SvgCanvas#event:changed
     * @type {Element[]}
     */

    /**
     * Array of selected elements.
     * @event module:svgcanvas.SvgCanvas#event:selected
     * @type {Element[]}
     */

    /**
     * Array of selected elements.
     * @event module:svgcanvas.SvgCanvas#event:transition
     * @type {Element[]}
     */

    /**
     * The Element is always `SVGGElement`?
     * If not `null`, will be the set current group element.
     * @event module:svgcanvas.SvgCanvas#event:contextset
     * @type {null|Element}
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:pointsAdded
     * @type {PlainObject}
     * @property {boolean} closedSubpath
     * @property {SVGCircleElement[]} grips Grips elements
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:zoomed
     * @type {PlainObject}
     * @property {Float} x
     * @property {Float} y
     * @property {Float} width
     * @property {Float} height
     * @property {0.5|2} factor
     * @see module:SVGEditor.BBoxObjectWithFactor
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:updateCanvas
     * @type {PlainObject}
     * @property {false} center
     * @property {module:math.XYObject} newCtr
     */

    /**
     * @typedef {PlainObject} module:svgcanvas.ExtensionInitResponsePlusName
     * @implements {module:svgcanvas.ExtensionInitResponse}
     * @property {string} name The extension's resolved ID (whether explicit or based on file name)
     */

    /**
     * Generalized extension object response of
     * [`init()`]{@link module:svgcanvas.ExtensionInitCallback}
     * along with the name of the extension.
     * @event module:svgcanvas.SvgCanvas#event:extension_added
     * @type {module:svgcanvas.ExtensionInitResponsePlusName|void}
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:extensions_added
     * @type {void}
    */

    /**
     * @typedef {PlainObject} module:svgcanvas.Message
     * @property {any} data The data
     * @property {string} origin The origin
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:message
     * @type {module:svgcanvas.Message}
     */

    /**
     * SVG canvas converted to string.
     * @event module:svgcanvas.SvgCanvas#event:saved
     * @type {string}
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:setnonce
     * @type {!(string|Integer)}
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:unsetnonce
     * @type {void}
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:zoomDone
     * @type {void}
    */

    /**
     * @event module:svgcanvas.SvgCanvas#event:cleared
     * @type {void}
    */

    /**
     * @event module:svgcanvas.SvgCanvas#event:exported
     * @type {module:svgcanvas.ImageExportedResults}
     */

    /**
     * @event module:svgcanvas.SvgCanvas#event:exportedPDF
     * @type {module:svgcanvas.PDFExportedResults}
     */

    /**
     * Creating a cover-all class until {@link https://github.com/jsdoc3/jsdoc/issues/1545} may be supported.
     * `undefined` may be returned by {@link module:svgcanvas.SvgCanvas#event:extension_added} if the extension's `init` returns `undefined` It is also the type for the following events "zoomDone", "unsetnonce", "cleared", and "extensions_added".
     * @event module:svgcanvas.SvgCanvas#event:GenericCanvasEvent
     * @type {module:svgcanvas.SvgCanvas#event:selected|module:svgcanvas.SvgCanvas#event:changed|module:svgcanvas.SvgCanvas#event:contextset|module:svgcanvas.SvgCanvas#event:pointsAdded|module:svgcanvas.SvgCanvas#event:extension_added|module:svgcanvas.SvgCanvas#event:extensions_added|module:svgcanvas.SvgCanvas#event:message|module:svgcanvas.SvgCanvas#event:transition|module:svgcanvas.SvgCanvas#event:zoomed|module:svgcanvas.SvgCanvas#event:updateCanvas|module:svgcanvas.SvgCanvas#event:saved|module:svgcanvas.SvgCanvas#event:exported|module:svgcanvas.SvgCanvas#event:exportedPDF|module:svgcanvas.SvgCanvas#event:setnonce|module:svgcanvas.SvgCanvas#event:unsetnonce|void}
     */

    /**
     * The promise return, if present, resolves to `undefined`
     *  (`extension_added`, `exported`, `saved`).
     * @typedef {Promise<void>|void} module:svgcanvas.EventHandlerReturn
    */

    /**
    * @callback module:svgcanvas.EventHandler
    * @param {external:Window} win
    * @param {module:svgcanvas.SvgCanvas#event:GenericCanvasEvent} arg
    * @listens module:svgcanvas.SvgCanvas#event:GenericCanvasEvent
    * @returns {module:svgcanvas.EventHandlerReturn}
    */

    /**
    * Attaches a callback function to an event.
    * @function module:svgcanvas.SvgCanvas#bind
    * @param {"changed"|"contextset"|"selected"|"pointsAdded"|"extension_added"|"extensions_added"|"message"|"transition"|"zoomed"|"updateCanvas"|"zoomDone"|"saved"|"exported"|"exportedPDF"|"setnonce"|"unsetnonce"|"cleared"} ev - String indicating the name of the event
    * @param {module:svgcanvas.EventHandler} f - The callback function to bind to the event
    * @returns {module:svgcanvas.EventHandler} The previous event
    */

    canvas.bind = function (ev, f) {
      var old = events[ev];
      events[ev] = f;
      return old;
    };
    /**
    * Runs the SVG Document through the sanitizer and then updates its paths.
    * @function module:svgcanvas.SvgCanvas#prepareSvg
    * @param {XMLDocument} newDoc - The SVG DOM document
    * @returns {void}
    */


    this.prepareSvg = function (newDoc) {
      this.sanitizeSvg(newDoc.documentElement); // convert paths into absolute commands

      var paths = _toConsumableArray(newDoc.getElementsByTagNameNS(NS.SVG, 'path'));

      paths.forEach(function (path) {
        path.setAttribute('d', pathActions$1.convertPath(path));
        pathActions$1.fixEnd(path);
      });
    };
    /**
    * Hack for Firefox bugs where text element features aren't updated or get
    * messed up. See issue 136 and issue 137.
    * This function clones the element and re-selects it.
    * @function module:svgcanvas~ffClone
    * @todo Test for this bug on load and add it to "support" object instead of
    * browser sniffing
    * @param {Element} elem - The (text) DOM element to clone
    * @returns {Element} Cloned element
    */


    var ffClone = function ffClone(elem) {
      if (!isGecko()) {
        return elem;
      }

      var clone = elem.cloneNode(true);
      elem.before(clone);
      elem.remove();
      selectorManager.releaseSelector(elem);
      selectedElements[0] = clone;
      selectorManager.requestSelector(clone).showGrips(true);
      return clone;
    }; // `this.each` is deprecated, if any extension used this it can be recreated by doing this:
    // * @example $(canvas.getRootElem()).children().each(...)
    // * @function module:svgcanvas.SvgCanvas#each
    // this.each = function (cb) {
    //  $(svgroot).children().each(cb);
    // };

    /**
    * Removes any old rotations if present, prepends a new rotation at the
    * transformed center.
    * @function module:svgcanvas.SvgCanvas#setRotationAngle
    * @param {string|Float} val - The new rotation angle in degrees
    * @param {boolean} preventUndo - Indicates whether the action should be undoable or not
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.setRotationAngle = function (val, preventUndo) {
      // ensure val is the proper type
      val = Number.parseFloat(val);
      var elem = selectedElements[0];
      var oldTransform = elem.getAttribute('transform');
      var bbox = getBBox(elem);
      var cx = bbox.x + bbox.width / 2,
          cy = bbox.y + bbox.height / 2;
      var tlist = getTransformList(elem); // only remove the real rotational transform if present (i.e. at index=0)

      if (tlist.numberOfItems > 0) {
        var xform = tlist.getItem(0);

        if (xform.type === 4) {
          tlist.removeItem(0);
        }
      } // find Rnc and insert it


      if (val !== 0) {
        var center = transformPoint(cx, cy, transformListToTransform(tlist).matrix);
        var Rnc = svgroot.createSVGTransform();
        Rnc.setRotate(val, center.x, center.y);

        if (tlist.numberOfItems) {
          tlist.insertItemBefore(Rnc, 0);
        } else {
          tlist.appendItem(Rnc);
        }
      } else if (tlist.numberOfItems === 0) {
        elem.removeAttribute('transform');
      }

      if (!preventUndo) {
        // we need to undo it, then redo it so it can be undo-able! :)
        // TODO: figure out how to make changes to transform list undo-able cross-browser?
        var newTransform = elem.getAttribute('transform');
        elem.setAttribute('transform', oldTransform);
        changeSelectedAttribute('transform', newTransform, selectedElements);
        call('changed', selectedElements);
      } // const pointGripContainer = getElem('pathpointgrip_container');
      // if (elem.nodeName === 'path' && pointGripContainer) {
      //   pathActions.setPointContainerTransform(elem.getAttribute('transform'));
      // }


      var selector = selectorManager.requestSelector(selectedElements[0]);
      selector.resize();
      Selector.updateGripCursors(val);
    };
    /**
    * Runs `recalculateDimensions` on the selected elements,
    * adding the changes to a single batch command.
    * @function module:svgcanvas.SvgCanvas#recalculateAllSelectedDimensions
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    var recalculateAllSelectedDimensions = this.recalculateAllSelectedDimensions = function () {
      var text = currentResizeMode === 'none' ? 'position' : 'size';
      var batchCmd = new BatchCommand$1(text);
      var i = selectedElements.length;

      while (i--) {
        var elem = selectedElements[i]; // if (getRotationAngle(elem) && !hasMatrixTransform(getTransformList(elem))) { continue; }

        var cmd = recalculateDimensions(elem);

        if (cmd) {
          batchCmd.addSubCommand(cmd);
        }
      }

      if (!batchCmd.isEmpty()) {
        addCommandToHistory(batchCmd);
        call('changed', selectedElements);
      }
    };
    /**
     * Debug tool to easily see the current matrix in the browser's console.
     * @function module:svgcanvas~logMatrix
     * @param {SVGMatrix} m The matrix
     * @returns {void}
     */


    var logMatrix = function logMatrix(m) {
      console.log([m.a, m.b, m.c, m.d, m.e, m.f]); // eslint-disable-line no-console
    }; // Root Current Transformation Matrix in user units


    var rootSctm = null;
    /**
    * Group: Selection.
    */
    // TODO: do we need to worry about selectedBBoxes here?

    /**
    * Selects only the given elements, shortcut for `clearSelection(); addToSelection()`.
    * @function module:svgcanvas.SvgCanvas#selectOnly
    * @param {Element[]} elems - an array of DOM elements to be selected
    * @param {boolean} showGrips - Indicates whether the resize grips should be shown
    * @returns {void}
    */

    var selectOnly = this.selectOnly = function (elems, showGrips) {
      clearSelection(true);
      addToSelection(elems, showGrips);
    }; // TODO: could use slice here to make this faster?
    // TODO: should the 'selected' handler

    /**
    * Removes elements from the selection.
    * @function module:svgcanvas.SvgCanvas#removeFromSelection
    * @param {Element[]} elemsToRemove - An array of elements to remove from selection
    * @returns {void}
    */

    /* const removeFromSelection = */


    this.removeFromSelection = function (elemsToRemove) {
      if (isNullish(selectedElements[0])) {
        return;
      }

      if (!elemsToRemove.length) {
        return;
      } // find every element and remove it from our array copy


      var newSelectedItems = [],
          len = selectedElements.length;

      for (var i = 0; i < len; ++i) {
        var elem = selectedElements[i];

        if (elem) {
          // keep the item
          if (!elemsToRemove.includes(elem)) {
            newSelectedItems.push(elem);
          } else {
            // remove the item and its selector
            selectorManager.releaseSelector(elem);
          }
        }
      } // the copy becomes the master now


      selectedElements = newSelectedItems;
    };
    /**
    * Clears the selection, then adds all elements in the current layer to the selection.
    * @function module:svgcanvas.SvgCanvas#selectAllInCurrentLayer
    * @returns {void}
    */


    this.selectAllInCurrentLayer = function () {
      var currentLayer = getCurrentDrawing().getCurrentLayer();

      if (currentLayer) {
        currentMode = 'select';
        selectOnly($$a(currentGroup || currentLayer).children());
      }
    };

    var drawnPath = null; // Mouse events

    (function () {
      var freehand = {
        minx: null,
        miny: null,
        maxx: null,
        maxy: null
      };
      var THRESHOLD_DIST = 0.8,
          STEP_COUNT = 10;
      var dAttr = null,
          startX = null,
          startY = null,
          rStartX = null,
          rStartY = null,
          initBbox = {},
          sumDistance = 0,
          controllPoint2 = {
        x: 0,
        y: 0
      },
          controllPoint1 = {
        x: 0,
        y: 0
      },
          start = {
        x: 0,
        y: 0
      },
          end = {
        x: 0,
        y: 0
      },
          bSpline = {
        x: 0,
        y: 0
      },
          nextPos = {
        x: 0,
        y: 0
      },
          parameter,
          nextParameter;

      var getBsplinePoint = function getBsplinePoint(t) {
        var spline = {
          x: 0,
          y: 0
        },
            p0 = controllPoint2,
            p1 = controllPoint1,
            p2 = start,
            p3 = end,
            S = 1.0 / 6.0,
            t2 = t * t,
            t3 = t2 * t;
        var m = [[-1, 3, -3, 1], [3, -6, 3, 0], [-3, 0, 3, 0], [1, 4, 1, 0]];
        spline.x = S * ((p0.x * m[0][0] + p1.x * m[0][1] + p2.x * m[0][2] + p3.x * m[0][3]) * t3 + (p0.x * m[1][0] + p1.x * m[1][1] + p2.x * m[1][2] + p3.x * m[1][3]) * t2 + (p0.x * m[2][0] + p1.x * m[2][1] + p2.x * m[2][2] + p3.x * m[2][3]) * t + (p0.x * m[3][0] + p1.x * m[3][1] + p2.x * m[3][2] + p3.x * m[3][3]));
        spline.y = S * ((p0.y * m[0][0] + p1.y * m[0][1] + p2.y * m[0][2] + p3.y * m[0][3]) * t3 + (p0.y * m[1][0] + p1.y * m[1][1] + p2.y * m[1][2] + p3.y * m[1][3]) * t2 + (p0.y * m[2][0] + p1.y * m[2][1] + p2.y * m[2][2] + p3.y * m[2][3]) * t + (p0.y * m[3][0] + p1.y * m[3][1] + p2.y * m[3][2] + p3.y * m[3][3]));
        return {
          x: spline.x,
          y: spline.y
        };
      };
      /**
       * Follows these conditions:
       * - When we are in a create mode, the element is added to the canvas but the
       *   action is not recorded until mousing up.
       * - When we are in select mode, select the element, remember the position
       *   and do nothing else.
       * @param {MouseEvent} evt
       * @fires module:svgcanvas.SvgCanvas#event:ext_mouseDown
       * @returns {void}
       */


      var mouseDown = function mouseDown(evt) {
        if (canvas.spaceKey || evt.button === 1) {
          return;
        }

        var rightClick = evt.button === 2;

        if (evt.altKey) {
          // duplicate when dragging
          canvas.cloneSelectedElements(0, 0);
        }

        rootSctm = $$a('#svgcontent g')[0].getScreenCTM().inverse();
        var pt = transformPoint(evt.pageX, evt.pageY, rootSctm),
            mouseX = pt.x * currentZoom,
            mouseY = pt.y * currentZoom;
        evt.preventDefault();

        if (rightClick) {
          currentMode = 'select';
          lastClickPoint = pt;
        } // This would seem to be unnecessary...
        // if (!['select', 'resize'].includes(currentMode)) {
        //   setGradient();
        // }


        var x = mouseX / currentZoom,
            y = mouseY / currentZoom;
        var mouseTarget = getMouseTarget(evt);

        if (mouseTarget.tagName === 'a' && mouseTarget.childNodes.length === 1) {
          mouseTarget = mouseTarget.firstChild;
        } // realX/y ignores grid-snap value


        var realX = x;
        rStartX = startX = x;
        var realY = y;
        rStartY = startY = y;

        if (curConfig.gridSnapping) {
          x = snapToGrid(x);
          y = snapToGrid(y);
          startX = snapToGrid(startX);
          startY = snapToGrid(startY);
        } // if it is a selector grip, then it must be a single element selected,
        // set the mouseTarget to that and update the mode to rotate/resize


        if (mouseTarget === selectorManager.selectorParentGroup && !isNullish(selectedElements[0])) {
          var grip = evt.target;
          var griptype = elData(grip, 'type'); // rotating

          if (griptype === 'rotate') {
            currentMode = 'rotate'; // resizing
          } else if (griptype === 'resize') {
            currentMode = 'resize';
            currentResizeMode = elData(grip, 'dir');
          }

          mouseTarget = selectedElements[0];
        }

        startTransform = mouseTarget.getAttribute('transform');
        var tlist = getTransformList(mouseTarget);

        switch (currentMode) {
          case 'select':
            started = true;
            currentResizeMode = 'none';

            if (rightClick) {
              started = false;
            }

            if (mouseTarget !== svgroot) {
              // if this element is not yet selected, clear selection and select it
              if (!selectedElements.includes(mouseTarget)) {
                // only clear selection if shift is not pressed (otherwise, add
                // element to selection)
                if (!evt.shiftKey) {
                  // No need to do the call here as it will be done on addToSelection
                  clearSelection(true);
                }

                addToSelection([mouseTarget]);
                justSelected = mouseTarget;
                pathActions$1.clear();
              } // else if it's a path, go into pathedit mode in mouseup


              if (!rightClick) {
                // insert a dummy transform so if the element(s) are moved it will have
                // a transform to use for its translate
                var _iterator = _createForOfIteratorHelper(selectedElements),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var selectedElement = _step.value;

                    if (isNullish(selectedElement)) {
                      continue;
                    }

                    var slist = getTransformList(selectedElement);

                    if (slist.numberOfItems) {
                      slist.insertItemBefore(svgroot.createSVGTransform(), 0);
                    } else {
                      slist.appendItem(svgroot.createSVGTransform());
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
            } else if (!rightClick) {
              clearSelection();
              currentMode = 'multiselect';

              if (isNullish(rubberBox)) {
                rubberBox = selectorManager.getRubberBandBox();
              }

              rStartX *= currentZoom;
              rStartY *= currentZoom; // console.log('p',[evt.pageX, evt.pageY]);
              // console.log('c',[evt.clientX, evt.clientY]);
              // console.log('o',[evt.offsetX, evt.offsetY]);
              // console.log('s',[startX, startY]);

              assignAttributes(rubberBox, {
                x: rStartX,
                y: rStartY,
                width: 0,
                height: 0,
                display: 'inline'
              });
            }

            break;

          case 'zoom':
            started = true;

            if (isNullish(rubberBox)) {
              rubberBox = selectorManager.getRubberBandBox();
            }

            assignAttributes(rubberBox, {
              x: realX * currentZoom,
              y: realX * currentZoom,
              width: 0,
              height: 0,
              display: 'inline'
            });
            break;

          case 'resize':
            {
              started = true;
              startX = x;
              startY = y; // Getting the BBox from the selection box, since we know we
              // want to orient around it

              initBbox = getBBox($$a('#selectedBox0')[0]);
              var bb = {};
              $$a.each(initBbox, function (key, val) {
                bb[key] = val / currentZoom;
              });
              initBbox = bb; // append three dummy transforms to the tlist so that
              // we can translate,scale,translate in mousemove

              var pos = getRotationAngle(mouseTarget) ? 1 : 0;

              if (hasMatrixTransform(tlist)) {
                tlist.insertItemBefore(svgroot.createSVGTransform(), pos);
                tlist.insertItemBefore(svgroot.createSVGTransform(), pos);
                tlist.insertItemBefore(svgroot.createSVGTransform(), pos);
              } else {
                tlist.appendItem(svgroot.createSVGTransform());
                tlist.appendItem(svgroot.createSVGTransform());
                tlist.appendItem(svgroot.createSVGTransform());

                if (supportsNonScalingStroke()) {
                  // Handle crash for newer Chrome and Safari 6 (Mobile and Desktop):
                  // https://code.google.com/p/svg-edit/issues/detail?id=904
                  // Chromium issue: https://code.google.com/p/chromium/issues/detail?id=114625
                  // TODO: Remove this workaround once vendor fixes the issue
                  var iswebkit = isWebkit();
                  var delayedStroke;

                  if (iswebkit) {
                    delayedStroke = function delayedStroke(ele) {
                      var stroke_ = ele.getAttribute('stroke');
                      ele.removeAttribute('stroke'); // Re-apply stroke after delay. Anything higher than 1 seems to cause flicker

                      if (stroke_ !== null) setTimeout(function () {
                        ele.setAttribute('stroke', stroke_);
                      }, 0);
                    };
                  }

                  mouseTarget.style.vectorEffect = 'non-scaling-stroke';

                  if (iswebkit) {
                    delayedStroke(mouseTarget);
                  }

                  var all = mouseTarget.getElementsByTagName('*'),
                      len = all.length;

                  for (var i = 0; i < len; i++) {
                    if (!all[i].style) {
                      // mathML
                      continue;
                    }

                    all[i].style.vectorEffect = 'non-scaling-stroke';

                    if (iswebkit) {
                      delayedStroke(all[i]);
                    }
                  }
                }
              }

              break;
            }

          case 'fhellipse':
          case 'fhrect':
          case 'fhpath':
            start.x = realX;
            start.y = realY;
            controllPoint1 = {
              x: 0,
              y: 0
            };
            controllPoint2 = {
              x: 0,
              y: 0
            };
            started = true;
            dAttr = realX + ',' + realY + ' '; // Commented out as doing nothing now:
            // strokeW = parseFloat(curShape.stroke_width) === 0 ? 1 : curShape.stroke_width;

            addSVGElementFromJson({
              element: 'polyline',
              curStyles: true,
              attr: {
                points: dAttr,
                id: getNextId(),
                fill: 'none',
                opacity: curShape.opacity / 2,
                'stroke-linecap': 'round',
                style: 'pointer-events:none'
              }
            });
            freehand.minx = realX;
            freehand.maxx = realX;
            freehand.miny = realY;
            freehand.maxy = realY;
            break;

          case 'image':
            {
              started = true;
              var newImage = addSVGElementFromJson({
                element: 'image',
                attr: {
                  x: x,
                  y: y,
                  width: 0,
                  height: 0,
                  id: getNextId(),
                  opacity: curShape.opacity / 2,
                  style: 'pointer-events:inherit'
                }
              });
              setHref(newImage, lastGoodImgUrl);
              preventClickDefault(newImage);
              break;
            }

          case 'square': // TODO: once we create the rect, we lose information that this was a square
          // (for resizing purposes this could be important)
          // Fallthrough

          case 'rect':
            started = true;
            startX = x;
            startY = y;
            addSVGElementFromJson({
              element: 'rect',
              curStyles: true,
              attr: {
                x: x,
                y: y,
                width: 0,
                height: 0,
                id: getNextId(),
                opacity: curShape.opacity / 2
              }
            });
            break;

          case 'line':
            {
              started = true;
              var strokeW = Number(curShape.stroke_width) === 0 ? 1 : curShape.stroke_width;
              addSVGElementFromJson({
                element: 'line',
                curStyles: true,
                attr: {
                  x1: x,
                  y1: y,
                  x2: x,
                  y2: y,
                  id: getNextId(),
                  stroke: curShape.stroke,
                  'stroke-width': strokeW,
                  'stroke-dasharray': curShape.stroke_dasharray,
                  'stroke-linejoin': curShape.stroke_linejoin,
                  'stroke-linecap': curShape.stroke_linecap,
                  'stroke-opacity': curShape.stroke_opacity,
                  fill: 'none',
                  opacity: curShape.opacity / 2,
                  style: 'pointer-events:none'
                }
              });
              break;
            }

          case 'circle':
            started = true;
            addSVGElementFromJson({
              element: 'circle',
              curStyles: true,
              attr: {
                cx: x,
                cy: y,
                r: 0,
                id: getNextId(),
                opacity: curShape.opacity / 2
              }
            });
            break;

          case 'ellipse':
            started = true;
            addSVGElementFromJson({
              element: 'ellipse',
              curStyles: true,
              attr: {
                cx: x,
                cy: y,
                rx: 0,
                ry: 0,
                id: getNextId(),
                opacity: curShape.opacity / 2
              }
            });
            break;

          case 'text':
            started = true;
            /* const newText = */

            addSVGElementFromJson({
              element: 'text',
              curStyles: true,
              attr: {
                x: x,
                y: y,
                id: getNextId(),
                fill: curText.fill,
                'stroke-width': curText.stroke_width,
                'font-size': curText.font_size,
                'font-family': curText.font_family,
                'text-anchor': 'middle',
                'xml:space': 'preserve',
                opacity: curShape.opacity
              }
            }); // newText.textContent = 'text';

            break;

          case 'path': // Fall through

          case 'pathedit':
            startX *= currentZoom;
            startY *= currentZoom;
            pathActions$1.mouseDown(evt, mouseTarget, startX, startY);
            started = true;
            break;

          case 'textedit':
            startX *= currentZoom;
            startY *= currentZoom;
            textActions.mouseDown(evt, mouseTarget, startX, startY);
            started = true;
            break;

          case 'rotate':
            started = true; // we are starting an undoable change (a drag-rotation)

            canvas.undoMgr.beginUndoableChange('transform', selectedElements);
            break;
        }
        /**
         * The main (left) mouse button is held down on the canvas area.
         * @event module:svgcanvas.SvgCanvas#event:ext_mouseDown
         * @type {PlainObject}
         * @property {MouseEvent} event The event object
         * @property {Float} start_x x coordinate on canvas
         * @property {Float} start_y y coordinate on canvas
         * @property {Element[]} selectedElements An array of the selected Elements
        */


        var extResult = runExtensions('mouseDown',
        /** @type {module:svgcanvas.SvgCanvas#event:ext_mouseDown} */
        {
          event: evt,
          start_x: startX,
          start_y: startY,
          selectedElements: selectedElements
        }, true);
        $$a.each(extResult, function (i, r) {
          if (r && r.started) {
            started = true;
          }
        });
      }; // in this function we do not record any state changes yet (but we do update
      // any elements that are still being created, moved or resized on the canvas)

      /**
       *
       * @param {MouseEvent} evt
       * @fires module:svgcanvas.SvgCanvas#event:transition
       * @fires module:svgcanvas.SvgCanvas#event:ext_mouseMove
       * @returns {void}
       */


      var mouseMove = function mouseMove(evt) {
        if (!started) {
          return;
        }

        if (evt.button === 1 || canvas.spaceKey) {
          return;
        }

        var i,
            xya,
            c,
            cx,
            cy,
            dx,
            dy,
            len,
            angle,
            box,
            selected = selectedElements[0];
        var pt = transformPoint(evt.pageX, evt.pageY, rootSctm),
            mouseX = pt.x * currentZoom,
            mouseY = pt.y * currentZoom,
            shape = getElem(getId());
        var realX = mouseX / currentZoom;
        var x = realX;
        var realY = mouseY / currentZoom;
        var y = realY;

        if (curConfig.gridSnapping) {
          x = snapToGrid(x);
          y = snapToGrid(y);
        }

        evt.preventDefault();
        var tlist;

        switch (currentMode) {
          case 'select':
            {
              // we temporarily use a translate on the element(s) being dragged
              // this transform is removed upon mousing up and the element is
              // relocated to the new location
              if (selectedElements[0] !== null) {
                dx = x - startX;
                dy = y - startY;

                if (curConfig.gridSnapping) {
                  dx = snapToGrid(dx);
                  dy = snapToGrid(dy);
                }
                /*
                // Commenting out as currently has no effect
                if (evt.shiftKey) {
                  xya = snapToAngle(startX, startY, x, y);
                  ({x, y} = xya);
                }
                */


                if (dx !== 0 || dy !== 0) {
                  len = selectedElements.length;

                  for (i = 0; i < len; ++i) {
                    selected = selectedElements[i];

                    if (isNullish(selected)) {
                      break;
                    } // if (i === 0) {
                    //   const box = utilsGetBBox(selected);
                    //     selectedBBoxes[i].x = box.x + dx;
                    //     selectedBBoxes[i].y = box.y + dy;
                    // }
                    // update the dummy transform in our transform list
                    // to be a translate


                    var xform = svgroot.createSVGTransform();
                    tlist = getTransformList(selected); // Note that if Webkit and there's no ID for this
                    // element, the dummy transform may have gotten lost.
                    // This results in unexpected behaviour

                    xform.setTranslate(dx, dy);

                    if (tlist.numberOfItems) {
                      tlist.replaceItem(xform, 0);
                    } else {
                      tlist.appendItem(xform);
                    } // update our internal bbox that we're tracking while dragging


                    selectorManager.requestSelector(selected).resize();
                  }

                  call('transition', selectedElements);
                }
              }

              break;
            }

          case 'multiselect':
            {
              realX *= currentZoom;
              realY *= currentZoom;
              assignAttributes(rubberBox, {
                x: Math.min(rStartX, realX),
                y: Math.min(rStartY, realY),
                width: Math.abs(realX - rStartX),
                height: Math.abs(realY - rStartY)
              }); // for each selected:
              // - if newList contains selected, do nothing
              // - if newList doesn't contain selected, remove it from selected
              // - for any newList that was not in selectedElements, add it to selected

              var elemsToRemove = selectedElements.slice(),
                  elemsToAdd = [],
                  newList = getIntersectionList(); // For every element in the intersection, add if not present in selectedElements.

              len = newList.length;

              for (i = 0; i < len; ++i) {
                var intElem = newList[i]; // Found an element that was not selected before, so we should add it.

                if (!selectedElements.includes(intElem)) {
                  elemsToAdd.push(intElem);
                } // Found an element that was already selected, so we shouldn't remove it.


                var foundInd = elemsToRemove.indexOf(intElem);

                if (foundInd !== -1) {
                  elemsToRemove.splice(foundInd, 1);
                }
              }

              if (elemsToRemove.length > 0) {
                canvas.removeFromSelection(elemsToRemove);
              }

              if (elemsToAdd.length > 0) {
                canvas.addToSelection(elemsToAdd);
              }

              break;
            }

          case 'resize':
            {
              // we track the resize bounding box and translate/scale the selected element
              // while the mouse is down, when mouse goes up, we use this to recalculate
              // the shape's coordinates
              tlist = getTransformList(selected);
              var hasMatrix = hasMatrixTransform(tlist);
              box = hasMatrix ? initBbox : getBBox(selected);
              var left = box.x,
                  top = box.y,
                  _box = box,
                  width = _box.width,
                  height = _box.height;
              dx = x - startX;
              dy = y - startY;

              if (curConfig.gridSnapping) {
                dx = snapToGrid(dx);
                dy = snapToGrid(dy);
                height = snapToGrid(height);
                width = snapToGrid(width);
              } // if rotated, adjust the dx,dy values


              angle = getRotationAngle(selected);

              if (angle) {
                var r = Math.sqrt(dx * dx + dy * dy),
                    theta = Math.atan2(dy, dx) - angle * Math.PI / 180.0;
                dx = r * Math.cos(theta);
                dy = r * Math.sin(theta);
              } // if not stretching in y direction, set dy to 0
              // if not stretching in x direction, set dx to 0


              if (!currentResizeMode.includes('n') && !currentResizeMode.includes('s')) {
                dy = 0;
              }

              if (!currentResizeMode.includes('e') && !currentResizeMode.includes('w')) {
                dx = 0;
              }

              var // ts = null,
              tx = 0,
                  ty = 0,
                  sy = height ? (height + dy) / height : 1,
                  sx = width ? (width + dx) / width : 1; // if we are dragging on the north side, then adjust the scale factor and ty

              if (currentResizeMode.includes('n')) {
                sy = height ? (height - dy) / height : 1;
                ty = height;
              } // if we dragging on the east side, then adjust the scale factor and tx


              if (currentResizeMode.includes('w')) {
                sx = width ? (width - dx) / width : 1;
                tx = width;
              } // update the transform list with translate,scale,translate


              var translateOrigin = svgroot.createSVGTransform(),
                  scale = svgroot.createSVGTransform(),
                  translateBack = svgroot.createSVGTransform();

              if (curConfig.gridSnapping) {
                left = snapToGrid(left);
                tx = snapToGrid(tx);
                top = snapToGrid(top);
                ty = snapToGrid(ty);
              }

              translateOrigin.setTranslate(-(left + tx), -(top + ty));

              if (evt.shiftKey) {
                if (sx === 1) {
                  sx = sy;
                } else {
                  sy = sx;
                }
              }

              scale.setScale(sx, sy);
              translateBack.setTranslate(left + tx, top + ty);

              if (hasMatrix) {
                var diff = angle ? 1 : 0;
                tlist.replaceItem(translateOrigin, 2 + diff);
                tlist.replaceItem(scale, 1 + diff);
                tlist.replaceItem(translateBack, Number(diff));
              } else {
                var N = tlist.numberOfItems;
                tlist.replaceItem(translateBack, N - 3);
                tlist.replaceItem(scale, N - 2);
                tlist.replaceItem(translateOrigin, N - 1);
              }

              selectorManager.requestSelector(selected).resize();
              call('transition', selectedElements);
              break;
            }

          case 'zoom':
            {
              realX *= currentZoom;
              realY *= currentZoom;
              assignAttributes(rubberBox, {
                x: Math.min(rStartX * currentZoom, realX),
                y: Math.min(rStartY * currentZoom, realY),
                width: Math.abs(realX - rStartX * currentZoom),
                height: Math.abs(realY - rStartY * currentZoom)
              });
              break;
            }

          case 'text':
            {
              assignAttributes(shape, {
                x: x,
                y: y
              });
              break;
            }

          case 'line':
            {
              if (curConfig.gridSnapping) {
                x = snapToGrid(x);
                y = snapToGrid(y);
              }

              var x2 = x;
              var y2 = y;

              if (evt.shiftKey) {
                xya = snapToAngle(startX, startY, x2, y2);
                x2 = xya.x;
                y2 = xya.y;
              }

              shape.setAttribute('x2', x2);
              shape.setAttribute('y2', y2);
              break;
            }

          case 'foreignObject': // fall through

          case 'square': // fall through

          case 'rect': // fall through

          case 'image':
            {
              var square = currentMode === 'square' || evt.shiftKey;
              var w = Math.abs(x - startX),
                  h = Math.abs(y - startY);
              var newX, newY;

              if (square) {
                w = h = Math.max(w, h);
                newX = startX < x ? startX : startX - w;
                newY = startY < y ? startY : startY - h;
              } else {
                newX = Math.min(startX, x);
                newY = Math.min(startY, y);
              }

              if (curConfig.gridSnapping) {
                w = snapToGrid(w);
                h = snapToGrid(h);
                newX = snapToGrid(newX);
                newY = snapToGrid(newY);
              }

              assignAttributes(shape, {
                width: w,
                height: h,
                x: newX,
                y: newY
              });
              break;
            }

          case 'circle':
            {
              c = $$a(shape).attr(['cx', 'cy']);
              var _c = c;
              cx = _c.cx;
              cy = _c.cy;
              var rad = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));

              if (curConfig.gridSnapping) {
                rad = snapToGrid(rad);
              }

              shape.setAttribute('r', rad);
              break;
            }

          case 'ellipse':
            {
              c = $$a(shape).attr(['cx', 'cy']);
              var _c2 = c;
              cx = _c2.cx;
              cy = _c2.cy;

              if (curConfig.gridSnapping) {
                x = snapToGrid(x);
                cx = snapToGrid(cx);
                y = snapToGrid(y);
                cy = snapToGrid(cy);
              }

              shape.setAttribute('rx', Math.abs(x - cx));
              var ry = Math.abs(evt.shiftKey ? x - cx : y - cy);
              shape.setAttribute('ry', ry);
              break;
            }

          case 'fhellipse':
          case 'fhrect':
            {
              freehand.minx = Math.min(realX, freehand.minx);
              freehand.maxx = Math.max(realX, freehand.maxx);
              freehand.miny = Math.min(realY, freehand.miny);
              freehand.maxy = Math.max(realY, freehand.maxy);
            }
          // Fallthrough

          case 'fhpath':
            {
              // dAttr += + realX + ',' + realY + ' ';
              // shape.setAttribute('points', dAttr);
              end.x = realX;
              end.y = realY;

              if (controllPoint2.x && controllPoint2.y) {
                for (i = 0; i < STEP_COUNT - 1; i++) {
                  parameter = i / STEP_COUNT;
                  nextParameter = (i + 1) / STEP_COUNT;
                  bSpline = getBsplinePoint(nextParameter);
                  nextPos = bSpline;
                  bSpline = getBsplinePoint(parameter);
                  sumDistance += Math.sqrt((nextPos.x - bSpline.x) * (nextPos.x - bSpline.x) + (nextPos.y - bSpline.y) * (nextPos.y - bSpline.y));

                  if (sumDistance > THRESHOLD_DIST) {
                    sumDistance -= THRESHOLD_DIST; // Faster than completely re-writing the points attribute.

                    var point = svgcontent.createSVGPoint();
                    point.x = bSpline.x;
                    point.y = bSpline.y;
                    shape.points.appendItem(point);
                  }
                }
              }

              controllPoint2 = {
                x: controllPoint1.x,
                y: controllPoint1.y
              };
              controllPoint1 = {
                x: start.x,
                y: start.y
              };
              start = {
                x: end.x,
                y: end.y
              };
              break; // update path stretch line coordinates
            }

          case 'path': // fall through

          case 'pathedit':
            {
              x *= currentZoom;
              y *= currentZoom;

              if (curConfig.gridSnapping) {
                x = snapToGrid(x);
                y = snapToGrid(y);
                startX = snapToGrid(startX);
                startY = snapToGrid(startY);
              }

              if (evt.shiftKey) {
                var path = path$1;
                var x1, y1;

                if (path) {
                  x1 = path.dragging ? path.dragging[0] : startX;
                  y1 = path.dragging ? path.dragging[1] : startY;
                } else {
                  x1 = startX;
                  y1 = startY;
                }

                xya = snapToAngle(x1, y1, x, y);
                var _xya = xya;
                x = _xya.x;
                y = _xya.y;
              }

              if (rubberBox && rubberBox.getAttribute('display') !== 'none') {
                realX *= currentZoom;
                realY *= currentZoom;
                assignAttributes(rubberBox, {
                  x: Math.min(rStartX * currentZoom, realX),
                  y: Math.min(rStartY * currentZoom, realY),
                  width: Math.abs(realX - rStartX * currentZoom),
                  height: Math.abs(realY - rStartY * currentZoom)
                });
              }

              pathActions$1.mouseMove(x, y);
              break;
            }

          case 'textedit':
            {
              x *= currentZoom;
              y *= currentZoom; // if (rubberBox && rubberBox.getAttribute('display') !== 'none') {
              //   assignAttributes(rubberBox, {
              //     x: Math.min(startX, x),
              //     y: Math.min(startY, y),
              //     width: Math.abs(x - startX),
              //     height: Math.abs(y - startY)
              //   }, 100);
              // }

              textActions.mouseMove(mouseX, mouseY);
              break;
            }

          case 'rotate':
            {
              box = getBBox(selected);
              cx = box.x + box.width / 2;
              cy = box.y + box.height / 2;
              var m = getMatrix(selected),
                  center = transformPoint(cx, cy, m);
              cx = center.x;
              cy = center.y;
              angle = (Math.atan2(cy - y, cx - x) * (180 / Math.PI) - 90) % 360;

              if (curConfig.gridSnapping) {
                angle = snapToGrid(angle);
              }

              if (evt.shiftKey) {
                // restrict rotations to nice angles (WRS)
                var snap = 45;
                angle = Math.round(angle / snap) * snap;
              }

              canvas.setRotationAngle(angle < -180 ? 360 + angle : angle, true);
              call('transition', selectedElements);
              break;
            }
        }
        /**
        * The mouse has moved on the canvas area.
        * @event module:svgcanvas.SvgCanvas#event:ext_mouseMove
        * @type {PlainObject}
        * @property {MouseEvent} event The event object
        * @property {Float} mouse_x x coordinate on canvas
        * @property {Float} mouse_y y coordinate on canvas
        * @property {Element} selected Refers to the first selected element
        */


        runExtensions('mouseMove',
        /** @type {module:svgcanvas.SvgCanvas#event:ext_mouseMove} */
        {
          event: evt,
          mouse_x: mouseX,
          mouse_y: mouseY,
          selected: selected
        });
      }; // mouseMove()
      // - in create mode, the element's opacity is set properly, we create an InsertElementCommand
      // and store it on the Undo stack
      // - in move/resize mode, the element's attributes which were affected by the move/resize are
      // identified, a ChangeElementCommand is created and stored on the stack for those attrs
      // this is done in when we recalculate the selected dimensions()

      /**
       *
       * @param {MouseEvent} evt
       * @fires module:svgcanvas.SvgCanvas#event:zoomed
       * @fires module:svgcanvas.SvgCanvas#event:changed
       * @fires module:svgcanvas.SvgCanvas#event:ext_mouseUp
       * @returns {void}
       */


      var mouseUp = function mouseUp(evt) {
        if (evt.button === 2) {
          return;
        }

        var tempJustSelected = justSelected;
        justSelected = null;

        if (!started) {
          return;
        }

        var pt = transformPoint(evt.pageX, evt.pageY, rootSctm),
            mouseX = pt.x * currentZoom,
            mouseY = pt.y * currentZoom,
            x = mouseX / currentZoom,
            y = mouseY / currentZoom;
        var element = getElem(getId());
        var keep = false;
        var realX = x;
        var realY = y; // TODO: Make true when in multi-unit mode

        started = false;
        var attrs, t;

        switch (currentMode) {
          // intentionally fall-through to select here
          case 'resize':
          case 'multiselect':
            if (!isNullish(rubberBox)) {
              rubberBox.setAttribute('display', 'none');
              curBBoxes = [];
            }

            currentMode = 'select';
          // Fallthrough

          case 'select':
            if (!isNullish(selectedElements[0])) {
              // if we only have one selected element
              if (isNullish(selectedElements[1])) {
                // set our current stroke/fill properties to the element's
                var selected = selectedElements[0];

                switch (selected.tagName) {
                  case 'g':
                  case 'use':
                  case 'image':
                  case 'foreignObject':
                    break;

                  default:
                    curProperties.fill = selected.getAttribute('fill');
                    curProperties.fill_opacity = selected.getAttribute('fill-opacity');
                    curProperties.stroke = selected.getAttribute('stroke');
                    curProperties.stroke_opacity = selected.getAttribute('stroke-opacity');
                    curProperties.stroke_width = selected.getAttribute('stroke-width');
                    curProperties.stroke_dasharray = selected.getAttribute('stroke-dasharray');
                    curProperties.stroke_linejoin = selected.getAttribute('stroke-linejoin');
                    curProperties.stroke_linecap = selected.getAttribute('stroke-linecap');
                }

                if (selected.tagName === 'text') {
                  curText.font_size = selected.getAttribute('font-size');
                  curText.font_family = selected.getAttribute('font-family');
                }

                selectorManager.requestSelector(selected).showGrips(true); // This shouldn't be necessary as it was done on mouseDown...
                // call('selected', [selected]);
              } // always recalculate dimensions to strip off stray identity transforms


              recalculateAllSelectedDimensions(); // if it was being dragged/resized

              if (realX !== rStartX || realY !== rStartY) {
                var len = selectedElements.length;

                for (var i = 0; i < len; ++i) {
                  if (isNullish(selectedElements[i])) {
                    break;
                  }

                  if (!selectedElements[i].firstChild) {
                    // Not needed for groups (incorrectly resizes elems), possibly not needed at all?
                    selectorManager.requestSelector(selectedElements[i]).resize();
                  }
                } // no change in position/size, so maybe we should move to pathedit

              } else {
                t = evt.target;

                if (selectedElements[0].nodeName === 'path' && isNullish(selectedElements[1])) {
                  pathActions$1.select(selectedElements[0]); // if it was a path
                  // else, if it was selected and this is a shift-click, remove it from selection
                } else if (evt.shiftKey) {
                  if (tempJustSelected !== t) {
                    canvas.removeFromSelection([t]);
                  }
                }
              } // no change in mouse position
              // Remove non-scaling stroke


              if (supportsNonScalingStroke()) {
                var elem = selectedElements[0];

                if (elem) {
                  elem.removeAttribute('style');
                  walkTree(elem, function (el) {
                    el.removeAttribute('style');
                  });
                }
              }
            }

            return;

          case 'zoom':
            {
              if (!isNullish(rubberBox)) {
                rubberBox.setAttribute('display', 'none');
              }

              var factor = evt.shiftKey ? 0.5 : 2;
              call('zoomed', {
                x: Math.min(rStartX, realX),
                y: Math.min(rStartY, realY),
                width: Math.abs(realX - rStartX),
                height: Math.abs(realY - rStartY),
                factor: factor
              });
              return;
            }

          case 'fhpath':
            {
              // Check that the path contains at least 2 points; a degenerate one-point path
              // causes problems.
              // Webkit ignores how we set the points attribute with commas and uses space
              // to separate all coordinates, see https://bugs.webkit.org/show_bug.cgi?id=29870
              sumDistance = 0;
              controllPoint2 = {
                x: 0,
                y: 0
              };
              controllPoint1 = {
                x: 0,
                y: 0
              };
              start = {
                x: 0,
                y: 0
              };
              end = {
                x: 0,
                y: 0
              };
              var coords = element.getAttribute('points');
              var commaIndex = coords.indexOf(',');

              if (commaIndex >= 0) {
                keep = coords.includes(',', commaIndex + 1);
              } else {
                keep = coords.includes(' ', coords.indexOf(' ') + 1);
              }

              if (keep) {
                element = pathActions$1.smoothPolylineIntoPath(element);
              }

              break;
            }

          case 'line':
            attrs = $$a(element).attr(['x1', 'x2', 'y1', 'y2']);
            keep = attrs.x1 !== attrs.x2 || attrs.y1 !== attrs.y2;
            break;

          case 'foreignObject':
          case 'square':
          case 'rect':
          case 'image':
            attrs = $$a(element).attr(['width', 'height']); // Image should be kept regardless of size (use inherit dimensions later)

            keep = attrs.width || attrs.height || currentMode === 'image';
            break;

          case 'circle':
            keep = element.getAttribute('r') !== '0';
            break;

          case 'ellipse':
            attrs = $$a(element).attr(['rx', 'ry']);
            keep = attrs.rx || attrs.ry;
            break;

          case 'fhellipse':
            if (freehand.maxx - freehand.minx > 0 && freehand.maxy - freehand.miny > 0) {
              element = addSVGElementFromJson({
                element: 'ellipse',
                curStyles: true,
                attr: {
                  cx: (freehand.minx + freehand.maxx) / 2,
                  cy: (freehand.miny + freehand.maxy) / 2,
                  rx: (freehand.maxx - freehand.minx) / 2,
                  ry: (freehand.maxy - freehand.miny) / 2,
                  id: getId()
                }
              });
              call('changed', [element]);
              keep = true;
            }

            break;

          case 'fhrect':
            if (freehand.maxx - freehand.minx > 0 && freehand.maxy - freehand.miny > 0) {
              element = addSVGElementFromJson({
                element: 'rect',
                curStyles: true,
                attr: {
                  x: freehand.minx,
                  y: freehand.miny,
                  width: freehand.maxx - freehand.minx,
                  height: freehand.maxy - freehand.miny,
                  id: getId()
                }
              });
              call('changed', [element]);
              keep = true;
            }

            break;

          case 'text':
            keep = true;
            selectOnly([element]);
            textActions.start(element);
            break;

          case 'path':
            {
              // set element to null here so that it is not removed nor finalized
              element = null; // continue to be set to true so that mouseMove happens

              started = true;
              var res = pathActions$1.mouseUp(evt, element, mouseX, mouseY);
              element = res.element;
              keep = res.keep;
              break;
            }

          case 'pathedit':
            keep = true;
            element = null;
            pathActions$1.mouseUp(evt);
            break;

          case 'textedit':
            keep = false;
            element = null;
            textActions.mouseUp(evt, mouseX, mouseY);
            break;

          case 'rotate':
            {
              keep = true;
              element = null;
              currentMode = 'select';
              var batchCmd = canvas.undoMgr.finishUndoableChange();

              if (!batchCmd.isEmpty()) {
                addCommandToHistory(batchCmd);
              } // perform recalculation to weed out any stray identity transforms that might get stuck


              recalculateAllSelectedDimensions();
              call('changed', selectedElements);
              break;
            }
        }
        /**
        * The main (left) mouse button is released (anywhere).
        * @event module:svgcanvas.SvgCanvas#event:ext_mouseUp
        * @type {PlainObject}
        * @property {MouseEvent} event The event object
        * @property {Float} mouse_x x coordinate on canvas
        * @property {Float} mouse_y y coordinate on canvas
        */


        var extResult = runExtensions('mouseUp',
        /** @type {module:svgcanvas.SvgCanvas#event:ext_mouseUp} */
        {
          event: evt,
          mouse_x: mouseX,
          mouse_y: mouseY
        }, true);
        $$a.each(extResult, function (i, r) {
          if (r) {
            keep = r.keep || keep;
            element = r.element;
            started = r.started || started;
          }
        });

        if (!keep && !isNullish(element)) {
          getCurrentDrawing().releaseId(getId());
          element.remove();
          element = null;
          t = evt.target; // if this element is in a group, go up until we reach the top-level group
          // just below the layer groups
          // TODO: once we implement links, we also would have to check for <a> elements

          while (t && t.parentNode && t.parentNode.parentNode && t.parentNode.parentNode.tagName === 'g') {
            t = t.parentNode;
          } // if we are not in the middle of creating a path, and we've clicked on some shape,
          // then go to Select mode.
          // WebKit returns <div> when the canvas is clicked, Firefox/Opera return <svg>


          if ((currentMode !== 'path' || !drawnPath) && t && t.parentNode && t.parentNode.id !== 'selectorParentGroup' && t.id !== 'svgcanvas' && t.id !== 'svgroot') {
            // switch into "select" mode if we've clicked on an element
            canvas.setMode('select');
            selectOnly([t], true);
          }
        } else if (!isNullish(element)) {
          /**
          * @name module:svgcanvas.SvgCanvas#addedNew
          * @type {boolean}
          */
          canvas.addedNew = true;

          var aniDur = 0.2;
          var cAni;

          if (opacAni.beginElement && Number.parseFloat(element.getAttribute('opacity')) !== curShape.opacity) {
            cAni = $$a(opacAni).clone().attr({
              to: curShape.opacity,
              dur: aniDur
            }).appendTo(element);

            try {
              // Fails in FF4 on foreignObject
              cAni[0].beginElement();
            } catch (e) {}
          } else {
            aniDur = 0;
          } // Ideally this would be done on the endEvent of the animation,
          // but that doesn't seem to be supported in Webkit


          setTimeout(function () {
            if (cAni) {
              cAni.remove();
            }

            element.setAttribute('opacity', curShape.opacity);
            element.setAttribute('style', 'pointer-events:inherit');
            cleanupElement(element);

            if (currentMode === 'path') {
              pathActions$1.toEditMode(element);
            } else if (curConfig.selectNew) {
              selectOnly([element], true);
            } // we create the insert command that is stored on the stack
            // undo means to call cmd.unapply(), redo means to call cmd.apply()


            addCommandToHistory(new InsertElementCommand$1(element));
            call('changed', [element]);
          }, aniDur * 1000);
        }

        startTransform = null;
      };

      var dblClick = function dblClick(evt) {
        var evtTarget = evt.target;
        var parent = evtTarget.parentNode;
        var mouseTarget = getMouseTarget(evt);
        var _mouseTarget = mouseTarget,
            tagName = _mouseTarget.tagName;

        if (tagName === 'text' && currentMode !== 'textedit') {
          var pt = transformPoint(evt.pageX, evt.pageY, rootSctm);
          textActions.select(mouseTarget, pt.x, pt.y);
        } // Do nothing if already in current group


        if (parent === currentGroup) {
          return;
        }

        if ((tagName === 'g' || tagName === 'a') && getRotationAngle(mouseTarget)) {
          // TODO: Allow method of in-group editing without having to do
          // this (similar to editing rotated paths)
          // Ungroup and regroup
          pushGroupProperties(mouseTarget);
          mouseTarget = selectedElements[0];
          clearSelection(true);
        } // Reset context


        if (currentGroup) {
          leaveContext();
        }

        if (parent.tagName !== 'g' && parent.tagName !== 'a' || parent === getCurrentDrawing().getCurrentLayer() || mouseTarget === selectorManager.selectorParentGroup) {
          // Escape from in-group edit
          return;
        }

        setContext(mouseTarget);
      }; // prevent links from being followed in the canvas


      var handleLinkInCanvas = function handleLinkInCanvas(e) {
        e.preventDefault();
        return false;
      }; // Added mouseup to the container here.
      // TODO(codedread): Figure out why after the Closure compiler, the window mouseup is ignored.


      $$a(container).mousedown(mouseDown).mousemove(mouseMove).click(handleLinkInCanvas).dblclick(dblClick).mouseup(mouseUp); // $(window).mouseup(mouseUp);
      // TODO(rafaelcastrocouto): User preference for shift key and zoom factor

      $$a(container).bind('mousewheel DOMMouseScroll',
      /**
       * @param {Event} e
       * @fires module:svgcanvas.SvgCanvas#event:updateCanvas
       * @fires module:svgcanvas.SvgCanvas#event:zoomDone
       * @returns {void}
       */
      function (e) {
        if (!e.shiftKey) {
          return;
        }

        e.preventDefault();
        var evt = e.originalEvent;
        rootSctm = $$a('#svgcontent g')[0].getScreenCTM().inverse();
        var workarea = $$a('#workarea');
        var scrbar = 15;
        var rulerwidth = curConfig.showRulers ? 16 : 0; // mouse relative to content area in content pixels

        var pt = transformPoint(evt.pageX, evt.pageY, rootSctm); // full work area width in screen pixels

        var editorFullW = workarea.width();
        var editorFullH = workarea.height(); // work area width minus scroll and ruler in screen pixels

        var editorW = editorFullW - scrbar - rulerwidth;
        var editorH = editorFullH - scrbar - rulerwidth; // work area width in content pixels

        var workareaViewW = editorW * rootSctm.a;
        var workareaViewH = editorH * rootSctm.d; // content offset from canvas in screen pixels

        var wOffset = workarea.offset();
        var wOffsetLeft = wOffset.left + rulerwidth;
        var wOffsetTop = wOffset.top + rulerwidth;
        var delta = evt.wheelDelta ? evt.wheelDelta : evt.detail ? -evt.detail : 0;

        if (!delta) {
          return;
        }

        var factor = Math.max(3 / 4, Math.min(4 / 3, delta));
        var wZoom, hZoom;

        if (factor > 1) {
          wZoom = Math.ceil(editorW / workareaViewW * factor * 100) / 100;
          hZoom = Math.ceil(editorH / workareaViewH * factor * 100) / 100;
        } else {
          wZoom = Math.floor(editorW / workareaViewW * factor * 100) / 100;
          hZoom = Math.floor(editorH / workareaViewH * factor * 100) / 100;
        }

        var zoomlevel = Math.min(wZoom, hZoom);
        zoomlevel = Math.min(10, Math.max(0.01, zoomlevel));

        if (zoomlevel === currentZoom) {
          return;
        }

        factor = zoomlevel / currentZoom; // top left of workarea in content pixels before zoom

        var topLeftOld = transformPoint(wOffsetLeft, wOffsetTop, rootSctm); // top left of workarea in content pixels after zoom

        var topLeftNew = {
          x: pt.x - (pt.x - topLeftOld.x) / factor,
          y: pt.y - (pt.y - topLeftOld.y) / factor
        }; // top left of workarea in canvas pixels relative to content after zoom

        var topLeftNewCanvas = {
          x: topLeftNew.x * zoomlevel,
          y: topLeftNew.y * zoomlevel
        }; // new center in canvas pixels

        var newCtr = {
          x: topLeftNewCanvas.x - rulerwidth + editorFullW / 2,
          y: topLeftNewCanvas.y - rulerwidth + editorFullH / 2
        };
        canvas.setZoom(zoomlevel);
        $$a('#zoom').val((zoomlevel * 100).toFixed(1));
        call('updateCanvas', {
          center: false,
          newCtr: newCtr
        });
        call('zoomDone');
      });
    })();
    /* eslint-disable jsdoc/require-property */

    /**
    * Group: Text edit functions
    * Functions relating to editing text elements.
    * @namespace {PlainObject} textActions
    * @memberof module:svgcanvas.SvgCanvas#
    */


    var textActions = canvas.textActions = function () {
      /* eslint-enable jsdoc/require-property */
      var curtext;
      var textinput;
      var cursor;
      var selblock;
      var blinker;
      var chardata = [];
      var textbb; // , transbb;

      var matrix;
      var lastX, lastY;
      var allowDbl;
      /**
       *
       * @param {Integer} index
       * @returns {void}
       */

      function setCursor(index) {
        var empty = textinput.value === '';
        $$a(textinput).focus();

        if (!arguments.length) {
          if (empty) {
            index = 0;
          } else {
            if (textinput.selectionEnd !== textinput.selectionStart) {
              return;
            }

            index = textinput.selectionEnd;
          }
        }

        var charbb = chardata[index];

        if (!empty) {
          textinput.setSelectionRange(index, index);
        }

        cursor = getElem('text_cursor');

        if (!cursor) {
          cursor = document.createElementNS(NS.SVG, 'line');
          assignAttributes(cursor, {
            id: 'text_cursor',
            stroke: '#333',
            'stroke-width': 1
          });
          cursor = getElem('selectorParentGroup').appendChild(cursor);
        }

        if (!blinker) {
          blinker = setInterval(function () {
            var show = cursor.getAttribute('display') === 'none';
            cursor.setAttribute('display', show ? 'inline' : 'none');
          }, 600);
        }

        var startPt = ptToScreen(charbb.x, textbb.y);
        var endPt = ptToScreen(charbb.x, textbb.y + textbb.height);
        assignAttributes(cursor, {
          x1: startPt.x,
          y1: startPt.y,
          x2: endPt.x,
          y2: endPt.y,
          visibility: 'visible',
          display: 'inline'
        });

        if (selblock) {
          selblock.setAttribute('d', '');
        }
      }
      /**
       *
       * @param {Integer} start
       * @param {Integer} end
       * @param {boolean} skipInput
       * @returns {void}
       */


      function setSelection(start, end, skipInput) {
        if (start === end) {
          setCursor(end);
          return;
        }

        if (!skipInput) {
          textinput.setSelectionRange(start, end);
        }

        selblock = getElem('text_selectblock');

        if (!selblock) {
          selblock = document.createElementNS(NS.SVG, 'path');
          assignAttributes(selblock, {
            id: 'text_selectblock',
            fill: 'green',
            opacity: 0.5,
            style: 'pointer-events:none'
          });
          getElem('selectorParentGroup').append(selblock);
        }

        var startbb = chardata[start];
        var endbb = chardata[end];
        cursor.setAttribute('visibility', 'hidden');
        var tl = ptToScreen(startbb.x, textbb.y),
            tr = ptToScreen(startbb.x + (endbb.x - startbb.x), textbb.y),
            bl = ptToScreen(startbb.x, textbb.y + textbb.height),
            br = ptToScreen(startbb.x + (endbb.x - startbb.x), textbb.y + textbb.height);
        var dstr = 'M' + tl.x + ',' + tl.y + ' L' + tr.x + ',' + tr.y + ' ' + br.x + ',' + br.y + ' ' + bl.x + ',' + bl.y + 'z';
        assignAttributes(selblock, {
          d: dstr,
          display: 'inline'
        });
      }
      /**
       *
       * @param {Float} mouseX
       * @param {Float} mouseY
       * @returns {Integer}
       */


      function getIndexFromPoint(mouseX, mouseY) {
        // Position cursor here
        var pt = svgroot.createSVGPoint();
        pt.x = mouseX;
        pt.y = mouseY; // No content, so return 0

        if (chardata.length === 1) {
          return 0;
        } // Determine if cursor should be on left or right of character


        var charpos = curtext.getCharNumAtPosition(pt);

        if (charpos < 0) {
          // Out of text range, look at mouse coords
          charpos = chardata.length - 2;

          if (mouseX <= chardata[0].x) {
            charpos = 0;
          }
        } else if (charpos >= chardata.length - 2) {
          charpos = chardata.length - 2;
        }

        var charbb = chardata[charpos];
        var mid = charbb.x + charbb.width / 2;

        if (mouseX > mid) {
          charpos++;
        }

        return charpos;
      }
      /**
       *
       * @param {Float} mouseX
       * @param {Float} mouseY
       * @returns {void}
       */


      function setCursorFromPoint(mouseX, mouseY) {
        setCursor(getIndexFromPoint(mouseX, mouseY));
      }
      /**
       *
       * @param {Float} x
       * @param {Float} y
       * @param {boolean} apply
       * @returns {void}
       */


      function setEndSelectionFromPoint(x, y, apply) {
        var i1 = textinput.selectionStart;
        var i2 = getIndexFromPoint(x, y);
        var start = Math.min(i1, i2);
        var end = Math.max(i1, i2);
        setSelection(start, end, !apply);
      }
      /**
       *
       * @param {Float} xIn
       * @param {Float} yIn
       * @returns {module:math.XYObject}
       */


      function screenToPt(xIn, yIn) {
        var out = {
          x: xIn,
          y: yIn
        };
        out.x /= currentZoom;
        out.y /= currentZoom;

        if (matrix) {
          var pt = transformPoint(out.x, out.y, matrix.inverse());
          out.x = pt.x;
          out.y = pt.y;
        }

        return out;
      }
      /**
       *
       * @param {Float} xIn
       * @param {Float} yIn
       * @returns {module:math.XYObject}
       */


      function ptToScreen(xIn, yIn) {
        var out = {
          x: xIn,
          y: yIn
        };

        if (matrix) {
          var pt = transformPoint(out.x, out.y, matrix);
          out.x = pt.x;
          out.y = pt.y;
        }

        out.x *= currentZoom;
        out.y *= currentZoom;
        return out;
      }
      /*
      // Not currently in use
      function hideCursor () {
        if (cursor) {
          cursor.setAttribute('visibility', 'hidden');
        }
      }
      */

      /**
       *
       * @param {Event} evt
       * @returns {void}
       */


      function selectAll(evt) {
        setSelection(0, curtext.textContent.length);
        $$a(this).unbind(evt);
      }
      /**
       *
       * @param {Event} evt
       * @returns {void}
       */


      function selectWord(evt) {
        if (!allowDbl || !curtext) {
          return;
        }

        var ept = transformPoint(evt.pageX, evt.pageY, rootSctm),
            mouseX = ept.x * currentZoom,
            mouseY = ept.y * currentZoom;
        var pt = screenToPt(mouseX, mouseY);
        var index = getIndexFromPoint(pt.x, pt.y);
        var str = curtext.textContent;
        var first = str.substr(0, index).replace(/[a-z\d]+$/i, '').length;
        var m = str.substr(index).match(/^[a-z\d]+/i);
        var last = (m ? m[0].length : 0) + index;
        setSelection(first, last); // Set tripleclick

        $$a(evt.target).click(selectAll);
        setTimeout(function () {
          $$a(evt.target).unbind('click', selectAll);
        }, 300);
      }

      return (
        /** @lends module:svgcanvas.SvgCanvas#textActions */
        {
          /**
          * @param {Element} target
          * @param {Float} x
          * @param {Float} y
          * @returns {void}
          */
          select: function select(target, x, y) {
            curtext = target;
            textActions.toEditMode(x, y);
          },

          /**
          * @param {Element} elem
          * @returns {void}
          */
          start: function start(elem) {
            curtext = elem;
            textActions.toEditMode();
          },

          /**
          * @param {external:MouseEvent} evt
          * @param {Element} mouseTarget
          * @param {Float} startX
          * @param {Float} startY
          * @returns {void}
          */
          mouseDown: function mouseDown(evt, mouseTarget, startX, startY) {
            var pt = screenToPt(startX, startY);
            textinput.focus();
            setCursorFromPoint(pt.x, pt.y);
            lastX = startX;
            lastY = startY; // TODO: Find way to block native selection
          },

          /**
          * @param {Float} mouseX
          * @param {Float} mouseY
          * @returns {void}
          */
          mouseMove: function mouseMove(mouseX, mouseY) {
            var pt = screenToPt(mouseX, mouseY);
            setEndSelectionFromPoint(pt.x, pt.y);
          },

          /**
          * @param {external:MouseEvent} evt
          * @param {Float} mouseX
          * @param {Float} mouseY
          * @returns {void}
          */
          mouseUp: function mouseUp(evt, mouseX, mouseY) {
            var pt = screenToPt(mouseX, mouseY);
            setEndSelectionFromPoint(pt.x, pt.y, true); // TODO: Find a way to make this work: Use transformed BBox instead of evt.target
            // if (lastX === mouseX && lastY === mouseY
            //   && !rectsIntersect(transbb, {x: pt.x, y: pt.y, width: 0, height: 0})) {
            //   textActions.toSelectMode(true);
            // }

            if (evt.target !== curtext && mouseX < lastX + 2 && mouseX > lastX - 2 && mouseY < lastY + 2 && mouseY > lastY - 2) {
              textActions.toSelectMode(true);
            }
          },

          /**
          * @function
          * @param {Integer} index
          * @returns {void}
          */
          setCursor: setCursor,

          /**
          * @param {Float} x
          * @param {Float} y
          * @returns {void}
          */
          toEditMode: function toEditMode(x, y) {
            allowDbl = false;
            currentMode = 'textedit';
            selectorManager.requestSelector(curtext).showGrips(false); // Make selector group accept clicks

            /* const selector = */

            selectorManager.requestSelector(curtext); // Do we need this? Has side effect of setting lock, so keeping for now, but next line wasn't being used
            // const sel = selector.selectorRect;

            textActions.init();
            $$a(curtext).css('cursor', 'text'); // if (supportsEditableText()) {
            //   curtext.setAttribute('editable', 'simple');
            //   return;
            // }

            if (!arguments.length) {
              setCursor();
            } else {
              var pt = screenToPt(x, y);
              setCursorFromPoint(pt.x, pt.y);
            }

            setTimeout(function () {
              allowDbl = true;
            }, 300);
          },

          /**
          * @param {boolean|Element} selectElem
          * @fires module:svgcanvas.SvgCanvas#event:selected
          * @returns {void}
          */
          toSelectMode: function toSelectMode(selectElem) {
            currentMode = 'select';
            clearInterval(blinker);
            blinker = null;

            if (selblock) {
              $$a(selblock).attr('display', 'none');
            }

            if (cursor) {
              $$a(cursor).attr('visibility', 'hidden');
            }

            $$a(curtext).css('cursor', 'move');

            if (selectElem) {
              clearSelection();
              $$a(curtext).css('cursor', 'move');
              call('selected', [curtext]);
              addToSelection([curtext], true);
            }

            if (curtext && !curtext.textContent.length) {
              // No content, so delete
              canvas.deleteSelectedElements();
            }

            $$a(textinput).blur();
            curtext = false; // if (supportsEditableText()) {
            //   curtext.removeAttribute('editable');
            // }
          },

          /**
          * @param {Element} elem
          * @returns {void}
          */
          setInputElem: function setInputElem(elem) {
            textinput = elem; // $(textinput).blur(hideCursor);
          },

          /**
          * @returns {void}
          */
          clear: function clear() {
            if (currentMode === 'textedit') {
              textActions.toSelectMode();
            }
          },

          /**
          * @param {Element} inputElem Not in use
          * @returns {void}
          */
          init: function init(inputElem) {
            if (!curtext) {
              return;
            }

            var i, end; // if (supportsEditableText()) {
            //   curtext.select();
            //   return;
            // }

            if (!curtext.parentNode) {
              // Result of the ffClone, need to get correct element
              curtext = selectedElements[0];
              selectorManager.requestSelector(curtext).showGrips(false);
            }

            var str = curtext.textContent;
            var len = str.length;
            var xform = curtext.getAttribute('transform');
            textbb = getBBox(curtext);
            matrix = xform ? getMatrix(curtext) : null;
            chardata = [];
            chardata.length = len;
            textinput.focus();
            $$a(curtext).unbind('dblclick', selectWord).dblclick(selectWord);

            if (!len) {
              end = {
                x: textbb.x + textbb.width / 2,
                width: 0
              };
            }

            for (i = 0; i < len; i++) {
              var start = curtext.getStartPositionOfChar(i);
              end = curtext.getEndPositionOfChar(i);

              if (!supportsGoodTextCharPos()) {
                var offset = canvas.contentW * currentZoom;
                start.x -= offset;
                end.x -= offset;
                start.x /= currentZoom;
                end.x /= currentZoom;
              } // Get a "bbox" equivalent for each character. Uses the
              // bbox data of the actual text for y, height purposes
              // TODO: Decide if y, width and height are actually necessary


              chardata[i] = {
                x: start.x,
                y: textbb.y,
                // start.y?
                width: end.x - start.x,
                height: textbb.height
              };
            } // Add a last bbox for cursor at end of text


            chardata.push({
              x: end.x,
              width: 0
            });
            setSelection(textinput.selectionStart, textinput.selectionEnd, true);
          }
        }
      );
    }();
    /**
    * Group: Serialization.
    */

    /**
    * Looks at DOM elements inside the `<defs>` to see if they are referred to,
    * removes them from the DOM if they are not.
    * @function module:svgcanvas.SvgCanvas#removeUnusedDefElems
    * @returns {Integer} The number of elements that were removed
    */


    var removeUnusedDefElems = this.removeUnusedDefElems = function () {
      var defs = svgcontent.getElementsByTagNameNS(NS.SVG, 'defs');

      if (!defs || !defs.length) {
        return 0;
      } // if (!defs.firstChild) { return; }


      var defelemUses = [];
      var numRemoved = 0;
      var attrs = ['fill', 'stroke', 'filter', 'marker-start', 'marker-mid', 'marker-end'];
      var alen = attrs.length;
      var allEls = svgcontent.getElementsByTagNameNS(NS.SVG, '*');
      var allLen = allEls.length;
      var i, j;

      for (i = 0; i < allLen; i++) {
        var el = allEls[i];

        for (j = 0; j < alen; j++) {
          var ref = getUrlFromAttr(el.getAttribute(attrs[j]));

          if (ref) {
            defelemUses.push(ref.substr(1));
          }
        } // gradients can refer to other gradients


        var href = getHref(el);

        if (href && href.startsWith('#')) {
          defelemUses.push(href.substr(1));
        }
      }

      var defelems = $$a(defs).find('linearGradient, radialGradient, filter, marker, svg, symbol');
      i = defelems.length;

      while (i--) {
        var defelem = defelems[i];
        var id = defelem.id;

        if (!defelemUses.includes(id)) {
          // Not found, so remove (but remember)
          removedElements[id] = defelem;
          defelem.remove();
          numRemoved++;
        }
      }

      return numRemoved;
    };
    /**
    * Main function to set up the SVG content for output.
    * @function module:svgcanvas.SvgCanvas#svgCanvasToString
    * @returns {string} The SVG image for output
    */


    this.svgCanvasToString = function () {
      // keep calling it until there are none to remove
      while (removeUnusedDefElems() > 0) {} // eslint-disable-line no-empty


      pathActions$1.clear(true); // Keep SVG-Edit comment on top

      $$a.each(svgcontent.childNodes, function (i, node) {
        if (i && node.nodeType === 8 && node.data.includes('Created with')) {
          svgcontent.firstChild.before(node);
        }
      }); // Move out of in-group editing mode

      if (currentGroup) {
        leaveContext();
        selectOnly([currentGroup]);
      }

      var nakedSvgs = []; // Unwrap gsvg if it has no special attributes (only id and style)

      $$a(svgcontent).find('g:data(gsvg)').each(function () {
        var attrs = this.attributes;
        var len = attrs.length;

        for (var i = 0; i < len; i++) {
          if (attrs[i].nodeName === 'id' || attrs[i].nodeName === 'style') {
            len--;
          }
        } // No significant attributes, so ungroup


        if (len <= 0) {
          var svg = this.firstChild;
          nakedSvgs.push(svg);
          $$a(this).replaceWith(svg);
        }
      });
      var output = this.svgToString(svgcontent, 0); // Rewrap gsvg

      if (nakedSvgs.length) {
        $$a(nakedSvgs).each(function () {
          groupSvgElem(this);
        });
      }

      return output;
    };
    /**
    * Sub function ran on each SVG element to convert it to a string as desired.
    * @function module:svgcanvas.SvgCanvas#svgToString
    * @param {Element} elem - The SVG element to convert
    * @param {Integer} indent - Number of spaces to indent this tag
    * @returns {string} The given element as an SVG tag
    */


    this.svgToString = function (elem, indent) {
      var out = [];
      var unit = curConfig.baseUnit;
      var unitRe = new RegExp('^-?[\\d\\.]+' + unit + '$');

      if (elem) {
        cleanupElement(elem);

        var attrs = _toConsumableArray(elem.attributes);

        var childs = elem.childNodes;
        attrs.sort(function (a, b) {
          return a.name > b.name ? -1 : 1;
        });

        for (var i = 0; i < indent; i++) {
          out.push(' ');
        }

        out.push('<');
        out.push(elem.nodeName);

        if (elem.id === 'svgcontent') {
          // Process root element separately
          var res = getResolution();
          var vb = ''; // TODO: Allow this by dividing all values by current baseVal
          // Note that this also means we should properly deal with this on import
          // if (curConfig.baseUnit !== 'px') {
          //   const unit = curConfig.baseUnit;
          //   const unitM = getTypeMap()[unit];
          //   res.w = shortFloat(res.w / unitM);
          //   res.h = shortFloat(res.h / unitM);
          //   vb = ' viewBox="' + [0, 0, res.w, res.h].join(' ') + '"';
          //   res.w += unit;
          //   res.h += unit;
          // }

          if (unit !== 'px') {
            res.w = convertUnit(res.w, unit) + unit;
            res.h = convertUnit(res.h, unit) + unit;
          }

          out.push(' width="' + res.w + '" height="' + res.h + '"' + vb + ' xmlns="' + NS.SVG + '"');
          var nsuris = {}; // Check elements for namespaces, add if found

          $$a(elem).find('*').andSelf().each(function () {
            // const el = this;
            // for some elements have no attribute
            var uri = this.namespaceURI;

            if (uri && !nsuris[uri] && nsMap[uri] && nsMap[uri] !== 'xmlns' && nsMap[uri] !== 'xml') {
              nsuris[uri] = true;
              out.push(' xmlns:' + nsMap[uri] + '="' + uri + '"');
            }

            $$a.each(this.attributes, function (i, attr) {
              var u = attr.namespaceURI;

              if (u && !nsuris[u] && nsMap[u] !== 'xmlns' && nsMap[u] !== 'xml') {
                nsuris[u] = true;
                out.push(' xmlns:' + nsMap[u] + '="' + u + '"');
              }
            });
          });
          var _i2 = attrs.length;
          var attrNames = ['width', 'height', 'xmlns', 'x', 'y', 'viewBox', 'id', 'overflow'];

          while (_i2--) {
            var attr = attrs[_i2];
            var attrVal = toXml(attr.value); // Namespaces have already been dealt with, so skip

            if (attr.nodeName.startsWith('xmlns:')) {
              continue;
            } // only serialize attributes we don't use internally


            if (attrVal !== '' && !attrNames.includes(attr.localName)) {
              if (!attr.namespaceURI || nsMap[attr.namespaceURI]) {
                out.push(' ');
                out.push(attr.nodeName);
                out.push('="');
                out.push(attrVal);
                out.push('"');
              }
            }
          }
        } else {
          // Skip empty defs
          if (elem.nodeName === 'defs' && !elem.firstChild) {
            return '';
          }

          var mozAttrs = ['-moz-math-font-style', '_moz-math-font-style'];

          for (var _i3 = attrs.length - 1; _i3 >= 0; _i3--) {
            var _attr = attrs[_i3];

            var _attrVal = toXml(_attr.value); // remove bogus attributes added by Gecko


            if (mozAttrs.includes(_attr.localName)) {
              continue;
            }

            if (_attrVal === 'null') {
              var styleName = _attr.localName.replace(/-[a-z]/g, function (s) {
                return s[1].toUpperCase();
              });

              if (Object.prototype.hasOwnProperty.call(elem.style, styleName)) {
                continue;
              }
            }

            if (_attrVal !== '') {
              if (_attrVal.startsWith('pointer-events')) {
                continue;
              }

              if (_attr.localName === 'class' && _attrVal.startsWith('se_')) {
                continue;
              }

              out.push(' ');

              if (_attr.localName === 'd') {
                _attrVal = pathActions$1.convertPath(elem, true);
              }

              if (!isNaN(_attrVal)) {
                _attrVal = shortFloat(_attrVal);
              } else if (unitRe.test(_attrVal)) {
                _attrVal = shortFloat(_attrVal) + unit;
              } // Embed images when saving


              if (saveOptions.apply && elem.nodeName === 'image' && _attr.localName === 'href' && saveOptions.images && saveOptions.images === 'embed') {
                var img = encodableImages[_attrVal];

                if (img) {
                  _attrVal = img;
                }
              } // map various namespaces to our fixed namespace prefixes
              // (the default xmlns attribute itself does not get a prefix)


              if (!_attr.namespaceURI || _attr.namespaceURI === NS.SVG || nsMap[_attr.namespaceURI]) {
                out.push(_attr.nodeName);
                out.push('="');
                out.push(_attrVal);
                out.push('"');
              }
            }
          }
        }

        if (elem.hasChildNodes()) {
          out.push('>');
          indent++;
          var bOneLine = false;

          for (var _i4 = 0; _i4 < childs.length; _i4++) {
            var child = childs.item(_i4);

            switch (child.nodeType) {
              case 1:
                // element node
                out.push('\n');
                out.push(this.svgToString(child, indent));
                break;

              case 3:
                {
                  // text node
                  var str = child.nodeValue.replace(/^\s+|\s+$/g, '');

                  if (str !== '') {
                    bOneLine = true;
                    out.push(String(toXml(str)));
                  }

                  break;
                }

              case 4:
                // cdata node
                out.push('\n');
                out.push(new Array(indent + 1).join(' '));
                out.push('<![CDATA[');
                out.push(child.nodeValue);
                out.push(']]>');
                break;

              case 8:
                // comment
                out.push('\n');
                out.push(new Array(indent + 1).join(' '));
                out.push('<!--');
                out.push(child.data);
                out.push('-->');
                break;
            } // switch on node type

          }

          indent--;

          if (!bOneLine) {
            out.push('\n');

            for (var _i5 = 0; _i5 < indent; _i5++) {
              out.push(' ');
            }
          }

          out.push('</');
          out.push(elem.nodeName);
          out.push('>');
        } else {
          out.push('/>');
        }
      }

      return out.join('');
    }; // end svgToString()

    /**
     * Function to run when image data is found.
     * @callback module:svgcanvas.ImageEmbeddedCallback
     * @param {string|false} result Data URL
     * @returns {void}
     */

    /**
    * Converts a given image file to a data URL when possible, then runs a given callback.
    * @function module:svgcanvas.SvgCanvas#embedImage
    * @param {string} src - The path/URL of the image
    * @returns {Promise<string|false>} Resolves to a Data URL (string|false)
    */


    this.embedImage = function (src) {
      // Todo: Remove this Promise in favor of making an async/await `Image.load` utility
      // eslint-disable-next-line promise/avoid-new
      return new Promise(function (resolve, reject) {
        // load in the image and once it's loaded, get the dimensions
        $$a(new Image()).load(function (response, status, xhr) {
          if (status === 'error') {
            reject(new Error('Error loading image: ' + xhr.status + ' ' + xhr.statusText));
            return;
          } // create a canvas the same size as the raster image


          var cvs = document.createElement('canvas');
          cvs.width = this.width;
          cvs.height = this.height; // load the raster image into the canvas

          cvs.getContext('2d').drawImage(this, 0, 0); // retrieve the data: URL

          try {
            var urldata = ';svgedit_url=' + encodeURIComponent(src);
            urldata = cvs.toDataURL().replace(';base64', urldata + ';base64');
            encodableImages[src] = urldata;
          } catch (e) {
            encodableImages[src] = false;
          }

          lastGoodImgUrl = src;
          resolve(encodableImages[src]);
        }).attr('src', src);
      });
    };
    /**
    * Sets a given URL to be a "last good image" URL.
    * @function module:svgcanvas.SvgCanvas#setGoodImage
    * @param {string} val
    * @returns {void}
    */


    this.setGoodImage = function (val) {
      lastGoodImgUrl = val;
    };
    /**
    * Does nothing by default, handled by optional widget/extension.
    * @function module:svgcanvas.SvgCanvas#open
    * @returns {void}
    */


    this.open = function () {
      /* */
    };
    /**
    * Serializes the current drawing into SVG XML text and passes it to the 'saved' handler.
    * This function also includes the XML prolog. Clients of the `SvgCanvas` bind their save
    * function to the 'saved' event.
    * @function module:svgcanvas.SvgCanvas#save
    * @param {module:svgcanvas.SaveOptions} opts
    * @fires module:svgcanvas.SvgCanvas#event:saved
    * @returns {void}
    */


    this.save = function (opts) {
      // remove the selected outline before serializing
      clearSelection(); // Update save options if provided

      if (opts) {
        $$a.extend(saveOptions, opts);
      }

      saveOptions.apply = true; // no need for doctype, see https://jwatt.org/svg/authoring/#doctype-declaration

      var str = this.svgCanvasToString();
      call('saved', str);
    };
    /**
    * @typedef {PlainObject} module:svgcanvas.IssuesAndCodes
    * @property {string[]} issueCodes The locale-independent code names
    * @property {string[]} issues The localized descriptions
    */

    /**
    * Codes only is useful for locale-independent detection.
    * @returns {module:svgcanvas.IssuesAndCodes}
    */


    function getIssues() {
      // remove the selected outline before serializing
      clearSelection(); // Check for known CanVG issues

      var issues = [];
      var issueCodes = []; // Selector and notice

      var issueList = {
        feGaussianBlur: uiStrings.exportNoBlur,
        foreignObject: uiStrings.exportNoforeignObject,
        '[stroke-dasharray]': uiStrings.exportNoDashArray
      };
      var content = $$a(svgcontent); // Add font/text check if Canvas Text API is not implemented

      if (!('font' in $$a('<canvas>')[0].getContext('2d'))) {
        issueList.text = uiStrings.exportNoText;
      }

      $$a.each(issueList, function (sel, descr) {
        if (content.find(sel).length) {
          issueCodes.push(sel);
          issues.push(descr);
        }
      });
      return {
        issues: issues,
        issueCodes: issueCodes
      };
    }

    var canvg;
    /**
    * @typedef {"feGaussianBlur"|"foreignObject"|"[stroke-dasharray]"|"text"} module:svgcanvas.IssueCode
    */

    /**
    * @typedef {PlainObject} module:svgcanvas.ImageExportedResults
    * @property {string} datauri Contents as a Data URL
    * @property {string} bloburl May be the empty string
    * @property {string} svg The SVG contents as a string
    * @property {string[]} issues The localization messages of `issueCodes`
    * @property {module:svgcanvas.IssueCode[]} issueCodes CanVG issues found with the SVG
    * @property {"PNG"|"JPEG"|"BMP"|"WEBP"|"ICO"} type The chosen image type
    * @property {"image/png"|"image/jpeg"|"image/bmp"|"image/webp"} mimeType The image MIME type
    * @property {Float} quality A decimal between 0 and 1 (for use with JPEG or WEBP)
    * @property {string} exportWindowName A convenience for passing along a `window.name` to target a window on which the export could be added
    */

    /**
    * Generates a PNG (or JPG, BMP, WEBP) Data URL based on the current image,
    * then calls "exported" with an object including the string, image
    * information, and any issues found.
    * @function module:svgcanvas.SvgCanvas#rasterExport
    * @param {"PNG"|"JPEG"|"BMP"|"WEBP"|"ICO"} [imgType="PNG"]
    * @param {Float} [quality] Between 0 and 1
    * @param {string} [exportWindowName]
    * @param {PlainObject} [opts]
    * @param {boolean} [opts.avoidEvent]
    * @fires module:svgcanvas.SvgCanvas#event:exported
    * @todo Confirm/fix ICO type
    * @returns {Promise<module:svgcanvas.ImageExportedResults>} Resolves to {@link module:svgcanvas.ImageExportedResults}
    */

    this.rasterExport = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(imgType, quality, exportWindowName) {
        var opts,
            type,
            mimeType,
            _getIssues,
            issues,
            issueCodes,
            svg,
            _yield$import$default,
            c,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};
                type = imgType === 'ICO' ? 'BMP' : imgType || 'PNG';
                mimeType = 'image/' + type.toLowerCase();
                _getIssues = getIssues(), issues = _getIssues.issues, issueCodes = _getIssues.issueCodes;
                svg = this.svgCanvasToString();

                if (canvg) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 8;
                return import(curConfig.canvgPath + 'canvg.js')["default"];

              case 8:
                _yield$import$default = _context2.sent;
                canvg = _yield$import$default.canvg;

              case 10:
                if (!$$a('#export_canvas').length) {
                  $$a('<canvas>', {
                    id: 'export_canvas'
                  }).hide().appendTo('body');
                }

                c = $$a('#export_canvas')[0];
                c.width = canvas.contentW;
                c.height = canvas.contentH;
                _context2.next = 16;
                return canvg(c, svg);

              case 16:
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  var dataURLType = type.toLowerCase();
                  var datauri = quality ? c.toDataURL('image/' + dataURLType, quality) : c.toDataURL('image/' + dataURLType);
                  var bloburl;
                  /**
                   * Called when `bloburl` is available for export.
                   * @returns {void}
                   */

                  function done() {
                    var obj = {
                      datauri: datauri,
                      bloburl: bloburl,
                      svg: svg,
                      issues: issues,
                      issueCodes: issueCodes,
                      type: imgType,
                      mimeType: mimeType,
                      quality: quality,
                      exportWindowName: exportWindowName
                    };

                    if (!opts.avoidEvent) {
                      call('exported', obj);
                    }

                    resolve(obj);
                  }

                  if (c.toBlob) {
                    c.toBlob(function (blob) {
                      bloburl = createObjectURL(blob);
                      done();
                    }, mimeType, quality);
                    return;
                  }

                  bloburl = dataURLToObjectURL(datauri);
                  done();
                }));

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function (_x4, _x5, _x6) {
        return _ref5.apply(this, arguments);
      };
    }();
    /**
     * @external jsPDF
     */

    /**
     * @typedef {void|"save"|"arraybuffer"|"blob"|"datauristring"|"dataurlstring"|"dataurlnewwindow"|"datauri"|"dataurl"} external:jsPDF.OutputType
     * @todo Newer version to add also allows these `outputType` values "bloburi"|"bloburl" which return strings, so document here and for `outputType` of `module:svgcanvas.PDFExportedResults` below if added
    */

    /**
    * @typedef {PlainObject} module:svgcanvas.PDFExportedResults
    * @property {string} svg The SVG PDF output
    * @property {string|ArrayBuffer|Blob|window} output The output based on the `outputType`;
    * if `undefined`, "datauristring", "dataurlstring", "datauri",
    * or "dataurl", will be a string (`undefined` gives a document, while the others
    * build as Data URLs; "datauri" and "dataurl" change the location of the current page); if
    * "arraybuffer", will return `ArrayBuffer`; if "blob", returns a `Blob`;
    * if "dataurlnewwindow", will change the current page's location and return a string
    * if in Safari and no window object is found; otherwise opens in, and returns, a new `window`
    * object; if "save", will have the same return as "dataurlnewwindow" if
    * `navigator.getUserMedia` support is found without `URL.createObjectURL` support; otherwise
    * returns `undefined` but attempts to save
    * @property {external:jsPDF.OutputType} outputType
    * @property {string[]} issues The human-readable localization messages of corresponding `issueCodes`
    * @property {module:svgcanvas.IssueCode[]} issueCodes
    * @property {string} exportWindowName
    */

    /**
    * Generates a PDF based on the current image, then calls "exportedPDF" with
    * an object including the string, the data URL, and any issues found.
    * @function module:svgcanvas.SvgCanvas#exportPDF
    * @param {string} [exportWindowName] Will also be used for the download file name here
    * @param {external:jsPDF.OutputType} [outputType="dataurlstring"]
    * @fires module:svgcanvas.SvgCanvas#event:exportedPDF
    * @returns {Promise<module:svgcanvas.PDFExportedResults>} Resolves to {@link module:svgcanvas.PDFExportedResults}
    */


    this.exportPDF = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(exportWindowName) {
        var outputType,
            res,
            orientation,
            unit,
            doc,
            docTitle,
            _getIssues2,
            issues,
            issueCodes,
            svg,
            obj,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                outputType = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : isChrome() ? 'save' : undefined;

                if (window.jsPDF) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 4;
                return Promise.resolve().then(function () { return underscoreMin$1; });

              case 4:
                _context3.next = 6;
                return Promise.resolve().then(function () { return jspdf_min$1; });

              case 6:
                _context3.next = 8;
                return Promise.resolve().then(function () { return jspdf_plugin_svgToPdf; });

              case 8:
                res = getResolution();
                orientation = res.w > res.h ? 'landscape' : 'portrait';
                unit = 'pt'; // curConfig.baseUnit; // We could use baseUnit, but that is presumably not intended for export purposes
                // Todo: Give options to use predefined jsPDF formats like "a4", etc. from pull-down (with option to keep customizable)

                doc = jsPDF({
                  orientation: orientation,
                  unit: unit,
                  format: [res.w, res.h] // , compressPdf: true

                });
                docTitle = getDocumentTitle();
                doc.setProperties({
                  title: docTitle
                  /* ,
                  subject: '',
                  author: '',
                  keywords: '',
                  creator: '' */

                });
                _getIssues2 = getIssues(), issues = _getIssues2.issues, issueCodes = _getIssues2.issueCodes;
                svg = this.svgCanvasToString();
                doc.addSVG(svg, 0, 0); // doc.output('save'); // Works to open in a new
                //  window; todo: configure this and other export
                //  options to optionally work in this manner as
                //  opposed to opening a new tab

                outputType = outputType || 'dataurlstring';
                obj = {
                  svg: svg,
                  issues: issues,
                  issueCodes: issueCodes,
                  exportWindowName: exportWindowName,
                  outputType: outputType
                };
                obj.output = doc.output(outputType, outputType === 'save' ? exportWindowName || 'svg.pdf' : undefined);
                call('exportedPDF', obj);
                return _context3.abrupt("return", obj);

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function (_x7) {
        return _ref6.apply(this, arguments);
      };
    }();
    /**
    * Returns the current drawing as raw SVG XML text.
    * @function module:svgcanvas.SvgCanvas#getSvgString
    * @returns {string} The current drawing as raw SVG XML text.
    */


    this.getSvgString = function () {
      saveOptions.apply = false;
      return this.svgCanvasToString();
    };
    /**
    * This function determines whether to use a nonce in the prefix, when
    * generating IDs for future documents in SVG-Edit.
    * If you're controlling SVG-Edit externally, and want randomized IDs, call
    * this BEFORE calling `svgCanvas.setSvgString`.
    * @function module:svgcanvas.SvgCanvas#randomizeIds
    * @param {boolean} [enableRandomization] If true, adds a nonce to the prefix. Thus
    * `svgCanvas.randomizeIds() <==> svgCanvas.randomizeIds(true)`
    * @returns {void}
    */


    this.randomizeIds = function (enableRandomization) {
      if (arguments.length > 0 && enableRandomization === false) {
        randomizeIds(false, getCurrentDrawing());
      } else {
        randomizeIds(true, getCurrentDrawing());
      }
    };
    /**
    * Ensure each element has a unique ID.
    * @function module:svgcanvas.SvgCanvas#uniquifyElems
    * @param {Element} g - The parent element of the tree to give unique IDs
    * @returns {void}
    */


    var uniquifyElems = this.uniquifyElems = function (g) {
      var ids = {}; // TODO: Handle markers and connectors. These are not yet re-identified properly
      // as their referring elements do not get remapped.
      //
      // <marker id='se_marker_end_svg_7'/>
      // <polyline id='svg_7' se:connector='svg_1 svg_6' marker-end='url(#se_marker_end_svg_7)'/>
      //
      // Problem #1: if svg_1 gets renamed, we do not update the polyline's se:connector attribute
      // Problem #2: if the polyline svg_7 gets renamed, we do not update the marker id nor the polyline's marker-end attribute

      var refElems = ['filter', 'linearGradient', 'pattern', 'radialGradient', 'symbol', 'textPath', 'use'];
      walkTree(g, function (n) {
        // if it's an element node
        if (n.nodeType === 1) {
          // and the element has an ID
          if (n.id) {
            // and we haven't tracked this ID yet
            if (!(n.id in ids)) {
              // add this id to our map
              ids[n.id] = {
                elem: null,
                attrs: [],
                hrefs: []
              };
            }

            ids[n.id].elem = n;
          } // now search for all attributes on this element that might refer
          // to other elements


          $$a.each(refAttrs, function (i, attr) {
            var attrnode = n.getAttributeNode(attr);

            if (attrnode) {
              // the incoming file has been sanitized, so we should be able to safely just strip off the leading #
              var url = getUrlFromAttr(attrnode.value),
                  refid = url ? url.substr(1) : null;

              if (refid) {
                if (!(refid in ids)) {
                  // add this id to our map
                  ids[refid] = {
                    elem: null,
                    attrs: [],
                    hrefs: []
                  };
                }

                ids[refid].attrs.push(attrnode);
              }
            }
          }); // check xlink:href now

          var href = getHref(n); // TODO: what if an <image> or <a> element refers to an element internally?

          if (href && refElems.includes(n.nodeName)) {
            var refid = href.substr(1);

            if (refid) {
              if (!(refid in ids)) {
                // add this id to our map
                ids[refid] = {
                  elem: null,
                  attrs: [],
                  hrefs: []
                };
              }

              ids[refid].hrefs.push(n);
            }
          }
        }
      }); // in ids, we now have a map of ids, elements and attributes, let's re-identify

      for (var oldid in ids) {
        if (!oldid) {
          continue;
        }

        var elem = ids[oldid].elem;

        if (elem) {
          var newid = getNextId(); // assign element its new id

          elem.id = newid; // remap all url() attributes

          var attrs = ids[oldid].attrs;
          var j = attrs.length;

          while (j--) {
            var attr = attrs[j];
            attr.ownerElement.setAttribute(attr.name, 'url(#' + newid + ')');
          } // remap all href attributes


          var hreffers = ids[oldid].hrefs;
          var k = hreffers.length;

          while (k--) {
            var hreffer = hreffers[k];
            setHref(hreffer, '#' + newid);
          }
        }
      }
    };
    /**
    * Assigns reference data for each use element.
    * @function module:svgcanvas.SvgCanvas#setUseData
    * @param {Element} parent
    * @returns {void}
    */


    var setUseData = this.setUseData = function (parent) {
      var elems = $$a(parent);

      if (parent.tagName !== 'use') {
        elems = elems.find('use');
      }

      elems.each(function () {
        var id = getHref(this).substr(1);
        var refElem = getElem(id);

        if (!refElem) {
          return;
        }

        $$a(this).data('ref', refElem);

        if (refElem.tagName === 'symbol' || refElem.tagName === 'svg') {
          $$a(this).data('symbol', refElem).data('ref', refElem);
        }
      });
    };
    /**
    * Converts gradients from userSpaceOnUse to objectBoundingBox.
    * @function module:svgcanvas.SvgCanvas#convertGradients
    * @param {Element} elem
    * @returns {void}
    */


    var convertGradients = this.convertGradients = function (elem) {
      var elems = $$a(elem).find('linearGradient, radialGradient');

      if (!elems.length && isWebkit()) {
        // Bug in webkit prevents regular *Gradient selector search
        elems = $$a(elem).find('*').filter(function () {
          return this.tagName.includes('Gradient');
        });
      }

      elems.each(function () {
        var grad = this;

        if ($$a(grad).attr('gradientUnits') === 'userSpaceOnUse') {
          // TODO: Support more than one element with this ref by duplicating parent grad
          var fillStrokeElems = $$a(svgcontent).find('[fill="url(#' + grad.id + ')"],[stroke="url(#' + grad.id + ')"]');

          if (!fillStrokeElems.length) {
            return;
          } // get object's bounding box


          var bb = getBBox(fillStrokeElems[0]); // This will occur if the element is inside a <defs> or a <symbol>,
          // in which we shouldn't need to convert anyway.

          if (!bb) {
            return;
          }

          if (grad.tagName === 'linearGradient') {
            var gCoords = $$a(grad).attr(['x1', 'y1', 'x2', 'y2']); // If has transform, convert

            var tlist = grad.gradientTransform.baseVal;

            if (tlist && tlist.numberOfItems > 0) {
              var m = transformListToTransform(tlist).matrix;
              var pt1 = transformPoint(gCoords.x1, gCoords.y1, m);
              var pt2 = transformPoint(gCoords.x2, gCoords.y2, m);
              gCoords.x1 = pt1.x;
              gCoords.y1 = pt1.y;
              gCoords.x2 = pt2.x;
              gCoords.y2 = pt2.y;
              grad.removeAttribute('gradientTransform');
            }

            $$a(grad).attr({
              x1: (gCoords.x1 - bb.x) / bb.width,
              y1: (gCoords.y1 - bb.y) / bb.height,
              x2: (gCoords.x2 - bb.x) / bb.width,
              y2: (gCoords.y2 - bb.y) / bb.height
            });
            grad.removeAttribute('gradientUnits');
          } // else {
          //   Note: radialGradient elements cannot be easily converted
          //   because userSpaceOnUse will keep circular gradients, while
          //   objectBoundingBox will x/y scale the gradient according to
          //   its bbox.
          //
          //   For now we'll do nothing, though we should probably have
          //   the gradient be updated as the element is moved, as
          //   inkscape/illustrator do.
          //
          //   const gCoords = $(grad).attr(['cx', 'cy', 'r']);
          //
          //   $(grad).attr({
          //     cx: (gCoords.cx - bb.x) / bb.width,
          //     cy: (gCoords.cy - bb.y) / bb.height,
          //     r: gCoords.r
          //   });
          //
          //   grad.removeAttribute('gradientUnits');
          // }

        }
      });
    };
    /**
    * Converts selected/given `<use>` or child SVG element to a group.
    * @function module:svgcanvas.SvgCanvas#convertToGroup
    * @param {Element} elem
    * @fires module:svgcanvas.SvgCanvas#event:selected
    * @returns {void}
    */


    var convertToGroup = this.convertToGroup = function (elem) {
      if (!elem) {
        elem = selectedElements[0];
      }

      var $elem = $$a(elem);
      var batchCmd = new BatchCommand$1();
      var ts;

      if ($elem.data('gsvg')) {
        // Use the gsvg as the new group
        var svg = elem.firstChild;
        var pt = $$a(svg).attr(['x', 'y']);
        $$a(elem.firstChild.firstChild).unwrap();
        $$a(elem).removeData('gsvg');
        var tlist = getTransformList(elem);
        var xform = svgroot.createSVGTransform();
        xform.setTranslate(pt.x, pt.y);
        tlist.appendItem(xform);
        recalculateDimensions(elem);
        call('selected', [elem]);
      } else if ($elem.data('symbol')) {
        elem = $elem.data('symbol');
        ts = $elem.attr('transform');
        var pos = $elem.attr(['x', 'y']);
        var vb = elem.getAttribute('viewBox');

        if (vb) {
          var nums = vb.split(' ');
          pos.x -= Number(nums[0]);
          pos.y -= Number(nums[1]);
        } // Not ideal, but works


        ts += ' translate(' + (pos.x || 0) + ',' + (pos.y || 0) + ')';
        var prev = $elem.prev(); // Remove <use> element

        batchCmd.addSubCommand(new RemoveElementCommand$1($elem[0], $elem[0].nextSibling, $elem[0].parentNode));
        $elem.remove(); // See if other elements reference this symbol

        var hasMore = $$a(svgcontent).find('use:data(symbol)').length;
        var g = svgdoc.createElementNS(NS.SVG, 'g');
        var childs = elem.childNodes;
        var i;

        for (i = 0; i < childs.length; i++) {
          g.append(childs[i].cloneNode(true));
        } // Duplicate the gradients for Gecko, since they weren't included in the <symbol>


        if (isGecko()) {
          var dupeGrads = $$a(findDefs()).children('linearGradient,radialGradient,pattern').clone();
          $$a(g).append(dupeGrads);
        }

        if (ts) {
          g.setAttribute('transform', ts);
        }

        var parent = elem.parentNode;
        uniquifyElems(g); // Put the dupe gradients back into <defs> (after uniquifying them)

        if (isGecko()) {
          $$a(findDefs()).append($$a(g).find('linearGradient,radialGradient,pattern'));
        } // now give the g itself a new id


        g.id = getNextId();
        prev.after(g);

        if (parent) {
          if (!hasMore) {
            // remove symbol/svg element
            var _elem = elem,
                nextSibling = _elem.nextSibling;
            elem.remove();
            batchCmd.addSubCommand(new RemoveElementCommand$1(elem, nextSibling, parent));
          }

          batchCmd.addSubCommand(new InsertElementCommand$1(g));
        }

        setUseData(g);

        if (isGecko()) {
          convertGradients(findDefs());
        } else {
          convertGradients(g);
        } // recalculate dimensions on the top-level children so that unnecessary transforms
        // are removed


        walkTreePost(g, function (n) {
          try {
            recalculateDimensions(n);
          } catch (e) {
            console.log(e); // eslint-disable-line no-console
          }
        }); // Give ID for any visible element missing one

        $$a(g).find(visElems).each(function () {
          if (!this.id) {
            this.id = getNextId();
          }
        });
        selectOnly([g]);
        var cm = pushGroupProperties(g, true);

        if (cm) {
          batchCmd.addSubCommand(cm);
        }

        addCommandToHistory(batchCmd);
      } else {
        console.log('Unexpected element to ungroup:', elem); // eslint-disable-line no-console
      }
    };
    /**
    * This function sets the current drawing as the input SVG XML.
    * @function module:svgcanvas.SvgCanvas#setSvgString
    * @param {string} xmlString - The SVG as XML text.
    * @param {boolean} [preventUndo=false] - Indicates if we want to do the
    * changes without adding them to the undo stack - e.g. for initializing a
    * drawing on page load.
    * @fires module:svgcanvas.SvgCanvas#event:setnonce
    * @fires module:svgcanvas.SvgCanvas#event:unsetnonce
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {boolean} This function returns `false` if the set was
    *     unsuccessful, `true` otherwise.
    */


    this.setSvgString = function (xmlString, preventUndo) {
      try {
        // convert string into XML document
        var newDoc = text2xml(xmlString);

        if (newDoc.firstElementChild && newDoc.firstElementChild.namespaceURI !== NS.SVG) {
          return false;
        }

        this.prepareSvg(newDoc);
        var batchCmd = new BatchCommand$1('Change Source'); // remove old svg document

        var _svgcontent = svgcontent,
            nextSibling = _svgcontent.nextSibling;
        svgcontent.remove();
        var oldzoom = svgcontent;
        batchCmd.addSubCommand(new RemoveElementCommand$1(oldzoom, nextSibling, svgroot)); // set new svg document
        // If DOM3 adoptNode() available, use it. Otherwise fall back to DOM2 importNode()

        if (svgdoc.adoptNode) {
          svgcontent = svgdoc.adoptNode(newDoc.documentElement);
        } else {
          svgcontent = svgdoc.importNode(newDoc.documentElement, true);
        }

        svgroot.append(svgcontent);
        var content = $$a(svgcontent);
        canvas.current_drawing_ = new Drawing(svgcontent, idprefix); // retrieve or set the nonce

        var nonce = getCurrentDrawing().getNonce();

        if (nonce) {
          call('setnonce', nonce);
        } else {
          call('unsetnonce');
        } // change image href vals if possible


        content.find('image').each(function () {
          var image = this;
          preventClickDefault(image);
          var val = getHref(this);

          if (val) {
            if (val.startsWith('data:')) {
              // Check if an SVG-edit data URI
              var m = val.match(/svgedit_url=(.*?);/); // const m = val.match(/svgedit_url=(?<url>.*?);/);

              if (m) {
                var url = decodeURIComponent(m[1]); // const url = decodeURIComponent(m.groups.url);

                $$a(new Image()).load(function () {
                  image.setAttributeNS(NS.XLINK, 'xlink:href', url);
                }).attr('src', url);
              }
            } // Add to encodableImages if it loads


            canvas.embedImage(val);
          }
        }); // Wrap child SVGs in group elements

        content.find('svg').each(function () {
          // Skip if it's in a <defs>
          if ($$a(this).closest('defs').length) {
            return;
          }

          uniquifyElems(this); // Check if it already has a gsvg group

          var pa = this.parentNode;

          if (pa.childNodes.length === 1 && pa.nodeName === 'g') {
            $$a(pa).data('gsvg', this);
            pa.id = pa.id || getNextId();
          } else {
            groupSvgElem(this);
          }
        }); // For Firefox: Put all paint elems in defs

        if (isGecko()) {
          content.find('linearGradient, radialGradient, pattern').appendTo(findDefs());
        } // Set ref element for <use> elements
        // TODO: This should also be done if the object is re-added through "redo"


        setUseData(content);
        convertGradients(content[0]);
        var attrs = {
          id: 'svgcontent',
          overflow: curConfig.show_outside_canvas ? 'visible' : 'hidden'
        };
        var percs = false; // determine proper size

        if (content.attr('viewBox')) {
          var vb = content.attr('viewBox').split(' ');
          attrs.width = vb[2];
          attrs.height = vb[3]; // handle content that doesn't have a viewBox
        } else {
          $$a.each(['width', 'height'], function (i, dim) {
            // Set to 100 if not given
            var val = content.attr(dim) || '100%';

            if (String(val).substr(-1) === '%') {
              // Use user units if percentage given
              percs = true;
            } else {
              attrs[dim] = convertToNum(dim, val);
            }
          });
        } // identify layers


        identifyLayers(); // Give ID for any visible layer children missing one

        content.children().find(visElems).each(function () {
          if (!this.id) {
            this.id = getNextId();
          }
        }); // Percentage width/height, so let's base it on visible elements

        if (percs) {
          var bb = getStrokedBBoxDefaultVisible();
          attrs.width = bb.width + bb.x;
          attrs.height = bb.height + bb.y;
        } // Just in case negative numbers are given or
        // result from the percs calculation


        if (attrs.width <= 0) {
          attrs.width = 100;
        }

        if (attrs.height <= 0) {
          attrs.height = 100;
        }

        content.attr(attrs);
        this.contentW = attrs.width;
        this.contentH = attrs.height;
        batchCmd.addSubCommand(new InsertElementCommand$1(svgcontent)); // update root to the correct size

        var changes = content.attr(['width', 'height']);
        batchCmd.addSubCommand(new ChangeElementCommand$1(svgroot, changes)); // reset zoom

        currentZoom = 1; // reset transform lists

        resetListMap();
        clearSelection();
        clearData();
        svgroot.append(selectorManager.selectorParentGroup);
        if (!preventUndo) addCommandToHistory(batchCmd);
        call('changed', [svgcontent]);
      } catch (e) {
        console.log(e); // eslint-disable-line no-console

        return false;
      }

      return true;
    };
    /**
    * This function imports the input SVG XML as a `<symbol>` in the `<defs>`, then adds a
    * `<use>` to the current layer.
    * @function module:svgcanvas.SvgCanvas#importSvgString
    * @param {string} xmlString - The SVG as XML text.
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {null|Element} This function returns null if the import was unsuccessful, or the element otherwise.
    * @todo
    * - properly handle if namespace is introduced by imported content (must add to svgcontent
    * and update all prefixes in the imported node)
    * - properly handle recalculating dimensions, `recalculateDimensions()` doesn't handle
    * arbitrary transform lists, but makes some assumptions about how the transform list
    * was obtained
    */


    this.importSvgString = function (xmlString) {
      var j, ts, useEl;

      try {
        // Get unique ID
        var uid = encode64(xmlString.length + xmlString).substr(0, 32);
        var useExisting = false; // Look for symbol and make sure symbol exists in image

        if (importIds[uid]) {
          if ($$a(importIds[uid].symbol).parents('#svgroot').length) {
            useExisting = true;
          }
        }

        var batchCmd = new BatchCommand$1('Import Image');
        var symbol;

        if (useExisting) {
          symbol = importIds[uid].symbol;
          ts = importIds[uid].xform;
        } else {
          // convert string into XML document
          var newDoc = text2xml(xmlString);
          this.prepareSvg(newDoc); // import new svg document into our document

          var svg; // If DOM3 adoptNode() available, use it. Otherwise fall back to DOM2 importNode()

          if (svgdoc.adoptNode) {
            svg = svgdoc.adoptNode(newDoc.documentElement);
          } else {
            svg = svgdoc.importNode(newDoc.documentElement, true);
          }

          uniquifyElems(svg);
          var innerw = convertToNum('width', svg.getAttribute('width')),
              innerh = convertToNum('height', svg.getAttribute('height')),
              innervb = svg.getAttribute('viewBox'),
              // if no explicit viewbox, create one out of the width and height
          vb = innervb ? innervb.split(' ') : [0, 0, innerw, innerh];

          for (j = 0; j < 4; ++j) {
            vb[j] = Number(vb[j]);
          } // TODO: properly handle preserveAspectRatio


          var // canvasw = +svgcontent.getAttribute('width'),
          canvash = Number(svgcontent.getAttribute('height')); // imported content should be 1/3 of the canvas on its largest dimension

          if (innerh > innerw) {
            ts = 'scale(' + canvash / 3 / vb[3] + ')';
          } else {
            ts = 'scale(' + canvash / 3 / vb[2] + ')';
          } // Hack to make recalculateDimensions understand how to scale


          ts = 'translate(0) ' + ts + ' translate(0)';
          symbol = svgdoc.createElementNS(NS.SVG, 'symbol');
          var defs = findDefs();

          if (isGecko()) {
            // Move all gradients into root for Firefox, workaround for this bug:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=353575
            // TODO: Make this properly undo-able.
            $$a(svg).find('linearGradient, radialGradient, pattern').appendTo(defs);
          }

          while (svg.firstChild) {
            var first = svg.firstChild;
            symbol.append(first);
          }

          var attrs = svg.attributes;

          var _iterator2 = _createForOfIteratorHelper(attrs),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var attr = _step2.value;
              // Ok for `NamedNodeMap`
              symbol.setAttribute(attr.nodeName, attr.value);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          symbol.id = getNextId(); // Store data

          importIds[uid] = {
            symbol: symbol,
            xform: ts
          };
          findDefs().append(symbol);
          batchCmd.addSubCommand(new InsertElementCommand$1(symbol));
        }

        useEl = svgdoc.createElementNS(NS.SVG, 'use');
        useEl.id = getNextId();
        setHref(useEl, '#' + symbol.id);
        (currentGroup || getCurrentDrawing().getCurrentLayer()).append(useEl);
        batchCmd.addSubCommand(new InsertElementCommand$1(useEl));
        clearSelection();
        useEl.setAttribute('transform', ts);
        recalculateDimensions(useEl);
        $$a(useEl).data('symbol', symbol).data('ref', symbol);
        addToSelection([useEl]); // TODO: Find way to add this in a recalculateDimensions-parsable way
        // if (vb[0] !== 0 || vb[1] !== 0) {
        //   ts = 'translate(' + (-vb[0]) + ',' + (-vb[1]) + ') ' + ts;
        // }

        addCommandToHistory(batchCmd);
        call('changed', [svgcontent]);
      } catch (e) {
        console.log(e); // eslint-disable-line no-console

        return null;
      } // we want to return the element so we can automatically select it


      return useEl;
    }; // Could deprecate, but besides external uses, their usage makes clear that
    //  canvas is a dependency for all of these


    var dr = {
      identifyLayers: identifyLayers,
      createLayer: createLayer,
      cloneLayer: cloneLayer,
      deleteCurrentLayer: deleteCurrentLayer,
      setCurrentLayer: setCurrentLayer,
      renameCurrentLayer: renameCurrentLayer,
      setCurrentLayerPosition: setCurrentLayerPosition,
      setLayerVisibility: setLayerVisibility,
      moveSelectedToLayer: moveSelectedToLayer,
      mergeLayer: mergeLayer,
      mergeAllLayers: mergeAllLayers,
      leaveContext: leaveContext,
      setContext: setContext
    };
    Object.entries(dr).forEach(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
          prop = _ref8[0],
          propVal = _ref8[1];

      canvas[prop] = propVal;
    });
    init$3(
    /**
    * @implements {module:draw.DrawCanvasInit}
    */
    {
      pathActions: pathActions$1,
      getCurrentGroup: function getCurrentGroup() {
        return currentGroup;
      },
      setCurrentGroup: function setCurrentGroup(cg) {
        currentGroup = cg;
      },
      getSelectedElements: getSelectedElements,
      getSVGContent: getSVGContent,
      undoMgr: undoMgr,
      elData: elData,
      getCurrentDrawing: getCurrentDrawing,
      clearSelection: clearSelection,
      call: call,
      addCommandToHistory: addCommandToHistory,

      /**
       * @fires module:svgcanvas.SvgCanvas#event:changed
       * @returns {void}
       */
      changeSVGContent: function changeSVGContent() {
        call('changed', [svgcontent]);
      }
    });
    /**
    * Group: Document functions.
    */

    /**
    * Clears the current document. This is not an undoable action.
    * @function module:svgcanvas.SvgCanvas#clear
    * @fires module:svgcanvas.SvgCanvas#event:cleared
    * @returns {void}
    */

    this.clear = function () {
      pathActions$1.clear();
      clearSelection(); // clear the svgcontent node

      canvas.clearSvgContentElement(); // create new document

      canvas.current_drawing_ = new Drawing(svgcontent); // create empty first layer

      canvas.createLayer('Layer 1'); // clear the undo stack

      canvas.undoMgr.resetUndoStack(); // reset the selector manager

      selectorManager.initGroup(); // reset the rubber band box

      rubberBox = selectorManager.getRubberBandBox();
      call('cleared');
    }; // Alias function


    this.linkControlPoints = pathActions$1.linkControlPoints;
    /**
    * @function module:svgcanvas.SvgCanvas#getContentElem
    * @returns {Element} The content DOM element
    */

    this.getContentElem = function () {
      return svgcontent;
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getRootElem
    * @returns {SVGSVGElement} The root DOM element
    */


    this.getRootElem = function () {
      return svgroot;
    };
    /**
    * @typedef {PlainObject} DimensionsAndZoom
    * @property {Float} w Width
    * @property {Float} h Height
    * @property {Float} zoom Zoom
    */

    /**
    * @function module:svgcanvas.SvgCanvas#getResolution
    * @returns {DimensionsAndZoom} The current dimensions and zoom level in an object
    */


    var getResolution = this.getResolution = function () {
      //    const vb = svgcontent.getAttribute('viewBox').split(' ');
      //    return {w:vb[2], h:vb[3], zoom: currentZoom};
      var w = svgcontent.getAttribute('width') / currentZoom;
      var h = svgcontent.getAttribute('height') / currentZoom;
      return {
        w: w,
        h: h,
        zoom: currentZoom
      };
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getSnapToGrid
    * @returns {boolean} The current snap to grid setting
    */


    this.getSnapToGrid = function () {
      return curConfig.gridSnapping;
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getVersion
    * @returns {string} A string which describes the revision number of SvgCanvas.
    */


    this.getVersion = function () {
      return 'svgcanvas.js ($Rev$)';
    };
    /**
    * Update interface strings with given values.
    * @function module:svgcanvas.SvgCanvas#setUiStrings
    * @param {module:path.uiStrings} strs - Object with strings (see the [locales API]{@link module:locale.LocaleStrings} and the [tutorial]{@tutorial LocaleDocs})
    * @returns {void}
    */


    this.setUiStrings = function (strs) {
      Object.assign(uiStrings, strs.notification);
      $$a = jQueryPluginDBox($$a, strs.common);
      setUiStrings(strs);
    };
    /**
    * Update configuration options with given values.
    * @function module:svgcanvas.SvgCanvas#setConfig
    * @param {module:SVGEditor.Config} opts - Object with options
    * @returns {void}
    */


    this.setConfig = function (opts) {
      Object.assign(curConfig, opts);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getTitle
    * @param {Element} [elem]
    * @returns {string|void} the current group/SVG's title contents or
    * `undefined` if no element is passed nd there are no selected elements.
    */


    this.getTitle = function (elem) {
      elem = elem || selectedElements[0];

      if (!elem) {
        return undefined;
      }

      elem = $$a(elem).data('gsvg') || $$a(elem).data('symbol') || elem;
      var childs = elem.childNodes;

      var _iterator3 = _createForOfIteratorHelper(childs),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var child = _step3.value;

          if (child.nodeName === 'title') {
            return child.textContent;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return '';
    };
    /**
    * Sets the group/SVG's title content.
    * @function module:svgcanvas.SvgCanvas#setGroupTitle
    * @param {string} val
    * @todo Combine this with `setDocumentTitle`
    * @returns {void}
    */


    this.setGroupTitle = function (val) {
      var elem = selectedElements[0];
      elem = $$a(elem).data('gsvg') || elem;
      var ts = $$a(elem).children('title');
      var batchCmd = new BatchCommand$1('Set Label');
      var title;

      if (!val.length) {
        // Remove title element
        var tsNextSibling = ts.nextSibling;
        batchCmd.addSubCommand(new RemoveElementCommand$1(ts[0], tsNextSibling, elem));
        ts.remove();
      } else if (ts.length) {
        // Change title contents
        title = ts[0];
        batchCmd.addSubCommand(new ChangeElementCommand$1(title, {
          '#text': title.textContent
        }));
        title.textContent = val;
      } else {
        // Add title element
        title = svgdoc.createElementNS(NS.SVG, 'title');
        title.textContent = val;
        $$a(elem).prepend(title);
        batchCmd.addSubCommand(new InsertElementCommand$1(title));
      }

      addCommandToHistory(batchCmd);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getDocumentTitle
    * @returns {string|void} The current document title or an empty string if not found
    */


    var getDocumentTitle = this.getDocumentTitle = function () {
      return canvas.getTitle(svgcontent);
    };
    /**
    * Adds/updates a title element for the document with the given name.
    * This is an undoable action.
    * @function module:svgcanvas.SvgCanvas#setDocumentTitle
    * @param {string} newTitle - String with the new title
    * @returns {void}
    */


    this.setDocumentTitle = function (newTitle) {
      var childs = svgcontent.childNodes;
      var docTitle = false,
          oldTitle = '';
      var batchCmd = new BatchCommand$1('Change Image Title');

      var _iterator4 = _createForOfIteratorHelper(childs),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var child = _step4.value;

          if (child.nodeName === 'title') {
            docTitle = child;
            oldTitle = docTitle.textContent;
            break;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (!docTitle) {
        docTitle = svgdoc.createElementNS(NS.SVG, 'title');
        svgcontent.insertBefore(docTitle, svgcontent.firstChild); // svgcontent.firstChild.before(docTitle); // Ok to replace above with this?
      }

      if (newTitle.length) {
        docTitle.textContent = newTitle;
      } else {
        // No title given, so element is not necessary
        docTitle.remove();
      }

      batchCmd.addSubCommand(new ChangeElementCommand$1(docTitle, {
        '#text': oldTitle
      }));
      addCommandToHistory(batchCmd);
    };
    /**
    * Returns the editor's namespace URL, optionally adding it to the root element.
    * @function module:svgcanvas.SvgCanvas#getEditorNS
    * @param {boolean} [add] - Indicates whether or not to add the namespace value
    * @returns {string} The editor's namespace URL
    */


    this.getEditorNS = function (add) {
      if (add) {
        svgcontent.setAttribute('xmlns:se', NS.SE);
      }

      return NS.SE;
    };
    /**
    * Changes the document's dimensions to the given size.
    * @function module:svgcanvas.SvgCanvas#setResolution
    * @param {Float|"fit"} x - Number with the width of the new dimensions in user units.
    * Can also be the string "fit" to indicate "fit to content".
    * @param {Float} y - Number with the height of the new dimensions in user units.
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {boolean} Indicates if resolution change was successful.
    * It will fail on "fit to content" option with no content to fit to.
    */


    this.setResolution = function (x, y) {
      var res = getResolution();
      var w = res.w,
          h = res.h;
      var batchCmd;

      if (x === 'fit') {
        // Get bounding box
        var bbox = getStrokedBBoxDefaultVisible();

        if (bbox) {
          batchCmd = new BatchCommand$1('Fit Canvas to Content');
          var visEls = getVisibleElements();
          addToSelection(visEls);
          var dx = [],
              dy = [];
          $$a.each(visEls, function (i, item) {
            dx.push(bbox.x * -1);
            dy.push(bbox.y * -1);
          });
          var cmd = canvas.moveSelectedElements(dx, dy, true);
          batchCmd.addSubCommand(cmd);
          clearSelection();
          x = Math.round(bbox.width);
          y = Math.round(bbox.height);
        } else {
          return false;
        }
      }

      if (x !== w || y !== h) {
        if (!batchCmd) {
          batchCmd = new BatchCommand$1('Change Image Dimensions');
        }

        x = convertToNum('width', x);
        y = convertToNum('height', y);
        svgcontent.setAttribute('width', x);
        svgcontent.setAttribute('height', y);
        this.contentW = x;
        this.contentH = y;
        batchCmd.addSubCommand(new ChangeElementCommand$1(svgcontent, {
          width: w,
          height: h
        }));
        svgcontent.setAttribute('viewBox', [0, 0, x / currentZoom, y / currentZoom].join(' '));
        batchCmd.addSubCommand(new ChangeElementCommand$1(svgcontent, {
          viewBox: ['0 0', w, h].join(' ')
        }));
        addCommandToHistory(batchCmd);
        call('changed', [svgcontent]);
      }

      return true;
    };
    /**
    * @typedef {module:jQueryAttr.Attributes} module:svgcanvas.ElementPositionInCanvas
    * @property {Float} x
    * @property {Float} y
    */

    /**
    * @function module:svgcanvas.SvgCanvas#getOffset
    * @returns {module:svgcanvas.ElementPositionInCanvas} An object with `x`, `y` values indicating the svgcontent element's
    * position in the editor's canvas.
    */


    this.getOffset = function () {
      return $$a(svgcontent).attr(['x', 'y']);
    };
    /**
     * @typedef {PlainObject} module:svgcanvas.ZoomAndBBox
     * @property {Float} zoom
     * @property {module:utilities.BBoxObject} bbox
     */

    /**
    * Sets the zoom level on the canvas-side based on the given value.
    * @function module:svgcanvas.SvgCanvas#setBBoxZoom
    * @param {"selection"|"canvas"|"content"|"layer"|module:SVGEditor.BBoxObjectWithFactor} val - Bounding box object to zoom to or string indicating zoom option. Note: the object value type is defined in `svg-editor.js`
    * @param {Integer} editorW - The editor's workarea box's width
    * @param {Integer} editorH - The editor's workarea box's height
    * @returns {module:svgcanvas.ZoomAndBBox|void}
    */


    this.setBBoxZoom = function (val, editorW, editorH) {
      var spacer = 0.85;
      var bb;

      var calcZoom = function calcZoom(bb) {
        // eslint-disable-line no-shadow
        if (!bb) {
          return false;
        }

        var wZoom = Math.round(editorW / bb.width * 100 * spacer) / 100;
        var hZoom = Math.round(editorH / bb.height * 100 * spacer) / 100;
        var zoom = Math.min(wZoom, hZoom);
        canvas.setZoom(zoom);
        return {
          zoom: zoom,
          bbox: bb
        };
      };

      if (_typeof(val) === 'object') {
        bb = val;

        if (bb.width === 0 || bb.height === 0) {
          var newzoom = bb.zoom ? bb.zoom : currentZoom * bb.factor;
          canvas.setZoom(newzoom);
          return {
            zoom: currentZoom,
            bbox: bb
          };
        }

        return calcZoom(bb);
      }

      switch (val) {
        case 'selection':
          {
            if (!selectedElements[0]) {
              return undefined;
            }

            var selectedElems = $$a.map(selectedElements, function (n) {
              if (n) {
                return n;
              }

              return undefined;
            });
            bb = getStrokedBBoxDefaultVisible(selectedElems);
            break;
          }

        case 'canvas':
          {
            var res = getResolution();
            spacer = 0.95;
            bb = {
              width: res.w,
              height: res.h,
              x: 0,
              y: 0
            };
            break;
          }

        case 'content':
          bb = getStrokedBBoxDefaultVisible();
          break;

        case 'layer':
          bb = getStrokedBBoxDefaultVisible(getVisibleElements(getCurrentDrawing().getCurrentLayer()));
          break;

        default:
          return undefined;
      }

      return calcZoom(bb);
    };
    /**
    * The zoom level has changed. Supplies the new zoom level as a number (not percentage).
    * @event module:svgcanvas.SvgCanvas#event:ext_zoomChanged
    * @type {Float}
    */

    /**
    * The bottom panel was updated.
    * @event module:svgcanvas.SvgCanvas#event:ext_toolButtonStateUpdate
    * @type {PlainObject}
    * @property {boolean} nofill Indicates fill is disabled
    * @property {boolean} nostroke Indicates stroke is disabled
    */

    /**
    * The element selection has changed (elements were added/removed from selection).
    * @event module:svgcanvas.SvgCanvas#event:ext_selectedChanged
    * @type {PlainObject}
    * @property {Element[]} elems Array of the newly selected elements
    * @property {Element|null} selectedElement The single selected element
    * @property {boolean} multiselected Indicates whether one or more elements were selected
    */

    /**
    * Called when part of element is in process of changing, generally on
    * mousemove actions like rotate, move, etc.
    * @event module:svgcanvas.SvgCanvas#event:ext_elementTransition
    * @type {PlainObject}
    * @property {Element[]} elems Array of transitioning elements
    */

    /**
    * One or more elements were changed.
    * @event module:svgcanvas.SvgCanvas#event:ext_elementChanged
    * @type {PlainObject}
    * @property {Element[]} elems Array of the affected elements
    */

    /**
    * Invoked as soon as the locale is ready.
    * @event module:svgcanvas.SvgCanvas#event:ext_langReady
    * @type {PlainObject}
    * @property {string} lang The two-letter language code
    * @property {module:SVGEditor.uiStrings} uiStrings
    * @property {module:SVGEditor~ImportLocale} importLocale
    */

    /**
    * The language was changed. Two-letter code of the new language.
    * @event module:svgcanvas.SvgCanvas#event:ext_langChanged
    * @type {string}
    */

    /**
    * Means for an extension to add locale data. The two-letter language code.
    * @event module:svgcanvas.SvgCanvas#event:ext_addLangData
    * @type {PlainObject}
    * @property {string} lang
    * @property {module:SVGEditor~ImportLocale} importLocale
    */

    /**
     * Called when new image is created.
     * @event module:svgcanvas.SvgCanvas#event:ext_onNewDocument
     * @type {void}
     */

    /**
     * Called when sidepanel is resized or toggled.
     * @event module:svgcanvas.SvgCanvas#event:ext_workareaResized
     * @type {void}
    */

    /**
     * Called upon addition of the extension, or, if svgicons are set,
     * after the icons are ready when extension SVG icons have loaded.
     * @event module:svgcanvas.SvgCanvas#event:ext_callback
     * @type {void}
    */

    /**
    * Sets the zoom to the given level.
    * @function module:svgcanvas.SvgCanvas#setZoom
    * @param {Float} zoomLevel - Float indicating the zoom level to change to
    * @fires module:svgcanvas.SvgCanvas#event:ext_zoomChanged
    * @returns {void}
    */


    this.setZoom = function (zoomLevel) {
      var res = getResolution();
      svgcontent.setAttribute('viewBox', '0 0 ' + res.w / zoomLevel + ' ' + res.h / zoomLevel);
      currentZoom = zoomLevel;
      $$a.each(selectedElements, function (i, elem) {
        if (!elem) {
          return;
        }

        selectorManager.requestSelector(elem).resize();
      });
      pathActions$1.zoomChange();
      runExtensions('zoomChanged',
      /** @type {module:svgcanvas.SvgCanvas#event:ext_zoomChanged} */
      zoomLevel);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getMode
    * @returns {string} The current editor mode string
    */


    this.getMode = function () {
      return currentMode;
    };
    /**
    * Sets the editor's mode to the given string.
    * @function module:svgcanvas.SvgCanvas#setMode
    * @param {string} name - String with the new mode to change to
    * @returns {void}
    */


    this.setMode = function (name) {
      pathActions$1.clear(true);
      textActions.clear();
      curProperties = selectedElements[0] && selectedElements[0].nodeName === 'text' ? curText : curShape;
      currentMode = name;
    };
    /**
    * Group: Element Styling.
    */

    /**
    * @typedef {PlainObject} module:svgcanvas.PaintOptions
    * @property {"solidColor"} type
    */

    /**
    * @function module:svgcanvas.SvgCanvas#getColor
    * @param {string} type
    * @returns {string|module:svgcanvas.PaintOptions|Float|module:jGraduate~Paint} The current fill/stroke option
    */


    this.getColor = function (type) {
      return curProperties[type];
    };
    /**
    * Change the current stroke/fill color/gradient value.
    * @function module:svgcanvas.SvgCanvas#setColor
    * @param {string} type - String indicating fill or stroke
    * @param {string} val - The value to set the stroke attribute to
    * @param {boolean} preventUndo - Boolean indicating whether or not this should be an undoable option
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.setColor = function (type, val, preventUndo) {
      curShape[type] = val;
      curProperties[type + '_paint'] = {
        type: 'solidColor'
      };
      var elems = [];
      /**
       *
       * @param {Element} e
       * @returns {void}
       */

      function addNonG(e) {
        if (e.nodeName !== 'g') {
          elems.push(e);
        }
      }

      var i = selectedElements.length;

      while (i--) {
        var elem = selectedElements[i];

        if (elem) {
          if (elem.tagName === 'g') {
            walkTree(elem, addNonG);
          } else if (type === 'fill') {
            if (elem.tagName !== 'polyline' && elem.tagName !== 'line') {
              elems.push(elem);
            }
          } else {
            elems.push(elem);
          }
        }
      }

      if (elems.length > 0) {
        if (!preventUndo) {
          changeSelectedAttribute(type, val, elems);
          call('changed', elems);
        } else {
          changeSelectedAttributeNoUndo(type, val, elems);
        }
      }
    };
    /**
    * Apply the current gradient to selected element's fill or stroke.
    * @function module:svgcanvas.SvgCanvas#setGradient
    * @param {"fill"|"stroke"} type - String indicating "fill" or "stroke" to apply to an element
    * @returns {void}
    */


    var setGradient = this.setGradient = function (type) {
      if (!curProperties[type + '_paint'] || curProperties[type + '_paint'].type === 'solidColor') {
        return;
      }

      var grad = canvas[type + 'Grad']; // find out if there is a duplicate gradient already in the defs

      var duplicateGrad = findDuplicateGradient(grad);
      var defs = findDefs(); // no duplicate found, so import gradient into defs

      if (!duplicateGrad) {
        // const origGrad = grad;
        grad = defs.appendChild(svgdoc.importNode(grad, true)); // get next id and set it on the grad

        grad.id = getNextId();
      } else {
        // use existing gradient
        grad = duplicateGrad;
      }

      canvas.setColor(type, 'url(#' + grad.id + ')');
    };
    /**
    * Check if exact gradient already exists.
    * @function module:svgcanvas~findDuplicateGradient
    * @param {SVGGradientElement} grad - The gradient DOM element to compare to others
    * @returns {SVGGradientElement} The existing gradient if found, `null` if not
    */


    var findDuplicateGradient = function findDuplicateGradient(grad) {
      var defs = findDefs();
      var existingGrads = $$a(defs).find('linearGradient, radialGradient');
      var i = existingGrads.length;
      var radAttrs = ['r', 'cx', 'cy', 'fx', 'fy'];

      while (i--) {
        var og = existingGrads[i];

        if (grad.tagName === 'linearGradient') {
          if (grad.getAttribute('x1') !== og.getAttribute('x1') || grad.getAttribute('y1') !== og.getAttribute('y1') || grad.getAttribute('x2') !== og.getAttribute('x2') || grad.getAttribute('y2') !== og.getAttribute('y2')) {
            continue;
          }
        } else {
          var _ret = function () {
            var gradAttrs = $$a(grad).attr(radAttrs);
            var ogAttrs = $$a(og).attr(radAttrs);
            var diff = false;
            $$a.each(radAttrs, function (j, attr) {
              if (gradAttrs[attr] !== ogAttrs[attr]) {
                diff = true;
              }
            });

            if (diff) {
              return "continue";
            }
          }();

          if (_ret === "continue") continue;
        } // else could be a duplicate, iterate through stops


        var stops = grad.getElementsByTagNameNS(NS.SVG, 'stop');
        var ostops = og.getElementsByTagNameNS(NS.SVG, 'stop');

        if (stops.length !== ostops.length) {
          continue;
        }

        var j = stops.length;

        while (j--) {
          var stop = stops[j];
          var ostop = ostops[j];

          if (stop.getAttribute('offset') !== ostop.getAttribute('offset') || stop.getAttribute('stop-opacity') !== ostop.getAttribute('stop-opacity') || stop.getAttribute('stop-color') !== ostop.getAttribute('stop-color')) {
            break;
          }
        }

        if (j === -1) {
          return og;
        }
      } // for each gradient in defs


      return null;
    };
    /**
    * Set a color/gradient to a fill/stroke.
    * @function module:svgcanvas.SvgCanvas#setPaint
    * @param {"fill"|"stroke"} type - String with "fill" or "stroke"
    * @param {module:jGraduate.jGraduatePaintOptions} paint - The jGraduate paint object to apply
    * @returns {void}
    */


    this.setPaint = function (type, paint) {
      // make a copy
      var p = new $$a.jGraduate.Paint(paint);
      this.setPaintOpacity(type, p.alpha / 100, true); // now set the current paint object

      curProperties[type + '_paint'] = p;

      switch (p.type) {
        case 'solidColor':
          this.setColor(type, p.solidColor !== 'none' ? '#' + p.solidColor : 'none');
          break;

        case 'linearGradient':
        case 'radialGradient':
          canvas[type + 'Grad'] = p[p.type];
          setGradient(type);
          break;
      }
    };
    /**
    * @function module:svgcanvas.SvgCanvas#setStrokePaint
    * @param {module:jGraduate~Paint} paint
    * @returns {void}
    */


    this.setStrokePaint = function (paint) {
      this.setPaint('stroke', paint);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#setFillPaint
    * @param {module:jGraduate~Paint} paint
    * @returns {void}
    */


    this.setFillPaint = function (paint) {
      this.setPaint('fill', paint);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getStrokeWidth
    * @returns {Float|string} The current stroke-width value
    */


    this.getStrokeWidth = function () {
      return curProperties.stroke_width;
    };
    /**
    * Sets the stroke width for the current selected elements.
    * When attempting to set a line's width to 0, this changes it to 1 instead.
    * @function module:svgcanvas.SvgCanvas#setStrokeWidth
    * @param {Float} val - A Float indicating the new stroke width value
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.setStrokeWidth = function (val) {
      if (val === 0 && ['line', 'path'].includes(currentMode)) {
        canvas.setStrokeWidth(1);
        return;
      }

      curProperties.stroke_width = val;
      var elems = [];
      /**
       *
       * @param {Element} e
       * @returns {void}
       */

      function addNonG(e) {
        if (e.nodeName !== 'g') {
          elems.push(e);
        }
      }

      var i = selectedElements.length;

      while (i--) {
        var elem = selectedElements[i];

        if (elem) {
          if (elem.tagName === 'g') {
            walkTree(elem, addNonG);
          } else {
            elems.push(elem);
          }
        }
      }

      if (elems.length > 0) {
        changeSelectedAttribute('stroke-width', val, elems);
        call('changed', selectedElements);
      }
    };
    /**
    * Set the given stroke-related attribute the given value for selected elements.
    * @function module:svgcanvas.SvgCanvas#setStrokeAttr
    * @param {string} attr - String with the attribute name
    * @param {string|Float} val - String or number with the attribute value
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.setStrokeAttr = function (attr, val) {
      curShape[attr.replace('-', '_')] = val;
      var elems = [];
      var i = selectedElements.length;

      while (i--) {
        var elem = selectedElements[i];

        if (elem) {
          if (elem.tagName === 'g') {
            walkTree(elem, function (e) {
              if (e.nodeName !== 'g') {
                elems.push(e);
              }
            });
          } else {
            elems.push(elem);
          }
        }
      }

      if (elems.length > 0) {
        changeSelectedAttribute(attr, val, elems);
        call('changed', selectedElements);
      }
    };
    /**
    * @typedef {PlainObject} module:svgcanvas.StyleOptions
    * @property {string} fill
    * @property {Float} fill_opacity
    * @property {string} stroke
    * @property {Float} stroke_width
    * @property {string} stroke_dasharray
    * @property {string} stroke_linejoin
    * @property {string} stroke_linecap
    * @property {Float} stroke_opacity
    * @property {Float} opacity
    */

    /**
    * @function module:svgcanvas.SvgCanvas#getStyle
    * @returns {module:svgcanvas.StyleOptions} current style options
    */


    this.getStyle = function () {
      return curShape;
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getOpacity
    * @returns {Float} the current opacity
    */


    this.getOpacity = getOpacity;
    /**
    * Sets the given opacity on the current selected elements.
    * @function module:svgcanvas.SvgCanvas#setOpacity
    * @param {string} val
    * @returns {void}
    */

    this.setOpacity = function (val) {
      curShape.opacity = val;
      changeSelectedAttribute('opacity', val);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getFillOpacity
    * @returns {Float} the current fill opacity
    */


    this.getFillOpacity = function () {
      return curShape.fill_opacity;
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getStrokeOpacity
    * @returns {string} the current stroke opacity
    */


    this.getStrokeOpacity = function () {
      return curShape.stroke_opacity;
    };
    /**
    * Sets the current fill/stroke opacity.
    * @function module:svgcanvas.SvgCanvas#setPaintOpacity
    * @param {string} type - String with "fill" or "stroke"
    * @param {Float} val - Float with the new opacity value
    * @param {boolean} preventUndo - Indicates whether or not this should be an undoable action
    * @returns {void}
    */


    this.setPaintOpacity = function (type, val, preventUndo) {
      curShape[type + '_opacity'] = val;

      if (!preventUndo) {
        changeSelectedAttribute(type + '-opacity', val);
      } else {
        changeSelectedAttributeNoUndo(type + '-opacity', val);
      }
    };
    /**
    * Gets the current fill/stroke opacity.
    * @function module:svgcanvas.SvgCanvas#getPaintOpacity
    * @param {"fill"|"stroke"} type - String with "fill" or "stroke"
    * @returns {Float} Fill/stroke opacity
    */


    this.getPaintOpacity = function (type) {
      return type === 'fill' ? this.getFillOpacity() : this.getStrokeOpacity();
    };
    /**
    * Gets the `stdDeviation` blur value of the given element.
    * @function module:svgcanvas.SvgCanvas#getBlur
    * @param {Element} elem - The element to check the blur value for
    * @returns {string} stdDeviation blur attribute value
    */


    this.getBlur = function (elem) {
      var val = 0; // const elem = selectedElements[0];

      if (elem) {
        var filterUrl = elem.getAttribute('filter');

        if (filterUrl) {
          var blur = getElem(elem.id + '_blur');

          if (blur) {
            val = blur.firstChild.getAttribute('stdDeviation');
          }
        }
      }

      return val;
    };

    (function () {
      var curCommand = null;
      var filter = null;
      var filterHidden = false;
      /**
      * Sets the `stdDeviation` blur value on the selected element without being undoable.
      * @function module:svgcanvas.SvgCanvas#setBlurNoUndo
      * @param {Float} val - The new `stdDeviation` value
      * @returns {void}
      */

      canvas.setBlurNoUndo = function (val) {
        if (!filter) {
          canvas.setBlur(val);
          return;
        }

        if (val === 0) {
          // Don't change the StdDev, as that will hide the element.
          // Instead, just remove the value for "filter"
          changeSelectedAttributeNoUndo('filter', '');
          filterHidden = true;
        } else {
          var elem = selectedElements[0];

          if (filterHidden) {
            changeSelectedAttributeNoUndo('filter', 'url(#' + elem.id + '_blur)');
          }

          if (isWebkit()) {
            // console.log('e', elem); // eslint-disable-line no-console
            elem.removeAttribute('filter');
            elem.setAttribute('filter', 'url(#' + elem.id + '_blur)');
          }

          changeSelectedAttributeNoUndo('stdDeviation', val, [filter.firstChild]);
          canvas.setBlurOffsets(filter, val);
        }
      };
      /**
       *
       * @returns {void}
       */


      function finishChange() {
        var bCmd = canvas.undoMgr.finishUndoableChange();
        curCommand.addSubCommand(bCmd);
        addCommandToHistory(curCommand);
        curCommand = null;
        filter = null;
      }
      /**
      * Sets the `x`, `y`, `width`, `height` values of the filter element in order to
      * make the blur not be clipped. Removes them if not neeeded.
      * @function module:svgcanvas.SvgCanvas#setBlurOffsets
      * @param {Element} filterElem - The filter DOM element to update
      * @param {Float} stdDev - The standard deviation value on which to base the offset size
      * @returns {void}
      */


      canvas.setBlurOffsets = function (filterElem, stdDev) {
        if (stdDev > 3) {
          // TODO: Create algorithm here where size is based on expected blur
          assignAttributes(filterElem, {
            x: '-50%',
            y: '-50%',
            width: '200%',
            height: '200%'
          }); // Removing these attributes hides text in Chrome (see Issue 579)
        } else if (!isWebkit()) {
          filterElem.removeAttribute('x');
          filterElem.removeAttribute('y');
          filterElem.removeAttribute('width');
          filterElem.removeAttribute('height');
        }
      };
      /**
      * Adds/updates the blur filter to the selected element.
      * @function module:svgcanvas.SvgCanvas#setBlur
      * @param {Float} val - Float with the new `stdDeviation` blur value
      * @param {boolean} complete - Whether or not the action should be completed (to add to the undo manager)
      * @returns {void}
      */


      canvas.setBlur = function (val, complete) {
        if (curCommand) {
          finishChange();
          return;
        } // Looks for associated blur, creates one if not found


        var elem = selectedElements[0];
        var elemId = elem.id;
        filter = getElem(elemId + '_blur');
        val -= 0;
        var batchCmd = new BatchCommand$1(); // Blur found!

        if (filter) {
          if (val === 0) {
            filter = null;
          }
        } else {
          // Not found, so create
          var newblur = addSVGElementFromJson({
            element: 'feGaussianBlur',
            attr: {
              "in": 'SourceGraphic',
              stdDeviation: val
            }
          });
          filter = addSVGElementFromJson({
            element: 'filter',
            attr: {
              id: elemId + '_blur'
            }
          });
          filter.append(newblur);
          findDefs().append(filter);
          batchCmd.addSubCommand(new InsertElementCommand$1(filter));
        }

        var changes = {
          filter: elem.getAttribute('filter')
        };

        if (val === 0) {
          elem.removeAttribute('filter');
          batchCmd.addSubCommand(new ChangeElementCommand$1(elem, changes));
          return;
        }

        changeSelectedAttribute('filter', 'url(#' + elemId + '_blur)');
        batchCmd.addSubCommand(new ChangeElementCommand$1(elem, changes));
        canvas.setBlurOffsets(filter, val);
        curCommand = batchCmd;
        canvas.undoMgr.beginUndoableChange('stdDeviation', [filter ? filter.firstChild : null]);

        if (complete) {
          canvas.setBlurNoUndo(val);
          finishChange();
        }
      };
    })();
    /**
    * Check whether selected element is bold or not.
    * @function module:svgcanvas.SvgCanvas#getBold
    * @returns {boolean} Indicates whether or not element is bold
    */


    this.getBold = function () {
      // should only have one element selected
      var selected = selectedElements[0];

      if (!isNullish(selected) && selected.tagName === 'text' && isNullish(selectedElements[1])) {
        return selected.getAttribute('font-weight') === 'bold';
      }

      return false;
    };
    /**
    * Make the selected element bold or normal.
    * @function module:svgcanvas.SvgCanvas#setBold
    * @param {boolean} b - Indicates bold (`true`) or normal (`false`)
    * @returns {void}
    */


    this.setBold = function (b) {
      var selected = selectedElements[0];

      if (!isNullish(selected) && selected.tagName === 'text' && isNullish(selectedElements[1])) {
        changeSelectedAttribute('font-weight', b ? 'bold' : 'normal');
      }

      if (!selectedElements[0].textContent) {
        textActions.setCursor();
      }
    };
    /**
    * Check whether selected element is in italics or not.
    * @function module:svgcanvas.SvgCanvas#getItalic
    * @returns {boolean} Indicates whether or not element is italic
    */


    this.getItalic = function () {
      var selected = selectedElements[0];

      if (!isNullish(selected) && selected.tagName === 'text' && isNullish(selectedElements[1])) {
        return selected.getAttribute('font-style') === 'italic';
      }

      return false;
    };
    /**
    * Make the selected element italic or normal.
    * @function module:svgcanvas.SvgCanvas#setItalic
    * @param {boolean} i - Indicates italic (`true`) or normal (`false`)
    * @returns {void}
    */


    this.setItalic = function (i) {
      var selected = selectedElements[0];

      if (!isNullish(selected) && selected.tagName === 'text' && isNullish(selectedElements[1])) {
        changeSelectedAttribute('font-style', i ? 'italic' : 'normal');
      }

      if (!selectedElements[0].textContent) {
        textActions.setCursor();
      }
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getFontFamily
    * @returns {string} The current font family
    */


    this.getFontFamily = function () {
      return curText.font_family;
    };
    /**
    * Set the new font family.
    * @function module:svgcanvas.SvgCanvas#setFontFamily
    * @param {string} val - String with the new font family
    * @returns {void}
    */


    this.setFontFamily = function (val) {
      curText.font_family = val;
      changeSelectedAttribute('font-family', val);

      if (selectedElements[0] && !selectedElements[0].textContent) {
        textActions.setCursor();
      }
    };
    /**
    * Set the new font color.
    * @function module:svgcanvas.SvgCanvas#setFontColor
    * @param {string} val - String with the new font color
    * @returns {void}
    */


    this.setFontColor = function (val) {
      curText.fill = val;
      changeSelectedAttribute('fill', val);
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getFontColor
    * @returns {string} The current font color
    */


    this.getFontColor = function () {
      return curText.fill;
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getFontSize
    * @returns {Float} The current font size
    */


    this.getFontSize = function () {
      return curText.font_size;
    };
    /**
    * Applies the given font size to the selected element.
    * @function module:svgcanvas.SvgCanvas#setFontSize
    * @param {Float} val - Float with the new font size
    * @returns {void}
    */


    this.setFontSize = function (val) {
      curText.font_size = val;
      changeSelectedAttribute('font-size', val);

      if (!selectedElements[0].textContent) {
        textActions.setCursor();
      }
    };
    /**
    * @function module:svgcanvas.SvgCanvas#getText
    * @returns {string} The current text (`textContent`) of the selected element
    */


    this.getText = function () {
      var selected = selectedElements[0];

      if (isNullish(selected)) {
        return '';
      }

      return selected.textContent;
    };
    /**
    * Updates the text element with the given string.
    * @function module:svgcanvas.SvgCanvas#setTextContent
    * @param {string} val - String with the new text
    * @returns {void}
    */


    this.setTextContent = function (val) {
      changeSelectedAttribute('#text', val);
      textActions.init(val);
      textActions.setCursor();
    };
    /**
    * Sets the new image URL for the selected image element. Updates its size if
    * a new URL is given.
    * @function module:svgcanvas.SvgCanvas#setImageURL
    * @param {string} val - String with the image URL/path
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.setImageURL = function (val) {
      var elem = selectedElements[0];

      if (!elem) {
        return;
      }

      var attrs = $$a(elem).attr(['width', 'height']);
      var setsize = !attrs.width || !attrs.height;
      var curHref = getHref(elem); // Do nothing if no URL change or size change

      if (curHref === val && !setsize) {
        return;
      }

      var batchCmd = new BatchCommand$1('Change Image URL');
      setHref(elem, val);
      batchCmd.addSubCommand(new ChangeElementCommand$1(elem, {
        '#href': curHref
      }));
      $$a(new Image()).load(function () {
        var changes = $$a(elem).attr(['width', 'height']);
        $$a(elem).attr({
          width: this.width,
          height: this.height
        });
        selectorManager.requestSelector(elem).resize();
        batchCmd.addSubCommand(new ChangeElementCommand$1(elem, changes));
        addCommandToHistory(batchCmd);
        call('changed', [elem]);
      }).attr('src', val);
    };
    /**
    * Sets the new link URL for the selected anchor element.
    * @function module:svgcanvas.SvgCanvas#setLinkURL
    * @param {string} val - String with the link URL/path
    * @returns {void}
    */


    this.setLinkURL = function (val) {
      var elem = selectedElements[0];

      if (!elem) {
        return;
      }

      if (elem.tagName !== 'a') {
        // See if parent is an anchor
        var parentsA = $$a(elem).parents('a');

        if (parentsA.length) {
          elem = parentsA[0];
        } else {
          return;
        }
      }

      var curHref = getHref(elem);

      if (curHref === val) {
        return;
      }

      var batchCmd = new BatchCommand$1('Change Link URL');
      setHref(elem, val);
      batchCmd.addSubCommand(new ChangeElementCommand$1(elem, {
        '#href': curHref
      }));
      addCommandToHistory(batchCmd);
    };
    /**
    * Sets the `rx` and `ry` values to the selected `rect` element
    * to change its corner radius.
    * @function module:svgcanvas.SvgCanvas#setRectRadius
    * @param {string|Float} val - The new radius
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.setRectRadius = function (val) {
      var selected = selectedElements[0];

      if (!isNullish(selected) && selected.tagName === 'rect') {
        var r = selected.getAttribute('rx');

        if (r !== String(val)) {
          selected.setAttribute('rx', val);
          selected.setAttribute('ry', val);
          addCommandToHistory(new ChangeElementCommand$1(selected, {
            rx: r,
            ry: r
          }, 'Radius'));
          call('changed', [selected]);
        }
      }
    };
    /**
    * Wraps the selected element(s) in an anchor element or converts group to one.
    * @function module:svgcanvas.SvgCanvas#makeHyperlink
    * @param {string} url
    * @returns {void}
    */


    this.makeHyperlink = function (url) {
      canvas.groupSelectedElements('a', url); // TODO: If element is a single "g", convert to "a"
      //  if (selectedElements.length > 1 && selectedElements[1]) {
    };
    /**
    * @function module:svgcanvas.SvgCanvas#removeHyperlink
    * @returns {void}
    */


    this.removeHyperlink = function () {
      canvas.ungroupSelectedElement();
    };
    /**
    * Group: Element manipulation.
    */

    /**
    * Sets the new segment type to the selected segment(s).
    * @function module:svgcanvas.SvgCanvas#setSegType
    * @param {Integer} newType - New segment type. See {@link https://www.w3.org/TR/SVG/paths.html#InterfaceSVGPathSeg} for list
    * @returns {void}
    */


    this.setSegType = function (newType) {
      pathActions$1.setSegType(newType);
    };
    /**
    * Convert selected element to a path, or get the BBox of an element-as-path.
    * @function module:svgcanvas.SvgCanvas#convertToPath
    * @todo (codedread): Remove the getBBox argument and split this function into two.
    * @param {Element} elem - The DOM element to be converted
    * @param {boolean} getBBox - Boolean on whether or not to only return the path's BBox
    * @returns {void|DOMRect|false|SVGPathElement|null} If the getBBox flag is true, the resulting path's bounding box object.
    * Otherwise the resulting path element is returned.
    */


    this.convertToPath = function (elem, getBBox) {
      if (isNullish(elem)) {
        var elems = selectedElements;
        $$a.each(elems, function (i, el) {
          if (el) {
            canvas.convertToPath(el);
          }
        });
        return undefined;
      }

      if (getBBox) {
        return getBBoxOfElementAsPath(elem, addSVGElementFromJson, pathActions$1);
      } // TODO: Why is this applying attributes from curShape, then inside utilities.convertToPath it's pulling addition attributes from elem?
      // TODO: If convertToPath is called with one elem, curShape and elem are probably the same; but calling with multiple is a bug or cool feature.


      var attrs = {
        fill: curShape.fill,
        'fill-opacity': curShape.fill_opacity,
        stroke: curShape.stroke,
        'stroke-width': curShape.stroke_width,
        'stroke-dasharray': curShape.stroke_dasharray,
        'stroke-linejoin': curShape.stroke_linejoin,
        'stroke-linecap': curShape.stroke_linecap,
        'stroke-opacity': curShape.stroke_opacity,
        opacity: curShape.opacity,
        visibility: 'hidden'
      };
      return convertToPath(elem, attrs, addSVGElementFromJson, pathActions$1, clearSelection, addToSelection, hstry, addCommandToHistory);
    };
    /**
    * This function makes the changes to the elements. It does not add the change
    * to the history stack.
    * @param {string} attr - Attribute name
    * @param {string|Float} newValue - String or number with the new attribute value
    * @param {Element[]} elems - The DOM elements to apply the change to
    * @returns {void}
    */


    var changeSelectedAttributeNoUndo = function changeSelectedAttributeNoUndo(attr, newValue, elems) {
      if (currentMode === 'pathedit') {
        // Editing node
        pathActions$1.moveNode(attr, newValue);
      }

      elems = elems || selectedElements;
      var i = elems.length;
      var noXYElems = ['g', 'polyline', 'path']; // const goodGAttrs = ['transform', 'opacity', 'filter'];

      var _loop = function _loop() {
        var elem = elems[i];

        if (isNullish(elem)) {
          return "continue";
        } // Set x,y vals on elements that don't have them


        if ((attr === 'x' || attr === 'y') && noXYElems.includes(elem.tagName)) {
          var bbox = getStrokedBBoxDefaultVisible([elem]);
          var diffX = attr === 'x' ? newValue - bbox.x : 0;
          var diffY = attr === 'y' ? newValue - bbox.y : 0;
          canvas.moveSelectedElements(diffX * currentZoom, diffY * currentZoom, true);
          return "continue";
        } // only allow the transform/opacity/filter attribute to change on <g> elements, slightly hacky
        // TODO: Missing statement body
        // if (elem.tagName === 'g' && goodGAttrs.includes(attr)) {}


        var oldval = attr === '#text' ? elem.textContent : elem.getAttribute(attr);

        if (isNullish(oldval)) {
          oldval = '';
        }

        if (oldval !== String(newValue)) {
          if (attr === '#text') {
            // const oldW = utilsGetBBox(elem).width;
            elem.textContent = newValue; // FF bug occurs on on rotated elements

            if (/rotate/.test(elem.getAttribute('transform'))) {
              elem = ffClone(elem);
            } // Hoped to solve the issue of moving text with text-anchor="start",
            // but this doesn't actually fix it. Hopefully on the right track, though. -Fyrd
            // const box = getBBox(elem), left = box.x, top = box.y, {width, height} = box,
            //   dx = width - oldW, dy = 0;
            // const angle = getRotationAngle(elem, true);
            // if (angle) {
            //   const r = Math.sqrt(dx * dx + dy * dy);
            //   const theta = Math.atan2(dy, dx) - angle;
            //   dx = r * Math.cos(theta);
            //   dy = r * Math.sin(theta);
            //
            //   elem.setAttribute('x', elem.getAttribute('x') - dx);
            //   elem.setAttribute('y', elem.getAttribute('y') - dy);
            // }

          } else if (attr === '#href') {
            setHref(elem, newValue);
          } else {
            elem.setAttribute(attr, newValue);
          } // Go into "select" mode for text changes
          // NOTE: Important that this happens AFTER elem.setAttribute() or else attributes like
          // font-size can get reset to their old value, ultimately by svgEditor.updateContextPanel(),
          // after calling textActions.toSelectMode() below


          if (currentMode === 'textedit' && attr !== '#text' && elem.textContent.length) {
            textActions.toSelectMode(elem);
          } // if (i === 0) {
          //   selectedBBoxes[0] = utilsGetBBox(elem);
          // }
          // Use the Firefox ffClone hack for text elements with gradients or
          // where other text attributes are changed.


          if (isGecko() && elem.nodeName === 'text' && /rotate/.test(elem.getAttribute('transform'))) {
            if (String(newValue).startsWith('url') || ['font-size', 'font-family', 'x', 'y'].includes(attr) && elem.textContent) {
              elem = ffClone(elem);
            }
          } // Timeout needed for Opera & Firefox
          // codedread: it is now possible for this function to be called with elements
          // that are not in the selectedElements array, we need to only request a
          // selector if the element is in that array


          if (selectedElements.includes(elem)) {
            setTimeout(function () {
              // Due to element replacement, this element may no longer
              // be part of the DOM
              if (!elem.parentNode) {
                return;
              }

              selectorManager.requestSelector(elem).resize();
            }, 0);
          } // if this element was rotated, and we changed the position of this element
          // we need to update the rotational transform attribute


          var angle = getRotationAngle(elem);

          if (angle !== 0 && attr !== 'transform') {
            var tlist = getTransformList(elem);
            var n = tlist.numberOfItems;

            while (n--) {
              var xform = tlist.getItem(n);

              if (xform.type === 4) {
                // remove old rotate
                tlist.removeItem(n);
                var box = getBBox(elem);
                var center = transformPoint(box.x + box.width / 2, box.y + box.height / 2, transformListToTransform(tlist).matrix);
                var cx = center.x,
                    cy = center.y;
                var newrot = svgroot.createSVGTransform();
                newrot.setRotate(angle, cx, cy);
                tlist.insertItemBefore(newrot, n);
                break;
              }
            }
          }
        } // if oldValue != newValue

      };

      while (i--) {
        var _ret2 = _loop();

        if (_ret2 === "continue") continue;
      } // for each elem

    };
    /**
    * Change the given/selected element and add the original value to the history stack.
    * If you want to change all `selectedElements`, ignore the `elems` argument.
    * If you want to change only a subset of `selectedElements`, then send the
    * subset to this function in the `elems` argument.
    * @function module:svgcanvas.SvgCanvas#changeSelectedAttribute
    * @param {string} attr - String with the attribute name
    * @param {string|Float} val - String or number with the new attribute value
    * @param {Element[]} elems - The DOM elements to apply the change to
    * @returns {void}
    */


    var changeSelectedAttribute = this.changeSelectedAttribute = function (attr, val, elems) {
      elems = elems || selectedElements;
      canvas.undoMgr.beginUndoableChange(attr, elems); // const i = elems.length;

      changeSelectedAttributeNoUndo(attr, val, elems);
      var batchCmd = canvas.undoMgr.finishUndoableChange();

      if (!batchCmd.isEmpty()) {
        addCommandToHistory(batchCmd);
      }
    };
    /**
    * Removes all selected elements from the DOM and adds the change to the
    * history stack.
    * @function module:svgcanvas.SvgCanvas#deleteSelectedElements
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.deleteSelectedElements = function () {
      var batchCmd = new BatchCommand$1('Delete Elements');
      var len = selectedElements.length;
      var selectedCopy = []; // selectedElements is being deleted

      for (var i = 0; i < len; ++i) {
        var selected = selectedElements[i];

        if (isNullish(selected)) {
          break;
        }

        var parent = selected.parentNode;
        var t = selected; // this will unselect the element and remove the selectedOutline

        selectorManager.releaseSelector(t); // Remove the path if present.

        removePath_(t.id); // Get the parent if it's a single-child anchor

        if (parent.tagName === 'a' && parent.childNodes.length === 1) {
          t = parent;
          parent = parent.parentNode;
        }

        var _t = t,
            nextSibling = _t.nextSibling;
        t.remove();
        var elem = t;
        selectedCopy.push(selected); // for the copy

        batchCmd.addSubCommand(new RemoveElementCommand$1(elem, nextSibling, parent));
      }

      selectedElements = [];

      if (!batchCmd.isEmpty()) {
        addCommandToHistory(batchCmd);
      }

      call('changed', selectedCopy);
      clearSelection();
    };
    /**
    * Removes all selected elements from the DOM and adds the change to the
    * history stack. Remembers removed elements on the clipboard.
    * @function module:svgcanvas.SvgCanvas#cutSelectedElements
    * @returns {void}
    */


    this.cutSelectedElements = function () {
      canvas.copySelectedElements();
      canvas.deleteSelectedElements();
    };

    var CLIPBOARD_ID = 'svgedit_clipboard';
    /**
    * Flash the clipboard data momentarily on localStorage so all tabs can see.
    * @returns {void}
    */

    function flashStorage() {
      var data = sessionStorage.getItem(CLIPBOARD_ID);
      localStorage.setItem(CLIPBOARD_ID, data);
      setTimeout(function () {
        localStorage.removeItem(CLIPBOARD_ID);
      }, 1);
    }
    /**
    * Transfers sessionStorage from one tab to another.
    * @param {!Event} ev Storage event.
    * @returns {void}
    */


    function storageChange(ev) {
      if (!ev.newValue) return; // This is a call from removeItem.

      if (ev.key === CLIPBOARD_ID + '_startup') {
        // Another tab asked for our sessionStorage.
        localStorage.removeItem(CLIPBOARD_ID + '_startup');
        flashStorage();
      } else if (ev.key === CLIPBOARD_ID) {
        // Another tab sent data.
        sessionStorage.setItem(CLIPBOARD_ID, ev.newValue);
      }
    } // Listen for changes to localStorage.


    window.addEventListener('storage', storageChange, false); // Ask other tabs for sessionStorage (this is ONLY to trigger event).

    localStorage.setItem(CLIPBOARD_ID + '_startup', Math.random());
    /**
    * Remembers the current selected elements on the clipboard.
    * @function module:svgcanvas.SvgCanvas#copySelectedElements
    * @returns {void}
    */

    this.copySelectedElements = function () {
      var data = JSON.stringify(selectedElements.map(function (x) {
        return getJsonFromSvgElement(x);
      })); // Use sessionStorage for the clipboard data.

      sessionStorage.setItem(CLIPBOARD_ID, data);
      flashStorage();
      var menu = $$a('#cmenu_canvas'); // Context menu might not exist (it is provided by editor.js).

      if (menu.enableContextMenuItems) {
        menu.enableContextMenuItems('#paste,#paste_in_place');
      }
    };
    /**
    * @function module:svgcanvas.SvgCanvas#pasteElements
    * @param {"in_place"|"point"|void} type
    * @param {Integer|void} x Expected if type is "point"
    * @param {Integer|void} y Expected if type is "point"
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @fires module:svgcanvas.SvgCanvas#event:ext_IDsUpdated
    * @returns {void}
    */


    this.pasteElements = function (type, x, y) {
      var clipb = JSON.parse(sessionStorage.getItem(CLIPBOARD_ID));
      if (!clipb) return;
      var len = clipb.length;
      if (!len) return;
      var pasted = [];
      var batchCmd = new BatchCommand$1('Paste elements'); // const drawing = getCurrentDrawing();

      /**
      * @typedef {PlainObject<string, string>} module:svgcanvas.ChangedIDs
      */

      /**
       * @type {module:svgcanvas.ChangedIDs}
       */

      var changedIDs = {}; // Recursively replace IDs and record the changes

      /**
       *
       * @param {module:svgcanvas.SVGAsJSON} elem
       * @returns {void}
       */

      function checkIDs(elem) {
        if (elem.attr && elem.attr.id) {
          changedIDs[elem.attr.id] = getNextId();
          elem.attr.id = changedIDs[elem.attr.id];
        }

        if (elem.children) elem.children.forEach(function (child) {
          return checkIDs(child);
        });
      }

      clipb.forEach(function (elem) {
        return checkIDs(elem);
      }); // Give extensions like the connector extension a chance to reflect new IDs and remove invalid elements

      /**
      * Triggered when `pasteElements` is called from a paste action (context menu or key).
      * @event module:svgcanvas.SvgCanvas#event:ext_IDsUpdated
      * @type {PlainObject}
      * @property {module:svgcanvas.SVGAsJSON[]} elems
      * @property {module:svgcanvas.ChangedIDs} changes Maps past ID (on attribute) to current ID
      */

      runExtensions('IDsUpdated',
      /** @type {module:svgcanvas.SvgCanvas#event:ext_IDsUpdated} */
      {
        elems: clipb,
        changes: changedIDs
      }, true).forEach(function (extChanges) {
        if (!extChanges || !('remove' in extChanges)) return;
        extChanges.remove.forEach(function (removeID) {
          clipb = clipb.filter(function (clipBoardItem) {
            return clipBoardItem.attr.id !== removeID;
          });
        });
      }); // Move elements to lastClickPoint

      while (len--) {
        var elem = clipb[len];

        if (!elem) {
          continue;
        }

        var copy = addSVGElementFromJson(elem);
        pasted.push(copy);
        batchCmd.addSubCommand(new InsertElementCommand$1(copy));
        restoreRefElems(copy);
      }

      selectOnly(pasted);

      if (type !== 'in_place') {
        var ctrX, ctrY;

        if (!type) {
          ctrX = lastClickPoint.x;
          ctrY = lastClickPoint.y;
        } else if (type === 'point') {
          ctrX = x;
          ctrY = y;
        }

        var bbox = getStrokedBBoxDefaultVisible(pasted);
        var cx = ctrX - (bbox.x + bbox.width / 2),
            cy = ctrY - (bbox.y + bbox.height / 2),
            dx = [],
            dy = [];
        $$a.each(pasted, function (i, item) {
          dx.push(cx);
          dy.push(cy);
        });
        var cmd = canvas.moveSelectedElements(dx, dy, false);
        if (cmd) batchCmd.addSubCommand(cmd);
      }

      addCommandToHistory(batchCmd);
      call('changed', pasted);
    };
    /**
    * Wraps all the selected elements in a group (`g`) element.
    * @function module:svgcanvas.SvgCanvas#groupSelectedElements
    * @param {"a"|"g"} [type="g"] - type of element to group into, defaults to `<g>`
    * @param {string} [urlArg]
    * @returns {void}
    */


    this.groupSelectedElements = function (type, urlArg) {
      if (!type) {
        type = 'g';
      }

      var cmdStr = '';
      var url;

      switch (type) {
        case 'a':
          {
            cmdStr = 'Make hyperlink';
            url = urlArg || '';
            break;
          }

        default:
          {
            type = 'g';
            cmdStr = 'Group Elements';
            break;
          }
      }

      var batchCmd = new BatchCommand$1(cmdStr); // create and insert the group element

      var g = addSVGElementFromJson({
        element: type,
        attr: {
          id: getNextId()
        }
      });

      if (type === 'a') {
        setHref(g, url);
      }

      batchCmd.addSubCommand(new InsertElementCommand$1(g)); // now move all children into the group

      var i = selectedElements.length;

      while (i--) {
        var elem = selectedElements[i];

        if (isNullish(elem)) {
          continue;
        }

        if (elem.parentNode.tagName === 'a' && elem.parentNode.childNodes.length === 1) {
          elem = elem.parentNode;
        }

        var oldNextSibling = elem.nextSibling;
        var oldParent = elem.parentNode;
        g.append(elem);
        batchCmd.addSubCommand(new MoveElementCommand$1(elem, oldNextSibling, oldParent));
      }

      if (!batchCmd.isEmpty()) {
        addCommandToHistory(batchCmd);
      } // update selection


      selectOnly([g], true);
    };
    /**
    * Pushes all appropriate parent group properties down to its children, then
    * removes them from the group.
    * @function module:svgcanvas.SvgCanvas#pushGroupProperties
    * @param {SVGAElement|SVGGElement} g
    * @param {boolean} undoable
    * @returns {BatchCommand|void}
    */


    var pushGroupProperties = this.pushGroupProperties = function (g, undoable) {
      var children = g.childNodes;
      var len = children.length;
      var xform = g.getAttribute('transform');
      var glist = getTransformList(g);
      var m = transformListToTransform(glist).matrix;
      var batchCmd = new BatchCommand$1('Push group properties'); // TODO: get all fill/stroke properties from the group that we are about to destroy
      // "fill", "fill-opacity", "fill-rule", "stroke", "stroke-dasharray", "stroke-dashoffset",
      // "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity",
      // "stroke-width"
      // and then for each child, if they do not have the attribute (or the value is 'inherit')
      // then set the child's attribute

      var gangle = getRotationAngle(g);
      var gattrs = $$a(g).attr(['filter', 'opacity']);
      var gfilter, gblur, changes;
      var drawing = getCurrentDrawing();

      for (var i = 0; i < len; i++) {
        var elem = children[i];

        if (elem.nodeType !== 1) {
          continue;
        }

        if (gattrs.opacity !== null && gattrs.opacity !== 1) {
          // const c_opac = elem.getAttribute('opacity') || 1;
          var newOpac = Math.round((elem.getAttribute('opacity') || 1) * gattrs.opacity * 100) / 100;
          changeSelectedAttribute('opacity', newOpac, [elem]);
        }

        if (gattrs.filter) {
          var cblur = this.getBlur(elem);
          var origCblur = cblur;

          if (!gblur) {
            gblur = this.getBlur(g);
          }

          if (cblur) {
            // Is this formula correct?
            cblur = Number(gblur) + Number(cblur);
          } else if (cblur === 0) {
            cblur = gblur;
          } // If child has no current filter, get group's filter or clone it.


          if (!origCblur) {
            // Set group's filter to use first child's ID
            if (!gfilter) {
              gfilter = getRefElem(gattrs.filter);
            } else {
              // Clone the group's filter
              gfilter = drawing.copyElem(gfilter);
              findDefs().append(gfilter);
            }
          } else {
            gfilter = getRefElem(elem.getAttribute('filter'));
          } // Change this in future for different filters


          var suffix = gfilter.firstChild.tagName === 'feGaussianBlur' ? 'blur' : 'filter';
          gfilter.id = elem.id + '_' + suffix;
          changeSelectedAttribute('filter', 'url(#' + gfilter.id + ')', [elem]); // Update blur value

          if (cblur) {
            changeSelectedAttribute('stdDeviation', cblur, [gfilter.firstChild]);
            canvas.setBlurOffsets(gfilter, cblur);
          }
        }

        var chtlist = getTransformList(elem); // Don't process gradient transforms

        if (elem.tagName.includes('Gradient')) {
          chtlist = null;
        } // Hopefully not a problem to add this. Necessary for elements like <desc/>


        if (!chtlist) {
          continue;
        } // Apparently <defs> can get get a transformlist, but we don't want it to have one!


        if (elem.tagName === 'defs') {
          continue;
        }

        if (glist.numberOfItems) {
          // TODO: if the group's transform is just a rotate, we can always transfer the
          // rotate() down to the children (collapsing consecutive rotates and factoring
          // out any translates)
          if (gangle && glist.numberOfItems === 1) {
            // [Rg] [Rc] [Mc]
            // we want [Tr] [Rc2] [Mc] where:
            //  - [Rc2] is at the child's current center but has the
            // sum of the group and child's rotation angles
            //  - [Tr] is the equivalent translation that this child
            // undergoes if the group wasn't there
            // [Tr] = [Rg] [Rc] [Rc2_inv]
            // get group's rotation matrix (Rg)
            var rgm = glist.getItem(0).matrix; // get child's rotation matrix (Rc)

            var rcm = svgroot.createSVGMatrix();
            var cangle = getRotationAngle(elem);

            if (cangle) {
              rcm = chtlist.getItem(0).matrix;
            } // get child's old center of rotation


            var cbox = getBBox(elem);
            var ceqm = transformListToTransform(chtlist).matrix;
            var coldc = transformPoint(cbox.x + cbox.width / 2, cbox.y + cbox.height / 2, ceqm); // sum group and child's angles

            var sangle = gangle + cangle; // get child's rotation at the old center (Rc2_inv)

            var r2 = svgroot.createSVGTransform();
            r2.setRotate(sangle, coldc.x, coldc.y); // calculate equivalent translate

            var trm = matrixMultiply(rgm, rcm, r2.matrix.inverse()); // set up tlist

            if (cangle) {
              chtlist.removeItem(0);
            }

            if (sangle) {
              if (chtlist.numberOfItems) {
                chtlist.insertItemBefore(r2, 0);
              } else {
                chtlist.appendItem(r2);
              }
            }

            if (trm.e || trm.f) {
              var tr = svgroot.createSVGTransform();
              tr.setTranslate(trm.e, trm.f);

              if (chtlist.numberOfItems) {
                chtlist.insertItemBefore(tr, 0);
              } else {
                chtlist.appendItem(tr);
              }
            }
          } else {
            // more complicated than just a rotate
            // transfer the group's transform down to each child and then
            // call recalculateDimensions()
            var oldxform = elem.getAttribute('transform');
            changes = {};
            changes.transform = oldxform || '';
            var newxform = svgroot.createSVGTransform(); // [ gm ] [ chm ] = [ chm ] [ gm' ]
            // [ gm' ] = [ chmInv ] [ gm ] [ chm ]

            var chm = transformListToTransform(chtlist).matrix,
                chmInv = chm.inverse();
            var gm = matrixMultiply(chmInv, m, chm);
            newxform.setMatrix(gm);
            chtlist.appendItem(newxform);
          }

          var cmd = recalculateDimensions(elem);

          if (cmd) {
            batchCmd.addSubCommand(cmd);
          }
        }
      } // remove transform and make it undo-able


      if (xform) {
        changes = {};
        changes.transform = xform;
        g.setAttribute('transform', '');
        g.removeAttribute('transform');
        batchCmd.addSubCommand(new ChangeElementCommand$1(g, changes));
      }

      if (undoable && !batchCmd.isEmpty()) {
        return batchCmd;
      }

      return undefined;
    };
    /**
    * Unwraps all the elements in a selected group (`g`) element. This requires
    * significant recalculations to apply group's transforms, etc. to its children.
    * @function module:svgcanvas.SvgCanvas#ungroupSelectedElement
    * @returns {void}
    */


    this.ungroupSelectedElement = function () {
      var g = selectedElements[0];

      if (!g) {
        return;
      }

      if ($$a(g).data('gsvg') || $$a(g).data('symbol')) {
        // Is svg, so actually convert to group
        convertToGroup(g);
        return;
      }

      if (g.tagName === 'use') {
        // Somehow doesn't have data set, so retrieve
        var symbol = getElem(getHref(g).substr(1));
        $$a(g).data('symbol', symbol).data('ref', symbol);
        convertToGroup(g);
        return;
      }

      var parentsA = $$a(g).parents('a');

      if (parentsA.length) {
        g = parentsA[0];
      } // Look for parent "a"


      if (g.tagName === 'g' || g.tagName === 'a') {
        var batchCmd = new BatchCommand$1('Ungroup Elements');
        var cmd = pushGroupProperties(g, true);

        if (cmd) {
          batchCmd.addSubCommand(cmd);
        }

        var parent = g.parentNode;
        var anchor = g.nextSibling;
        var children = new Array(g.childNodes.length);
        var i = 0;

        while (g.firstChild) {
          var elem = g.firstChild;
          var oldNextSibling = elem.nextSibling;
          var oldParent = elem.parentNode; // Remove child title elements

          if (elem.tagName === 'title') {
            var nextSibling = elem.nextSibling;
            batchCmd.addSubCommand(new RemoveElementCommand$1(elem, nextSibling, oldParent));
            elem.remove();
            continue;
          }

          if (anchor) {
            anchor.before(elem);
          } else {
            g.after(elem);
          }

          children[i++] = elem;
          batchCmd.addSubCommand(new MoveElementCommand$1(elem, oldNextSibling, oldParent));
        } // remove the group from the selection


        clearSelection(); // delete the group element (but make undo-able)

        var gNextSibling = g.nextSibling;
        g.remove();
        batchCmd.addSubCommand(new RemoveElementCommand$1(g, gNextSibling, parent));

        if (!batchCmd.isEmpty()) {
          addCommandToHistory(batchCmd);
        } // update selection


        addToSelection(children);
      }
    };
    /**
    * Repositions the selected element to the bottom in the DOM to appear on top of
    * other elements.
    * @function module:svgcanvas.SvgCanvas#moveToTopSelectedElement
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.moveToTopSelectedElement = function () {
      var _selectedElements = selectedElements,
          _selectedElements2 = _slicedToArray(_selectedElements, 1),
          selected = _selectedElements2[0];

      if (!isNullish(selected)) {
        var t = selected;
        var oldParent = t.parentNode;
        var oldNextSibling = t.nextSibling;
        t = t.parentNode.appendChild(t); // If the element actually moved position, add the command and fire the changed
        // event handler.

        if (oldNextSibling !== t.nextSibling) {
          addCommandToHistory(new MoveElementCommand$1(t, oldNextSibling, oldParent, 'top'));
          call('changed', [t]);
        }
      }
    };
    /**
    * Repositions the selected element to the top in the DOM to appear under
    * other elements.
    * @function module:svgcanvas.SvgCanvas#moveToBottomSelectedElement
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.moveToBottomSelectedElement = function () {
      var _selectedElements3 = selectedElements,
          _selectedElements4 = _slicedToArray(_selectedElements3, 1),
          selected = _selectedElements4[0];

      if (!isNullish(selected)) {
        var t = selected;
        var oldParent = t.parentNode;
        var oldNextSibling = t.nextSibling;
        var firstChild = t.parentNode.firstChild;

        if (firstChild.tagName === 'title') {
          firstChild = firstChild.nextSibling;
        } // This can probably be removed, as the defs should not ever apppear
        // inside a layer group


        if (firstChild.tagName === 'defs') {
          firstChild = firstChild.nextSibling;
        }

        t = t.parentNode.insertBefore(t, firstChild); // If the element actually moved position, add the command and fire the changed
        // event handler.

        if (oldNextSibling !== t.nextSibling) {
          addCommandToHistory(new MoveElementCommand$1(t, oldNextSibling, oldParent, 'bottom'));
          call('changed', [t]);
        }
      }
    };
    /**
    * Moves the select element up or down the stack, based on the visibly
    * intersecting elements.
    * @function module:svgcanvas.SvgCanvas#moveUpDownSelected
    * @param {"Up"|"Down"} dir - String that's either 'Up' or 'Down'
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {void}
    */


    this.moveUpDownSelected = function (dir) {
      var selected = selectedElements[0];

      if (!selected) {
        return;
      }

      curBBoxes = [];
      var closest, foundCur; // jQuery sorts this list

      var list = $$a(getIntersectionList(getStrokedBBoxDefaultVisible([selected]))).toArray();

      if (dir === 'Down') {
        list.reverse();
      }

      $$a.each(list, function () {
        if (!foundCur) {
          if (this === selected) {
            foundCur = true;
          }

          return true;
        }

        closest = this;
        return false;
      });

      if (!closest) {
        return;
      }

      var t = selected;
      var oldParent = t.parentNode;
      var oldNextSibling = t.nextSibling;
      $$a(closest)[dir === 'Down' ? 'before' : 'after'](t); // If the element actually moved position, add the command and fire the changed
      // event handler.

      if (oldNextSibling !== t.nextSibling) {
        addCommandToHistory(new MoveElementCommand$1(t, oldNextSibling, oldParent, 'Move ' + dir));
        call('changed', [t]);
      }
    };
    /**
    * Moves selected elements on the X/Y axis.
    * @function module:svgcanvas.SvgCanvas#moveSelectedElements
    * @param {Float} dx - Float with the distance to move on the x-axis
    * @param {Float} dy - Float with the distance to move on the y-axis
    * @param {boolean} undoable - Boolean indicating whether or not the action should be undoable
    * @fires module:svgcanvas.SvgCanvas#event:changed
    * @returns {BatchCommand|void} Batch command for the move
    */


    this.moveSelectedElements = function (dx, dy, undoable) {
      // if undoable is not sent, default to true
      // if single values, scale them to the zoom
      if (dx.constructor !== Array) {
        dx /= currentZoom;
        dy /= currentZoom;
      }

      undoable = undoable || true;
      var batchCmd = new BatchCommand$1('position');
      var i = selectedElements.length;

      while (i--) {
        var selected = selectedElements[i];

        if (!isNullish(selected)) {
          // if (i === 0) {
          //   selectedBBoxes[0] = utilsGetBBox(selected);
          // }
          // const b = {};
          // for (const j in selectedBBoxes[i]) b[j] = selectedBBoxes[i][j];
          // selectedBBoxes[i] = b;
          var xform = svgroot.createSVGTransform();
          var tlist = getTransformList(selected); // dx and dy could be arrays

          if (dx.constructor === Array) {
            // if (i === 0) {
            //   selectedBBoxes[0].x += dx[0];
            //   selectedBBoxes[0].y += dy[0];
            // }
            xform.setTranslate(dx[i], dy[i]);
          } else {
            // if (i === 0) {
            //   selectedBBoxes[0].x += dx;
            //   selectedBBoxes[0].y += dy;
            // }
            xform.setTranslate(dx, dy);
          }

          if (tlist.numberOfItems) {
            tlist.insertItemBefore(xform, 0);
          } else {
            tlist.appendItem(xform);
          }

          var cmd = recalculateDimensions(selected);

          if (cmd) {
            batchCmd.addSubCommand(cmd);
          }

          selectorManager.requestSelector(selected).resize();
        }
      }

      if (!batchCmd.isEmpty()) {
        if (undoable) {
          addCommandToHistory(batchCmd);
        }

        call('changed', selectedElements);
        return batchCmd;
      }

      return undefined;
    };
    /**
    * Create deep DOM copies (clones) of all selected elements and move them slightly
    * from their originals.
    * @function module:svgcanvas.SvgCanvas#cloneSelectedElements
    * @param {Float} x Float with the distance to move on the x-axis
    * @param {Float} y Float with the distance to move on the y-axis
    * @returns {void}
    */


    this.cloneSelectedElements = function (x, y) {
      var i, elem;
      var batchCmd = new BatchCommand$1('Clone Elements'); // find all the elements selected (stop at first null)

      var len = selectedElements.length;
      /**
       * Sorts an array numerically and ascending.
       * @param {Element} a
       * @param {Element} b
       * @returns {Integer}
       */

      function sortfunction(a, b) {
        return $$a(b).index() - $$a(a).index();
      }

      selectedElements.sort(sortfunction);

      for (i = 0; i < len; ++i) {
        elem = selectedElements[i];

        if (isNullish(elem)) {
          break;
        }
      } // use slice to quickly get the subset of elements we need


      var copiedElements = selectedElements.slice(0, i);
      this.clearSelection(true); // note that we loop in the reverse way because of the way elements are added
      // to the selectedElements array (top-first)

      var drawing = getCurrentDrawing();
      i = copiedElements.length;

      while (i--) {
        // clone each element and replace it within copiedElements
        elem = copiedElements[i] = drawing.copyElem(copiedElements[i]);
        (currentGroup || drawing.getCurrentLayer()).append(elem);
        batchCmd.addSubCommand(new InsertElementCommand$1(elem));
      }

      if (!batchCmd.isEmpty()) {
        addToSelection(copiedElements.reverse()); // Need to reverse for correct selection-adding

        this.moveSelectedElements(x, y, false);
        addCommandToHistory(batchCmd);
      }
    };
    /**
    * Aligns selected elements.
    * @function module:svgcanvas.SvgCanvas#alignSelectedElements
    * @param {string} type - String with single character indicating the alignment type
    * @param {"selected"|"largest"|"smallest"|"page"} relativeTo
    * @returns {void}
    */


    this.alignSelectedElements = function (type, relativeTo) {
      var bboxes = []; // angles = [];

      var len = selectedElements.length;

      if (!len) {
        return;
      }

      var minx = Number.MAX_VALUE,
          maxx = Number.MIN_VALUE,
          miny = Number.MAX_VALUE,
          maxy = Number.MIN_VALUE;
      var curwidth = Number.MIN_VALUE,
          curheight = Number.MIN_VALUE;

      for (var i = 0; i < len; ++i) {
        if (isNullish(selectedElements[i])) {
          break;
        }

        var elem = selectedElements[i];
        bboxes[i] = getStrokedBBoxDefaultVisible([elem]); // now bbox is axis-aligned and handles rotation

        switch (relativeTo) {
          case 'smallest':
            if ((type === 'l' || type === 'c' || type === 'r') && (curwidth === Number.MIN_VALUE || curwidth > bboxes[i].width) || (type === 't' || type === 'm' || type === 'b') && (curheight === Number.MIN_VALUE || curheight > bboxes[i].height)) {
              minx = bboxes[i].x;
              miny = bboxes[i].y;
              maxx = bboxes[i].x + bboxes[i].width;
              maxy = bboxes[i].y + bboxes[i].height;
              curwidth = bboxes[i].width;
              curheight = bboxes[i].height;
            }

            break;

          case 'largest':
            if ((type === 'l' || type === 'c' || type === 'r') && (curwidth === Number.MIN_VALUE || curwidth < bboxes[i].width) || (type === 't' || type === 'm' || type === 'b') && (curheight === Number.MIN_VALUE || curheight < bboxes[i].height)) {
              minx = bboxes[i].x;
              miny = bboxes[i].y;
              maxx = bboxes[i].x + bboxes[i].width;
              maxy = bboxes[i].y + bboxes[i].height;
              curwidth = bboxes[i].width;
              curheight = bboxes[i].height;
            }

            break;

          default:
            // 'selected'
            if (bboxes[i].x < minx) {
              minx = bboxes[i].x;
            }

            if (bboxes[i].y < miny) {
              miny = bboxes[i].y;
            }

            if (bboxes[i].x + bboxes[i].width > maxx) {
              maxx = bboxes[i].x + bboxes[i].width;
            }

            if (bboxes[i].y + bboxes[i].height > maxy) {
              maxy = bboxes[i].y + bboxes[i].height;
            }

            break;
        }
      } // loop for each element to find the bbox and adjust min/max


      if (relativeTo === 'page') {
        minx = 0;
        miny = 0;
        maxx = canvas.contentW;
        maxy = canvas.contentH;
      }

      var dx = new Array(len);
      var dy = new Array(len);

      for (var _i6 = 0; _i6 < len; ++_i6) {
        if (isNullish(selectedElements[_i6])) {
          break;
        } // const elem = selectedElements[i];


        var bbox = bboxes[_i6];
        dx[_i6] = 0;
        dy[_i6] = 0;

        switch (type) {
          case 'l':
            // left (horizontal)
            dx[_i6] = minx - bbox.x;
            break;

          case 'c':
            // center (horizontal)
            dx[_i6] = (minx + maxx) / 2 - (bbox.x + bbox.width / 2);
            break;

          case 'r':
            // right (horizontal)
            dx[_i6] = maxx - (bbox.x + bbox.width);
            break;

          case 't':
            // top (vertical)
            dy[_i6] = miny - bbox.y;
            break;

          case 'm':
            // middle (vertical)
            dy[_i6] = (miny + maxy) / 2 - (bbox.y + bbox.height / 2);
            break;

          case 'b':
            // bottom (vertical)
            dy[_i6] = maxy - (bbox.y + bbox.height);
            break;
        }
      }

      this.moveSelectedElements(dx, dy);
    };
    /**
    * Group: Additional editor tools.
    */

    /**
    * @name module:svgcanvas.SvgCanvas#contentW
    * @type {Float}
    */


    this.contentW = getResolution().w;
    /**
    * @name module:svgcanvas.SvgCanvas#contentH
    * @type {Float}
    */

    this.contentH = getResolution().h;
    /**
    * @typedef {PlainObject} module:svgcanvas.CanvasInfo
    * @property {Float} x - The canvas' new x coordinate
    * @property {Float} y - The canvas' new y coordinate
    * @property {string} oldX - The canvas' old x coordinate
    * @property {string} oldY - The canvas' old y coordinate
    * @property {Float} d_x - The x position difference
    * @property {Float} d_y - The y position difference
    */

    /**
    * Updates the editor canvas width/height/position after a zoom has occurred.
    * @function module:svgcanvas.SvgCanvas#updateCanvas
    * @param {Float} w - Float with the new width
    * @param {Float} h - Float with the new height
    * @fires module:svgcanvas.SvgCanvas#event:ext_canvasUpdated
    * @returns {module:svgcanvas.CanvasInfo}
    */

    this.updateCanvas = function (w, h) {
      svgroot.setAttribute('width', w);
      svgroot.setAttribute('height', h);
      var bg = $$a('#canvasBackground')[0];
      var oldX = svgcontent.getAttribute('x');
      var oldY = svgcontent.getAttribute('y');
      var x = (w - this.contentW * currentZoom) / 2;
      var y = (h - this.contentH * currentZoom) / 2;
      assignAttributes(svgcontent, {
        width: this.contentW * currentZoom,
        height: this.contentH * currentZoom,
        x: x,
        y: y,
        viewBox: '0 0 ' + this.contentW + ' ' + this.contentH
      });
      assignAttributes(bg, {
        width: svgcontent.getAttribute('width'),
        height: svgcontent.getAttribute('height'),
        x: x,
        y: y
      });
      var bgImg = getElem('background_image');

      if (bgImg) {
        assignAttributes(bgImg, {
          width: '100%',
          height: '100%'
        });
      }

      selectorManager.selectorParentGroup.setAttribute('transform', 'translate(' + x + ',' + y + ')');
      /**
      * Invoked upon updates to the canvas.
      * @event module:svgcanvas.SvgCanvas#event:ext_canvasUpdated
      * @type {PlainObject}
      * @property {Integer} new_x
      * @property {Integer} new_y
      * @property {string} old_x (Of Integer)
      * @property {string} old_y (Of Integer)
      * @property {Integer} d_x
      * @property {Integer} d_y
      */

      runExtensions('canvasUpdated',
      /**
       * @type {module:svgcanvas.SvgCanvas#event:ext_canvasUpdated}
       */
      {
        new_x: x,
        new_y: y,
        old_x: oldX,
        old_y: oldY,
        d_x: x - oldX,
        d_y: y - oldY
      });
      return {
        x: x,
        y: y,
        old_x: oldX,
        old_y: oldY,
        d_x: x - oldX,
        d_y: y - oldY
      };
    };
    /**
    * Set the background of the editor (NOT the actual document).
    * @function module:svgcanvas.SvgCanvas#setBackground
    * @param {string} color - String with fill color to apply
    * @param {string} url - URL or path to image to use
    * @returns {void}
    */


    this.setBackground = function (color, url) {
      var bg = getElem('canvasBackground');
      var border = $$a(bg).find('rect')[0];
      var bgImg = getElem('background_image');
      var bgPattern = getElem('background_pattern');
      border.setAttribute('fill', color === 'chessboard' ? '#fff' : color);

      if (color === 'chessboard') {
        if (!bgPattern) {
          bgPattern = svgdoc.createElementNS(NS.SVG, 'foreignObject');
          assignAttributes(bgPattern, {
            id: 'background_pattern',
            width: '100%',
            height: '100%',
            preserveAspectRatio: 'xMinYMin',
            style: 'pointer-events:none'
          });
          var div = document.createElement('div');
          assignAttributes(div, {
            style: 'pointer-events:none;width:100%;height:100%;' + 'background-image:url(data:image/gif;base64,' + 'R0lGODlhEAAQAIAAAP///9bW1iH5BAAAAAAALAAAAAAQABAAAAIfjG+' + 'gq4jM3IFLJgpswNly/XkcBpIiVaInlLJr9FZWAQA7);'
          });
          bgPattern.appendChild(div);
          bg.append(bgPattern);
        }
      } else if (bgPattern) {
        bgPattern.remove();
      }

      if (url) {
        if (!bgImg) {
          bgImg = svgdoc.createElementNS(NS.SVG, 'image');
          assignAttributes(bgImg, {
            id: 'background_image',
            width: '100%',
            height: '100%',
            preserveAspectRatio: 'xMinYMin',
            style: 'pointer-events:none'
          });
        }

        setHref(bgImg, url);
        bg.append(bgImg);
      } else if (bgImg) {
        bgImg.remove();
      }
    };
    /**
    * Select the next/previous element within the current layer.
    * @function module:svgcanvas.SvgCanvas#cycleElement
    * @param {boolean} next - true = next and false = previous element
    * @fires module:svgcanvas.SvgCanvas#event:selected
    * @returns {void}
    */


    this.cycleElement = function (next) {
      var num;
      var curElem = selectedElements[0];
      var elem = false;
      var allElems = getVisibleElements(currentGroup || getCurrentDrawing().getCurrentLayer());

      if (!allElems.length) {
        return;
      }

      if (isNullish(curElem)) {
        num = next ? allElems.length - 1 : 0;
        elem = allElems[num];
      } else {
        var i = allElems.length;

        while (i--) {
          if (allElems[i] === curElem) {
            num = next ? i - 1 : i + 1;

            if (num >= allElems.length) {
              num = 0;
            } else if (num < 0) {
              num = allElems.length - 1;
            }

            elem = allElems[num];
            break;
          }
        }
      }

      selectOnly([elem], true);
      call('selected', selectedElements);
    };

    this.clear();
    /**
    * @interface module:svgcanvas.PrivateMethods
    * @type {PlainObject}
    * @property {module:svgcanvas~addCommandToHistory} addCommandToHistory
    * @property {module:history.HistoryCommand} BatchCommand
    * @property {module:history.HistoryCommand} ChangeElementCommand
    * @property {module:utilities.decode64} decode64
    * @property {module:utilities.dropXMLInternalSubset} dropXMLInternalSubset
    * @property {module:utilities.encode64} encode64
    * @property {module:svgcanvas~ffClone} ffClone
    * @property {module:svgcanvas~findDuplicateGradient} findDuplicateGradient
    * @property {module:utilities.getPathBBox} getPathBBox
    * @property {module:units.getTypeMap} getTypeMap
    * @property {module:draw.identifyLayers} identifyLayers
    * @property {module:history.HistoryCommand} InsertElementCommand
    * @property {module:browser.isChrome} isChrome
    * @property {module:math.isIdentity} isIdentity
    * @property {module:browser.isIE} isIE
    * @property {module:svgcanvas~logMatrix} logMatrix
    * @property {module:history.HistoryCommand} MoveElementCommand
    * @property {module:namespaces.NS} NS
    * @property {module:utilities.preventClickDefault} preventClickDefault
    * @property {module:history.HistoryCommand} RemoveElementCommand
    * @property {module:SVGTransformList.SVGEditTransformList} SVGEditTransformList
    * @property {module:utilities.text2xml} text2xml
    * @property {module:math.transformBox} transformBox
    * @property {module:math.transformPoint} transformPoint
    * @property {module:utilities.walkTree} walkTree
    */

    /**
    * @deprecated getPrivateMethods
    * Since all methods are/should be public somehow, this function should be removed;
    *  we might require `import` in place of this in the future once ES6 Modules
    *  widespread
    
    * Being able to access private methods publicly seems wrong somehow,
    * but currently appears to be the best way to allow testing and provide
    * access to them to plugins.
    * @function module:svgcanvas.SvgCanvas#getPrivateMethods
    * @returns {module:svgcanvas.PrivateMethods}
    */

    this.getPrivateMethods = function () {
      var obj = {
        addCommandToHistory: addCommandToHistory,
        BatchCommand: BatchCommand$1,
        ChangeElementCommand: ChangeElementCommand$1,
        decode64: decode64,
        dropXMLInternalSubset: dropXMLInternalSubset,
        encode64: encode64,
        ffClone: ffClone,
        findDefs: findDefs,
        findDuplicateGradient: findDuplicateGradient,
        getElem: getElem,
        getPathBBox: getPathBBox,
        getTypeMap: getTypeMap,
        getUrlFromAttr: getUrlFromAttr,
        identifyLayers: identifyLayers,
        InsertElementCommand: InsertElementCommand$1,
        isChrome: isChrome,
        isIdentity: isIdentity,
        isIE: isIE,
        logMatrix: logMatrix,
        MoveElementCommand: MoveElementCommand$1,
        NS: NS,
        preventClickDefault: preventClickDefault,
        RemoveElementCommand: RemoveElementCommand$1,
        SVGEditTransformList: SVGTransformList,
        text2xml: text2xml,
        transformBox: transformBox,
        transformPoint: transformPoint,
        walkTree: walkTree
      };
      return obj;
    };
  } // End constructor
  ; // End class

  // Todo: Update: https://github.com/jeresig/jquery.hotkeys

  /*
   * jQuery Hotkeys Plugin
   * Copyright 2010, John Resig
   * Dual licensed under the MIT or GPL Version 2 licenses.
   *
   * http://github.com/jeresig/jquery.hotkeys
   *
   * Based upon the plugin by Tzury Bar Yochay:
   * http://github.com/tzuryby/hotkeys
   *
   * Original idea by:
   * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
  */
  // We *do* want to allow the escape key within textareas (and possibly tab too), so add the condition `n.which !== 27`
  function jQueryPluginJSHotkeys (b) {
    b.hotkeys = {
      version: "0.8",
      specialKeys: {
        8: "backspace",
        9: "tab",
        13: "return",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "del",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        144: "numlock",
        145: "scroll",
        191: "/",
        224: "meta",
        219: "[",
        221: "]"
      },
      shiftNums: {
        "`": "~",
        "1": "!",
        "2": "@",
        "3": "#",
        "4": "$",
        "5": "%",
        "6": "^",
        "7": "&",
        "8": "*",
        "9": "(",
        "0": ")",
        "-": "_",
        "=": "+",
        ";": ": ",
        "'": '"',
        ",": "<",
        ".": ">",
        "/": "?",
        "\\": "|"
      }
    };

    function a(d) {
      if (typeof d.data !== "string") {
        return;
      }

      var c = d.handler,
          e = d.data.toLowerCase().split(" ");

      d.handler = function (n) {
        if (this !== n.target && n.which !== 27 && (/textarea|select/i.test(n.target.nodeName) || n.target.type === "text")) {
          return;
        }

        var h = n.type !== "keypress" && b.hotkeys.specialKeys[n.which],
            o = String.fromCharCode(n.which).toLowerCase(),
            m = "",
            g = {};

        if (n.altKey && h !== "alt") {
          m += "alt+";
        }

        if (n.ctrlKey && h !== "ctrl") {
          m += "ctrl+";
        }

        if (n.metaKey && !n.ctrlKey && h !== "meta") {
          m += "meta+";
        }

        if (n.shiftKey && h !== "shift") {
          m += "shift+";
        }

        if (h) {
          g[m + h] = true;
        } else {
          g[m + o] = true;
          g[m + b.hotkeys.shiftNums[o]] = true;

          if (m === "shift+") {
            g[b.hotkeys.shiftNums[o]] = true;
          }
        }

        for (var j = 0, f = e.length; j < f; j++) {
          if (g[e[j]]) {
            return c.apply(this, arguments);
          }
        }
      };
    }

    b.each(["keydown", "keyup", "keypress"], function () {
      b.event.special[this] = {
        add: a
      };
    });
    return b;
  }

  /**
   * @file SVG Icon Loader 2.0
   *
   * jQuery Plugin for loading SVG icons from a single file
   *
   * Adds {@link external:jQuery.svgIcons}, {@link external:jQuery.getSvgIcon}, {@link external:jQuery.resizeSvgIcons}
   *
   * How to use:

  1. Create the SVG master file that includes all icons:

  The master SVG icon-containing file is an SVG file that contains
  `<g>` elements. Each `<g>` element should contain the markup of an SVG
  icon. The `<g>` element has an ID that should
  correspond with the ID of the HTML element used on the page that should contain
  or optionally be replaced by the icon. Additionally, one empty element should be
  added at the end with id "svg_eof".

  2. Optionally create fallback raster images for each SVG icon.

  3. Include the jQuery and the SVG Icon Loader scripts on your page.

  4. Run `$.svgIcons()` when the document is ready. See its signature

  5. To access an icon at a later point without using the callback, use this:
    `$.getSvgIcon(id (string), uniqueClone (boolean))`;

  This will return the icon (as jQuery object) with a given ID.

  6. To resize icons at a later point without using the callback, use this:
    `$.resizeSvgIcons(resizeOptions)` (use the same way as the "resize" parameter)
   *
   * @module jQuerySVGIcons
   * @license MIT
   * @copyright (c) 2009 Alexis Deveria
   * {@link http://a.deveria.com}
   * @example
    $(function () {
       $.svgIcons('my_icon_set.svg'); // The SVG file that contains all icons
       // No options have been set, so all icons will automatically be inserted
       // into HTML elements that match the same IDs.
    });

    * @example
    $(function () {
       // The SVG file that contains all icons
       $.svgIcons('my_icon_set.svg', {
         callback (icons) { // Custom callback function that sets click
           // events for each icon
           $.each(icons, function (id, icon) {
             icon.click(function () {
               alert('You clicked on the icon with id ' + id);
             });
           });
         }
       });
     });

    * @example
     $(function () {
       // The SVGZ file that contains all icons
       $.svgIcons('my_icon_set.svgz', {
         w: 32, // All icons will be 32px wide
         h: 32, // All icons will be 32px high
         fallback_path: 'icons/', // All fallback files can be found here
         fallback: {
           '#open_icon': 'open.png', // The "open.png" will be appended to the
           // HTML element with ID "open_icon"
           '#close_icon': 'close.png',
           '#save_icon': 'save.png'
         },
         placement: {'.open_icon': 'open'}, // The "open" icon will be added
         // to all elements with class "open_icon"
         resize: {
           '#save_icon .svg_icon': 64 // The "save" icon will be resized to 64 x 64px
         },

         callback (icons) { // Sets background color for "close" icon
           icons.close.css('background', 'red');
         },

         svgz: true // Indicates that an SVGZ file is being used
       });
     });
  */
  var isOpera$1 = Boolean(window.opera);

  var fixIDs = function fixIDs(svgEl, svgNum, force) {
    var defs = svgEl.find('defs');
    if (!defs.length) return svgEl;
    var idElems;

    if (isOpera$1) {
      idElems = defs.find('*').filter(function () {
        return Boolean(this.id);
      });
    } else {
      idElems = defs.find('[id]');
    }

    var allElems = svgEl[0].getElementsByTagName('*'),
        len = allElems.length;
    idElems.each(function (i) {
      var id = this.id;
      /*
      const noDupes = ($(svgdoc).find('#' + id).length <= 1);
      if (isOpera) noDupes = false; // Opera didn't clone svgEl, so not reliable
      if(!force && noDupes) return;
      */

      var newId = 'x' + id + svgNum + i;
      this.id = newId;
      var oldVal = 'url(#' + id + ')';
      var newVal = 'url(#' + newId + ')'; // Selector method, possibly faster but fails in Opera / jQuery 1.4.3
      //  svgEl.find('[fill="url(#' + id + ')"]').each(function() {
      //    this.setAttribute('fill', 'url(#' + newId + ')');
      //  }).end().find('[stroke="url(#' + id + ')"]').each(function() {
      //    this.setAttribute('stroke', 'url(#' + newId + ')');
      //  }).end().find('use').each(function() {
      //    if(this.getAttribute('xlink:href') == '#' + id) {
      //      this.setAttributeNS(xlinkns,'href','#' + newId);
      //    }
      //  }).end().find('[filter="url(#' + id + ')"]').each(function() {
      //    this.setAttribute('filter', 'url(#' + newId + ')');
      //  });

      for (i = 0; i < len; i++) {
        var elem = allElems[i];

        if (elem.getAttribute('fill') === oldVal) {
          elem.setAttribute('fill', newVal);
        }

        if (elem.getAttribute('stroke') === oldVal) {
          elem.setAttribute('stroke', newVal);
        }

        if (elem.getAttribute('filter') === oldVal) {
          elem.setAttribute('filter', newVal);
        }
      }
    });
    return svgEl;
  };
  /**
  * @callback module:jQuerySVGIcons.SVGIconsLoadedCallback
  * @param {PlainObject<string, external:jQuery>} svgIcons IDs keyed to jQuery objects of images
  * @returns {void}
  */

  /**
   * @function module:jQuerySVGIcons.jQuerySVGIcons
   * @param {external:jQuery} $ Its keys include all icon IDs and the values, the icon as a jQuery object
   * @returns {external:jQuery} The enhanced jQuery object
  */


  function jQueryPluginSVGIcons($) {
    var svgIcons = {};
    /**
     * Map of raster images with each key being the SVG icon ID
     *   to replace, and the value the image file name.
     * @typedef {PlainObject<string, string>} external:jQuery.svgIcons.Fallback
    */

    /**
     * Map of raster images with each key being the SVG icon ID
     *   whose `alt` will be set, and the value being the `alt` text.
     * @typedef {PlainObject<string, string>} external:jQuery.svgIcons.Alts
    */

    /**
    * @function external:jQuery.svgIcons
    * @param {string} file The location of a local SVG or SVGz file
    * @param {PlainObject} [opts]
    * @param {Float} [opts.w] The icon widths
    * @param {Float} [opts.h] The icon heights
    * @param {external:jQuery.svgIcons.Fallback} [opts.fallback]
    * @param {string} [opts.fallback_path] The path to use for all images
    *   listed under "fallback"
    * @param {boolean} [opts.replace] If set to `true`, HTML elements will
    *   be replaced by, rather than include the SVG icon.
    * @param {PlainObject<string, string>} [opts.placement] Map with selectors
    *   for keys and SVG icon ids as values. This provides a custom method of
    *   adding icons.
    * @param {PlainObject<string, module:jQuerySVGIcons.Size>} [opts.resize] Map
    *   with selectors for keys and numbers as values. This allows an easy way to
    *   resize specific icons.
    * @param {module:jQuerySVGIcons.SVGIconsLoadedCallback} [opts.callback] A
    *   function to call when all icons have been loaded.
    * @param {boolean} [opts.id_match=true] Automatically attempt to match
    *   SVG icon ids with corresponding HTML id
    * @param {boolean} [opts.no_img] Prevent attempting to convert the icon
    *   into an `<img>` element (may be faster, help for browser consistency)
    * @param {boolean} [opts.svgz] Indicate that the file is an SVGZ file, and
    *   thus not to parse as XML. SVGZ files add compression benefits, but
    *   getting data from them fails in Firefox 2 and older.
    * @param {jQuery.svgIcons.Alts} [opts.alts] Map of images with each key
    *   being the SVG icon ID whose `alt` will be set, and the value being
    *   the `alt` text
    * @param {string} [opts.testIconAlt="icon"] Alt text for the injected test image.
    *   In case wish to ensure have one for accessibility
    * @returns {void}
    */

    $.svgIcons = function (file) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var svgns = 'http://www.w3.org/2000/svg',
          xlinkns = 'http://www.w3.org/1999/xlink',
          iconW = opts.w || 24,
          iconH = opts.h || 24;
      var elems,
          svgdoc,
          testImg,
          iconsMade = false,
          dataLoaded = false,
          loadAttempts = 0;
      var // ua = navigator.userAgent,
      // isSafari = (ua.includes('Safari/') && !ua.includes('Chrome/')),
      dataPre = 'data:image/svg+xml;charset=utf-8;base64,';
      var dataEl;

      if (opts.svgz) {
        dataEl = $('<object data="' + file + '" type=image/svg+xml>').appendTo('body').hide();

        try {
          svgdoc = dataEl[0].contentDocument;
          dataEl.load(getIcons);
          getIcons(0, true); // Opera will not run "load" event if file is already cached
        } catch (err1) {
          useFallback();
        }
      } else {
        var parser = new DOMParser();
        $.ajax({
          url: file,
          dataType: 'string',
          success: function success(data) {
            if (!data) {
              $(useFallback);
              return;
            }

            svgdoc = parser.parseFromString(data, 'text/xml');
            $(function () {
              getIcons('ajax');
            });
          },
          error: function error(err) {
            // TODO: Fix Opera widget icon bug
            if (window.opera) {
              $(function () {
                useFallback();
              });
            } else if (err.responseText) {
              svgdoc = parser.parseFromString(err.responseText, 'text/xml');

              if (!svgdoc.childNodes.length) {
                $(useFallback);
              }

              $(function () {
                getIcons('ajax');
              });
            } else {
              $(useFallback);
            }
          }
        });
      }
      /**
       *
       * @param {"ajax"|0|void} evt
       * @param {boolean} [noWait]
       * @returns {void}
       */


      function getIcons(evt, noWait) {
        if (evt !== 'ajax') {
          if (dataLoaded) return; // Webkit sometimes says svgdoc is undefined, other times
          // it fails to load all nodes. Thus we must make sure the "eof"
          // element is loaded.

          svgdoc = dataEl[0].contentDocument; // Needed again for Webkit

          var isReady = svgdoc && svgdoc.getElementById('svg_eof');

          if (!isReady && !(noWait && isReady)) {
            loadAttempts++;

            if (loadAttempts < 50) {
              setTimeout(getIcons, 20);
            } else {
              useFallback();
              dataLoaded = true;
            }

            return;
          }

          dataLoaded = true;
        }

        elems = $(svgdoc.firstChild).children(); // .getElementsByTagName('foreignContent');

        if (!opts.no_img) {
          var testSrc = dataPre + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zd' + 'mciIHdpZHRoPSIyNzUiIGhlaWdodD0iMjc1Ij48L3N2Zz4%3D';
          testImg = $(new Image()).attr({
            src: testSrc,
            width: 0,
            height: 0,
            alt: opts.testIconAlt || 'icon'
          }).appendTo('body').load(function () {
            // Safari 4 crashes, Opera and Chrome don't
            makeIcons(true);
          }).error(function () {
            makeIcons();
          });
        } else {
          setTimeout(function () {
            if (!iconsMade) makeIcons();
          }, 500);
        }
      }
      /**
       *
       * @param {external:jQuery} target
       * @param {external:jQuery} icon A wrapped `defs` or Image
       * @param {string} id SVG icon ID
       * @param {boolean} setID Whether to set the ID attribute (with `id`)
       * @returns {void}
       */


      function setIcon(target, icon, id, setID) {
        if (isOpera$1) icon.css('visibility', 'hidden');

        if (opts.replace) {
          if (setID) icon.attr('id', id);
          var cl = target.attr('class');
          if (cl) icon.attr('class', 'svg_icon ' + cl);

          if (!target.alt) {
            var alt = 'icon';

            if (opts.alts) {
              alt = opts.alts[id] || alt;
            }

            icon.attr('alt', alt);
          }

          target.replaceWith(icon);
        } else {
          target.append(icon);
        }

        if (isOpera$1) {
          setTimeout(function () {
            icon.removeAttr('style');
          }, 1);
        }
      }

      var holder;
      /**
       * @param {external:jQuery} icon A wrapped `defs` or Image
       * @param {string} id SVG icon ID
       * @returns {void}
       */

      function addIcon(icon, id) {
        if (opts.id_match === undefined || opts.id_match !== false) {
          setIcon(holder, icon, id, true);
        }

        svgIcons[id] = icon;
      }
      /**
       *
       * @param {boolean} [toImage]
       * @param {external:jQuery.svgIcons.Fallback} [fallback=false]
       * @returns {void}
       */


      function makeIcons() {
        var toImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (iconsMade) return;
        if (opts.no_img) toImage = false;
        var tempHolder;

        if (toImage) {
          tempHolder = $(document.createElement('div'));
          tempHolder.hide().appendTo('body');
        }

        if (fallback) {
          var path = opts.fallback_path || '';
          $.each(fallback, function (id, imgsrc) {
            holder = $('#' + id);
            var alt = 'icon';

            if (opts.alts) {
              alt = opts.alts[id] || alt;
            }

            var icon = $(new Image()).attr({
              "class": 'svg_icon',
              src: path + imgsrc,
              width: iconW,
              height: iconH,
              alt: alt
            });
            addIcon(icon, id);
          });
        } else {
          var len = elems.length;

          for (var i = 0; i < len; i++) {
            var elem = elems[i];
            var id = elem.id;
            if (id === 'svg_eof') break;
            holder = $('#' + id);
            var svgroot = document.createElementNS(svgns, 'svg'); // Per https://www.w3.org/TR/xml-names11/#defaulting, the namespace for
            // attributes should have no value.

            svgroot.setAttribute('viewBox', [0, 0, iconW, iconH].join(' '));
            var svg = elem.getElementsByTagNameNS(svgns, 'svg')[0]; // Make flexible by converting width/height to viewBox

            var w = svg.getAttribute('width');
            var h = svg.getAttribute('height');
            svg.removeAttribute('width');
            svg.removeAttribute('height');
            var vb = svg.getAttribute('viewBox');

            if (!vb) {
              svg.setAttribute('viewBox', [0, 0, w, h].join(' '));
            } // Not using jQuery to be a bit faster


            svgroot.setAttribute('xmlns', svgns);
            svgroot.setAttribute('width', iconW);
            svgroot.setAttribute('height', iconH);
            svgroot.setAttribute('xmlns:xlink', xlinkns);
            svgroot.setAttribute('class', 'svg_icon'); // Without cloning, Firefox will make another GET request.
            // With cloning, causes issue in Opera/Win/Non-EN

            if (!isOpera$1) svg = svg.cloneNode(true);
            svgroot.append(svg);
            var icon = void 0;

            if (toImage) {
              tempHolder.empty().append(svgroot);
              var str = dataPre + encode64(unescape(encodeURIComponent(new XMLSerializer().serializeToString(svgroot))));
              var alt = 'icon';

              if (opts.alts) {
                alt = opts.alts[id] || alt;
              }

              icon = $(new Image()).attr({
                "class": 'svg_icon',
                src: str,
                alt: alt
              });
            } else {
              icon = fixIDs($(svgroot), i);
            }

            addIcon(icon, id);
          }
        }

        if (opts.placement) {
          $.each(opts.placement, function (sel, id) {
            if (!svgIcons[id]) return;
            $(sel).each(function (i) {
              var copy = svgIcons[id].clone();
              if (i > 0 && !toImage) copy = fixIDs(copy, i);
              setIcon($(this), copy, id);
            });
          });
        }

        if (!fallback) {
          if (toImage) tempHolder.remove();
          if (dataEl) dataEl.remove();
          if (testImg) testImg.remove();
        }

        if (opts.resize) $.resizeSvgIcons(opts.resize);
        iconsMade = true;
        if (opts.callback) opts.callback(svgIcons);
      }
      /**
       * @returns {void}
       */


      function useFallback() {
        if (file.includes('.svgz')) {
          var regFile = file.replace('.svgz', '.svg');

          if (window.console) {
            console.log('.svgz failed, trying with .svg'); // eslint-disable-line no-console
          }

          $.svgIcons(regFile, opts);
        } else if (opts.fallback) {
          makeIcons(false, opts.fallback);
        }
      }
    };
    /**
    * @function external:jQuery.getSvgIcon
    * @param {string} id
    * @param {boolean} uniqueClone Whether to clone
    * @returns {external:jQuery} The icon (optionally cloned)
    */


    $.getSvgIcon = function (id, uniqueClone) {
      var icon = svgIcons[id];

      if (uniqueClone && icon) {
        icon = fixIDs(icon, 0).clone(true);
      }

      return icon;
    };
    /**
    * @typedef {GenericArray} module:jQuerySVGIcons.Dimensions
    * @property {Integer} length 2
    * @property {Float} 0 Width
    * @property {Float} 1 Height
    */

    /**
    * If a Float is used, it will represent width and height. Arrays contain
    *   the width and height.
    * @typedef {module:jQuerySVGIcons.Dimensions|Float} module:jQuerySVGIcons.Size
    */

    /**
    * @function external:jQuery.resizeSvgIcons
    * @param {PlainObject<string, module:jQuerySVGIcons.Size>} obj Object with
    *   selectors as keys. The values are sizes.
    * @returns {void}
    */


    $.resizeSvgIcons = function (obj) {
      // FF2 and older don't detect .svg_icon, so we change it detect svg elems instead
      var changeSel = !$('.svg_icon:first').length;
      $.each(obj, function (sel, size) {
        var arr = Array.isArray(size);
        var w = arr ? size[0] : size,
            h = arr ? size[1] : size;

        if (changeSel) {
          sel = sel.replace(/\.svg_icon/g, 'svg');
        }

        $(sel).each(function () {
          this.setAttribute('width', w);
          this.setAttribute('height', h);

          if (window.opera && window.widget) {
            this.parentNode.style.width = w + 'px';
            this.parentNode.style.height = h + 'px';
          }
        });
      });
    };

    return $;
  }

  /**
   * @file jGraduate 0.4
   *
   * jQuery Plugin for a gradient picker
   *
   * @module jGraduate
   * @copyright 2010 Jeff Schiller {@link http://blog.codedread.com/}, 2010 Alexis Deveria {@link http://a.deveria.com/}
   *
   * @license Apache-2.0
   * @example
   * // The Paint object is described below.
   * $.jGraduate.Paint(); // constructs a 'none' color
   * @example $.jGraduate.Paint({copy: o}); // creates a copy of the paint o
   * @example $.jGraduate.Paint({hex: '#rrggbb'}); // creates a solid color paint with hex = "#rrggbb"
   * @example $.jGraduate.Paint({linearGradient: o, a: 50}); // creates a linear gradient paint with opacity=0.5
   * @example $.jGraduate.Paint({radialGradient: o, a: 7}); // creates a radial gradient paint with opacity=0.07
   * @example $.jGraduate.Paint({hex: '#rrggbb', linearGradient: o}); // throws an exception?
  */

  /* eslint-disable jsdoc/require-property */

  /**
    * The jQuery namespace.
    * @external jQuery
  */

  /**
   * The jQuery plugin namespace.
   * @namespace {PlainObject} fn
   * @memberof external:jQuery
   * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins}
   */

  /* eslint-enable jsdoc/require-property */
  var ns = {
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink'
  };

  if (!window.console) {
    window.console = {
      log: function log(str) {
        /* */
      },
      dir: function dir(str) {
        /* */
      }
    };
  }
  /**
  * Adds {@link external:jQuery.jGraduate.Paint},
  * {@link external:jQuery.fn.jGraduateDefaults},
  * {@link external:jQuery.fn.jGraduate}.
  * @function module:jGraduate.jGraduate
  * @param {external:jQuery} $ The jQuery instance to wrap
  * @returns {external:jQuery}
  */


  function jQueryPluginJGraduate($) {
    /**
    * @typedef {PlainObject} module:jGraduate.jGraduatePaintOptions
    * @property {Float} [alpha]
    * @property {module:jGraduate~Paint} [copy] Copy paint object
    * @property {SVGLinearGradientElement} [linearGradient]
    * @property {SVGRadialGradientElement} [radialGradient]
    * @property {string} [solidColor]
    */

    /**
    * @memberof module:jGraduate~
    */
    var Paint =
    /**
     * @param {module:jGraduate.jGraduatePaintOptions} [opt]
    */
    function Paint(opt) {
      _classCallCheck(this, Paint);

      var options = opt || {};
      this.alpha = isNaN(options.alpha) ? 100 : options.alpha; // copy paint object

      if (options.copy) {
        /**
         * @name module:jGraduate~Paint#type
         * @type {"none"|"solidColor"|"linearGradient"|"radialGradient"}
         */
        this.type = options.copy.type;
        /**
         * Represents opacity (0-100).
         * @name module:jGraduate~Paint#alpha
         * @type {Float}
         */

        this.alpha = options.copy.alpha;
        /**
         * Represents #RRGGBB hex of color.
         * @name module:jGraduate~Paint#solidColor
         * @type {string}
         */

        this.solidColor = null;
        /**
         * @name module:jGraduate~Paint#linearGradient
         * @type {SVGLinearGradientElement}
         */

        this.linearGradient = null;
        /**
         * @name module:jGraduate~Paint#radialGradient
         * @type {SVGRadialGradientElement}
         */

        this.radialGradient = null;

        switch (this.type) {
          case 'none':
            break;

          case 'solidColor':
            this.solidColor = options.copy.solidColor;
            break;

          case 'linearGradient':
            this.linearGradient = options.copy.linearGradient.cloneNode(true);
            break;

          case 'radialGradient':
            this.radialGradient = options.copy.radialGradient.cloneNode(true);
            break;
        } // create linear gradient paint

      } else if (options.linearGradient) {
        this.type = 'linearGradient';
        this.solidColor = null;
        this.radialGradient = null;
        this.linearGradient = options.linearGradient.cloneNode(true); // create linear gradient paint
      } else if (options.radialGradient) {
        this.type = 'radialGradient';
        this.solidColor = null;
        this.linearGradient = null;
        this.radialGradient = options.radialGradient.cloneNode(true); // create solid color paint
      } else if (options.solidColor) {
        this.type = 'solidColor';
        this.solidColor = options.solidColor; // create empty paint
      } else {
        this.type = 'none';
        this.solidColor = null;
        this.linearGradient = null;
        this.radialGradient = null;
      }
    };
    /* eslint-disable jsdoc/require-property */

    /**
    * @namespace {PlainObject} jGraduate
    * @memberof external:jQuery
    */


    $.jGraduate =
    /** @lends external:jQuery.jGraduate */
    {
      /* eslint-enable jsdoc/require-property */

      /**
      * @class external:jQuery.jGraduate.Paint
      * @see module:jGraduate~Paint
      */
      Paint: Paint
    }; // JSDoc doesn't show this as belonging to our `module:jGraduate.Options` type,
    //   so we use `@see`

    /**
    * @namespace {module:jGraduate.Options} jGraduateDefaults
    * @memberof external:jQuery.fn
    */

    $.fn.jGraduateDefaults =
    /** @lends external:jQuery.fn.jGraduateDefaults */
    {
      /**
      * Creates an object with a 'none' color.
      * @type {external:jQuery.jGraduate.Paint}
      * @see module:jGraduate.Options
      */
      paint: new $.jGraduate.Paint(),

      /**
      * @namespace
      */
      window: {
        /**
        * @type {string}
        * @see module:jGraduate.Options
        */
        pickerTitle: 'Drag markers to pick a paint'
      },

      /**
      * @namespace
      */
      images: {
        /**
        * @type {string}
        * @see module:jGraduate.Options
        */
        clientPath: 'images/'
      },

      /**
      * @type {string}
      * @see module:jGraduate.Options
      */
      newstop: 'inverse' // same, inverse, black, white

    };
    var isGecko = navigator.userAgent.includes('Gecko/');
    /**
    * @typedef {PlainObject<string, string>} module:jGraduate.Attrs
    */

    /**
    * @param {SVGElement} elem
    * @param {module:jGraduate.Attrs} attrs
    * @returns {void}
    */

    function setAttrs(elem, attrs) {
      if (isGecko) {
        Object.entries(attrs).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              aname = _ref2[0],
              val = _ref2[1];

          elem.setAttribute(aname, val);
        });
      } else {
        Object.entries(attrs).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              aname = _ref4[0],
              val = _ref4[1];

          var prop = elem[aname];

          if (prop && prop.constructor === 'SVGLength') {
            prop.baseVal.value = val;
          } else {
            elem.setAttribute(aname, val);
          }
        });
      }
    }
    /**
    * @param {string} name
    * @param {module:jGraduate.Attrs} attrs
    * @param {Element} newparent
    * @returns {SVGElement}
    */


    function mkElem(name, attrs, newparent) {
      var elem = document.createElementNS(ns.svg, name);
      setAttrs(elem, attrs);

      if (newparent) {
        newparent.append(elem);
      }

      return elem;
    }
    /**
    * @typedef {PlainObject} module:jGraduate.ColorOpac Object may have one or both values
    * @property {string} [color] #Hex color
    * @property {Float} [opac] 0-1
    */

    /**
    * @typedef {PlainObject} module:jGraduate.Options
    * @property {module:jGraduate~Paint} [paint] A Paint object object describing the paint to display initially; defaults to a new instance without options (defaults to opaque white)
    * @property {external:Window} [window]
    * @property {string} [window.pickerTitle='Drag markers to pick a paint']
    * @property {PlainObject} [images]
    * @property {string} [images.clientPath='images/']
    * @property {"same"|"inverse"|"black"|"white"|module:jGraduate.ColorOpac} [newstop="inverse"]
    */

    /**
    * @callback external:jQuery.fn.jGraduate.OkCallback
    * @param {external:jQuery.jGraduate.Paint} paint
    * @returns {void}
    */

    /**
    * @callback external:jQuery.fn.jGraduate.CancelCallback
    * @returns {void}
    */

    /**
    * @function external:jQuery.fn.jGraduate
    * @param {module:jGraduate.Options} [options]
    * @param {external:jQuery.fn.jGraduate.OkCallback} [okCallback] Called with a Paint object when Ok is pressed
    * @param {external:jQuery.fn.jGraduate.CancelCallback} [cancelCallback] Called with no arguments when Cancel is pressed
    * @returns {external:jQuery}
    */


    $.fn.jGraduate = function (options, okCallback, cancelCallback) {
      return this.each(function () {
        var $this = $(this),
            $settings = $.extend(true, {}, $.fn.jGraduateDefaults, options || {}),
            id = $this.attr('id'),
            idref = '#' + $this.attr('id') + ' ';

        if (!idref) {
          /* await */
          $.alert('Container element must have an id attribute to maintain unique id strings for sub-elements.');
          return;
        }

        var okClicked = function okClicked() {
          switch ($this.paint.type) {
            case 'radialGradient':
              $this.paint.linearGradient = null;
              break;

            case 'linearGradient':
              $this.paint.radialGradient = null;
              break;

            case 'solidColor':
              $this.paint.radialGradient = $this.paint.linearGradient = null;
              break;
          }

          typeof $this.okCallback === 'function' && $this.okCallback($this.paint);
          $this.hide();
        };

        var cancelClicked = function cancelClicked() {
          typeof $this.cancelCallback === 'function' && $this.cancelCallback();
          $this.hide();
        };

        $.extend(true, $this, // public properties, methods, and callbacks
        {
          // make a copy of the incoming paint
          paint: new $.jGraduate.Paint({
            copy: $settings.paint
          }),
          okCallback: typeof okCallback === 'function' ? okCallback : null,
          cancelCallback: typeof cancelCallback === 'function' ? cancelCallback : null
        });
        var // pos = $this.position(),
        color = null;
        var $win = $(window);

        if ($this.paint.type === 'none') {
          $this.paint = new $.jGraduate.Paint({
            solidColor: 'ffffff'
          });
        }

        $this.addClass('jGraduate_Picker');
        /* eslint-disable max-len */

        $this.html('<ul class="jGraduate_tabs">' + '<li class="jGraduate_tab_color jGraduate_tab_current" data-type="col">Solid Color</li>' + '<li class="jGraduate_tab_lingrad" data-type="lg">Linear Gradient</li>' + '<li class="jGraduate_tab_radgrad" data-type="rg">Radial Gradient</li>' + '</ul>' + '<div class="jGraduate_colPick"></div>' + '<div class="jGraduate_gradPick"></div>' + '<div class="jGraduate_LightBox"></div>' + '<div id="' + id + '_jGraduate_stopPicker" class="jGraduate_stopPicker"></div>');
        var colPicker = $(idref + '> .jGraduate_colPick');
        var gradPicker = $(idref + '> .jGraduate_gradPick');
        gradPicker.html('<div id="' + id + '_jGraduate_Swatch" class="jGraduate_Swatch">' + '<h2 class="jGraduate_Title">' + $settings.window.pickerTitle + '</h2>' + '<div id="' + id + '_jGraduate_GradContainer" class="jGraduate_GradContainer"></div>' + '<div id="' + id + '_jGraduate_StopSlider" class="jGraduate_StopSlider"></div>' + '</div>' + '<div class="jGraduate_Form jGraduate_Points jGraduate_lg_field">' + '<div class="jGraduate_StopSection">' + '<label class="jGraduate_Form_Heading">Begin Point</label>' + '<div class="jGraduate_Form_Section">' + '<label>x:</label>' + '<input type="text" id="' + id + '_jGraduate_x1" size="3" title="Enter starting x value between 0.0 and 1.0"/>' + '<label>y:</label>' + '<input type="text" id="' + id + '_jGraduate_y1" size="3" title="Enter starting y value between 0.0 and 1.0"/>' + '</div>' + '</div>' + '<div class="jGraduate_StopSection">' + '<label class="jGraduate_Form_Heading">End Point</label>' + '<div class="jGraduate_Form_Section">' + '<label>x:</label>' + '<input type="text" id="' + id + '_jGraduate_x2" size="3" title="Enter ending x value between 0.0 and 1.0"/>' + '<label>y:</label>' + '<input type="text" id="' + id + '_jGraduate_y2" size="3" title="Enter ending y value between 0.0 and 1.0"/>' + '</div>' + '</div>' + '</div>' + '<div class="jGraduate_Form jGraduate_Points jGraduate_rg_field">' + '<div class="jGraduate_StopSection">' + '<label class="jGraduate_Form_Heading">Center Point</label>' + '<div class="jGraduate_Form_Section">' + '<label>x:</label>' + '<input type="text" id="' + id + '_jGraduate_cx" size="3" title="Enter x value between 0.0 and 1.0"/>' + '<label>y:</label>' + '<input type="text" id="' + id + '_jGraduate_cy" size="3" title="Enter y value between 0.0 and 1.0"/>' + '</div>' + '</div>' + '<div class="jGraduate_StopSection">' + '<label class="jGraduate_Form_Heading">Focal Point</label>' + '<div class="jGraduate_Form_Section">' + '<label>Match center: <input type="checkbox" checked="checked" id="' + id + '_jGraduate_match_ctr"/></label><br/>' + '<label>x:</label>' + '<input type="text" id="' + id + '_jGraduate_fx" size="3" title="Enter x value between 0.0 and 1.0"/>' + '<label>y:</label>' + '<input type="text" id="' + id + '_jGraduate_fy" size="3" title="Enter y value between 0.0 and 1.0"/>' + '</div>' + '</div>' + '</div>' + '<div class="jGraduate_StopSection jGraduate_SpreadMethod">' + '<label class="jGraduate_Form_Heading">Spread method</label>' + '<div class="jGraduate_Form_Section">' + '<select class="jGraduate_spreadMethod">' + '<option value=pad selected>Pad</option>' + '<option value=reflect>Reflect</option>' + '<option value=repeat>Repeat</option>' + '</select>' + '</div>' + '</div>' + '<div class="jGraduate_Form">' + '<div class="jGraduate_Slider jGraduate_RadiusField jGraduate_rg_field">' + '<label class="prelabel">Radius:</label>' + '<div id="' + id + '_jGraduate_Radius" class="jGraduate_SliderBar jGraduate_Radius" title="Click to set radius">' + '<img id="' + id + '_jGraduate_RadiusArrows" class="jGraduate_RadiusArrows" src="' + $settings.images.clientPath + 'rangearrows2.gif">' + '</div>' + '<label><input type="text" id="' + id + '_jGraduate_RadiusInput" size="3" value="100"/>%</label>' + '</div>' + '<div class="jGraduate_Slider jGraduate_EllipField jGraduate_rg_field">' + '<label class="prelabel">Ellip:</label>' + '<div id="' + id + '_jGraduate_Ellip" class="jGraduate_SliderBar jGraduate_Ellip" title="Click to set Ellip">' + '<img id="' + id + '_jGraduate_EllipArrows" class="jGraduate_EllipArrows" src="' + $settings.images.clientPath + 'rangearrows2.gif">' + '</div>' + '<label><input type="text" id="' + id + '_jGraduate_EllipInput" size="3" value="0"/>%</label>' + '</div>' + '<div class="jGraduate_Slider jGraduate_AngleField jGraduate_rg_field">' + '<label class="prelabel">Angle:</label>' + '<div id="' + id + '_jGraduate_Angle" class="jGraduate_SliderBar jGraduate_Angle" title="Click to set Angle">' + '<img id="' + id + '_jGraduate_AngleArrows" class="jGraduate_AngleArrows" src="' + $settings.images.clientPath + 'rangearrows2.gif">' + '</div>' + '<label><input type="text" id="' + id + '_jGraduate_AngleInput" size="3" value="0"/>deg</label>' + '</div>' + '<div class="jGraduate_Slider jGraduate_OpacField">' + '<label class="prelabel">Opac:</label>' + '<div id="' + id + '_jGraduate_Opac" class="jGraduate_SliderBar jGraduate_Opac" title="Click to set Opac">' + '<img id="' + id + '_jGraduate_OpacArrows" class="jGraduate_OpacArrows" src="' + $settings.images.clientPath + 'rangearrows2.gif">' + '</div>' + '<label><input type="text" id="' + id + '_jGraduate_OpacInput" size="3" value="100"/>%</label>' + '</div>' + '</div>' + '<div class="jGraduate_OkCancel">' + '<input type="button" id="' + id + '_jGraduate_Ok" class="jGraduate_Ok" value="OK"/>' + '<input type="button" id="' + id + '_jGraduate_Cancel" class="jGraduate_Cancel" value="Cancel"/>' + '</div>');
        /* eslint-enable max-len */
        // --------------
        // Set up all the SVG elements (the gradient, stops and rectangle)

        var MAX = 256,
            MARGINX = 0,
            MARGINY = 0,
            // STOP_RADIUS = 15 / 2,
        SIZEX = MAX - 2 * MARGINX,
            SIZEY = MAX - 2 * MARGINY;
        var attrInput = {};
        var SLIDERW = 145;
        $('.jGraduate_SliderBar').width(SLIDERW);
        var container = $('#' + id + '_jGraduate_GradContainer')[0];
        var svg = mkElem('svg', {
          id: id + '_jgraduate_svg',
          width: MAX,
          height: MAX,
          xmlns: ns.svg
        }, container); // This wasn't working as designed
        // let curType;
        // curType = curType || $this.paint.type;
        // if we are sent a gradient, import it

        var curType = $this.paint.type;
        var grad = $this.paint[curType];
        var curGradient = grad;
        var gradalpha = $this.paint.alpha;
        var isSolid = curType === 'solidColor'; // Make any missing gradients

        switch (curType) {
          case 'solidColor': // fall through

          case 'linearGradient':
            if (!isSolid) {
              curGradient.id = id + '_lg_jgraduate_grad';
              grad = curGradient = svg.appendChild(curGradient); // .cloneNode(true));
            }

            mkElem('radialGradient', {
              id: id + '_rg_jgraduate_grad'
            }, svg);

            if (curType === 'linearGradient') {
              break;
            }

          // fall through

          case 'radialGradient':
            if (!isSolid) {
              curGradient.id = id + '_rg_jgraduate_grad';
              grad = curGradient = svg.appendChild(curGradient); // .cloneNode(true));
            }

            mkElem('linearGradient', {
              id: id + '_lg_jgraduate_grad'
            }, svg);
        }

        var stopGroup; // eslint-disable-line prefer-const

        if (isSolid) {
          grad = curGradient = $('#' + id + '_lg_jgraduate_grad')[0];
          color = $this.paint[curType];
          mkStop(0, '#' + color, 1);

          var type = _typeof($settings.newstop);

          if (type === 'string') {
            switch ($settings.newstop) {
              case 'same':
                mkStop(1, '#' + color, 1);
                break;

              case 'inverse':
                {
                  // Invert current color for second stop
                  var inverted = '';

                  for (var i = 0; i < 6; i += 2) {
                    // const ch = color.substr(i, 2);
                    var inv = (255 - Number.parseInt(color.substr(i, 2), 16)).toString(16);
                    if (inv.length < 2) inv = 0 + inv;
                    inverted += inv;
                  }

                  mkStop(1, '#' + inverted, 1);
                  break;
                }

              case 'white':
                mkStop(1, '#ffffff', 1);
                break;

              case 'black':
                mkStop(1, '#000000', 1);
                break;
            }
          } else if (type === 'object') {
            var opac = 'opac' in $settings.newstop ? $settings.newstop.opac : 1;
            mkStop(1, $settings.newstop.color || '#' + color, opac);
          }
        }

        var x1 = Number.parseFloat(grad.getAttribute('x1') || 0.0),
            y1 = Number.parseFloat(grad.getAttribute('y1') || 0.0),
            x2 = Number.parseFloat(grad.getAttribute('x2') || 1.0),
            y2 = Number.parseFloat(grad.getAttribute('y2') || 0.0);
        var cx = Number.parseFloat(grad.getAttribute('cx') || 0.5),
            cy = Number.parseFloat(grad.getAttribute('cy') || 0.5),
            fx = Number.parseFloat(grad.getAttribute('fx') || cx),
            fy = Number.parseFloat(grad.getAttribute('fy') || cy);
        var previewRect = mkElem('rect', {
          id: id + '_jgraduate_rect',
          x: MARGINX,
          y: MARGINY,
          width: SIZEX,
          height: SIZEY,
          fill: 'url(#' + id + '_jgraduate_grad)',
          'fill-opacity': gradalpha / 100
        }, svg); // stop visuals created here

        var beginCoord = $('<div/>').attr({
          "class": 'grad_coord jGraduate_lg_field',
          title: 'Begin Stop'
        }).text(1).css({
          top: y1 * MAX,
          left: x1 * MAX
        }).data('coord', 'start').appendTo(container);
        var endCoord = beginCoord.clone().text(2).css({
          top: y2 * MAX,
          left: x2 * MAX
        }).attr('title', 'End stop').data('coord', 'end').appendTo(container);
        var centerCoord = $('<div/>').attr({
          "class": 'grad_coord jGraduate_rg_field',
          title: 'Center stop'
        }).text('C').css({
          top: cy * MAX,
          left: cx * MAX
        }).data('coord', 'center').appendTo(container);
        var focusCoord = centerCoord.clone().text('F').css({
          top: fy * MAX,
          left: fx * MAX,
          display: 'none'
        }).attr('title', 'Focus point').data('coord', 'focus').appendTo(container);
        focusCoord[0].id = id + '_jGraduate_focusCoord'; // const coords = $(idref + ' .grad_coord');
        // $(container).hover(function () {
        //   coords.animate({
        //     opacity: 1
        //   }, 500);
        // }, function () {
        //   coords.animate({
        //     opacity: .2
        //   }, 500);
        // });

        var showFocus;
        $.each(['x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'fx', 'fy'], function (i, attr) {
          var isRadial = isNaN(attr[1]);
          var attrval = curGradient.getAttribute(attr);

          if (!attrval) {
            // Set defaults
            if (isRadial) {
              // For radial points
              attrval = '0.5';
            } else {
              // Only x2 is 1
              attrval = attr === 'x2' ? '1.0' : '0.0';
            }
          }

          attrInput[attr] = $('#' + id + '_jGraduate_' + attr).val(attrval).change(function () {
            // TODO: Support values < 0 and > 1 (zoomable preview?)
            if (isNaN(Number.parseFloat(this.value)) || this.value < 0) {
              this.value = 0.0;
            } else if (this.value > 1) {
              this.value = 1.0;
            }

            if (!(attr[0] === 'f' && !showFocus)) {
              if (isRadial && curType === 'radialGradient' || !isRadial && curType === 'linearGradient') {
                curGradient.setAttribute(attr, this.value);
              }
            }

            var $elem = isRadial ? attr[0] === 'c' ? centerCoord : focusCoord : attr[1] === '1' ? beginCoord : endCoord;
            var cssName = attr.includes('x') ? 'left' : 'top';
            $elem.css(cssName, this.value * MAX);
          }).change();
        });
        /**
         *
         * @param {Float} n
         * @param {Float|string} colr
         * @param {Float} opac
         * @param {boolean} [sel]
         * @param {SVGStopElement} [stopElem]
         * @returns {SVGStopElement}
         */

        function mkStop(n, colr, opac, sel, stopElem) {
          var stop = stopElem || mkElem('stop', {
            'stop-color': colr,
            'stop-opacity': opac,
            offset: n
          }, curGradient);

          if (stopElem) {
            colr = stopElem.getAttribute('stop-color');
            opac = stopElem.getAttribute('stop-opacity');
            n = stopElem.getAttribute('offset');
          } else {
            curGradient.append(stop);
          }

          if (opac === null) opac = 1;
          var pickerD = 'M-6.2,0.9c3.6-4,6.7-4.3,6.7-12.4c-0.2,7.9,' + '3.1,8.8,6.5,12.4c3.5,3.8,2.9,9.6,0,12.3c-3.1,2.8-10.4,' + '2.7-13.2,0C-9.6,9.9-9.4,4.4-6.2,0.9z';
          var pathbg = mkElem('path', {
            d: pickerD,
            fill: 'url(#jGraduate_trans)',
            transform: 'translate(' + (10 + n * MAX) + ', 26)'
          }, stopGroup);
          var path = mkElem('path', {
            d: pickerD,
            fill: colr,
            'fill-opacity': opac,
            transform: 'translate(' + (10 + n * MAX) + ', 26)',
            stroke: '#000',
            'stroke-width': 1.5
          }, stopGroup);
          $(path).mousedown(function (e) {
            selectStop(this);
            drag = curStop;
            $win.mousemove(dragColor).mouseup(remDrags);
            stopOffset = stopMakerDiv.offset();
            e.preventDefault();
            return false;
          }).data('stop', stop).data('bg', pathbg).dblclick(function () {
            $('div.jGraduate_LightBox').show();
            var colorhandle = this;
            var stopOpacity = Number(stop.getAttribute('stop-opacity')) || 1;
            var stopColor = stop.getAttribute('stop-color') || 1;
            var thisAlpha = (Number.parseFloat(stopOpacity) * 255).toString(16);

            while (thisAlpha.length < 2) {
              thisAlpha = '0' + thisAlpha;
            }

            colr = stopColor.substr(1) + thisAlpha;
            $('#' + id + '_jGraduate_stopPicker').css({
              left: 100,
              bottom: 15
            }).jPicker({
              window: {
                title: 'Pick the start color and opacity for the gradient'
              },
              images: {
                clientPath: $settings.images.clientPath
              },
              color: {
                active: colr,
                alphaSupport: true
              }
            }, function (clr, arg2) {
              stopColor = clr.val('hex') ? '#' + clr.val('hex') : 'none';
              stopOpacity = clr.val('a') !== null ? clr.val('a') / 256 : 1;
              colorhandle.setAttribute('fill', stopColor);
              colorhandle.setAttribute('fill-opacity', stopOpacity);
              stop.setAttribute('stop-color', stopColor);
              stop.setAttribute('stop-opacity', stopOpacity);
              $('div.jGraduate_LightBox').hide();
              $('#' + id + '_jGraduate_stopPicker').hide();
            }, null, function () {
              $('div.jGraduate_LightBox').hide();
              $('#' + id + '_jGraduate_stopPicker').hide();
            });
          });
          $(curGradient).find('stop').each(function () {
            var curS = $(this);

            if (Number(this.getAttribute('offset')) > n) {
              if (!colr) {
                var newcolor = this.getAttribute('stop-color');
                var newopac = this.getAttribute('stop-opacity');
                stop.setAttribute('stop-color', newcolor);
                path.setAttribute('fill', newcolor);
                stop.setAttribute('stop-opacity', newopac === null ? 1 : newopac);
                path.setAttribute('fill-opacity', newopac === null ? 1 : newopac);
              }

              curS.before(stop);
              return false;
            }

            return true;
          });
          if (sel) selectStop(path);
          return stop;
        }
        /**
        *
        * @returns {void}
        */


        function remStop() {
          delStop.setAttribute('display', 'none');
          var path = $(curStop);
          var stop = path.data('stop');
          var bg = path.data('bg');
          $([curStop, stop, bg]).remove();
        }

        var stopMakerDiv = $('#' + id + '_jGraduate_StopSlider');
        var stops, curStop, drag;
        var delStop = mkElem('path', {
          d: 'm9.75,-6l-19.5,19.5m0,-19.5l19.5,19.5',
          fill: 'none',
          stroke: '#D00',
          'stroke-width': 5,
          display: 'none'
        }, undefined); // stopMakerSVG);

        /**
        * @param {Element} item
        * @returns {void}
        */

        function selectStop(item) {
          if (curStop) curStop.setAttribute('stroke', '#000');
          item.setAttribute('stroke', 'blue');
          curStop = item; //   stops = $('stop');
          //   opac_select.val(curStop.attr('fill-opacity') || 1);
          //   root.append(delStop);
        }

        var stopOffset;
        /**
        *
        * @returns {void}
        */

        function remDrags() {
          $win.unbind('mousemove', dragColor);

          if (delStop.getAttribute('display') !== 'none') {
            remStop();
          }

          drag = null;
        }

        var scaleX = 1,
            scaleY = 1,
            angle = 0;
        var cX = cx;
        var cY = cy;
        /**
        *
        * @returns {void}
        */

        function xform() {
          var rot = angle ? 'rotate(' + angle + ',' + cX + ',' + cY + ') ' : '';

          if (scaleX === 1 && scaleY === 1) {
            curGradient.removeAttribute('gradientTransform'); // $('#ang').addClass('dis');
          } else {
            var x = -cX * (scaleX - 1);
            var y = -cY * (scaleY - 1);
            curGradient.setAttribute('gradientTransform', rot + 'translate(' + x + ',' + y + ') scale(' + scaleX + ',' + scaleY + ')'); // $('#ang').removeClass('dis');
          }
        }
        /**
        * @param {Event} evt
        * @returns {void}
        */


        function dragColor(evt) {
          var x = evt.pageX - stopOffset.left;
          var y = evt.pageY - stopOffset.top;
          x = x < 10 ? 10 : x > MAX + 10 ? MAX + 10 : x;
          var xfStr = 'translate(' + x + ', 26)';

          if (y < -60 || y > 130) {
            delStop.setAttribute('display', 'block');
            delStop.setAttribute('transform', xfStr);
          } else {
            delStop.setAttribute('display', 'none');
          }

          drag.setAttribute('transform', xfStr);
          $.data(drag, 'bg').setAttribute('transform', xfStr);
          var stop = $.data(drag, 'stop');
          var sX = (x - 10) / MAX;
          stop.setAttribute('offset', sX);
          var last = 0;
          $(curGradient).find('stop').each(function (i) {
            var cur = this.getAttribute('offset');
            var t = $(this);

            if (cur < last) {
              t.prev().before(t);
              stops = $(curGradient).find('stop');
            }

            last = cur;
          });
        }

        var stopMakerSVG = mkElem('svg', {
          width: '100%',
          height: 45
        }, stopMakerDiv[0]);
        var transPattern = mkElem('pattern', {
          width: 16,
          height: 16,
          patternUnits: 'userSpaceOnUse',
          id: 'jGraduate_trans'
        }, stopMakerSVG);
        var transImg = mkElem('image', {
          width: 16,
          height: 16
        }, transPattern);
        var bgImage = $settings.images.clientPath + 'map-opacity.png';
        transImg.setAttributeNS(ns.xlink, 'xlink:href', bgImage);
        $(stopMakerSVG).click(function (evt) {
          stopOffset = stopMakerDiv.offset();
          var target = evt.target;
          if (target.tagName === 'path') return;
          var x = evt.pageX - stopOffset.left - 8;
          x = x < 10 ? 10 : x > MAX + 10 ? MAX + 10 : x;
          mkStop(x / MAX, 0, 0, true);
          evt.stopPropagation();
        });
        $(stopMakerSVG).mouseover(function () {
          stopMakerSVG.append(delStop);
        });
        stopGroup = mkElem('g', {}, stopMakerSVG);
        mkElem('line', {
          x1: 10,
          y1: 15,
          x2: MAX + 10,
          y2: 15,
          'stroke-width': 2,
          stroke: '#000'
        }, stopMakerSVG);
        var spreadMethodOpt = gradPicker.find('.jGraduate_spreadMethod').change(function () {
          curGradient.setAttribute('spreadMethod', $(this).val());
        }); // handle dragging the stop around the swatch

        var draggingCoord = null;

        var onCoordDrag = function onCoordDrag(evt) {
          var x = evt.pageX - offset.left;
          var y = evt.pageY - offset.top; // clamp stop to the swatch

          x = x < 0 ? 0 : x > MAX ? MAX : x;
          y = y < 0 ? 0 : y > MAX ? MAX : y;
          draggingCoord.css('left', x).css('top', y); // calculate stop offset

          var fracx = x / SIZEX;
          var fracy = y / SIZEY;
          var type = draggingCoord.data('coord');
          var grd = curGradient;

          switch (type) {
            case 'start':
              attrInput.x1.val(fracx);
              attrInput.y1.val(fracy);
              grd.setAttribute('x1', fracx);
              grd.setAttribute('y1', fracy);
              break;

            case 'end':
              attrInput.x2.val(fracx);
              attrInput.y2.val(fracy);
              grd.setAttribute('x2', fracx);
              grd.setAttribute('y2', fracy);
              break;

            case 'center':
              attrInput.cx.val(fracx);
              attrInput.cy.val(fracy);
              grd.setAttribute('cx', fracx);
              grd.setAttribute('cy', fracy);
              cX = fracx;
              cY = fracy;
              xform();
              break;

            case 'focus':
              attrInput.fx.val(fracx);
              attrInput.fy.val(fracy);
              grd.setAttribute('fx', fracx);
              grd.setAttribute('fy', fracy);
              xform();
          }

          evt.preventDefault();
        };

        var onCoordUp = function onCoordUp() {
          draggingCoord = null;
          $win.unbind('mousemove', onCoordDrag).unbind('mouseup', onCoordUp);
        }; // Linear gradient
        // (function () {


        stops = curGradient.getElementsByTagNameNS(ns.svg, 'stop');
        var numstops = stops.length; // if there are not at least two stops, then

        if (numstops < 2) {
          while (numstops < 2) {
            curGradient.append(document.createElementNS(ns.svg, 'stop'));
            ++numstops;
          }

          stops = curGradient.getElementsByTagNameNS(ns.svg, 'stop');
        }

        for (var _i = 0; _i < numstops; _i++) {
          mkStop(0, 0, 0, 0, stops[_i]);
        }

        spreadMethodOpt.val(curGradient.getAttribute('spreadMethod') || 'pad');
        var offset; // No match, so show focus point

        showFocus = false;
        previewRect.setAttribute('fill-opacity', gradalpha / 100);
        $('#' + id + ' div.grad_coord').mousedown(function (evt) {
          evt.preventDefault();
          draggingCoord = $(this); // const sPos = draggingCoord.offset();

          offset = draggingCoord.parent().offset();
          $win.mousemove(onCoordDrag).mouseup(onCoordUp);
        }); // bind GUI elements

        $('#' + id + '_jGraduate_Ok').bind('click', function () {
          $this.paint.type = curType;
          $this.paint[curType] = curGradient.cloneNode(true);
          $this.paint.solidColor = null;
          okClicked();
        });
        $('#' + id + '_jGraduate_Cancel').bind('click', function (paint) {
          cancelClicked();
        });

        if (curType === 'radialGradient') {
          if (showFocus) {
            focusCoord.show();
          } else {
            focusCoord.hide();
            attrInput.fx.val('');
            attrInput.fy.val('');
          }
        }

        $('#' + id + '_jGraduate_match_ctr')[0].checked = !showFocus;
        var lastfx, lastfy;
        $('#' + id + '_jGraduate_match_ctr').change(function () {
          showFocus = !this.checked;
          focusCoord.toggle(showFocus);
          attrInput.fx.val('');
          attrInput.fy.val('');
          var grd = curGradient;

          if (!showFocus) {
            lastfx = grd.getAttribute('fx');
            lastfy = grd.getAttribute('fy');
            grd.removeAttribute('fx');
            grd.removeAttribute('fy');
          } else {
            var fX = lastfx || 0.5;
            var fY = lastfy || 0.5;
            grd.setAttribute('fx', fX);
            grd.setAttribute('fy', fY);
            attrInput.fx.val(fX);
            attrInput.fy.val(fY);
          }
        });
        stops = curGradient.getElementsByTagNameNS(ns.svg, 'stop');
        numstops = stops.length; // if there are not at least two stops, then

        if (numstops < 2) {
          while (numstops < 2) {
            curGradient.append(document.createElementNS(ns.svg, 'stop'));
            ++numstops;
          }

          stops = curGradient.getElementsByTagNameNS(ns.svg, 'stop');
        }

        var slider;

        var setSlider = function setSlider(e) {
          var _slider = slider,
              left = _slider.offset.left;
          var div = slider.parent;
          var x = e.pageX - left - Number.parseInt(div.css('border-left-width'));
          if (x > SLIDERW) x = SLIDERW;
          if (x <= 0) x = 0;
          var posx = x - 5;
          x /= SLIDERW;

          switch (slider.type) {
            case 'radius':
              x = Math.pow(x * 2, 2.5);
              if (x > 0.98 && x < 1.02) x = 1;
              if (x <= 0.01) x = 0.01;
              curGradient.setAttribute('r', x);
              break;

            case 'opacity':
              $this.paint.alpha = Number.parseInt(x * 100);
              previewRect.setAttribute('fill-opacity', x);
              break;

            case 'ellip':
              scaleX = 1;
              scaleY = 1;

              if (x < 0.5) {
                x /= 0.5; // 0.001

                scaleX = x <= 0 ? 0.01 : x;
              } else if (x > 0.5) {
                x /= 0.5; // 2

                x = 2 - x;
                scaleY = x <= 0 ? 0.01 : x;
              }

              xform();
              x -= 1;

              if (scaleY === x + 1) {
                x = Math.abs(x);
              }

              break;

            case 'angle':
              x -= 0.5;
              angle = x *= 180;
              xform();
              x /= 100;
              break;
          }

          slider.elem.css({
            'margin-left': posx
          });
          x = Math.round(x * 100);
          slider.input.val(x);
        };

        var ellipVal = 0,
            angleVal = 0;

        if (curType === 'radialGradient') {
          var tlist = curGradient.gradientTransform.baseVal;

          if (tlist.numberOfItems === 2) {
            var t = tlist.getItem(0);
            var s = tlist.getItem(1);

            if (t.type === 2 && s.type === 3) {
              var m = s.matrix;

              if (m.a !== 1) {
                ellipVal = Math.round(-(1 - m.a) * 100);
              } else if (m.d !== 1) {
                ellipVal = Math.round((1 - m.d) * 100);
              }
            }
          } else if (tlist.numberOfItems === 3) {
            // Assume [R][T][S]
            var r = tlist.getItem(0);

            var _t = tlist.getItem(1);

            var _s = tlist.getItem(2);

            if (r.type === 4 && _t.type === 2 && _s.type === 3) {
              angleVal = Math.round(r.angle);
              var _m = _s.matrix;

              if (_m.a !== 1) {
                ellipVal = Math.round(-(1 - _m.a) * 100);
              } else if (_m.d !== 1) {
                ellipVal = Math.round((1 - _m.d) * 100);
              }
            }
          }
        }

        var sliders = {
          radius: {
            handle: '#' + id + '_jGraduate_RadiusArrows',
            input: '#' + id + '_jGraduate_RadiusInput',
            val: (curGradient.getAttribute('r') || 0.5) * 100
          },
          opacity: {
            handle: '#' + id + '_jGraduate_OpacArrows',
            input: '#' + id + '_jGraduate_OpacInput',
            val: $this.paint.alpha || 100
          },
          ellip: {
            handle: '#' + id + '_jGraduate_EllipArrows',
            input: '#' + id + '_jGraduate_EllipInput',
            val: ellipVal
          },
          angle: {
            handle: '#' + id + '_jGraduate_AngleArrows',
            input: '#' + id + '_jGraduate_AngleInput',
            val: angleVal
          }
        };
        $.each(sliders, function (type, data) {
          var handle = $(data.handle);
          handle.mousedown(function (evt) {
            var parent = handle.parent();
            slider = {
              type: type,
              elem: handle,
              input: $(data.input),
              parent: parent,
              offset: parent.offset()
            };
            $win.mousemove(dragSlider).mouseup(stopSlider);
            evt.preventDefault();
          });
          $(data.input).val(data.val).change(function () {
            var isRad = curType === 'radialGradient';
            var val = Number(this.value);
            var xpos = 0;

            switch (type) {
              case 'radius':
                if (isRad) curGradient.setAttribute('r', val / 100);
                xpos = Math.pow(val / 100, 1 / 2.5) / 2 * SLIDERW;
                break;

              case 'opacity':
                $this.paint.alpha = val;
                previewRect.setAttribute('fill-opacity', val / 100);
                xpos = val * (SLIDERW / 100);
                break;

              case 'ellip':
                scaleX = scaleY = 1;

                if (val === 0) {
                  xpos = SLIDERW * 0.5;
                  break;
                }

                if (val > 99.5) val = 99.5;

                if (val > 0) {
                  scaleY = 1 - val / 100;
                } else {
                  scaleX = -(val / 100) - 1;
                }

                xpos = SLIDERW * ((val + 100) / 2) / 100;
                if (isRad) xform();
                break;

              case 'angle':
                angle = val;
                xpos = angle / 180;
                xpos += 0.5;
                xpos *= SLIDERW;
                if (isRad) xform();
            }

            if (xpos > SLIDERW) {
              xpos = SLIDERW;
            } else if (xpos < 0) {
              xpos = 0;
            }

            handle.css({
              'margin-left': xpos - 5
            });
          }).change();
        });

        var dragSlider = function dragSlider(evt) {
          setSlider(evt);
          evt.preventDefault();
        };

        var stopSlider = function stopSlider(evt) {
          $win.unbind('mousemove', dragSlider).unbind('mouseup', stopSlider);
          slider = null;
        }; // --------------


        var thisAlpha = ($this.paint.alpha * 255 / 100).toString(16);

        while (thisAlpha.length < 2) {
          thisAlpha = '0' + thisAlpha;
        }

        thisAlpha = thisAlpha.split('.')[0];
        color = $this.paint.solidColor === 'none' ? '' : $this.paint.solidColor + thisAlpha;

        if (!isSolid) {
          color = stops[0].getAttribute('stop-color');
        } // This should be done somewhere else, probably


        $.extend($.fn.jPicker.defaults.window, {
          alphaSupport: true,
          effects: {
            type: 'show',
            speed: 0
          }
        });
        colPicker.jPicker({
          window: {
            title: $settings.window.pickerTitle
          },
          images: {
            clientPath: $settings.images.clientPath
          },
          color: {
            active: color,
            alphaSupport: true
          }
        }, function (clr) {
          $this.paint.type = 'solidColor';
          $this.paint.alpha = clr.val('ahex') ? Math.round(clr.val('a') / 255 * 100) : 100;
          $this.paint.solidColor = clr.val('hex') ? clr.val('hex') : 'none';
          $this.paint.radialGradient = null;
          okClicked();
        }, null, function () {
          cancelClicked();
        });
        var tabs = $(idref + ' .jGraduate_tabs li');
        tabs.click(function () {
          tabs.removeClass('jGraduate_tab_current');
          $(this).addClass('jGraduate_tab_current');
          $(idref + ' > div').hide();
          var type = $(this).attr('data-type');
          /* const container = */

          $(idref + ' .jGraduate_gradPick').show();

          if (type === 'rg' || type === 'lg') {
            // Show/hide appropriate fields
            $('.jGraduate_' + type + '_field').show();
            $('.jGraduate_' + (type === 'lg' ? 'rg' : 'lg') + '_field').hide();
            $('#' + id + '_jgraduate_rect')[0].setAttribute('fill', 'url(#' + id + '_' + type + '_jgraduate_grad)'); // Copy stops

            curType = type === 'lg' ? 'linearGradient' : 'radialGradient';
            $('#' + id + '_jGraduate_OpacInput').val($this.paint.alpha).change();
            var newGrad = $('#' + id + '_' + type + '_jgraduate_grad')[0];

            if (curGradient !== newGrad) {
              var curStops = $(curGradient).find('stop');
              $(newGrad).empty().append(curStops);
              curGradient = newGrad;
              var sm = spreadMethodOpt.val();
              curGradient.setAttribute('spreadMethod', sm);
            }

            showFocus = type === 'rg' && curGradient.getAttribute('fx') !== null && !(cx === fx && cy === fy);
            $('#' + id + '_jGraduate_focusCoord').toggle(showFocus);

            if (showFocus) {
              $('#' + id + '_jGraduate_match_ctr')[0].checked = false;
            }
          } else {
            $(idref + ' .jGraduate_gradPick').hide();
            $(idref + ' .jGraduate_colPick').show();
          }
        });
        $(idref + ' > div').hide();
        tabs.removeClass('jGraduate_tab_current');
        var tab;

        switch ($this.paint.type) {
          case 'linearGradient':
            tab = $(idref + ' .jGraduate_tab_lingrad');
            break;

          case 'radialGradient':
            tab = $(idref + ' .jGraduate_tab_radgrad');
            break;

          default:
            tab = $(idref + ' .jGraduate_tab_color');
            break;
        }

        $this.show(); // jPicker will try to show after a 0ms timeout, so need to fire this after that

        setTimeout(function () {
          tab.addClass('jGraduate_tab_current').click();
        }, 10);
      });
    };

    return $;
  }

  /**
   * SpinButton control.
   *
   * Adds bells and whistles to any ordinary textbox to
   * make it look and feel like a SpinButton Control.
   *
   * Supplies {@link external:jQuery.fn.SpinButton}).
   *
   * Originally written by George Adamson, Software Unity (george.jquery@softwareunity.com) August 2006:
   * - Added min/max options.
   * - Added step size option.
   * - Added bigStep (page up/down) option.
   *
   * Modifications made by Mark Gibson, (mgibson@designlinks.net) September 2006:
   * - Converted to jQuery plugin.
   * - Allow limited or unlimited min/max values.
   * - Allow custom class names, and add class to input element.
   * - Removed global vars.
   * - Reset (to original or through config) when invalid value entered.
   * - Repeat whilst holding mouse button down (with initial pause, like keyboard repeat).
   * - Support mouse wheel in Firefox.
   * - Fix double click in IE.
   * - Refactored some code and renamed some vars.
   *
   * Modifications by Jeff Schiller, June 2009:
   * - provide callback function for when the value changes based on the following
   *   {@link https://www.mail-archive.com/jquery-en@googlegroups.com/msg36070.html}.
   *
   * Modifications by Jeff Schiller, July 2009:
   * - improve styling for widget in Opera.
   * - consistent key-repeat handling cross-browser.
   *
   * Modifications by Alexis Deveria, October 2009:
   * - provide "stepfunc" callback option to allow custom function to run when changing a value.
   * - Made adjustValue(0) only run on certain keyup events, not all.
   *
   * Tested in IE6, Opera9, Firefox 1.5.
   *
   * | Version | Date | Author | Notes |
   * |---------|------|--------|-------|
   * | v1.0 | 11 Aug 2006 | George Adamson | First release |
   * | v1.1 | Aug 2006 | George Adamson | Minor enhancements |
   * | v1.2 | 27 Sep 2006 | Mark Gibson | Major enhancements |
   * | v1.3a | 28 Sep 2006 | George Adamson | Minor enhancements |
   * | v1.4 | 18 Jun 2009 | Jeff Schiller | Added callback function |
   * | v1.5 | 06 Jul 2009 | Jeff Schiller | Fixes for Opera. |
   * | v1.6 | 13 Oct 2009 | Alexis Deveria | Added stepfunc function |
   * | v1.7 | 21 Oct 2009 | Alexis Deveria | Minor fixes.<br />Fast-repeat for keys and live updating as you type. |
   * | v1.8 | 12 Jan 2010 | Benjamin Thomas | Fixes for mouseout behavior.<br />Added smallStep |
   * | v1.9 | 20 May 2018 | Brett Zamir | Avoid SVGEdit dependency via `stateObj` config;<br />convert to ES6 module |
   * .
   *
   * @module jQuerySpinButton
   * @example
    // Create group of settings to initialise spinbutton(s). (Optional)
    const myOptions = {
       min: 0, // Set lower limit.
       max: 100, // Set upper limit.
       step: 1, // Set increment size.
       smallStep: 0.5, // Set shift-click increment size.
       stateObj: {tool_scale: 1}, // Object to allow passing in live-updating scale
       spinClass: mySpinBtnClass, // CSS class to style the spinbutton. (Class also specifies url of the up/down button image.)
       upClass: mySpinUpClass, // CSS class for style when mouse over up button.
       downClass: mySpinDnClass // CSS class for style when mouse over down button.
    };

    $(function () {
       // Initialise INPUT element(s) as SpinButtons: (passing options if desired)
       $('#myInputElement').SpinButton(myOptions);
    });
   */

  /**
   * @function module:jQuerySpinButton.jQuerySpinButton
   * @param {external:jQuery} $ The jQuery object to which to add the plug-in
   * @returns {external:jQuery}
  */
  function jQueryPluginSpinButton($) {
    /**
    * @callback module:jQuerySpinButton.StepCallback
    * @param {external:jQuery} thisArg Value of `this`
    * @param {Float} i Value to adjust
    * @returns {Float}
    */

    /**
    * @callback module:jQuerySpinButton.ValueCallback
    * @param {external:jQuery.fn.SpinButton} thisArg Spin Button; check its `value` to see how it was changed.
    * @returns {void}
    */

    /**
     * @typedef {PlainObject} module:jQuerySpinButton.SpinButtonConfig
     * @property {Float} min Set lower limit
     * @property {Float} max Set upper limit.
     * @property {Float} step Set increment size.
     * @property {module:jQuerySpinButton.StepCallback} stepfunc Custom function to run when changing a value; called with `this` of object and the value to adjust and returns a float.
     * @property {module:jQuerySpinButton.ValueCallback} callback Called after value adjusted (with `this` of object)
     * @property {Float} smallStep Set shift-click increment size.
     * @property {PlainObject} stateObj Object to allow passing in live-updating scale
     * @property {Float} stateObj.tool_scale
     * @property {string} spinClass CSS class to style the spinbutton. (Class also specifies url of the up/down button image.)
     * @property {string} upClass CSS class for style when mouse over up button.
     * @property {string} downClass CSS class for style when mouse over down button.
     * @property {Float} page Value to be adjusted on page up/page down
     * @property {Float} reset Reset value when invalid value entered
     * @property {Float} delay Millisecond delay
     * @property {Float} interval Millisecond interval
    */

    /**
    * @function external:jQuery.fn.SpinButton
    * @param {module:jQuerySpinButton.SpinButtonConfig} cfg
    * @returns {external:jQuery}
    */
    $.fn.SpinButton = function (cfg) {
      cfg = cfg || {};
      /**
       *
       * @param {Element} el
       * @param {"offsetLeft"|"offsetTop"} prop
       * @returns {Integer}
       */

      function coord(el, prop) {
        var b = document.body;
        var c = el[prop];

        while ((el = el.offsetParent) && el !== b) {
          if (!$.browser.msie || el.currentStyle.position !== 'relative') {
            c += el[prop];
          }
        }

        return c;
      }

      return this.each(function () {
        this.repeating = false; // Apply specified options or defaults:
        // (Ought to refactor this some day to use $.extend() instead)

        this.spinCfg = {
          // min: cfg.min ? Number(cfg.min) : null,
          // max: cfg.max ? Number(cfg.max) : null,
          min: !isNaN(Number.parseFloat(cfg.min)) ? Number(cfg.min) : null,
          // Fixes bug with min:0
          max: !isNaN(Number.parseFloat(cfg.max)) ? Number(cfg.max) : null,
          step: cfg.step ? Number(cfg.step) : 1,
          stepfunc: cfg.stepfunc || false,
          page: cfg.page ? Number(cfg.page) : 10,
          upClass: cfg.upClass || 'up',
          downClass: cfg.downClass || 'down',
          reset: cfg.reset || this.value,
          delay: cfg.delay ? Number(cfg.delay) : 500,
          interval: cfg.interval ? Number(cfg.interval) : 100,
          _btn_width: 20,
          _direction: null,
          _delay: null,
          _repeat: null,
          callback: cfg.callback || null
        }; // if a smallStep isn't supplied, use half the regular step

        this.spinCfg.smallStep = cfg.smallStep || this.spinCfg.step / 2;

        this.adjustValue = function (i) {
          var v;

          if (isNaN(this.value)) {
            v = this.spinCfg.reset;
          } else if (typeof this.spinCfg.stepfunc === 'function') {
            v = this.spinCfg.stepfunc(this, i);
          } else {
            // weirdest JavaScript bug ever: 5.1 + 0.1 = 5.199999999
            v = Number((Number(this.value) + Number(i)).toFixed(5));
          }

          if (this.spinCfg.min !== null) {
            v = Math.max(v, this.spinCfg.min);
          }

          if (this.spinCfg.max !== null) {
            v = Math.min(v, this.spinCfg.max);
          }

          this.value = v;

          if (typeof this.spinCfg.callback === 'function') {
            this.spinCfg.callback(this);
          }
        };

        $(this).addClass(cfg.spinClass || 'spin-button').mousemove(function (e) {
          // Determine which button mouse is over, or not (spin direction):
          var x = e.pageX || e.x;
          var y = e.pageY || e.y;
          var el = e.target;
          var scale = cfg.stateObj.tool_scale || 1;
          var height = $(el).height() / 2;
          var direction = x > coord(el, 'offsetLeft') + el.offsetWidth * scale - this.spinCfg._btn_width ? y < coord(el, 'offsetTop') + height * scale ? 1 : -1 : 0;

          if (direction !== this.spinCfg._direction) {
            // Style up/down buttons:
            switch (direction) {
              case 1:
                // Up arrow:
                $(this).removeClass(this.spinCfg.downClass).addClass(this.spinCfg.upClass);
                break;

              case -1:
                // Down arrow:
                $(this).removeClass(this.spinCfg.upClass).addClass(this.spinCfg.downClass);
                break;

              default:
                // Mouse is elsewhere in the textbox
                $(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
            } // Set spin direction:


            this.spinCfg._direction = direction;
          }
        }).mouseout(function () {
          // Reset up/down buttons to their normal appearance when mouse moves away:
          $(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
          this.spinCfg._direction = null;
          window.clearInterval(this.spinCfg._repeat);
          window.clearTimeout(this.spinCfg._delay);
        }).mousedown(function (e) {
          var _this = this;

          if (e.button === 0 && this.spinCfg._direction !== 0) {
            // Respond to click on one of the buttons:
            var stepSize = e.shiftKey ? this.spinCfg.smallStep : this.spinCfg.step;

            var adjust = function adjust() {
              _this.adjustValue(_this.spinCfg._direction * stepSize);
            };

            adjust(); // Initial delay before repeating adjustment

            this.spinCfg._delay = window.setTimeout(function () {
              adjust(); // Repeat adjust at regular intervals

              _this.spinCfg._repeat = window.setInterval(adjust, _this.spinCfg.interval);
            }, this.spinCfg.delay);
          }
        }).mouseup(function (e) {
          // Cancel repeating adjustment
          window.clearInterval(this.spinCfg._repeat);
          window.clearTimeout(this.spinCfg._delay);
        }).dblclick(function (e) {
          if ($.browser.msie) {
            this.adjustValue(this.spinCfg._direction * this.spinCfg.step);
          }
        }).keydown(function (e) {
          // Respond to up/down arrow keys.
          switch (e.keyCode) {
            case 38:
              this.adjustValue(this.spinCfg.step);
              break;
            // Up

            case 40:
              this.adjustValue(-this.spinCfg.step);
              break;
            // Down

            case 33:
              this.adjustValue(this.spinCfg.page);
              break;
            // PageUp

            case 34:
              this.adjustValue(-this.spinCfg.page);
              break;
            // PageDown
          }
        })
        /*
        http://unixpapa.com/js/key.html describes the current state-of-affairs for
        key repeat events:
        - Safari 3.1 changed their model so that keydown is reliably repeated going forward
        - Firefox and Opera still only repeat the keypress event, not the keydown
        */
        .keypress(function (e) {
          if (this.repeating) {
            // Respond to up/down arrow keys.
            switch (e.keyCode) {
              case 38:
                this.adjustValue(this.spinCfg.step);
                break;
              // Up

              case 40:
                this.adjustValue(-this.spinCfg.step);
                break;
              // Down

              case 33:
                this.adjustValue(this.spinCfg.page);
                break;
              // PageUp

              case 34:
                this.adjustValue(-this.spinCfg.page);
                break;
              // PageDown
            } // we always ignore the first keypress event (use the keydown instead)

          } else {
            this.repeating = true;
          }
        }) // clear the 'repeating' flag
        .keyup(function (e) {
          this.repeating = false;

          switch (e.keyCode) {
            case 38: // Up

            case 40: // Down

            case 33: // PageUp

            case 34: // PageDown

            case 13:
              this.adjustValue(0);
              break;
            // Enter/Return
          }
        }).bind('mousewheel', function (e) {
          // Respond to mouse wheel in IE. (It returns up/dn motion in multiples of 120)
          if (e.wheelDelta >= 120) {
            this.adjustValue(this.spinCfg.step);
          } else if (e.wheelDelta <= -120) {
            this.adjustValue(-this.spinCfg.step);
          }

          e.preventDefault();
        }).change(function (e) {
          this.adjustValue(0);
        });

        if (this.addEventListener) {
          // Respond to mouse wheel in Firefox
          this.addEventListener('DOMMouseScroll', function (e) {
            if (e.detail > 0) {
              this.adjustValue(-this.spinCfg.step);
            } else if (e.detail < 0) {
              this.adjustValue(this.spinCfg.step);
            }

            e.preventDefault();
          });
        }
      });
    };

    return $;
  }

  /**
  * @callback module:jQueryContextMenu.jQueryContextMenuListener
  * @param {string} href The `href` value after the first character (for bypassing an initial `#`)
  * @param {external:jQuery} srcElement The wrapped jQuery srcElement
  * @param {{x: Float, y: Float, docX: Float, docY: Float}} coords
  * @returns {void}
  */

  /**
  * @typedef {PlainObject} module:jQueryContextMenu.jQueryContextMenuConfig
  * @property {string} menu
  * @property {Float} inSpeed
  * @property {Float} outSpeed
  * @property {boolean} allowLeft
  */

  /**
  * Adds {@link external:jQuery.fn.contextMenu},
  * {@link external:jQuery.fn.disableContextMenuItems},
  * {@link external:jQuery.fn.enableContextMenuItems},
  * {@link external:jQuery.fn.disableContextMenu},
  * {@link external:jQuery.fn.enableContextMenu},
  * {@link external:jQuery.fn.destroyContextMenu}.
  * @function module:jQueryContextMenu.jQueryContextMenu
  * @param {external:jQuery} $ The jQuery object to wrap (with `contextMenu`, `disableContextMenuItems`, `enableContextMenuItems`, `disableContextMenu`, `enableContextMenu`, `destroyContextMenu`)
  * @returns {external:jQuery}
  */

  function jQueryContextMenu($) {
    var win = $(window);
    var doc = $(document);
    $.extend($.fn, {
      /**
      * @memberof external:jQuery.fn
      * @param {module:jQueryContextMenu.jQueryContextMenuConfig} o
      * @param {module:jQueryContextMenu.jQueryContextMenuListener} listener
      * @returns {external:jQuery}
      */
      contextMenu: function contextMenu(o, listener) {
        // Defaults
        if (o.menu === undefined) return false;
        if (o.inSpeed === undefined) o.inSpeed = 150;
        if (o.outSpeed === undefined) o.outSpeed = 75; // 0 needs to be -1 for expected results (no fade)

        if (o.inSpeed === 0) o.inSpeed = -1;
        if (o.outSpeed === 0) o.outSpeed = -1; // Loop each context menu

        $(this).each(function () {
          var el = $(this);
          var offset = $(el).offset();
          var menu = $('#' + o.menu); // Add contextMenu class

          menu.addClass('contextMenu'); // Simulate a true right click

          $(this).bind('mousedown', function (evt) {
            $(this).mouseup(function (e) {
              var srcElement = $(this);
              srcElement.unbind('mouseup');

              if (!(evt.button === 2 || o.allowLeft || evt.ctrlKey && isMac())) {
                return undefined;
              }

              e.stopPropagation(); // Hide context menus that may be showing

              $('.contextMenu').hide(); // Get this context menu

              if (el.hasClass('disabled')) return false; // Detect mouse position

              var x = e.pageX,
                  y = e.pageY;
              var xOff = win.width() - menu.width(),
                  yOff = win.height() - menu.height();
              if (x > xOff - 15) x = xOff - 15;
              if (y > yOff - 30) y = yOff - 30; // 30 is needed to prevent scrollbars in FF
              // Show the menu

              doc.unbind('click');
              menu.css({
                top: y,
                left: x
              }).fadeIn(o.inSpeed); // Hover events

              menu.find('A').mouseover(function () {
                menu.find('LI.hover').removeClass('hover');
                $(this).parent().addClass('hover');
              }).mouseout(function () {
                menu.find('LI.hover').removeClass('hover');
              }); // Keyboard

              doc.keypress(function (ev) {
                switch (ev.keyCode) {
                  case 38:
                    // up
                    if (!menu.find('LI.hover').length) {
                      menu.find('LI:last').addClass('hover');
                    } else {
                      menu.find('LI.hover').removeClass('hover').prevAll('LI:not(.disabled)').eq(0).addClass('hover');
                      if (!menu.find('LI.hover').length) menu.find('LI:last').addClass('hover');
                    }

                    break;

                  case 40:
                    // down
                    if (!menu.find('LI.hover').length) {
                      menu.find('LI:first').addClass('hover');
                    } else {
                      menu.find('LI.hover').removeClass('hover').nextAll('LI:not(.disabled)').eq(0).addClass('hover');
                      if (!menu.find('LI.hover').length) menu.find('LI:first').addClass('hover');
                    }

                    break;

                  case 13:
                    // enter
                    menu.find('LI.hover A').trigger('click');
                    break;

                  case 27:
                    // esc
                    doc.trigger('click');
                    break;
                }
              }); // When items are selected

              menu.find('A').unbind('mouseup');
              menu.find('LI:not(.disabled) A').mouseup(function () {
                doc.unbind('click').unbind('keypress');
                $('.contextMenu').hide();

                if (listener) {
                  listener($(this).attr('href').substr(1), $(srcElement), {
                    x: x - offset.left,
                    y: y - offset.top,
                    docX: x,
                    docY: y
                  });
                }

                return false;
              }); // Hide bindings

              setTimeout(function () {
                // Delay for Mozilla
                doc.click(function () {
                  doc.unbind('click').unbind('keypress');
                  menu.fadeOut(o.outSpeed);
                  return false;
                });
              }, 0);
              return undefined;
            });
          }); // Disable text selection

          if ($.browser.mozilla) {
            $('#' + o.menu).each(function () {
              $(this).css({
                MozUserSelect: 'none'
              });
            });
          } else if ($.browser.msie) {
            $('#' + o.menu).each(function () {
              $(this).bind('selectstart.disableTextSelect', function () {
                return false;
              });
            });
          } else {
            $('#' + o.menu).each(function () {
              $(this).bind('mousedown.disableTextSelect', function () {
                return false;
              });
            });
          } // Disable browser context menu (requires both selectors to work in IE/Safari + FF/Chrome)


          $(el).add($('UL.contextMenu')).bind('contextmenu', function () {
            return false;
          });
        });
        return $(this);
      },

      /**
      * Disable context menu items on the fly.
      * @memberof external:jQuery.fn
      * @param {void|string} o Comma-separated
      * @returns {external:jQuery}
      */
      disableContextMenuItems: function disableContextMenuItems(o) {
        if (o === undefined) {
          // Disable all
          $(this).find('LI').addClass('disabled');
          return $(this);
        }

        $(this).each(function () {
          if (o !== undefined) {
            var d = o.split(',');

            var _iterator = _createForOfIteratorHelper(d),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var href = _step.value;
                $(this).find('A[href="' + href + '"]').parent().addClass('disabled');
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        });
        return $(this);
      },

      /**
      * Enable context menu items on the fly.
      * @memberof external:jQuery.fn
      * @param {void|string} o Comma-separated
      * @returns {external:jQuery}
      */
      enableContextMenuItems: function enableContextMenuItems(o) {
        if (o === undefined) {
          // Enable all
          $(this).find('LI.disabled').removeClass('disabled');
          return $(this);
        }

        $(this).each(function () {
          if (o !== undefined) {
            var d = o.split(',');

            var _iterator2 = _createForOfIteratorHelper(d),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var href = _step2.value;
                $(this).find('A[href="' + href + '"]').parent().removeClass('disabled');
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        });
        return $(this);
      },

      /**
      * Disable context menu(s).
      * @memberof external:jQuery.fn
      * @returns {external:jQuery}
      */
      disableContextMenu: function disableContextMenu() {
        $(this).each(function () {
          $(this).addClass('disabled');
        });
        return $(this);
      },

      /**
      * Enable context menu(s).
      * @memberof external:jQuery.fn
      * @returns {external:jQuery}
      */
      enableContextMenu: function enableContextMenu() {
        $(this).each(function () {
          $(this).removeClass('disabled');
        });
        return $(this);
      },

      /**
      * Destroy context menu(s).
      * @memberof external:jQuery.fn
      * @returns {external:jQuery}
      */
      destroyContextMenu: function destroyContextMenu() {
        // Destroy specified context menus
        $(this).each(function () {
          // Disable action
          $(this).unbind('mousedown').unbind('mouseup');
        });
        return $(this);
      }
    });
    return $;
  }

  /* eslint-disable no-bitwise, max-len */

  /**
   * @file jPicker (Adapted from version 1.1.6)
   *
   * jQuery Plugin for Photoshop style color picker
   *
   * @module jPicker
   * @copyright (c) 2010 Christopher T. Tillman
   * Digital Magic Productions, Inc. ({@link http://www.digitalmagicpro.com/})
   * FREE to use, alter, copy, sell, and especially ENHANCE
   * @license MIT
   *
   * Painstakingly ported from John Dyers' excellent work on his own color picker based on the Prototype framework.
   *
   * John Dyers' website: {@link http://johndyer.name}
   * Color Picker page: {@link http://johndyer.name/photoshop-like-javascript-color-picker/}
   */

  /**
  * @external Math
  */

  /**
  * @memberof external:Math
  * @param {Float} value
  * @param {Float} precision
  * @returns {Float}
  */
  function toFixedNumeric(value, precision) {
    if (precision === undefined) precision = 0;
    return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);
  }
  /**
   * Whether a value is `null` or `undefined`.
   * @param {any} val
   * @returns {boolean}
   */


  var isNullish$1 = function isNullish(val) {
    return val === null || val === undefined;
  };
  /**
  * @function module:jPicker.jPicker
  * @param {external:jQuery} $ The jQuery object, {@link external:jQuery.fn.$.fn.jPicker}, {@link external:jQuery.fn.$.fn.jPicker.defaults})
  * @returns {external:jQuery}
  */


  var jPicker = function jPicker($) {
    /**
    * @typedef {PlainObject} module:jPicker.SliderOptions
    * @property {external:jQuery|PlainObject} arrow
    * @property {string} arrow.image Not in use?
    * @property {Float} arrow.width
    * @property {Float} arrow.height
    * @property {PlainObject} map
    * @property {Float} map.width
    * @property {Float} map.height
    */

    /**
    * Encapsulate slider functionality for the ColorMap and ColorBar -
    * could be useful to use a jQuery UI draggable for this with certain extensions.
    * @memberof module:jPicker
    */
    var Slider =
    /**
     * @param {external:jQuery} bar
     * @param {module:jPicker.SliderOptions} options
     */
    function Slider(bar, options) {
      _classCallCheck(this, Slider);

      var that = this;
      /**
       * Fire events on the supplied `context`
       * @param {module:jPicker.JPickerInit} context
       * @returns {void}
       */

      function fireChangeEvents(context) {
        changeEvents.forEach(function (changeEvent) {
          changeEvent.call(that, that, context);
        });
      }
      /**
       * Bind the mousedown to the bar not the arrow for quick snapping to the clicked location.
       * @param {external:jQuery.Event} e
       * @returns {void}
       */


      function mouseDown(e) {
        var off = bar.offset();
        offset = {
          l: off.left | 0,
          t: off.top | 0
        };
        clearTimeout(timeout); // using setTimeout for visual updates - once the style is updated the browser will re-render internally allowing the next Javascript to run

        timeout = setTimeout(function () {
          setValuesFromMousePosition.call(that, e);
        }, 0); // Bind mousemove and mouseup event to the document so it responds when dragged of of the bar - we will unbind these when on mouseup to save processing

        $(document).bind('mousemove', mouseMove).bind('mouseup', mouseUp);
        e.preventDefault(); // don't try to select anything or drag the image to the desktop
      }
      /**
       * Set the values as the mouse moves.
       * @param {external:jQuery.Event} e
       * @returns {false}
       */


      function mouseMove(e) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          setValuesFromMousePosition.call(that, e);
        }, 0);
        e.stopPropagation();
        e.preventDefault();
        return false;
      }
      /**
       * Unbind the document events - they aren't needed when not dragging.
       * @param {external:jQuery.Event} e
       * @returns {false}
       */


      function mouseUp(e) {
        $(document).unbind('mouseup', mouseUp).unbind('mousemove', mouseMove);
        e.stopPropagation();
        e.preventDefault();
        return false;
      }
      /**
       * Calculate mouse position and set value within the current range.
       * @param {Event} e
       * @returns {void}
       */


      function setValuesFromMousePosition(e) {
        var barW = bar.w,
            // local copies for YUI compressor
        barH = bar.h;
        var locX = e.pageX - offset.l,
            locY = e.pageY - offset.t; // keep the arrow within the bounds of the bar

        if (locX < 0) locX = 0;else if (locX > barW) locX = barW;
        if (locY < 0) locY = 0;else if (locY > barH) locY = barH;
        val.call(that, 'xy', {
          x: locX / barW * rangeX + minX,
          y: locY / barH * rangeY + minY
        });
      }
      /**
       *
       * @returns {void}
       */


      function draw() {
        var barW = bar.w,
            barH = bar.h,
            arrowW = arrow.w,
            arrowH = arrow.h;
        var arrowOffsetX = 0,
            arrowOffsetY = 0;
        setTimeout(function () {
          if (rangeX > 0) {
            // range is greater than zero
            // constrain to bounds
            if (x === maxX) arrowOffsetX = barW;else arrowOffsetX = x / rangeX * barW | 0;
          }

          if (rangeY > 0) {
            // range is greater than zero
            // constrain to bounds
            if (y === maxY) arrowOffsetY = barH;else arrowOffsetY = y / rangeY * barH | 0;
          } // if arrow width is greater than bar width, center arrow and prevent horizontal dragging


          if (arrowW >= barW) arrowOffsetX = (barW >> 1) - (arrowW >> 1); // number >> 1 - superfast bitwise divide by two and truncate (move bits over one bit discarding lowest)
          else arrowOffsetX -= arrowW >> 1; // if arrow height is greater than bar height, center arrow and prevent vertical dragging

          if (arrowH >= barH) arrowOffsetY = (barH >> 1) - (arrowH >> 1);else arrowOffsetY -= arrowH >> 1; // set the arrow position based on these offsets

          arrow.css({
            left: arrowOffsetX + 'px',
            top: arrowOffsetY + 'px'
          });
        });
      }
      /**
       * Get or set a value.
       * @param {?("xy"|"x"|"y")} name
       * @param {module:math.XYObject} value
       * @param {module:jPicker.Slider} context
       * @returns {module:math.XYObject|Float|void}
       */


      function val(name, value, context) {
        var set = value !== undefined;

        if (!set) {
          if (isNullish$1(name)) name = 'xy';

          switch (name.toLowerCase()) {
            case 'x':
              return x;

            case 'y':
              return y;

            case 'xy':
            default:
              return {
                x: x,
                y: y
              };
          }
        }

        if (!isNullish$1(context) && context === that) return undefined;
        var changed = false;
        var newX, newY;
        if (isNullish$1(name)) name = 'xy';

        switch (name.toLowerCase()) {
          case 'x':
            newX = value && (value.x && value.x | 0 || value | 0) || 0;
            break;

          case 'y':
            newY = value && (value.y && value.y | 0 || value | 0) || 0;
            break;

          case 'xy':
          default:
            newX = value && value.x && value.x | 0 || 0;
            newY = value && value.y && value.y | 0 || 0;
            break;
        }

        if (!isNullish$1(newX)) {
          if (newX < minX) newX = minX;else if (newX > maxX) newX = maxX;

          if (x !== newX) {
            x = newX;
            changed = true;
          }
        }

        if (!isNullish$1(newY)) {
          if (newY < minY) newY = minY;else if (newY > maxY) newY = maxY;

          if (y !== newY) {
            y = newY;
            changed = true;
          }
        }

        changed && fireChangeEvents.call(that, context || that);
        return undefined;
      }
      /**
      * @typedef {PlainObject} module:jPicker.MinMaxRangeX
      * @property {Float} minX
      * @property {Float} maxX
      * @property {Float} rangeX
      */

      /**
      * @typedef {PlainObject} module:jPicker.MinMaxRangeY
      * @property {Float} minY
      * @property {Float} maxY
      * @property {Float} rangeY
      */

      /**
      * @typedef {module:jPicker.MinMaxRangeY|module:jPicker.MinMaxRangeX} module:jPicker.MinMaxRangeXY
      */

      /**
       *
       * @param {"minx"|"maxx"|"rangex"|"miny"|"maxy"|"rangey"|"all"} name
       * @param {module:jPicker.MinMaxRangeXY} value
       * @returns {module:jPicker.MinMaxRangeXY|module:jPicker.MinMaxRangeX|module:jPicker.MinMaxRangeY|void}
       */


      function range(name, value) {
        var set = value !== undefined;

        if (!set) {
          if (isNullish$1(name)) name = 'all';

          switch (name.toLowerCase()) {
            case 'minx':
              return minX;

            case 'maxx':
              return maxX;

            case 'rangex':
              return {
                minX: minX,
                maxX: maxX,
                rangeX: rangeX
              };

            case 'miny':
              return minY;

            case 'maxy':
              return maxY;

            case 'rangey':
              return {
                minY: minY,
                maxY: maxY,
                rangeY: rangeY
              };

            case 'all':
            default:
              return {
                minX: minX,
                maxX: maxX,
                rangeX: rangeX,
                minY: minY,
                maxY: maxY,
                rangeY: rangeY
              };
          }
        }

        var // changed = false,
        newMinX, newMaxX, newMinY, newMaxY;
        if (isNullish$1(name)) name = 'all';

        switch (name.toLowerCase()) {
          case 'minx':
            newMinX = value && (value.minX && value.minX | 0 || value | 0) || 0;
            break;

          case 'maxx':
            newMaxX = value && (value.maxX && value.maxX | 0 || value | 0) || 0;
            break;

          case 'rangex':
            newMinX = value && value.minX && value.minX | 0 || 0;
            newMaxX = value && value.maxX && value.maxX | 0 || 0;
            break;

          case 'miny':
            newMinY = value && (value.minY && value.minY | 0 || value | 0) || 0;
            break;

          case 'maxy':
            newMaxY = value && (value.maxY && value.maxY | 0 || value | 0) || 0;
            break;

          case 'rangey':
            newMinY = value && value.minY && value.minY | 0 || 0;
            newMaxY = value && value.maxY && value.maxY | 0 || 0;
            break;

          case 'all':
          default:
            newMinX = value && value.minX && value.minX | 0 || 0;
            newMaxX = value && value.maxX && value.maxX | 0 || 0;
            newMinY = value && value.minY && value.minY | 0 || 0;
            newMaxY = value && value.maxY && value.maxY | 0 || 0;
            break;
        }

        if (!isNullish$1(newMinX) && minX !== newMinX) {
          minX = newMinX;
          rangeX = maxX - minX;
        }

        if (!isNullish$1(newMaxX) && maxX !== newMaxX) {
          maxX = newMaxX;
          rangeX = maxX - minX;
        }

        if (!isNullish$1(newMinY) && minY !== newMinY) {
          minY = newMinY;
          rangeY = maxY - minY;
        }

        if (!isNullish$1(newMaxY) && maxY !== newMaxY) {
          maxY = newMaxY;
          rangeY = maxY - minY;
        }

        return undefined;
      }
      /**
      * @param {GenericCallback} callback
      * @returns {void}
      */


      function bind(callback) {
        // eslint-disable-line promise/prefer-await-to-callbacks
        if (typeof callback === 'function') changeEvents.push(callback);
      }
      /**
      * @param {GenericCallback} callback
      * @returns {void}
      */


      function unbind(callback) {
        // eslint-disable-line promise/prefer-await-to-callbacks
        if (typeof callback !== 'function') return;
        var i;

        while (i = changeEvents.includes(callback)) {
          changeEvents.splice(i, 1);
        }
      }
      /**
      *
      * @returns {void}
      */


      function destroy() {
        // unbind all possible events and null objects
        $(document).unbind('mouseup', mouseUp).unbind('mousemove', mouseMove);
        bar.unbind('mousedown', mouseDown);
        bar = null;
        arrow = null;
        changeEvents = null;
      }

      var offset,
          timeout,
          x = 0,
          y = 0,
          minX = 0,
          maxX = 100,
          rangeX = 100,
          minY = 0,
          maxY = 100,
          rangeY = 100,
          arrow = bar.find('img:first'),
          // the arrow image to drag
      changeEvents = [];
      $.extend(true, // public properties, methods, and event bindings - these we need
      //   to access from other controls
      that, {
        val: val,
        range: range,
        bind: bind,
        unbind: unbind,
        destroy: destroy
      }); // initialize this control

      arrow.src = options.arrow && options.arrow.image;
      arrow.w = options.arrow && options.arrow.width || arrow.width();
      arrow.h = options.arrow && options.arrow.height || arrow.height();
      bar.w = options.map && options.map.width || bar.width();
      bar.h = options.map && options.map.height || bar.height(); // bind mousedown event

      bar.bind('mousedown', mouseDown);
      bind.call(that, draw);
    };
    /**
     * Controls for all the input elements for the typing in color values.
     */


    var ColorValuePicker =
    /**
     * @param {external:jQuery} picker
     * @param {external:jQuery.jPicker.Color} color
     * @param {external:jQuery.fn.$.fn.jPicker} bindedHex
     * @param {Float} alphaPrecision
     */
    function ColorValuePicker(picker, color, bindedHex, alphaPrecision) {
      _classCallCheck(this, ColorValuePicker);

      var that = this; // private properties and methods

      var inputs = picker.find('td.Text input'); // input box key down - use arrows to alter color

      /**
       *
       * @param {Event} e
       * @returns {Event|false|void}
       */

      function keyDown(e) {
        if (e.target.value === '' && e.target !== hex.get(0) && (!isNullish$1(bindedHex) && e.target !== bindedHex.get(0) || isNullish$1(bindedHex))) return undefined;
        if (!validateKey(e)) return e;

        switch (e.target) {
          case red.get(0):
            switch (e.keyCode) {
              case 38:
                red.val(setValueInRange.call(that, (red.val() << 0) + 1, 0, 255));
                color.val('r', red.val(), e.target);
                return false;

              case 40:
                red.val(setValueInRange.call(that, (red.val() << 0) - 1, 0, 255));
                color.val('r', red.val(), e.target);
                return false;
            }

            break;

          case green.get(0):
            switch (e.keyCode) {
              case 38:
                green.val(setValueInRange.call(that, (green.val() << 0) + 1, 0, 255));
                color.val('g', green.val(), e.target);
                return false;

              case 40:
                green.val(setValueInRange.call(that, (green.val() << 0) - 1, 0, 255));
                color.val('g', green.val(), e.target);
                return false;
            }

            break;

          case blue.get(0):
            switch (e.keyCode) {
              case 38:
                blue.val(setValueInRange.call(that, (blue.val() << 0) + 1, 0, 255));
                color.val('b', blue.val(), e.target);
                return false;

              case 40:
                blue.val(setValueInRange.call(that, (blue.val() << 0) - 1, 0, 255));
                color.val('b', blue.val(), e.target);
                return false;
            }

            break;

          case alpha && alpha.get(0):
            switch (e.keyCode) {
              case 38:
                alpha.val(setValueInRange.call(that, Number.parseFloat(alpha.val()) + 1, 0, 100));
                color.val('a', toFixedNumeric(alpha.val() * 255 / 100, alphaPrecision), e.target);
                return false;

              case 40:
                alpha.val(setValueInRange.call(that, Number.parseFloat(alpha.val()) - 1, 0, 100));
                color.val('a', toFixedNumeric(alpha.val() * 255 / 100, alphaPrecision), e.target);
                return false;
            }

            break;

          case hue.get(0):
            switch (e.keyCode) {
              case 38:
                hue.val(setValueInRange.call(that, (hue.val() << 0) + 1, 0, 360));
                color.val('h', hue.val(), e.target);
                return false;

              case 40:
                hue.val(setValueInRange.call(that, (hue.val() << 0) - 1, 0, 360));
                color.val('h', hue.val(), e.target);
                return false;
            }

            break;

          case saturation.get(0):
            switch (e.keyCode) {
              case 38:
                saturation.val(setValueInRange.call(that, (saturation.val() << 0) + 1, 0, 100));
                color.val('s', saturation.val(), e.target);
                return false;

              case 40:
                saturation.val(setValueInRange.call(that, (saturation.val() << 0) - 1, 0, 100));
                color.val('s', saturation.val(), e.target);
                return false;
            }

            break;

          case value.get(0):
            switch (e.keyCode) {
              case 38:
                value.val(setValueInRange.call(that, (value.val() << 0) + 1, 0, 100));
                color.val('v', value.val(), e.target);
                return false;

              case 40:
                value.val(setValueInRange.call(that, (value.val() << 0) - 1, 0, 100));
                color.val('v', value.val(), e.target);
                return false;
            }

            break;
        }

        return undefined;
      } // input box key up - validate value and set color

      /**
      * @param {Event} e
      * @returns {Event|void}
      * @todo Why is this returning an event?
      */


      function keyUp(e) {
        if (e.target.value === '' && e.target !== hex.get(0) && (!isNullish$1(bindedHex) && e.target !== bindedHex.get(0) || isNullish$1(bindedHex))) return undefined;
        if (!validateKey(e)) return e;

        switch (e.target) {
          case red.get(0):
            red.val(setValueInRange.call(that, red.val(), 0, 255));
            color.val('r', red.val(), e.target);
            break;

          case green.get(0):
            green.val(setValueInRange.call(that, green.val(), 0, 255));
            color.val('g', green.val(), e.target);
            break;

          case blue.get(0):
            blue.val(setValueInRange.call(that, blue.val(), 0, 255));
            color.val('b', blue.val(), e.target);
            break;

          case alpha && alpha.get(0):
            alpha.val(setValueInRange.call(that, alpha.val(), 0, 100));
            color.val('a', toFixedNumeric(alpha.val() * 255 / 100, alphaPrecision), e.target);
            break;

          case hue.get(0):
            hue.val(setValueInRange.call(that, hue.val(), 0, 360));
            color.val('h', hue.val(), e.target);
            break;

          case saturation.get(0):
            saturation.val(setValueInRange.call(that, saturation.val(), 0, 100));
            color.val('s', saturation.val(), e.target);
            break;

          case value.get(0):
            value.val(setValueInRange.call(that, value.val(), 0, 100));
            color.val('v', value.val(), e.target);
            break;

          case hex.get(0):
            hex.val(hex.val().replace(/[^a-fA-F\d]/g, '').toLowerCase().substring(0, 6));
            bindedHex && bindedHex.val(hex.val());
            color.val('hex', hex.val() !== '' ? hex.val() : null, e.target);
            break;

          case bindedHex && bindedHex.get(0):
            bindedHex.val(bindedHex.val().replace(/[^a-fA-F\d]/g, '').toLowerCase().substring(0, 6));
            hex.val(bindedHex.val());
            color.val('hex', bindedHex.val() !== '' ? bindedHex.val() : null, e.target);
            break;

          case ahex && ahex.get(0):
            ahex.val(ahex.val().replace(/[^a-fA-F\d]/g, '').toLowerCase().substring(0, 2));
            color.val('a', !isNullish$1(ahex.val()) ? Number.parseInt(ahex.val(), 16) : null, e.target);
            break;
        }

        return undefined;
      } // input box blur - reset to original if value empty

      /**
      * @param {Event} e
      * @returns {void}
      */


      function blur(e) {
        if (!isNullish$1(color.val())) {
          switch (e.target) {
            case red.get(0):
              red.val(color.val('r'));
              break;

            case green.get(0):
              green.val(color.val('g'));
              break;

            case blue.get(0):
              blue.val(color.val('b'));
              break;

            case alpha && alpha.get(0):
              alpha.val(toFixedNumeric(color.val('a') * 100 / 255, alphaPrecision));
              break;

            case hue.get(0):
              hue.val(color.val('h'));
              break;

            case saturation.get(0):
              saturation.val(color.val('s'));
              break;

            case value.get(0):
              value.val(color.val('v'));
              break;

            case hex.get(0):
            case bindedHex && bindedHex.get(0):
              hex.val(color.val('hex'));
              bindedHex && bindedHex.val(color.val('hex'));
              break;

            case ahex && ahex.get(0):
              ahex.val(color.val('ahex').substring(6));
              break;
          }
        }
      }
      /**
      * @param {Event} e
      * @returns {boolean}
      */


      function validateKey(e) {
        switch (e.keyCode) {
          case 9:
          case 16:
          case 29:
          case 37:
          case 39:
            return false;

          case 'c'.charCodeAt():
          case 'v'.charCodeAt():
            if (e.ctrlKey) return false;
        }

        return true;
      }
      /**
      * Constrain value within range.
      * @param {Float|string} value
      * @param {Float} min
      * @param {Float} max
      * @returns {Float|string} Returns a number or numeric string
      */


      function setValueInRange(value, min, max) {
        if (value === '' || isNaN(value)) return min;
        if (value > max) return max;
        if (value < min) return min;
        return value;
      }
      /**
      * @param {external:jQuery} ui
      * @param {Element} context
      * @returns {void}
      */


      function colorChanged(ui, context) {
        var all = ui.val('all');
        if (context !== red.get(0)) red.val(!isNullish$1(all) ? all.r : '');
        if (context !== green.get(0)) green.val(!isNullish$1(all) ? all.g : '');
        if (context !== blue.get(0)) blue.val(!isNullish$1(all) ? all.b : '');
        if (alpha && context !== alpha.get(0)) alpha.val(!isNullish$1(all) ? toFixedNumeric(all.a * 100 / 255, alphaPrecision) : '');
        if (context !== hue.get(0)) hue.val(!isNullish$1(all) ? all.h : '');
        if (context !== saturation.get(0)) saturation.val(!isNullish$1(all) ? all.s : '');
        if (context !== value.get(0)) value.val(!isNullish$1(all) ? all.v : '');
        if (context !== hex.get(0) && (bindedHex && context !== bindedHex.get(0) || !bindedHex)) hex.val(!isNullish$1(all) ? all.hex : '');
        if (bindedHex && context !== bindedHex.get(0) && context !== hex.get(0)) bindedHex.val(!isNullish$1(all) ? all.hex : '');
        if (ahex && context !== ahex.get(0)) ahex.val(!isNullish$1(all) ? all.ahex.substring(6) : '');
      }
      /**
      * Unbind all events and null objects.
      * @returns {void}
      */


      function destroy() {
        red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).add(hex).add(bindedHex).add(ahex).unbind('keyup', keyUp).unbind('blur', blur);
        red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).unbind('keydown', keyDown);
        color.unbind(colorChanged);
        red = null;
        green = null;
        blue = null;
        alpha = null;
        hue = null;
        saturation = null;
        value = null;
        hex = null;
        ahex = null;
      }

      var red = inputs.eq(3),
          green = inputs.eq(4),
          blue = inputs.eq(5),
          alpha = inputs.length > 7 ? inputs.eq(6) : null,
          hue = inputs.eq(0),
          saturation = inputs.eq(1),
          value = inputs.eq(2),
          hex = inputs.eq(inputs.length > 7 ? 7 : 6),
          ahex = inputs.length > 7 ? inputs.eq(8) : null;
      $.extend(true, that, {
        // public properties and methods
        destroy: destroy
      });
      red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).add(hex).add(bindedHex).add(ahex).bind('keyup', keyUp).bind('blur', blur);
      red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).bind('keydown', keyDown);
      color.bind(colorChanged);
    };
    /**
    * @typedef {PlainObject} module:jPicker.JPickerInit
    * @property {Integer} [a]
    * @property {Integer} [b]
    * @property {Integer} [g]
    * @property {Integer} [h]
    * @property {Integer} [r]
    * @property {Integer} [s]
    * @property {Integer} [v]
    * @property {string} [hex]
    * @property {string} [ahex]
    */

    /* eslint-disable jsdoc/require-property */

    /**
    * @namespace {PlainObject} jPicker
    * @memberof external:jQuery
    */


    $.jPicker =
    /** @lends external:jQuery.jPicker */
    {
      /* eslint-enable jsdoc/require-property */

      /**
      * Array holding references to each active instance of the jPicker control.
      * @type {external:jQuery.fn.$.fn.jPicker[]}
      */
      List: [],

      /**
      * Color object - we will be able to assign by any color space type or
      * retrieve any color space info.
      * We want this public so we can optionally assign new color objects to
      * initial values using inputs other than a string hex value (also supported)
      * Note: JSDoc didn't document when expressed here as an ES6 Class.
      * @namespace
      * @class
      * @memberof external:jQuery.jPicker
      * @param {module:jPicker.JPickerInit} init
      * @returns {external:jQuery.jPicker.Color}
      */
      Color: function Color(init) {
        // eslint-disable-line object-shorthand
        var that = this;
        /**
         *
         * @param {module:jPicker.Slider} context
         * @returns {void}
         */

        function fireChangeEvents(context) {
          for (var i = 0; i < changeEvents.length; i++) {
            changeEvents[i].call(that, that, context);
          }
        }
        /**
         * @param {string|"ahex"|"hex"|"all"|""|null|void} name String composed of letters "r", "g", "b", "a", "h", "s", and/or "v"
         * @param {module:jPicker.RGBA|module:jPicker.JPickerInit|string} [value]
         * @param {external:jQuery.jPicker.Color} context
         * @returns {module:jPicker.JPickerInit|string|null|void}
         */


        function val(name, value, context) {
          // Kind of ugly
          var set = Boolean(value);
          if (set && value.ahex === '') value.ahex = '00000000';

          if (!set) {
            var ret;
            if (isNullish$1(name) || name === '') name = 'all';
            if (isNullish$1(r)) return null;

            switch (name.toLowerCase()) {
              case 'ahex':
                return ColorMethods.rgbaToHex({
                  r: r,
                  g: g,
                  b: b,
                  a: a
                });

              case 'hex':
                return val('ahex').substring(0, 6);

              case 'all':
                return {
                  r: r,
                  g: g,
                  b: b,
                  a: a,
                  h: h,
                  s: s,
                  v: v,
                  hex: val.call(that, 'hex'),
                  ahex: val.call(that, 'ahex')
                };

              default:
                {
                  ret = {};
                  var nameLength = name.length;

                  _toConsumableArray(name).forEach(function (ch) {
                    switch (ch) {
                      case 'r':
                        if (nameLength === 1) ret = r;else ret.r = r;
                        break;

                      case 'g':
                        if (nameLength === 1) ret = g;else ret.g = g;
                        break;

                      case 'b':
                        if (nameLength === 1) ret = b;else ret.b = b;
                        break;

                      case 'a':
                        if (nameLength === 1) ret = a;else ret.a = a;
                        break;

                      case 'h':
                        if (nameLength === 1) ret = h;else ret.h = h;
                        break;

                      case 's':
                        if (nameLength === 1) ret = s;else ret.s = s;
                        break;

                      case 'v':
                        if (nameLength === 1) ret = v;else ret.v = v;
                        break;
                    }
                  });
                }
            }

            return _typeof(ret) === 'object' && !Object.keys(ret).length ? val.call(that, 'all') : ret;
          }

          if (!isNullish$1(context) && context === that) return undefined;
          if (isNullish$1(name)) name = '';
          var changed = false;

          if (isNullish$1(value)) {
            if (!isNullish$1(r)) {
              r = null;
              changed = true;
            }

            if (!isNullish$1(g)) {
              g = null;
              changed = true;
            }

            if (!isNullish$1(b)) {
              b = null;
              changed = true;
            }

            if (!isNullish$1(a)) {
              a = null;
              changed = true;
            }

            if (!isNullish$1(h)) {
              h = null;
              changed = true;
            }

            if (!isNullish$1(s)) {
              s = null;
              changed = true;
            }

            if (!isNullish$1(v)) {
              v = null;
              changed = true;
            }

            changed && fireChangeEvents.call(that, context || that);
            return undefined;
          }

          switch (name.toLowerCase()) {
            case 'ahex':
            case 'hex':
              {
                var _ret = ColorMethods.hexToRgba(value && (value.ahex || value.hex) || value || 'none');

                val.call(that, 'rgba', {
                  r: _ret.r,
                  g: _ret.g,
                  b: _ret.b,
                  a: name === 'ahex' ? _ret.a : !isNullish$1(a) ? a : 255
                }, context);
                break;
              }

            default:
              {
                if (value && (!isNullish$1(value.ahex) || !isNullish$1(value.hex))) {
                  val.call(that, 'ahex', value.ahex || value.hex || '00000000', context);
                  return undefined;
                }

                var newV = {};
                var rgb = false,
                    hsv = false;
                if (value.r !== undefined && !name.includes('r')) name += 'r';
                if (value.g !== undefined && !name.includes('g')) name += 'g';
                if (value.b !== undefined && !name.includes('b')) name += 'b';
                if (value.a !== undefined && !name.includes('a')) name += 'a';
                if (value.h !== undefined && !name.includes('h')) name += 'h';
                if (value.s !== undefined && !name.includes('s')) name += 's';
                if (value.v !== undefined && !name.includes('v')) name += 'v';

                _toConsumableArray(name).forEach(function (ch) {
                  switch (ch) {
                    case 'r':
                      if (hsv) return;
                      rgb = true;
                      newV.r = value.r && value.r | 0 || value | 0 || 0;
                      if (newV.r < 0) newV.r = 0;else if (newV.r > 255) newV.r = 255;

                      if (r !== newV.r) {
                        r = newV.r;
                        changed = true;
                      }

                      break;

                    case 'g':
                      if (hsv) return;
                      rgb = true;
                      newV.g = value && value.g && value.g | 0 || value && value | 0 || 0;
                      if (newV.g < 0) newV.g = 0;else if (newV.g > 255) newV.g = 255;

                      if (g !== newV.g) {
                        g = newV.g;
                        changed = true;
                      }

                      break;

                    case 'b':
                      if (hsv) return;
                      rgb = true;
                      newV.b = value && value.b && value.b | 0 || value && value | 0 || 0;
                      if (newV.b < 0) newV.b = 0;else if (newV.b > 255) newV.b = 255;

                      if (b !== newV.b) {
                        b = newV.b;
                        changed = true;
                      }

                      break;

                    case 'a':
                      newV.a = value && !isNullish$1(value.a) ? value.a | 0 : value | 0;
                      if (newV.a < 0) newV.a = 0;else if (newV.a > 255) newV.a = 255;

                      if (a !== newV.a) {
                        a = newV.a;
                        changed = true;
                      }

                      break;

                    case 'h':
                      if (rgb) return;
                      hsv = true;
                      newV.h = value && value.h && value.h | 0 || value && value | 0 || 0;
                      if (newV.h < 0) newV.h = 0;else if (newV.h > 360) newV.h = 360;

                      if (h !== newV.h) {
                        h = newV.h;
                        changed = true;
                      }

                      break;

                    case 's':
                      if (rgb) return;
                      hsv = true;
                      newV.s = !isNullish$1(value.s) ? value.s | 0 : value | 0;
                      if (newV.s < 0) newV.s = 0;else if (newV.s > 100) newV.s = 100;

                      if (s !== newV.s) {
                        s = newV.s;
                        changed = true;
                      }

                      break;

                    case 'v':
                      if (rgb) return;
                      hsv = true;
                      newV.v = !isNullish$1(value.v) ? value.v | 0 : value | 0;
                      if (newV.v < 0) newV.v = 0;else if (newV.v > 100) newV.v = 100;

                      if (v !== newV.v) {
                        v = newV.v;
                        changed = true;
                      }

                      break;
                  }
                });

                if (changed) {
                  if (rgb) {
                    r = r || 0;
                    g = g || 0;
                    b = b || 0;

                    var _ret2 = ColorMethods.rgbToHsv({
                      r: r,
                      g: g,
                      b: b
                    });

                    h = _ret2.h;
                    s = _ret2.s;
                    v = _ret2.v;
                  } else if (hsv) {
                    h = h || 0;
                    s = !isNullish$1(s) ? s : 100;
                    v = !isNullish$1(v) ? v : 100;

                    var _ret3 = ColorMethods.hsvToRgb({
                      h: h,
                      s: s,
                      v: v
                    });

                    r = _ret3.r;
                    g = _ret3.g;
                    b = _ret3.b;
                  }

                  a = !isNullish$1(a) ? a : 255;
                  fireChangeEvents.call(that, context || that);
                }

                break;
              }
          }

          return undefined;
        }
        /**
        * @param {GenericCallback} callback
        * @returns {void}
        */


        function bind(callback) {
          // eslint-disable-line promise/prefer-await-to-callbacks
          if (typeof callback === 'function') changeEvents.push(callback);
        }
        /**
        * @param {GenericCallback} callback
        * @returns {void}
        */


        function unbind(callback) {
          // eslint-disable-line promise/prefer-await-to-callbacks
          if (typeof callback !== 'function') return;
          var i;

          while (i = changeEvents.includes(callback)) {
            changeEvents.splice(i, 1);
          }
        }
        /**
        * Unset `changeEvents`
        * @returns {void}
        */


        function destroy() {
          changeEvents = null;
        }

        var r,
            g,
            b,
            a,
            h,
            s,
            v,
            changeEvents = [];
        $.extend(true, that, {
          // public properties and methods
          val: val,
          bind: bind,
          unbind: unbind,
          destroy: destroy
        });

        if (init) {
          if (!isNullish$1(init.ahex)) {
            val('ahex', init);
          } else if (!isNullish$1(init.hex)) {
            val((!isNullish$1(init.a) ? 'a' : '') + 'hex', !isNullish$1(init.a) ? {
              ahex: init.hex + ColorMethods.intToHex(init.a)
            } : init);
          } else if (!isNullish$1(init.r) && !isNullish$1(init.g) && !isNullish$1(init.b)) {
            val('rgb' + (!isNullish$1(init.a) ? 'a' : ''), init);
          } else if (!isNullish$1(init.h) && !isNullish$1(init.s) && !isNullish$1(init.v)) {
            val('hsv' + (!isNullish$1(init.a) ? 'a' : ''), init);
          }
        }
      },

      /**
      * Color conversion methods  - make public to give use to external scripts.
      * @namespace
      */
      ColorMethods: {
        /**
        * @typedef {PlainObject} module:jPicker.RGBA
        * @property {Integer} r
        * @property {Integer} g
        * @property {Integer} b
        * @property {Integer} a
        */

        /**
        * @typedef {PlainObject} module:jPicker.RGB
        * @property {Integer} r
        * @property {Integer} g
        * @property {Integer} b
        */

        /**
        * @param {string} hex
        * @returns {module:jPicker.RGBA}
        */
        hexToRgba: function hexToRgba(hex) {
          if (hex === '' || hex === 'none') return {
            r: null,
            g: null,
            b: null,
            a: null
          };
          hex = this.validateHex(hex);
          var r = '00',
              g = '00',
              b = '00',
              a = '255';
          if (hex.length === 6) hex += 'ff';

          if (hex.length > 6) {
            r = hex.substring(0, 2);
            g = hex.substring(2, 4);
            b = hex.substring(4, 6);
            a = hex.substring(6, hex.length);
          } else {
            if (hex.length > 4) {
              r = hex.substring(4, hex.length);
              hex = hex.substring(0, 4);
            }

            if (hex.length > 2) {
              g = hex.substring(2, hex.length);
              hex = hex.substring(0, 2);
            }

            if (hex.length > 0) b = hex.substring(0, hex.length);
          }

          return {
            r: this.hexToInt(r),
            g: this.hexToInt(g),
            b: this.hexToInt(b),
            a: this.hexToInt(a)
          };
        },

        /**
        * @param {string} hex
        * @returns {string}
        */
        validateHex: function validateHex(hex) {
          // if (typeof hex === 'object') return '';
          hex = hex.toLowerCase().replace(/[^a-f\d]/g, '');
          if (hex.length > 8) hex = hex.substring(0, 8);
          return hex;
        },

        /**
        * @param {module:jPicker.RGBA} rgba
        * @returns {string}
        */
        rgbaToHex: function rgbaToHex(rgba) {
          return this.intToHex(rgba.r) + this.intToHex(rgba.g) + this.intToHex(rgba.b) + this.intToHex(rgba.a);
        },

        /**
        * @param {Integer} dec
        * @returns {string}
        */
        intToHex: function intToHex(dec) {
          var result = (dec | 0).toString(16);
          if (result.length === 1) result = '0' + result;
          return result.toLowerCase();
        },

        /**
        * @param {string} hex
        * @returns {Integer}
        */
        hexToInt: function hexToInt(hex) {
          return Number.parseInt(hex, 16);
        },

        /**
        * @typedef {PlainObject} module:jPicker.HSV
        * @property {Integer} h
        * @property {Integer} s
        * @property {Integer} v
        */

        /**
        * @param {module:jPicker.RGB} rgb
        * @returns {module:jPicker.HSV}
        */
        rgbToHsv: function rgbToHsv(rgb) {
          var r = rgb.r / 255,
              g = rgb.g / 255,
              b = rgb.b / 255,
              hsv = {
            h: 0,
            s: 0,
            v: 0
          };
          var min = 0,
              max = 0;

          if (r >= g && r >= b) {
            max = r;
            min = g > b ? b : g;
          } else if (g >= b && g >= r) {
            max = g;
            min = r > b ? b : r;
          } else {
            max = b;
            min = g > r ? r : g;
          }

          hsv.v = max;
          hsv.s = max ? (max - min) / max : 0;
          var delta;
          if (!hsv.s) hsv.h = 0;else {
            delta = max - min;
            if (r === max) hsv.h = (g - b) / delta;else if (g === max) hsv.h = 2 + (b - r) / delta;else hsv.h = 4 + (r - g) / delta;
            hsv.h = Number.parseInt(hsv.h * 60);
            if (hsv.h < 0) hsv.h += 360;
          }
          hsv.s = hsv.s * 100 | 0;
          hsv.v = hsv.v * 100 | 0;
          return hsv;
        },

        /**
        * @param {module:jPicker.HSV} hsv
        * @returns {module:jPicker.RGB}
        */
        hsvToRgb: function hsvToRgb(hsv) {
          var rgb = {
            r: 0,
            g: 0,
            b: 0,
            a: 100
          };
          var h = hsv.h,
              s = hsv.s,
              v = hsv.v;

          if (s === 0) {
            if (v === 0) rgb.r = rgb.g = rgb.b = 0;else rgb.r = rgb.g = rgb.b = v * 255 / 100 | 0;
          } else {
            if (h === 360) h = 0;
            h /= 60;
            s /= 100;
            v /= 100;
            var i = h | 0,
                f = h - i,
                p = v * (1 - s),
                q = v * (1 - s * f),
                t = v * (1 - s * (1 - f));

            switch (i) {
              case 0:
                rgb.r = v;
                rgb.g = t;
                rgb.b = p;
                break;

              case 1:
                rgb.r = q;
                rgb.g = v;
                rgb.b = p;
                break;

              case 2:
                rgb.r = p;
                rgb.g = v;
                rgb.b = t;
                break;

              case 3:
                rgb.r = p;
                rgb.g = q;
                rgb.b = v;
                break;

              case 4:
                rgb.r = t;
                rgb.g = p;
                rgb.b = v;
                break;

              case 5:
                rgb.r = v;
                rgb.g = p;
                rgb.b = q;
                break;
            }

            rgb.r = rgb.r * 255 | 0;
            rgb.g = rgb.g * 255 | 0;
            rgb.b = rgb.b * 255 | 0;
          }

          return rgb;
        }
      }
    };
    var _$$jPicker = $.jPicker,
        Color = _$$jPicker.Color,
        List = _$$jPicker.List,
        ColorMethods = _$$jPicker.ColorMethods; // local copies for YUI compressor

    /* eslint-disable jsdoc/require-returns */

    /**
     * @function external:jQuery.fn.jPicker
     * @see {@link external:jQuery.fn.$.fn.jPicker}
     */

    /* eslint-enable jsdoc/require-returns */

    /**
    * Will be bound to active {@link jQuery.jPicker.Color}.
    * @callback module:jPicker.LiveCallback
    * @param {external:jQuery} ui
    * @param {Element} context
    * @returns {void}
    */

    /**
    * @callback module:jPicker.CommitCallback
    * @param {external:jQuery.jPicker.Color} activeColor
    * @param {external:jQuery} okButton
    * @returns {void} Return value not used.
    */

    /**
     * @callback module:jPicker.CancelCallback
     * @param {external:jQuery.jPicker.Color} activeColor
     * @param {external:jQuery} cancelButton
     * @returns {void} Return value not used.
     */

    /**
    * While it would seem this should specify the name `jPicker` for JSDoc, that doesn't
    *   get us treated as a function as well as a namespace (even with `@function name`),
    *   so we use an approach to add a redundant `$.fn.` in the name.
    * @namespace
    * @memberof external:jQuery.fn
    * @param {external:jQuery.fn.jPickerOptions} options
    * @param {module:jPicker.CommitCallback} [commitCallback]
    * @param {module:jPicker.LiveCallback} [liveCallback]
    * @param {module:jPicker.CancelCallback} [cancelCallback]
    * @returns {external:jQuery}
    */

    $.fn.jPicker = function (options, commitCallback, liveCallback, cancelCallback) {
      return this.each(function () {
        var that = this,
            settings = $.extend(true, {}, $.fn.jPicker.defaults, options); // local copies for YUI compressor

        if ($(that).get(0).nodeName.toLowerCase() === 'input') {
          // Add color picker icon if binding to an input element and bind the events to the input
          $.extend(true, settings, {
            window: {
              bindToInput: true,
              expandable: true,
              input: $(that)
            }
          });

          if ($(that).val() === '') {
            settings.color.active = new Color({
              hex: null
            });
            settings.color.current = new Color({
              hex: null
            });
          } else if (ColorMethods.validateHex($(that).val())) {
            settings.color.active = new Color({
              hex: $(that).val(),
              a: settings.color.active.val('a')
            });
            settings.color.current = new Color({
              hex: $(that).val(),
              a: settings.color.active.val('a')
            });
          }
        }

        if (settings.window.expandable) {
          $(that).after('<span class="jPicker"><span class="Icon"><span class="Color">&nbsp;</span><span class="Alpha">&nbsp;</span><span class="Image" title="Click To Open Color Picker">&nbsp;</span><span class="Container">&nbsp;</span></span></span>');
        } else {
          settings.window.liveUpdate = false; // Basic control binding for inline use - You will need to override the liveCallback or commitCallback function to retrieve results
        }

        var isLessThanIE7 = Number.parseFloat(navigator.appVersion.split('MSIE')[1]) < 7 && document.body.filters; // needed to run the AlphaImageLoader function for IE6
        // set color mode and update visuals for the new color mode

        /**
         *
         * @param {"h"|"s"|"v"|"r"|"g"|"b"|"a"} colorMode
         * @throws {Error} Invalid mode
         * @returns {void}
         */

        function setColorMode(colorMode) {
          var active = color.active,
              hex = active.val('hex');
          var rgbMap, rgbBar;
          settings.color.mode = colorMode;

          switch (colorMode) {
            case 'h':
              setTimeout(function () {
                setBG.call(that, colorMapDiv, 'transparent');
                setImgLoc.call(that, colorMapL1, 0);
                setAlpha.call(that, colorMapL1, 100);
                setImgLoc.call(that, colorMapL2, 260);
                setAlpha.call(that, colorMapL2, 100);
                setBG.call(that, colorBarDiv, 'transparent');
                setImgLoc.call(that, colorBarL1, 0);
                setAlpha.call(that, colorBarL1, 100);
                setImgLoc.call(that, colorBarL2, 260);
                setAlpha.call(that, colorBarL2, 100);
                setImgLoc.call(that, colorBarL3, 260);
                setAlpha.call(that, colorBarL3, 100);
                setImgLoc.call(that, colorBarL4, 260);
                setAlpha.call(that, colorBarL4, 100);
                setImgLoc.call(that, colorBarL6, 260);
                setAlpha.call(that, colorBarL6, 100);
              }, 0);
              colorMap.range('all', {
                minX: 0,
                maxX: 100,
                minY: 0,
                maxY: 100
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 360
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('s'),
                y: 100 - active.val('v')
              }, colorMap);
              colorBar.val('y', 360 - active.val('h'), colorBar);
              break;

            case 's':
              setTimeout(function () {
                setBG.call(that, colorMapDiv, 'transparent');
                setImgLoc.call(that, colorMapL1, -260);
                setImgLoc.call(that, colorMapL2, -520);
                setImgLoc.call(that, colorBarL1, -260);
                setImgLoc.call(that, colorBarL2, -520);
                setImgLoc.call(that, colorBarL6, 260);
                setAlpha.call(that, colorBarL6, 100);
              }, 0);
              colorMap.range('all', {
                minX: 0,
                maxX: 360,
                minY: 0,
                maxY: 100
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 100
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('h'),
                y: 100 - active.val('v')
              }, colorMap);
              colorBar.val('y', 100 - active.val('s'), colorBar);
              break;

            case 'v':
              setTimeout(function () {
                setBG.call(that, colorMapDiv, '000000');
                setImgLoc.call(that, colorMapL1, -780);
                setImgLoc.call(that, colorMapL2, 260);
                setBG.call(that, colorBarDiv, hex);
                setImgLoc.call(that, colorBarL1, -520);
                setImgLoc.call(that, colorBarL2, 260);
                setAlpha.call(that, colorBarL2, 100);
                setImgLoc.call(that, colorBarL6, 260);
                setAlpha.call(that, colorBarL6, 100);
              }, 0);
              colorMap.range('all', {
                minX: 0,
                maxX: 360,
                minY: 0,
                maxY: 100
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 100
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('h'),
                y: 100 - active.val('s')
              }, colorMap);
              colorBar.val('y', 100 - active.val('v'), colorBar);
              break;

            case 'r':
              rgbMap = -1040;
              rgbBar = -780;
              colorMap.range('all', {
                minX: 0,
                maxX: 255,
                minY: 0,
                maxY: 255
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 255
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('b'),
                y: 255 - active.val('g')
              }, colorMap);
              colorBar.val('y', 255 - active.val('r'), colorBar);
              break;

            case 'g':
              rgbMap = -1560;
              rgbBar = -1820;
              colorMap.range('all', {
                minX: 0,
                maxX: 255,
                minY: 0,
                maxY: 255
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 255
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('b'),
                y: 255 - active.val('r')
              }, colorMap);
              colorBar.val('y', 255 - active.val('g'), colorBar);
              break;

            case 'b':
              rgbMap = -2080;
              rgbBar = -2860;
              colorMap.range('all', {
                minX: 0,
                maxX: 255,
                minY: 0,
                maxY: 255
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 255
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('r'),
                y: 255 - active.val('g')
              }, colorMap);
              colorBar.val('y', 255 - active.val('b'), colorBar);
              break;

            case 'a':
              setTimeout(function () {
                setBG.call(that, colorMapDiv, 'transparent');
                setImgLoc.call(that, colorMapL1, -260);
                setImgLoc.call(that, colorMapL2, -520);
                setImgLoc.call(that, colorBarL1, 260);
                setImgLoc.call(that, colorBarL2, 260);
                setAlpha.call(that, colorBarL2, 100);
                setImgLoc.call(that, colorBarL6, 0);
                setAlpha.call(that, colorBarL6, 100);
              }, 0);
              colorMap.range('all', {
                minX: 0,
                maxX: 360,
                minY: 0,
                maxY: 100
              });
              colorBar.range('rangeY', {
                minY: 0,
                maxY: 255
              });
              if (isNullish$1(active.val('ahex'))) break;
              colorMap.val('xy', {
                x: active.val('h'),
                y: 100 - active.val('v')
              }, colorMap);
              colorBar.val('y', 255 - active.val('a'), colorBar);
              break;

            default:
              throw new Error('Invalid Mode');
          }

          switch (colorMode) {
            case 'h':
              break;

            case 's':
            case 'v':
            case 'a':
              setTimeout(function () {
                setAlpha.call(that, colorMapL1, 100);
                setAlpha.call(that, colorBarL1, 100);
                setImgLoc.call(that, colorBarL3, 260);
                setAlpha.call(that, colorBarL3, 100);
                setImgLoc.call(that, colorBarL4, 260);
                setAlpha.call(that, colorBarL4, 100);
              }, 0);
              break;

            case 'r':
            case 'g':
            case 'b':
              setTimeout(function () {
                setBG.call(that, colorMapDiv, 'transparent');
                setBG.call(that, colorBarDiv, 'transparent');
                setAlpha.call(that, colorBarL1, 100);
                setAlpha.call(that, colorMapL1, 100);
                setImgLoc.call(that, colorMapL1, rgbMap);
                setImgLoc.call(that, colorMapL2, rgbMap - 260);
                setImgLoc.call(that, colorBarL1, rgbBar - 780);
                setImgLoc.call(that, colorBarL2, rgbBar - 520);
                setImgLoc.call(that, colorBarL3, rgbBar);
                setImgLoc.call(that, colorBarL4, rgbBar - 260);
                setImgLoc.call(that, colorBarL6, 260);
                setAlpha.call(that, colorBarL6, 100);
              }, 0);
              break;
          }

          if (isNullish$1(active.val('ahex'))) return;
          activeColorChanged.call(that, active);
        }
        /**
         * Update color when user changes text values.
         * @param {external:jQuery} ui
         * @param {?module:jPicker.Slider} context
         * @returns {void}
        */


        function activeColorChanged(ui, context) {
          if (isNullish$1(context) || context !== colorBar && context !== colorMap) positionMapAndBarArrows.call(that, ui, context);
          setTimeout(function () {
            updatePreview.call(that, ui);
            updateMapVisuals.call(that, ui);
            updateBarVisuals.call(that, ui);
          }, 0);
        }
        /**
         * User has dragged the ColorMap pointer.
         * @param {external:jQuery} ui
         * @param {?module:jPicker.Slider} context
         * @returns {void}
        */


        function mapValueChanged(ui, context) {
          var active = color.active;
          if (context !== colorMap && isNullish$1(active.val())) return;
          var xy = ui.val('all');

          switch (settings.color.mode) {
            case 'h':
              active.val('sv', {
                s: xy.x,
                v: 100 - xy.y
              }, context);
              break;

            case 's':
            case 'a':
              active.val('hv', {
                h: xy.x,
                v: 100 - xy.y
              }, context);
              break;

            case 'v':
              active.val('hs', {
                h: xy.x,
                s: 100 - xy.y
              }, context);
              break;

            case 'r':
              active.val('gb', {
                g: 255 - xy.y,
                b: xy.x
              }, context);
              break;

            case 'g':
              active.val('rb', {
                r: 255 - xy.y,
                b: xy.x
              }, context);
              break;

            case 'b':
              active.val('rg', {
                r: xy.x,
                g: 255 - xy.y
              }, context);
              break;
          }
        }
        /**
         * User has dragged the ColorBar slider.
         * @param {external:jQuery} ui
         * @param {?module:jPicker.Slider} context
         * @returns {void}
        */


        function colorBarValueChanged(ui, context) {
          var active = color.active;
          if (context !== colorBar && isNullish$1(active.val())) return;

          switch (settings.color.mode) {
            case 'h':
              active.val('h', {
                h: 360 - ui.val('y')
              }, context);
              break;

            case 's':
              active.val('s', {
                s: 100 - ui.val('y')
              }, context);
              break;

            case 'v':
              active.val('v', {
                v: 100 - ui.val('y')
              }, context);
              break;

            case 'r':
              active.val('r', {
                r: 255 - ui.val('y')
              }, context);
              break;

            case 'g':
              active.val('g', {
                g: 255 - ui.val('y')
              }, context);
              break;

            case 'b':
              active.val('b', {
                b: 255 - ui.val('y')
              }, context);
              break;

            case 'a':
              active.val('a', 255 - ui.val('y'), context);
              break;
          }
        }
        /**
         * Position map and bar arrows to match current color.
         * @param {external:jQuery} ui
         * @param {?module:jPicker.Slider} context
         * @returns {void}
        */


        function positionMapAndBarArrows(ui, context) {
          if (context !== colorMap) {
            switch (settings.color.mode) {
              case 'h':
                {
                  var sv = ui.val('sv');
                  colorMap.val('xy', {
                    x: !isNullish$1(sv) ? sv.s : 100,
                    y: 100 - (!isNullish$1(sv) ? sv.v : 100)
                  }, context);
                  break;
                }

              case 's': // Fall through

              case 'a':
                {
                  var hv = ui.val('hv');
                  colorMap.val('xy', {
                    x: hv && hv.h || 0,
                    y: 100 - (!isNullish$1(hv) ? hv.v : 100)
                  }, context);
                  break;
                }

              case 'v':
                {
                  var hs = ui.val('hs');
                  colorMap.val('xy', {
                    x: hs && hs.h || 0,
                    y: 100 - (!isNullish$1(hs) ? hs.s : 100)
                  }, context);
                  break;
                }

              case 'r':
                {
                  var bg = ui.val('bg');
                  colorMap.val('xy', {
                    x: bg && bg.b || 0,
                    y: 255 - (bg && bg.g || 0)
                  }, context);
                  break;
                }

              case 'g':
                {
                  var br = ui.val('br');
                  colorMap.val('xy', {
                    x: br && br.b || 0,
                    y: 255 - (br && br.r || 0)
                  }, context);
                  break;
                }

              case 'b':
                {
                  var rg = ui.val('rg');
                  colorMap.val('xy', {
                    x: rg && rg.r || 0,
                    y: 255 - (rg && rg.g || 0)
                  }, context);
                  break;
                }
            }
          }

          if (context !== colorBar) {
            switch (settings.color.mode) {
              case 'h':
                colorBar.val('y', 360 - (ui.val('h') || 0), context);
                break;

              case 's':
                {
                  var s = ui.val('s');
                  colorBar.val('y', 100 - (!isNullish$1(s) ? s : 100), context);
                  break;
                }

              case 'v':
                {
                  var v = ui.val('v');
                  colorBar.val('y', 100 - (!isNullish$1(v) ? v : 100), context);
                  break;
                }

              case 'r':
                colorBar.val('y', 255 - (ui.val('r') || 0), context);
                break;

              case 'g':
                colorBar.val('y', 255 - (ui.val('g') || 0), context);
                break;

              case 'b':
                colorBar.val('y', 255 - (ui.val('b') || 0), context);
                break;

              case 'a':
                {
                  var a = ui.val('a');
                  colorBar.val('y', 255 - (!isNullish$1(a) ? a : 255), context);
                  break;
                }
            }
          }
        }
        /**
        * @param {external:jQuery} ui
        * @returns {void}
        */


        function updatePreview(ui) {
          try {
            var all = ui.val('all');
            activePreview.css({
              backgroundColor: all && '#' + all.hex || 'transparent'
            });
            setAlpha.call(that, activePreview, all && toFixedNumeric(all.a * 100 / 255, 4) || 0);
          } catch (e) {}
        }
        /**
        * @param {external:jQuery} ui
        * @returns {void}
        */


        function updateMapVisuals(ui) {
          switch (settings.color.mode) {
            case 'h':
              setBG.call(that, colorMapDiv, new Color({
                h: ui.val('h') || 0,
                s: 100,
                v: 100
              }).val('hex'));
              break;

            case 's':
            case 'a':
              {
                var s = ui.val('s');
                setAlpha.call(that, colorMapL2, 100 - (!isNullish$1(s) ? s : 100));
                break;
              }

            case 'v':
              {
                var v = ui.val('v');
                setAlpha.call(that, colorMapL1, !isNullish$1(v) ? v : 100);
                break;
              }

            case 'r':
              setAlpha.call(that, colorMapL2, toFixedNumeric((ui.val('r') || 0) / 255 * 100, 4));
              break;

            case 'g':
              setAlpha.call(that, colorMapL2, toFixedNumeric((ui.val('g') || 0) / 255 * 100, 4));
              break;

            case 'b':
              setAlpha.call(that, colorMapL2, toFixedNumeric((ui.val('b') || 0) / 255 * 100));
              break;
          }

          var a = ui.val('a');
          setAlpha.call(that, colorMapL3, toFixedNumeric((255 - (a || 0)) * 100 / 255, 4));
        }
        /**
        * @param {external:jQuery} ui
        * @returns {void}
        */


        function updateBarVisuals(ui) {
          switch (settings.color.mode) {
            case 'h':
              {
                var a = ui.val('a');
                setAlpha.call(that, colorBarL5, toFixedNumeric((255 - (a || 0)) * 100 / 255, 4));
                break;
              }

            case 's':
              {
                var hva = ui.val('hva'),
                    saturatedColor = new Color({
                  h: hva && hva.h || 0,
                  s: 100,
                  v: !isNullish$1(hva) ? hva.v : 100
                });
                setBG.call(that, colorBarDiv, saturatedColor.val('hex'));
                setAlpha.call(that, colorBarL2, 100 - (!isNullish$1(hva) ? hva.v : 100));
                setAlpha.call(that, colorBarL5, toFixedNumeric((255 - (hva && hva.a || 0)) * 100 / 255, 4));
                break;
              }

            case 'v':
              {
                var hsa = ui.val('hsa'),
                    valueColor = new Color({
                  h: hsa && hsa.h || 0,
                  s: !isNullish$1(hsa) ? hsa.s : 100,
                  v: 100
                });
                setBG.call(that, colorBarDiv, valueColor.val('hex'));
                setAlpha.call(that, colorBarL5, toFixedNumeric((255 - (hsa && hsa.a || 0)) * 100 / 255, 4));
                break;
              }

            case 'r':
            case 'g':
            case 'b':
              {
                var rgba = ui.val('rgba');
                var hValue = 0,
                    vValue = 0;

                if (settings.color.mode === 'r') {
                  hValue = rgba && rgba.b || 0;
                  vValue = rgba && rgba.g || 0;
                } else if (settings.color.mode === 'g') {
                  hValue = rgba && rgba.b || 0;
                  vValue = rgba && rgba.r || 0;
                } else if (settings.color.mode === 'b') {
                  hValue = rgba && rgba.r || 0;
                  vValue = rgba && rgba.g || 0;
                }

                var middle = vValue > hValue ? hValue : vValue;
                setAlpha.call(that, colorBarL2, hValue > vValue ? toFixedNumeric((hValue - vValue) / (255 - vValue) * 100, 4) : 0);
                setAlpha.call(that, colorBarL3, vValue > hValue ? toFixedNumeric((vValue - hValue) / (255 - hValue) * 100, 4) : 0);
                setAlpha.call(that, colorBarL4, toFixedNumeric(middle / 255 * 100, 4));
                setAlpha.call(that, colorBarL5, toFixedNumeric((255 - (rgba && rgba.a || 0)) * 100 / 255, 4));
                break;
              }

            case 'a':
              {
                var _a = ui.val('a');

                setBG.call(that, colorBarDiv, ui.val('hex') || '000000');
                setAlpha.call(that, colorBarL5, !isNullish$1(_a) ? 0 : 100);
                setAlpha.call(that, colorBarL6, !isNullish$1(_a) ? 100 : 0);
                break;
              }
          }
        }
        /**
        * @param {external:jQuery} el
        * @param {string} [c="transparent"]
        * @returns {void}
        */


        function setBG(el, c) {
          el.css({
            backgroundColor: c && c.length === 6 && '#' + c || 'transparent'
          });
        }
        /**
        * @param {external:jQuery} img
        * @param {string} src The image source
        * @returns {void}
        */


        function setImg(img, src) {
          if (isLessThanIE7 && (src.includes('AlphaBar.png') || src.includes('Bars.png') || src.includes('Maps.png'))) {
            img.attr('pngSrc', src);
            img.css({
              backgroundImage: 'none',
              filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' + src + '\', sizingMethod=\'scale\')'
            });
          } else img.css({
            backgroundImage: 'url(\'' + src + '\')'
          });
        }
        /**
        * @param {external:jQuery} img
        * @param {Float} y
        * @returns {void}
        */


        function setImgLoc(img, y) {
          img.css({
            top: y + 'px'
          });
        }
        /**
        * @param {external:jQuery} obj
        * @param {Float} alpha
        * @returns {void}
        */


        function setAlpha(obj, alpha) {
          obj.css({
            visibility: alpha > 0 ? 'visible' : 'hidden'
          });

          if (alpha > 0 && alpha < 100) {
            if (isLessThanIE7) {
              var src = obj.attr('pngSrc');

              if (!isNullish$1(src) && (src.includes('AlphaBar.png') || src.includes('Bars.png') || src.includes('Maps.png'))) {
                obj.css({
                  filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' + src + '\', sizingMethod=\'scale\') progid:DXImageTransform.Microsoft.Alpha(opacity=' + alpha + ')'
                });
              } else obj.css({
                opacity: toFixedNumeric(alpha / 100, 4)
              });
            } else obj.css({
              opacity: toFixedNumeric(alpha / 100, 4)
            });
          } else if (alpha === 0 || alpha === 100) {
            if (isLessThanIE7) {
              var _src = obj.attr('pngSrc');

              if (!isNullish$1(_src) && (_src.includes('AlphaBar.png') || _src.includes('Bars.png') || _src.includes('Maps.png'))) {
                obj.css({
                  filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' + _src + '\', sizingMethod=\'scale\')'
                });
              } else obj.css({
                opacity: ''
              });
            } else obj.css({
              opacity: ''
            });
          }
        }
        /**
        * Revert color to original color when opened.
        * @returns {void}
        */


        function revertColor() {
          color.active.val('ahex', color.current.val('ahex'));
        }
        /**
        * Commit the color changes.
        * @returns {void}
        */


        function commitColor() {
          color.current.val('ahex', color.active.val('ahex'));
        }
        /**
        * @param {Event} e
        * @returns {void}
        */


        function radioClicked(e) {
          $(this).parents('tbody:first').find('input:radio[value!="' + e.target.value + '"]').removeAttr('checked');
          setColorMode.call(that, e.target.value);
        }
        /**
        *
        * @returns {void}
        */


        function currentClicked() {
          revertColor.call(that);
        }
        /**
        *
        * @returns {void}
        */


        function cancelClicked() {
          revertColor.call(that);
          settings.window.expandable && hide.call(that);
          typeof cancelCallback === 'function' && cancelCallback.call(that, color.active, cancelButton);
        }
        /**
        *
        * @returns {void}
        */


        function okClicked() {
          commitColor.call(that);
          settings.window.expandable && hide.call(that);
          typeof commitCallback === 'function' && commitCallback.call(that, color.active, okButton);
        }
        /**
        *
        * @returns {void}
        */


        function iconImageClicked() {
          show.call(that);
        }
        /**
        * @param {external:jQuery} ui
        * @returns {void}
        */


        function currentColorChanged(ui) {
          var hex = ui.val('hex');
          currentPreview.css({
            backgroundColor: hex && '#' + hex || 'transparent'
          });
          setAlpha.call(that, currentPreview, toFixedNumeric((ui.val('a') || 0) * 100 / 255, 4));
        }
        /**
        * @param {external:jQuery} ui
        * @returns {void}
        */


        function expandableColorChanged(ui) {
          var hex = ui.val('hex');
          var va = ui.val('va');
          iconColor.css({
            backgroundColor: hex && '#' + hex || 'transparent'
          });
          setAlpha.call(that, iconAlpha, toFixedNumeric((255 - (va && va.a || 0)) * 100 / 255, 4));

          if (settings.window.bindToInput && settings.window.updateInputColor) {
            settings.window.input.css({
              backgroundColor: hex && '#' + hex || 'transparent',
              color: isNullish$1(va) || va.v > 75 ? '#000000' : '#ffffff'
            });
          }
        }
        /**
        * @param {Event} e
        * @returns {void}
        */


        function moveBarMouseDown(e) {
          // const {element} = settings.window, // local copies for YUI compressor
          //     {page} = settings.window;
          elementStartX = Number.parseInt(container.css('left'));
          elementStartY = Number.parseInt(container.css('top'));
          pageStartX = e.pageX;
          pageStartY = e.pageY; // bind events to document to move window - we will unbind these on mouseup

          $(document).bind('mousemove', documentMouseMove).bind('mouseup', documentMouseUp);
          e.preventDefault(); // prevent attempted dragging of the column
        }
        /**
        * @param {Event} e
        * @returns {false}
        */


        function documentMouseMove(e) {
          container.css({
            left: elementStartX - (pageStartX - e.pageX) + 'px',
            top: elementStartY - (pageStartY - e.pageY) + 'px'
          });

          if (settings.window.expandable && !$.support.boxModel) {
            container.prev().css({
              left: container.css('left'),
              top: container.css('top')
            });
          }

          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        /**
        * @param {Event} e
        * @returns {false}
        */


        function documentMouseUp(e) {
          $(document).unbind('mousemove', documentMouseMove).unbind('mouseup', documentMouseUp);
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
        /**
        * @param {Event} e
        * @returns {false}
        */


        function quickPickClicked(e) {
          e.preventDefault();
          e.stopPropagation();
          color.active.val('ahex', $(this).attr('title') || null, e.target);
          return false;
        }
        /**
        *
        * @returns {void}
        */


        function show() {
          color.current.val('ahex', color.active.val('ahex'));
          /**
          *
          * @returns {void}
          */

          function attachIFrame() {
            if (!settings.window.expandable || $.support.boxModel) return;
            var table = container.find('table:first');
            container.before('<iframe/>');
            container.prev().css({
              width: table.width(),
              height: container.height(),
              opacity: 0,
              position: 'absolute',
              left: container.css('left'),
              top: container.css('top')
            });
          }

          if (settings.window.expandable) {
            $(document.body).children('div.jPicker.Container').css({
              zIndex: 10
            });
            container.css({
              zIndex: 20
            });
          }

          switch (settings.window.effects.type) {
            case 'fade':
              container.fadeIn(settings.window.effects.speed.show, attachIFrame);
              break;

            case 'slide':
              container.slideDown(settings.window.effects.speed.show, attachIFrame);
              break;

            case 'show':
            default:
              container.show(settings.window.effects.speed.show, attachIFrame);
              break;
          }
        }
        /**
        *
        * @returns {void}
        */


        function hide() {
          /**
          *
          * @returns {void}
          */
          function removeIFrame() {
            if (settings.window.expandable) container.css({
              zIndex: 10
            });
            if (!settings.window.expandable || $.support.boxModel) return;
            container.prev().remove();
          }

          switch (settings.window.effects.type) {
            case 'fade':
              container.fadeOut(settings.window.effects.speed.hide, removeIFrame);
              break;

            case 'slide':
              container.slideUp(settings.window.effects.speed.hide, removeIFrame);
              break;

            case 'show':
            default:
              container.hide(settings.window.effects.speed.hide, removeIFrame);
              break;
          }
        }
        /**
        *
        * @returns {void}
        */


        function initialize() {
          var win = settings.window,
              popup = win.expandable ? $(that).next().find('.Container:first') : null;
          container = win.expandable ? $('<div/>') : $(that);
          container.addClass('jPicker Container');
          if (win.expandable) container.hide();

          container.get(0).onselectstart = function (e) {
            if (e.target.nodeName.toLowerCase() !== 'input') return false;
            return true;
          }; // inject html source code - we are using a single table for this control - I know tables are considered bad, but it takes care of equal height columns and
          // this control really is tabular data, so I believe it is the right move


          var all = color.active.val('all');
          if (win.alphaPrecision < 0) win.alphaPrecision = 0;else if (win.alphaPrecision > 2) win.alphaPrecision = 2;
          var controlHtml = "<table class=\"jPicker\" cellpadding=\"0\" cellspacing=\"0\">\n          <tbody>\n            ".concat(win.expandable ? '<tr><td class="Move" colspan="5">&nbsp;</td></tr>' : '', "\n            <tr>\n              <td rowspan=\"9\"><h2 class=\"Title\">").concat(win.title || localization.text.title, "</h2><div class=\"Map\"><span class=\"Map1\">&nbsp;</span><span class=\"Map2\">&nbsp;</span><span class=\"Map3\">&nbsp;</span><img src=\"").concat(images.clientPath + images.colorMap.arrow.file, "\" class=\"Arrow\"/></div></td>\n              <td rowspan=\"9\"><div class=\"Bar\"><span class=\"Map1\">&nbsp;</span><span class=\"Map2\">&nbsp;</span><span class=\"Map3\">&nbsp;</span><span class=\"Map4\">&nbsp;</span><span class=\"Map5\">&nbsp;</span><span class=\"Map6\">&nbsp;</span><img src=\"").concat(images.clientPath + images.colorBar.arrow.file, "\" class=\"Arrow\"/></div></td>\n              <td colspan=\"2\" class=\"Preview\">").concat(localization.text.newColor, "<div><span class=\"Active\" title=\"").concat(localization.tooltips.colors.newColor, "\">&nbsp;</span><span class=\"Current\" title=\"").concat(localization.tooltips.colors.currentColor, "\">&nbsp;</span></div>").concat(localization.text.currentColor, "</td>\n              <td rowspan=\"9\" class=\"Button\"><input type=\"button\" class=\"Ok\" value=\"").concat(localization.text.ok, "\" title=\"").concat(localization.tooltips.buttons.ok, "\"/><input type=\"button\" class=\"Cancel\" value=\"").concat(localization.text.cancel, "\" title=\"").concat(localization.tooltips.buttons.cancel, "\"/><hr/><div class=\"Grid\">&nbsp;</div></td>\n            </tr>\n            <tr class=\"Hue\">\n              <td class=\"Radio\"><label title=\"").concat(localization.tooltips.hue.radio, "\"><input type=\"radio\" value=\"h\"").concat(settings.color.mode === 'h' ? ' checked="checked"' : '', "/>H:</label></td>\n              <td class=\"Text\"><input type=\"text\" maxlength=\"3\" value=\"").concat(!isNullish$1(all) ? all.h : '', "\" title=\"").concat(localization.tooltips.hue.textbox, "\"/>&nbsp;&deg;</td>\n            </tr>\n            <tr class=\"Saturation\">\n              <td class=\"Radio\"><label title=\"").concat(localization.tooltips.saturation.radio, "\"><input type=\"radio\" value=\"s\"").concat(settings.color.mode === 's' ? ' checked="checked"' : '', "/>S:</label></td>\n              <td class=\"Text\"><input type=\"text\" maxlength=\"3\" value=\"").concat(!isNullish$1(all) ? all.s : '', "\" title=\"").concat(localization.tooltips.saturation.textbox, "\"/>&nbsp;%</td>\n            </tr>\n            <tr class=\"Value\">\n              <td class=\"Radio\"><label title=\"").concat(localization.tooltips.value.radio, "\"><input type=\"radio\" value=\"v\"").concat(settings.color.mode === 'v' ? ' checked="checked"' : '', "/>V:</label><br/><br/></td>\n              <td class=\"Text\"><input type=\"text\" maxlength=\"3\" value=\"").concat(!isNullish$1(all) ? all.v : '', "\" title=\"").concat(localization.tooltips.value.textbox, "\"/>&nbsp;%<br/><br/></td>\n            </tr>\n            <tr class=\"Red\">\n              <td class=\"Radio\"><label title=\"").concat(localization.tooltips.red.radio, "\"><input type=\"radio\" value=\"r\"").concat(settings.color.mode === 'r' ? ' checked="checked"' : '', "/>R:</label></td>\n              <td class=\"Text\"><input type=\"text\" maxlength=\"3\" value=\"").concat(!isNullish$1(all) ? all.r : '', "\" title=\"").concat(localization.tooltips.red.textbox, "\"/></td>\n            </tr>\n            <tr class=\"Green\">\n              <td class=\"Radio\"><label title=\"").concat(localization.tooltips.green.radio, "\"><input type=\"radio\" value=\"g\"").concat(settings.color.mode === 'g' ? ' checked="checked"' : '', "/>G:</label></td>\n              <td class=\"Text\"><input type=\"text\" maxlength=\"3\" value=\"").concat(!isNullish$1(all) ? all.g : '', "\" title=\"").concat(localization.tooltips.green.textbox, "\"/></td>\n            </tr>\n            <tr class=\"Blue\">\n              <td class=\"Radio\"><label title=\"").concat(localization.tooltips.blue.radio, "\"><input type=\"radio\" value=\"b\"").concat(settings.color.mode === 'b' ? ' checked="checked"' : '', "/>B:</label></td>\n              <td class=\"Text\"><input type=\"text\" maxlength=\"3\" value=\"").concat(!isNullish$1(all) ? all.b : '', "\" title=\"").concat(localization.tooltips.blue.textbox, "\"/></td>\n            </tr>\n            <tr class=\"Alpha\">\n              <td class=\"Radio\">").concat(win.alphaSupport ? "<label title=\"".concat(localization.tooltips.alpha.radio, "\"><input type=\"radio\" value=\"a\"").concat(settings.color.mode === 'a' ? ' checked="checked"' : '', "/>A:</label>") : '&nbsp;', "</td>\n              <td class=\"Text\">").concat(win.alphaSupport ? "<input type=\"text\" maxlength=\"".concat(3 + win.alphaPrecision, "\" value=\"").concat(!isNullish$1(all) ? toFixedNumeric(all.a * 100 / 255, win.alphaPrecision) : '', "\" title=\"").concat(localization.tooltips.alpha.textbox, "\"/>&nbsp;%") : '&nbsp;', "</td>\n            </tr>\n            <tr class=\"Hex\">\n              <td colspan=\"2\" class=\"Text\"><label title=\"").concat(localization.tooltips.hex.textbox, "\">#:<input type=\"text\" maxlength=\"6\" class=\"Hex\" value=\"").concat(!isNullish$1(all) ? all.hex : '', "\"/></label>").concat(win.alphaSupport ? "<input type=\"text\" maxlength=\"2\" class=\"AHex\" value=\"".concat(!isNullish$1(all) ? all.ahex.substring(6) : '', "\" title=\"").concat(localization.tooltips.hex.alpha, "\"/></td>") : '&nbsp;', "\n            </tr>\n          </tbody></table>");

          if (win.expandable) {
            container.html(controlHtml);

            if (!$(document.body).children('div.jPicker.Container').length) {
              $(document.body).prepend(container);
            } else {
              $(document.body).children('div.jPicker.Container:last').after(container);
            }

            container.mousedown(function () {
              $(document.body).children('div.jPicker.Container').css({
                zIndex: 10
              });
              container.css({
                zIndex: 20
              });
            });
            container.css( // positions must be set and display set to absolute before source code injection or IE will size the container to fit the window
            {
              left: win.position.x === 'left' ? popup.offset().left - 530 - (win.position.y === 'center' ? 25 : 0) + 'px' : win.position.x === 'center' ? popup.offset().left - 260 + 'px' : win.position.x === 'right' ? popup.offset().left - 10 + (win.position.y === 'center' ? 25 : 0) + 'px' : win.position.x === 'screenCenter' ? ($(document).width() >> 1) - 260 + 'px' : popup.offset().left + Number.parseInt(win.position.x) + 'px',
              position: 'absolute',
              top: win.position.y === 'top' ? popup.offset().top - 312 + 'px' : win.position.y === 'center' ? popup.offset().top - 156 + 'px' : win.position.y === 'bottom' ? popup.offset().top + 25 + 'px' : popup.offset().top + Number.parseInt(win.position.y) + 'px'
            });
          } else {
            container = $(that);
            container.html(controlHtml);
          } // initialize the objects to the source code just injected


          var tbody = container.find('tbody:first');
          colorMapDiv = tbody.find('div.Map:first');
          colorBarDiv = tbody.find('div.Bar:first');
          var MapMaps = colorMapDiv.find('span');
          var BarMaps = colorBarDiv.find('span');
          colorMapL1 = MapMaps.filter('.Map1:first');
          colorMapL2 = MapMaps.filter('.Map2:first');
          colorMapL3 = MapMaps.filter('.Map3:first');
          colorBarL1 = BarMaps.filter('.Map1:first');
          colorBarL2 = BarMaps.filter('.Map2:first');
          colorBarL3 = BarMaps.filter('.Map3:first');
          colorBarL4 = BarMaps.filter('.Map4:first');
          colorBarL5 = BarMaps.filter('.Map5:first');
          colorBarL6 = BarMaps.filter('.Map6:first'); // create color pickers and maps

          colorMap = new Slider(colorMapDiv, {
            map: {
              width: images.colorMap.width,
              height: images.colorMap.height
            },
            arrow: {
              image: images.clientPath + images.colorMap.arrow.file,
              width: images.colorMap.arrow.width,
              height: images.colorMap.arrow.height
            }
          });
          colorMap.bind(mapValueChanged);
          colorBar = new Slider(colorBarDiv, {
            map: {
              width: images.colorBar.width,
              height: images.colorBar.height
            },
            arrow: {
              image: images.clientPath + images.colorBar.arrow.file,
              width: images.colorBar.arrow.width,
              height: images.colorBar.arrow.height
            }
          });
          colorBar.bind(colorBarValueChanged);
          colorPicker = new ColorValuePicker(tbody, color.active, win.expandable && win.bindToInput ? win.input : null, win.alphaPrecision);
          var hex = !isNullish$1(all) ? all.hex : null,
              preview = tbody.find('.Preview'),
              button = tbody.find('.Button');
          activePreview = preview.find('.Active:first').css({
            backgroundColor: hex && '#' + hex || 'transparent'
          });
          currentPreview = preview.find('.Current:first').css({
            backgroundColor: hex && '#' + hex || 'transparent'
          }).bind('click', currentClicked);
          setAlpha.call(that, currentPreview, toFixedNumeric(color.current.val('a') * 100 / 255, 4));
          okButton = button.find('.Ok:first').bind('click', okClicked);
          cancelButton = button.find('.Cancel:first').bind('click', cancelClicked);
          grid = button.find('.Grid:first');
          setTimeout(function () {
            setImg.call(that, colorMapL1, images.clientPath + 'Maps.png');
            setImg.call(that, colorMapL2, images.clientPath + 'Maps.png');
            setImg.call(that, colorMapL3, images.clientPath + 'map-opacity.png');
            setImg.call(that, colorBarL1, images.clientPath + 'Bars.png');
            setImg.call(that, colorBarL2, images.clientPath + 'Bars.png');
            setImg.call(that, colorBarL3, images.clientPath + 'Bars.png');
            setImg.call(that, colorBarL4, images.clientPath + 'Bars.png');
            setImg.call(that, colorBarL5, images.clientPath + 'bar-opacity.png');
            setImg.call(that, colorBarL6, images.clientPath + 'AlphaBar.png');
            setImg.call(that, preview.find('div:first'), images.clientPath + 'preview-opacity.png');
          }, 0);
          tbody.find('td.Radio input').bind('click', radioClicked); // initialize quick list

          if (color.quickList && color.quickList.length > 0) {
            var html = '';

            for (var i = 0; i < color.quickList.length; i++) {
              /* if default colors are hex strings, change them to color objects */
              if (_typeof(color.quickList[i]).toString().toLowerCase() === 'string') {
                color.quickList[i] = new Color({
                  hex: color.quickList[i]
                });
              }

              var _alpha = color.quickList[i].val('a');

              var _ahex = color.quickList[i].val('ahex');

              if (!win.alphaSupport && _ahex) _ahex = _ahex.substring(0, 6) + 'ff';
              var quickHex = color.quickList[i].val('hex');
              if (!_ahex) _ahex = '00000000';
              html += '<span class="QuickColor"' + (' title="#' + _ahex + '"') + ' style="background-color:' + (quickHex && '#' + quickHex || '') + ';' + (quickHex ? '' : 'background-image:url(' + images.clientPath + 'NoColor.png)') + (win.alphaSupport && _alpha && _alpha < 255 ? ';opacity:' + toFixedNumeric(_alpha / 255, 4) + ';filter:Alpha(opacity=' + toFixedNumeric(_alpha / 2.55, 4) + ')' : '') + '">&nbsp;</span>';
            }

            setImg.call(that, grid, images.clientPath + 'bar-opacity.png');
            grid.html(html);
            grid.find('.QuickColor').click(quickPickClicked);
          }

          setColorMode.call(that, settings.color.mode);
          color.active.bind(activeColorChanged);
          typeof liveCallback === 'function' && color.active.bind(liveCallback);
          color.current.bind(currentColorChanged); // bind to input

          if (win.expandable) {
            that.icon = popup.parents('.Icon:first');
            iconColor = that.icon.find('.Color:first').css({
              backgroundColor: hex && '#' + hex || 'transparent'
            });
            iconAlpha = that.icon.find('.Alpha:first');
            setImg.call(that, iconAlpha, images.clientPath + 'bar-opacity.png');
            setAlpha.call(that, iconAlpha, toFixedNumeric((255 - (!isNullish$1(all) ? all.a : 0)) * 100 / 255, 4));
            iconImage = that.icon.find('.Image:first').css({
              backgroundImage: 'url(\'' + images.clientPath + images.picker.file + '\')'
            }).bind('click', iconImageClicked);

            if (win.bindToInput && win.updateInputColor) {
              win.input.css({
                backgroundColor: hex && '#' + hex || 'transparent',
                color: isNullish$1(all) || all.v > 75 ? '#000000' : '#ffffff'
              });
            }

            moveBar = tbody.find('.Move:first').bind('mousedown', moveBarMouseDown);
            color.active.bind(expandableColorChanged);
          } else show.call(that);
        }
        /**
        *
        * @returns {void}
        */


        function destroy() {
          container.find('td.Radio input').unbind('click', radioClicked);
          currentPreview.unbind('click', currentClicked);
          cancelButton.unbind('click', cancelClicked);
          okButton.unbind('click', okClicked);

          if (settings.window.expandable) {
            iconImage.unbind('click', iconImageClicked);
            moveBar.unbind('mousedown', moveBarMouseDown);
            that.icon = null;
          }

          container.find('.QuickColor').unbind('click', quickPickClicked);
          colorMapDiv = null;
          colorBarDiv = null;
          colorMapL1 = null;
          colorMapL2 = null;
          colorMapL3 = null;
          colorBarL1 = null;
          colorBarL2 = null;
          colorBarL3 = null;
          colorBarL4 = null;
          colorBarL5 = null;
          colorBarL6 = null;
          colorMap.destroy();
          colorMap = null;
          colorBar.destroy();
          colorBar = null;
          colorPicker.destroy();
          colorPicker = null;
          activePreview = null;
          currentPreview = null;
          okButton = null;
          cancelButton = null;
          grid = null;
          commitCallback = null;
          cancelCallback = null;
          liveCallback = null;
          container.html('');

          for (var i = 0; i < List.length; i++) {
            if (List[i] === that) {
              List.splice(i, 1);
              i--; // Decrement to ensure we don't miss next item (lgtm warning)
            }
          }
        }

        var images = settings.images,
            localization = settings.localization; // local copies for YUI compressor

        var color = {
          active: _typeof(settings.color.active).toString().toLowerCase() === 'string' ? new Color({
            ahex: !settings.window.alphaSupport && settings.color.active ? settings.color.active.substring(0, 6) + 'ff' : settings.color.active
          }) : new Color({
            ahex: !settings.window.alphaSupport && settings.color.active.val('ahex') ? settings.color.active.val('ahex').substring(0, 6) + 'ff' : settings.color.active.val('ahex')
          }),
          current: _typeof(settings.color.active).toString().toLowerCase() === 'string' ? new Color({
            ahex: !settings.window.alphaSupport && settings.color.active ? settings.color.active.substring(0, 6) + 'ff' : settings.color.active
          }) : new Color({
            ahex: !settings.window.alphaSupport && settings.color.active.val('ahex') ? settings.color.active.val('ahex').substring(0, 6) + 'ff' : settings.color.active.val('ahex')
          }),
          quickList: settings.color.quickList
        };

        if (typeof commitCallback !== 'function') {
          commitCallback = null;
        }

        if (typeof liveCallback !== 'function') {
          liveCallback = null;
        }

        if (typeof cancelCallback !== 'function') {
          cancelCallback = null;
        }

        var elementStartX = null,
            // Used to record the starting css positions for dragging the control
        elementStartY = null,
            pageStartX = null,
            // Used to record the mousedown coordinates for dragging the control
        pageStartY = null,
            container = null,
            colorMapDiv = null,
            colorBarDiv = null,
            colorMapL1 = null,
            // different layers of colorMap and colorBar
        colorMapL2 = null,
            colorMapL3 = null,
            colorBarL1 = null,
            colorBarL2 = null,
            colorBarL3 = null,
            colorBarL4 = null,
            colorBarL5 = null,
            colorBarL6 = null,
            colorMap = null,
            // color maps
        colorBar = null,
            colorPicker = null,
            activePreview = null,
            // color boxes above the radio buttons
        currentPreview = null,
            okButton = null,
            cancelButton = null,
            grid = null,
            // preset colors grid
        iconColor = null,
            // iconColor for popup icon
        iconAlpha = null,
            // iconAlpha for popup icon
        iconImage = null,
            // iconImage popup icon
        moveBar = null; // drag bar

        $.extend(true, that, {
          // public properties, methods, and callbacks
          commitCallback: commitCallback,
          // commitCallback function can be overridden to return the selected color to a method you specify when the user clicks "OK"
          liveCallback: liveCallback,
          // liveCallback function can be overridden to return the selected color to a method you specify in live mode (continuous update)
          cancelCallback: cancelCallback,
          // cancelCallback function can be overridden to a method you specify when the user clicks "Cancel"
          color: color,
          show: show,
          hide: hide,
          destroy: destroy // destroys this control entirely, removing all events and objects, and removing itself from the List

        });
        List.push(that);
        setTimeout(function () {
          initialize.call(that);
        }, 0);
      });
    };
    /**
    * @typedef {PlainObject} external:jQuery.fn.jPickerOptionsIconInfo
    * @property {string} file Color Map/Color Bar/Color Picker arrow icon
    * @property {Float} width
    * @property {Float} height
    */

    /**
    * @typedef {PlainObject} external:jQuery.fn.jPickerOptionsImagesDimensionsArrow
    * @property {Float} width
    * @property {Float} height
    * @property {external:jQuery.fn.jPickerOptionsIconInfo} arrow
    */

    /**
    * @typedef {PlainObject} external:jQuery.fn.jPickerOptionsRadioTextboxLocale
    * @property {string} radio
    * @property {string} textbox
    */

    /**
    * @typedef {PlainObject} external:jQuery.fn.jPickerOptions
    * @property {PlainObject} window
    * @property {string|null} window.title Any title for the jPicker window itself - displays
    * "Drag Markers To Pick A Color" if left null
    * @property {PlainObject} window.effects
    * @property {"slide"|"show"|"fade"} window.effects.type Effect used to show/hide an expandable picker
    * @property {PlainObject} window.effects.speed
    * @property {"fast"|"slow"|Float} window.effects.speed.show Duration of "show" effect. Time in milliseconds.
    * @property {"fast"|"slow"|Float} window.effects.speed.hide Duration of "hide" effect. Time in milliseconds
    * @property {PlainObject} window.position
    * @property {"left"|"center"|"right"|"screenCenter"|Float} window.position.x Relative px value
    * @property {"top"|"bottom"|"center"|Float} window.position.y Relative px value
    * @property {boolean} window.expandable Defaults to large static picker - set to `true` to make an expandable
    * picker (small icon with popup) - set automatically when binded to input element; added by `$.fn.jPicker`
    * @property {boolean} window.liveUpdate Set `false` if you want the user to have to click "OK" before the
    * binded input box updates values (always `true` for expandable picker)
    * @property {boolean} window.alphaSupport Set to `true` to enable alpha picking
    * @property {Float} window.alphaPrecision Set decimal precision for alpha percentage display - hex codes do
    * not map directly to percentage integers - range 0-2
    * @property {boolean} window.updateInputColor Set to `false` to prevent binded input colors from changing
    * @property {boolean} [window.bindToInput] Added by `$.fn.jPicker`
    * @property {external:jQuery} [window.input] Added by `$.fn.jPicker`
    * @property {PlainObject} color
    * @property {"h"|"s"|"v"|"r"|"g"|"b"|"a"} color.mode Symbols stand for "h" (hue), "s" (saturation), "v" (value), "r" (red), "g" (green), "b" (blue), "a" (alpha)
    * @property {Color|string} color.active Strings are HEX values (e.g. #ffc000) WITH OR WITHOUT the "#" prefix
    * @property {Color[]|string[]} color.quickList The quick pick color list
    * Strings are HEX values (e.g. #ffc000) WITH OR WITHOUT the "#" prefix
    * @property {PlainObject} images
    * @property {string} images.clientPath Path to image files
    * @property {external:jQuery.fn.jPickerOptionsImagesDimensionsArrow} images.colorMap
    * @property {external:jQuery.fn.jPickerOptionsImagesDimensionsArrow} images.colorBar
    * @property {external:jQuery.fn.jPickerOptionsIconInfo} images.picker
    * @property {PlainObject} localization alter these to change the text presented by the picker (e.g. different language)
    * @property {PlainObject} localization.text
    * @property {string} localization.text.title
    * @property {string} localization.text.newColor
    * @property {string} localization.text.currentColor
    * @property {string} localization.text.ok
    * @property {string} localization.text.cancel
    * @property {PlainObject} localization.tooltips
    * @property {PlainObject} localization.tooltips.colors
    * @property {string} localization.tooltips.colors.newColor
    * @property {string} localization.tooltips.colors.currentColor
    * @property {PlainObject} localization.tooltips.buttons
    * @property {string} localization.tooltips.buttons.ok
    * @property {string} localization.tooltips.buttons.cancel
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.hue
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.saturation
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.value
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.red
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.green
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.blue
    * @property {external:jQuery.fn.jPickerOptionsRadioTextboxLocale} localization.tooltips.alpha
    * @property {PlainObject} localization.tooltips.hex
    * @property {string} localization.tooltips.hex.textbox
    * @property {string} localization.tooltips.hex.alpha
    */

    /**
    * The jPicker defaults - you can change anything in this section (such as the
    * clientPath to your images) without fear of breaking the program.
    * @namespace {external:jQuery.fn.jPickerOptions} defaults
    * @memberof external:jQuery.fn.$.fn.jPicker
    * @borrows external:jQuery.fn.jPickerOptions as external:jQuery.fn.jPicker.defaults
    * @see Source for all of the values
    */


    $.fn.jPicker.defaults = {
      window: {
        title: null,
        effects: {
          type: 'slide',
          speed: {
            show: 'slow',
            hide: 'fast'
          }
        },
        position: {
          x: 'screenCenter',
          y: 'top'
        },
        expandable: false,
        liveUpdate: true,
        alphaSupport: false,
        alphaPrecision: 0,
        updateInputColor: true
      },
      color: {
        mode: 'h',
        active: new Color({
          ahex: '#ffcc00ff'
        }),
        quickList: [new Color({
          h: 360,
          s: 33,
          v: 100
        }), new Color({
          h: 360,
          s: 66,
          v: 100
        }), new Color({
          h: 360,
          s: 100,
          v: 100
        }), new Color({
          h: 360,
          s: 100,
          v: 75
        }), new Color({
          h: 360,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 100
        }), new Color({
          h: 30,
          s: 33,
          v: 100
        }), new Color({
          h: 30,
          s: 66,
          v: 100
        }), new Color({
          h: 30,
          s: 100,
          v: 100
        }), new Color({
          h: 30,
          s: 100,
          v: 75
        }), new Color({
          h: 30,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 90
        }), new Color({
          h: 60,
          s: 33,
          v: 100
        }), new Color({
          h: 60,
          s: 66,
          v: 100
        }), new Color({
          h: 60,
          s: 100,
          v: 100
        }), new Color({
          h: 60,
          s: 100,
          v: 75
        }), new Color({
          h: 60,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 80
        }), new Color({
          h: 90,
          s: 33,
          v: 100
        }), new Color({
          h: 90,
          s: 66,
          v: 100
        }), new Color({
          h: 90,
          s: 100,
          v: 100
        }), new Color({
          h: 90,
          s: 100,
          v: 75
        }), new Color({
          h: 90,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 70
        }), new Color({
          h: 120,
          s: 33,
          v: 100
        }), new Color({
          h: 120,
          s: 66,
          v: 100
        }), new Color({
          h: 120,
          s: 100,
          v: 100
        }), new Color({
          h: 120,
          s: 100,
          v: 75
        }), new Color({
          h: 120,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 60
        }), new Color({
          h: 150,
          s: 33,
          v: 100
        }), new Color({
          h: 150,
          s: 66,
          v: 100
        }), new Color({
          h: 150,
          s: 100,
          v: 100
        }), new Color({
          h: 150,
          s: 100,
          v: 75
        }), new Color({
          h: 150,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 50
        }), new Color({
          h: 180,
          s: 33,
          v: 100
        }), new Color({
          h: 180,
          s: 66,
          v: 100
        }), new Color({
          h: 180,
          s: 100,
          v: 100
        }), new Color({
          h: 180,
          s: 100,
          v: 75
        }), new Color({
          h: 180,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 40
        }), new Color({
          h: 210,
          s: 33,
          v: 100
        }), new Color({
          h: 210,
          s: 66,
          v: 100
        }), new Color({
          h: 210,
          s: 100,
          v: 100
        }), new Color({
          h: 210,
          s: 100,
          v: 75
        }), new Color({
          h: 210,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 30
        }), new Color({
          h: 240,
          s: 33,
          v: 100
        }), new Color({
          h: 240,
          s: 66,
          v: 100
        }), new Color({
          h: 240,
          s: 100,
          v: 100
        }), new Color({
          h: 240,
          s: 100,
          v: 75
        }), new Color({
          h: 240,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 20
        }), new Color({
          h: 270,
          s: 33,
          v: 100
        }), new Color({
          h: 270,
          s: 66,
          v: 100
        }), new Color({
          h: 270,
          s: 100,
          v: 100
        }), new Color({
          h: 270,
          s: 100,
          v: 75
        }), new Color({
          h: 270,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 10
        }), new Color({
          h: 300,
          s: 33,
          v: 100
        }), new Color({
          h: 300,
          s: 66,
          v: 100
        }), new Color({
          h: 300,
          s: 100,
          v: 100
        }), new Color({
          h: 300,
          s: 100,
          v: 75
        }), new Color({
          h: 300,
          s: 100,
          v: 50
        }), new Color({
          h: 180,
          s: 0,
          v: 0
        }), new Color({
          h: 330,
          s: 33,
          v: 100
        }), new Color({
          h: 330,
          s: 66,
          v: 100
        }), new Color({
          h: 330,
          s: 100,
          v: 100
        }), new Color({
          h: 330,
          s: 100,
          v: 75
        }), new Color({
          h: 330,
          s: 100,
          v: 50
        }), new Color()]
      },
      images: {
        clientPath: '/jPicker/images/',
        colorMap: {
          width: 256,
          height: 256,
          arrow: {
            file: 'mappoint.gif',
            width: 15,
            height: 15
          }
        },
        colorBar: {
          width: 20,
          height: 256,
          arrow: {
            file: 'rangearrows.gif',
            width: 20,
            height: 7
          }
        },
        picker: {
          file: 'picker.gif',
          width: 25,
          height: 24
        }
      },
      localization: {
        text: {
          title: 'Drag Markers To Pick A Color',
          newColor: 'new',
          currentColor: 'current',
          ok: 'OK',
          cancel: 'Cancel'
        },
        tooltips: {
          colors: {
            newColor: 'New Color - Press &ldquo;OK&rdquo; To Commit',
            currentColor: 'Click To Revert To Original Color'
          },
          buttons: {
            ok: 'Commit To This Color Selection',
            cancel: 'Cancel And Revert To Original Color'
          },
          hue: {
            radio: 'Set To &ldquo;Hue&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Hue&rdquo; Value (0-360&deg;)'
          },
          saturation: {
            radio: 'Set To &ldquo;Saturation&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Saturation&rdquo; Value (0-100%)'
          },
          value: {
            radio: 'Set To &ldquo;Value&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Value&rdquo; Value (0-100%)'
          },
          red: {
            radio: 'Set To &ldquo;Red&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Red&rdquo; Value (0-255)'
          },
          green: {
            radio: 'Set To &ldquo;Green&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Green&rdquo; Value (0-255)'
          },
          blue: {
            radio: 'Set To &ldquo;Blue&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Blue&rdquo; Value (0-255)'
          },
          alpha: {
            radio: 'Set To &ldquo;Alpha&rdquo; Color Mode',
            textbox: 'Enter A &ldquo;Alpha&rdquo; Value (0-100)'
          },
          hex: {
            textbox: 'Enter A &ldquo;Hex&rdquo; Color Value (#000000-#ffffff)',
            alpha: 'Enter A &ldquo;Alpha&rdquo; Value (#00-#ff)'
          }
        }
      }
    };
    return $;
  };

  /* globals jQuery */

  /**
   * Localizing script for SVG-edit UI.
   * @module locale
   * @license MIT
   *
   * @copyright 2010 Narendra Sisodya
   * @copyright 2010 Alexis Deveria
   *
   */

  /**
   * Used, for example, in the ImageLibs extension, to present libraries
   * (with name/URL/description) in order.
   * @typedef {GenericArray<module:locale.LocaleStrings>} module:locale.LocaleArray
  */

  /**
   * The string keys of the object are two-letter language codes.
   * @tutorial LocaleDocs
   * @typedef {PlainObject<string, string|module:locale.LocaleStrings|module:locale.LocaleArray>} module:locale.LocaleStrings
   */
  // keyed to an array of objects with "id" and "title" or "textContent" properties

  /**
   * @typedef {PlainObject<string, string>} module:locale.LocaleSelectorValue
   */
  var $$b = jQuery;
  var langParam;
  /**
   * Looks for elements to localize using the supplied `obj` to indicate
   *   on which selectors (or IDs if `ids` is set to `true`) to set its
   *   strings (with selectors relative to the editor root element). All
   *   keys will be translated, but for each selector, only the first item
   *   found matching will be modified.
   * If the type is `content`, the selector-identified element's children
   *   will be checked, and the first (non-empty) text (placeholder) node
   *   found will have its text replaced.
   * If the type is `title`, the element's `title`
   *   property will be set.
   * If the type is `aria-label`, the element's `aria-label` attribute
   *   will be set (i.e., instructions for screen readers when there is
   *   otherwise no visible text to be read for the function of the form
   *   control).
   * @param {"content"|"title"} type
   * @param {module:locale.LocaleSelectorValue} obj Selectors or IDs keyed to strings
   * @param {boolean} ids
   * @returns {void}
  */

  var setStrings = function setStrings(type, obj, ids) {
    // Root element to look for element from
    var parent = $$b('#svg_editor').parent();
    Object.entries(obj).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          sel = _ref2[0],
          val = _ref2[1];

      if (!val) {
        console.log(sel); // eslint-disable-line no-console

        return; // keep old text when has no translation
      }

      if (ids) {
        sel = '#' + sel;
      }

      var $elem = parent.find(sel);

      if ($elem.length) {
        var elem = $elem[0];

        switch (type) {
          case 'aria-label':
            elem.setAttribute('aria-label', val);
            break;

          case 'content':
            _toConsumableArray(elem.childNodes).some(function (node) {
              if (node.nodeType === 3
              /* Node.TEXT_NODE */
              && node.textContent.trim()) {
                node.textContent = val;
                return true;
              }

              return false;
            });

            break;

          case 'title':
            elem.title = val;
            break;
        }
      } else {
        console.log('Missing element for localization: ' + sel); // eslint-disable-line no-console
      }
    });
  };
  /**
  * The "data" property is generally set to an an array of objects with
  *   "id" and "title" or "textContent" properties.
  * @typedef {PlainObject} module:locale.AddLangExtensionLocaleData
  * @property {module:locale.LocaleStrings[]} data See {@tutorial LocaleDocs}
  */

  /**
  * @interface module:locale.LocaleEditorInit
  */

  /**
   * @function module:locale.LocaleEditorInit#addLangData
   * @param {string} langParam
   * @returns {module:locale.AddLangExtensionLocaleData}
  */

  var editor_;
  /**
   * Sets the current editor instance (on which `addLangData`) exists.
   * @function init
   * @memberof module:locale
   * @param {module:locale.LocaleEditorInit} editor
   * @returns {void}
  */

  var init$7 = function init(editor) {
    editor_ = editor;
  };
  /**
  * @typedef {PlainObject} module:locale.LangAndData
  * @property {string} langParam
  * @property {module:locale.LocaleStrings} langData
  */

  /**
  * @function module:locale.readLang
  * @param {module:locale.LocaleStrings} langData See {@tutorial LocaleDocs}
  * @fires module:svgcanvas.SvgCanvas#event:ext_addLangData
  * @returns {Promise<module:locale.LangAndData>} Resolves to [`LangAndData`]{@link module:locale.LangAndData}
  */

  var readLang = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(langData) {
      var more, _langData, tools, properties, config, layers, common, ui, opts, ariaLabels;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return editor_.addLangData(langParam);

            case 2:
              more = _context.sent;
              $$b.each(more, function (i, m) {
                if (m.data) {
                  langData = $$b.merge(langData, m.data);
                }
              }); // Old locale file, do nothing for now.

              if (langData.tools) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", undefined);

            case 6:
              _langData = langData, tools = _langData.tools, properties = _langData.properties, config = _langData.config, layers = _langData.layers, common = _langData.common, ui = _langData.ui;
              setStrings('content', {
                // Todo: Add this powered by (probably by default) but with config to remove
                // copyrightLabel: misc.powered_by, // Currently commented out in svg-editor.html
                curve_segments: properties.curve_segments,
                fitToContent: tools.fitToContent,
                fit_to_all: tools.fit_to_all,
                fit_to_canvas: tools.fit_to_canvas,
                fit_to_layer_content: tools.fit_to_layer_content,
                fit_to_sel: tools.fit_to_sel,
                icon_large: config.icon_large,
                icon_medium: config.icon_medium,
                icon_small: config.icon_small,
                icon_xlarge: config.icon_xlarge,
                image_opt_embed: config.image_opt_embed,
                image_opt_ref: config.image_opt_ref,
                includedImages: config.included_images,
                largest_object: tools.largest_object,
                layersLabel: layers.layers,
                page: tools.page,
                relativeToLabel: tools.relativeTo,
                selLayerLabel: layers.move_elems_to,
                selectedPredefined: config.select_predefined,
                selected_objects: tools.selected_objects,
                smallest_object: tools.smallest_object,
                straight_segments: properties.straight_segments,
                svginfo_bg_url: config.editor_img_url + ':',
                svginfo_bg_note: config.editor_bg_note,
                svginfo_change_background: config.background,
                svginfo_dim: config.doc_dims,
                svginfo_editor_prefs: config.editor_prefs,
                svginfo_height: common.height,
                svginfo_icons: config.icon_size,
                svginfo_image_props: config.image_props,
                svginfo_lang: config.language,
                svginfo_title: config.doc_title,
                svginfo_width: common.width,
                tool_docprops_cancel: common.cancel,
                tool_docprops_save: common.ok,
                tool_source_cancel: common.cancel,
                tool_source_save: common.ok,
                tool_prefs_cancel: common.cancel,
                tool_prefs_save: common.ok,
                sidepanel_handle: layers.layers.split('').join(' '),
                tool_clear: tools.new_doc,
                tool_docprops: tools.docprops,
                tool_export: tools.export_img,
                tool_import: tools.import_doc,
                tool_open: tools.open_doc,
                tool_save: tools.save_doc,
                tool_editor_prefs: config.editor_prefs,
                tool_editor_homepage: tools.editor_homepage,
                svginfo_units_rulers: config.units_and_rulers,
                svginfo_rulers_onoff: config.show_rulers,
                svginfo_unit: config.base_unit,
                svginfo_grid_settings: config.grid,
                svginfo_snap_onoff: config.snapping_onoff,
                svginfo_snap_step: config.snapping_stepsize,
                svginfo_grid_color: config.grid_color
              }, true); // Context menus

              opts = {};
              ['cut', 'copy', 'paste', 'paste_in_place', 'delete', 'group', 'ungroup', 'move_front', 'move_up', 'move_down', 'move_back'].forEach(function (item) {
                opts['#cmenu_canvas a[href="#' + item + '"]'] = tools[item];
              });
              ['dupe', 'merge_down', 'merge_all'].forEach(function (item) {
                opts['#cmenu_layers a[href="#' + item + '"]'] = layers[item];
              });
              opts['#cmenu_layers a[href="#delete"]'] = layers.del;
              setStrings('content', opts);
              ariaLabels = {};
              Object.entries({
                tool_blur: properties.blur,
                tool_position: tools.align_to_page,
                tool_font_family: properties.font_family,
                zoom_panel: ui.zoom_level,
                stroke_linejoin: properties.linejoin_miter,
                stroke_linecap: properties.linecap_butt,
                tool_opacity: properties.opacity
              }).forEach(function (_ref4) {
                var _ref5 = _slicedToArray(_ref4, 2),
                    id = _ref5[0],
                    value = _ref5[1];

                ariaLabels['#' + id + ' button'] = value;
              });
              Object.entries({
                group_opacity: properties.opacity,
                zoom: ui.zoom_level
              }).forEach(function (_ref6) {
                var _ref7 = _slicedToArray(_ref6, 2),
                    id = _ref7[0],
                    value = _ref7[1];

                ariaLabels['#' + id] = value;
              });
              setStrings('aria-label', ariaLabels);
              setStrings('title', {
                align_relative_to: tools.align_relative_to,
                circle_cx: properties.circle_cx,
                circle_cy: properties.circle_cy,
                circle_r: properties.circle_r,
                cornerRadiusLabel: properties.corner_radius,
                ellipse_cx: properties.ellipse_cx,
                ellipse_cy: properties.ellipse_cy,
                ellipse_rx: properties.ellipse_rx,
                ellipse_ry: properties.ellipse_ry,
                fill_color: properties.fill_color,
                font_family: properties.font_family,
                idLabel: properties.id,
                image_height: properties.image_height,
                image_url: properties.image_url,
                image_width: properties.image_width,
                layer_delete: layers.del,
                layer_down: layers.move_down,
                layer_new: layers["new"],
                layer_rename: layers.rename,
                layer_moreopts: common.more_opts,
                layer_up: layers.move_up,
                line_x1: properties.line_x1,
                line_x2: properties.line_x2,
                line_y1: properties.line_y1,
                line_y2: properties.line_y2,
                linecap_butt: properties.linecap_butt,
                linecap_round: properties.linecap_round,
                linecap_square: properties.linecap_square,
                linejoin_bevel: properties.linejoin_bevel,
                linejoin_miter: properties.linejoin_miter,
                linejoin_round: properties.linejoin_round,
                main_icon: tools.main_menu,
                palette: ui.palette_info,
                zoom_panel: ui.zoom_level,
                path_node_x: properties.node_x,
                path_node_y: properties.node_y,
                rect_height_tool: properties.rect_height,
                rect_width_tool: properties.rect_width,
                seg_type: properties.seg_type,
                selLayerNames: layers.move_selected,
                selected_x: properties.pos_x,
                selected_y: properties.pos_y,
                stroke_color: properties.stroke_color,
                stroke_style: properties.stroke_style,
                stroke_width: properties.stroke_width,
                svginfo_title: config.doc_title,
                text: properties.text_contents,
                toggle_stroke_tools: ui.toggle_stroke_tools,
                tool_add_subpath: tools.add_subpath,
                tool_alignbottom: tools.align_bottom,
                tool_aligncenter: tools.align_center,
                tool_alignleft: tools.align_left,
                tool_alignmiddle: tools.align_middle,
                tool_alignright: tools.align_right,
                tool_aligntop: tools.align_top,
                tool_angle: properties.angle,
                tool_blur: properties.blur,
                tool_bold: properties.bold,
                tool_circle: tools.mode_circle,
                tool_clone: tools.clone,
                tool_clone_multi: tools.clone,
                tool_delete: tools.del,
                tool_delete_multi: tools.del,
                tool_ellipse: tools.mode_ellipse,
                tool_fhellipse: tools.mode_fhellipse,
                tool_fhpath: tools.mode_fhpath,
                tool_fhrect: tools.mode_fhrect,
                tool_font_size: properties.font_size,
                tool_group_elements: tools.group_elements,
                tool_make_link: tools.make_link,
                tool_link_url: tools.set_link_url,
                tool_image: tools.mode_image,
                tool_italic: properties.italic,
                tool_line: tools.mode_line,
                tool_move_bottom: tools.move_bottom,
                tool_move_top: tools.move_top,
                tool_node_clone: tools.node_clone,
                tool_node_delete: tools.node_delete,
                tool_node_link: tools.node_link,
                tool_opacity: properties.opacity,
                tool_openclose_path: tools.openclose_path,
                tool_path: tools.mode_path,
                tool_position: tools.align_to_page,
                tool_rect: tools.mode_rect,
                tool_redo: tools.redo,
                tool_reorient: tools.reorient_path,
                tool_select: tools.mode_select,
                tool_source: tools.source_save,
                tool_square: tools.mode_square,
                tool_text: tools.mode_text,
                tool_topath: tools.to_path,
                tool_undo: tools.undo,
                tool_ungroup: tools.ungroup,
                tool_wireframe: tools.wireframe_mode,
                tool_zoom: tools.mode_zoom,
                url_notice: tools.no_embed
              }, true);
              return _context.abrupt("return", {
                langParam: langParam,
                langData: langData
              });

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function readLang(_x) {
      return _ref3.apply(this, arguments);
    };
  }();
  /**
   *
   * @function module:locale.putLocale
   * @param {string} givenParam
   * @param {string[]} goodLangs
   * @param {{langPath: string}} conf
   * @fires module:svgcanvas.SvgCanvas#event:ext_addLangData
   * @fires module:svgcanvas.SvgCanvas#event:ext_langReady
   * @fires module:svgcanvas.SvgCanvas#event:ext_langChanged
   * @returns {Promise<module:locale.LangAndData>} Resolves to result of {@link module:locale.readLang}
  */

  var putLocale = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(givenParam, goodLangs, conf) {
      var url, module;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (givenParam) {
                langParam = givenParam;
              } else if (navigator.userLanguage) {
                // Explorer
                langParam = navigator.userLanguage;
              } else if (navigator.language) {
                // FF, Opera, ...
                langParam = navigator.language;
              }

              console.log('Lang: ' + langParam); // eslint-disable-line no-console
              // Set to English if language is not in list of good langs

              if (!goodLangs.includes(langParam) && langParam !== 'test') {
                langParam = 'en';
              }

              url = conf.langPath + 'lang.' + langParam + '.js'; // eslint-disable-next-line node/no-unsupported-features/es-syntax

              _context2.next = 6;
              return import(url);

            case 6:
              module = _context2.sent;
              return _context2.abrupt("return", readLang(module["default"]));

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function putLocale(_x2, _x3, _x4) {
      return _ref8.apply(this, arguments);
    };
  }();

  var $q$1 = $q;
  var editor = {};
  var $$c = [jQueryPluginJSHotkeys, jQueryPluginSVGIcons, jQueryPluginJGraduate, jQueryPluginSpinButton, jQueryPluginSVG, jQueryContextMenu, jPicker].reduce(function (jq, func) {
    return func(jq);
  }, jQuery);
  var homePage = 'https://github.com/SVG-Edit/svgedit'; // EDITOR PROPERTIES: (defined below)
  //    curPrefs, curConfig, canvas, storage, uiStrings
  //
  // STATE MAINTENANCE PROPERTIES

  /**
  * @type {Float}
  */

  editor.tool_scale = 1; // Dependent on icon size, so any use to making configurable instead? Used by `jQuery.SpinButton.js`

  /**
  * @type {Integer}
  */

  editor.exportWindowCt = 0;
  /**
  * @type {boolean}
  */

  editor.langChanged = false;
  /**
  * @type {boolean}
  */

  editor.showSaveWarning = false;
  /**
   * Will be set to a boolean by `ext-storage.js`
   * @type {"ignore"|"waiting"|"closed"}
  */

  editor.storagePromptState = 'ignore';
  var callbacks = [],

  /**
  * @typedef {"s"|"m"|"l"|"xl"|Float} module:SVGEditor.IconSize
  */

  /**
  * Preferences.
  * @interface module:SVGEditor.Prefs
  * @property {string} [lang="en"] Two-letter language code. The language must exist in the Editor Preferences language list. Defaults to "en" if `locale.js` detection does not detect another language.
  * @property {module:SVGEditor.IconSize} [iconsize="s"|"m"] Size of the toolbar icons. Will default to 's' if the window height is smaller than the minimum height and 'm' otherwise.
  * @property {string} [bkgd_color="#FFF"] Color hex for canvas background color. Defaults to white.
  * @property {string} [bkgd_url=""] Background raster image URL. This image will fill the background of the document; useful for tracing purposes.
  * @property {"embed"|"ref"} [img_save="embed"] Defines whether included raster images should be saved as Data URIs when possible, or as URL references. Settable in the Document Properties dialog.
  * @property {boolean} [save_notice_done=false] Used to track alert status
  * @property {boolean} [export_notice_done=false] Used to track alert status
  * @todo `save_notice_done` and `export_notice_done` should be changed to flags rather than preferences
  */

  /**
  * @namespace {module:SVGEditor.Prefs} defaultPrefs
  * @memberof module:SVGEditor~
  * @implements {module:SVGEditor.Prefs}
  */
  // The iteration algorithm for defaultPrefs does not currently support array/objects
  defaultPrefs =
  /** @lends module:SVGEditor~defaultPrefs */
  {
    // EDITOR OPTIONS (DIALOG)

    /**
    * Default to "en" if locale.js detection does not detect another language.
    */
    lang: '',

    /**
    * Will default to 's' if the window height is smaller than the minimum
    * height and 'm' otherwise.
    */
    iconsize: '',
    bkgd_color: '#FFF',
    bkgd_url: '',
    // DOCUMENT PROPERTIES (DIALOG)
    img_save: 'embed',
    // ALERT NOTICES
    // Only shows in UI as far as alert notices, but useful to remember, so keeping as pref
    save_notice_done: false,
    export_notice_done: false
  },

  /**
  * @name module:SVGEditor~defaultExtensions
  * @type {string[]}
  */
  defaultExtensions = ['ext-connector.js', 'ext-eyedropper.js', 'ext-grid.js', 'ext-imagelib.js', 'ext-markers.js', 'ext-overview_window.js', 'ext-panning.js', 'ext-polygon.js', 'ext-shapes.js', 'ext-star.js', 'ext-storage.js'],

  /**
  * @typedef {"@default"|string} module:SVGEditor.Stylesheet `@default` will automatically load all of the default CSS paths for SVGEditor
  */

  /**
  * @typedef {GenericArray} module:SVGEditor.XYDimensions
  * @property {Integer} length 2
  * @property {Float} 0
  * @property {Float} 1
  */

  /**
  * @tutorial ConfigOptions
  * @interface module:SVGEditor.Config
  * @property {string} [canvasName="default"] Used to namespace storage provided via `ext-storage.js`; you can use this if you wish to have multiple independent instances of SVG Edit on the same domain
  * @property {boolean} [no_save_warning=false] If `true`, prevents the warning dialog box from appearing when closing/reloading the page. Mostly useful for testing.
  * @property {string} [imgPath="images/"] The path where the SVG icons are located, with trailing slash. Note that as of version 2.7, this is not configurable by URL for security reasons.
  * @property {string} [langPath="locale/"] The path where the language files are located, with trailing slash. Default will be changed to `../dist/locale/` if this is a modular load. Note that as of version 2.7, this is not configurable by URL for security reasons.
  * @property {string} [extPath="extensions/"] The path used for extension files, with trailing slash. Default will be changed to `../dist/extensions/` if this is a modular load. Note that as of version 2.7, this is not configurable by URL for security reasons.
  * @property {string} [canvgPath="canvg/"] The path used for `canvg` files, with trailing slash. Default will be changed to `../dist/` if this is a modular load.
  * @property {string} [jspdfPath="jspdf/"] The path used for `jsPDF` files, with trailing slash. Default will be changed to `../dist/` if this is a modular load.
  * @property {string} [extIconsPath="extensions/"] The path used for extension icons, with trailing slash.
  * @property {string} [jGraduatePath="jgraduate/images/"] The path where jGraduate images are located. Note that as of version 2.7, this is not configurable by URL for security reasons.
  * @property {boolean} [preventAllURLConfig=false] Set to `true` to override the ability for URLs to set non-content configuration (including extension config). Must be set early, i.e., in `svgedit-config-iife.js`; extension loading is too late!
  * @property {boolean} [preventURLContentLoading=false] Set to `true` to override the ability for URLs to set URL-based SVG content. Must be set early, i.e., in `svgedit-config-iife.js`; extension loading is too late!
  * @property {boolean} [lockExtensions=false] Set to `true` to override the ability for URLs to set their own extensions; disallowed in URL setting. There is no need for this when `preventAllURLConfig` is used. Must be set early, i.e., in `svgedit-config-iife.js`; extension loading is too late!
  * @property {boolean} [noDefaultExtensions=false] If set to `true`, prohibits automatic inclusion of default extensions (though "extensions" can still be used to add back any desired default extensions along with any other extensions). This can only be meaningfully used in `svgedit-config-iife.js` or in the URL
  * @property {boolean} [noStorageOnLoad=false] Some interaction with `ext-storage.js`; prevent even the loading of previously saved local storage.
  * @property {boolean} [forceStorage=false] Some interaction with `ext-storage.js`; strongly discouraged from modification as it bypasses user privacy by preventing them from choosing whether to keep local storage or not (and may be required by law in some regions)
  * @property {boolean} [emptyStorageOnDecline=false] Used by `ext-storage.js`; empty any prior storage if the user declines to store
  * @property {boolean} [avoidClientSide=false] DEPRECATED (use `avoidClientSideDownload` instead); Used by `ext-server_opensave.js`; set to `true` if you wish to always save to server and not only as fallback when client support is lacking
  * @property {boolean} [avoidClientSideDownload=false] Used by `ext-server_opensave.js`; set to `true` if you wish to always save to server and not only as fallback when client support is lacking
  * @property {boolean} [avoidClientSideOpen=false] Used by `ext-server_opensave.js`; set to `true` if you wish to always open from the server and not only as fallback when FileReader client support is lacking
  * @property {string[]} [extensions=module:SVGEditor~defaultExtensions] Extensions to load on startup. Use an array in `setConfig` and comma separated file names in the URL. Extension names must begin with "ext-". Note that as of version 2.7, paths containing "/", "\", or ":", are disallowed for security reasons. Although previous versions of this list would entirely override the default list, as of version 2.7, the defaults will always be added to this explicit list unless the configuration `noDefaultExtensions` is included.
  * @property {string[]} [allowedOrigins=[]] Used by `ext-xdomain-messaging.js` to indicate which origins are permitted for cross-domain messaging (e.g., between the embedded editor and main editor code). Besides explicit domains, one might add '*' to allow all domains (not recommended for privacy/data integrity of your user's content!), `window.location.origin` for allowing the same origin (should be safe if you trust all apps on your domain), 'null' to allow `file:///` URL usage
  * @property {null|PlainObject} [colorPickerCSS=null] Object of CSS properties mapped to values (for jQuery) to apply to the color picker. See {@link http://api.jquery.com/css/#css-properties}. A `null` value (the default) will cause the CSS to default to `left` with a position equal to that of the `fill_color` or `stroke_color` element minus 140, and a `bottom` equal to 40
  * @property {string} [paramurl] This was available via URL only. Allowed an un-encoded URL within the query string (use "url" or "source" with a data: URI instead)
  * @property {Float} [canvas_expansion=3] The minimum area visible outside the canvas, as a multiple of the image dimensions. The larger the number, the more one can scroll outside the canvas.
  * @property {PlainObject} [initFill] Init fill properties
  * @property {string} [initFill.color="FF0000"] The initial fill color. Must be a hex code string. Defaults to solid red.
  * @property {Float} [initFill.opacity=1] The initial fill opacity. Must be a number between 0 and 1
  * @property {PlainObject} [initStroke] Init stroke properties
  * @property {Float} [initStroke.width=5] The initial stroke width. Must be a positive number.
  * @property {string} [initStroke.color="000000"] The initial stroke color. Must be a hex code. Defaults to solid black.
  * @property {Float} [initStroke.opacity=1] The initial stroke opacity. Must be a number between 0 and 1.
  * @property {PlainObject} text Text style properties
  * @property {Float} [text.stroke_width=0] Text stroke width
  * @property {Float} [text.font_size=24] Text font size
  * @property {string} [text.font_family="serif"] Text font family
  * @property {Float} [initOpacity=1] Initial opacity (multiplied by 100)
  * @property {module:SVGEditor.XYDimensions} [dimensions=[640, 480]] The default width/height of a new document. Use an array in `setConfig` (e.g., `[800, 600]`) and comma separated numbers in the URL.
  * @property {boolean} [gridSnapping=false] Enable snap to grid by default. Set in Editor Options.
  * @property {string} [gridColor="#000"] Accepts hex, e.g., '#000'. Set in Editor Options. Defaults to black.
  * @property {string} [baseUnit="px"] Set in Editor Options.
  * @property {Float} [snappingStep=10] Set the default grid snapping value. Set in Editor Options.
  * @property {boolean} [showRulers=true] Initial state of ruler display (v2.6). Set in Editor Options.
  * @property {string} [initTool="select"] The initially selected tool. Must be either the ID of the button for the tool, or the ID without `tool_` prefix (e.g., "select").
  * @property {boolean} [wireframe=false] Start in wireframe mode
  * @property {boolean} [showlayers=false] Open the layers side-panel by default.
  * @property {"new"|"same"} [exportWindowType="new"] Can be "new" or "same" to indicate whether new windows will be generated for each export; the `window.name` of the export window is namespaced based on the `canvasName` (and incremented if "new" is selected as the type). Introduced 2.8.
  * @property {boolean} [showGrid=false] Set by `ext-grid.js`; determines whether or not to show the grid by default
  * @property {boolean} [show_outside_canvas=true] Defines whether or not elements outside the canvas should be visible. Set and used in `svgcanvas.js`.
  * @property {boolean} [selectNew=true] If true, will replace the selection with the current element and automatically select element objects (when not in "path" mode) after they are created, showing their grips (v2.6). Set and used in `svgcanvas.js` (`mouseUp`).
  * @todo Some others could be preferences as well (e.g., preventing URL changing of extensions, defaultExtensions, stylesheets, colorPickerCSS); Change the following to preferences and add pref controls where missing to the UI (e.g., `canvas_expansion`, `initFill`, `initStroke`, `text`, `initOpacity`, `dimensions`, `initTool`, `wireframe`, `showlayers`, `gridSnapping`, `gridColor`, `baseUnit`, `snappingStep`, `showRulers`, `exportWindowType`, `showGrid`, `show_outside_canvas`, `selectNew`)?
  */

  /**
  * @namespace {module:SVGEditor.Config} defaultConfig
  * @memberof module:SVGEditor~
  * @implements {module:SVGEditor.Config}
  */
  defaultConfig = {
    canvasName: 'default',
    canvas_expansion: 3,
    initFill: {
      color: 'FF0000',
      // solid red
      opacity: 1
    },
    initStroke: {
      width: 5,
      color: '000000',
      // solid black
      opacity: 1
    },
    text: {
      stroke_width: 0,
      font_size: 24,
      font_family: 'serif'
    },
    initOpacity: 1,
    colorPickerCSS: null,
    // Defaults to 'left' with a position equal to that of the fill_color or stroke_color element minus 140, and a 'bottom' equal to 40
    initTool: 'select',
    exportWindowType: 'new',
    // 'same' (todo: also support 'download')
    wireframe: false,
    showlayers: false,
    no_save_warning: false,
    // PATH CONFIGURATION
    // The following path configuration items are disallowed in the URL (as should any future path configurations)
    langPath: '/src/editor/locale/',
    // Default will be changed if this is a non-modular load
    extPath: '/src/editor/extensions/',
    // Default will be changed if this is a non-modular load
    canvgPath: '/src/editor/canvg/',
    // Default will be changed if this is a non-modular load
    jspdfPath: '/src/editor/jspdf/',
    // Default will be changed if this is a non-modular load
    imgPath: '/src/editor/images/',
    jGraduatePath: '/src/editor/jgraduate/images/',
    extIconsPath: '/src/editor/extensions/',
    // DOCUMENT PROPERTIES
    // Change the following to a preference (already in the Document Properties dialog)?
    dimensions: [640, 480],
    // EDITOR OPTIONS
    // Change the following to preferences (already in the Editor Options dialog)?
    gridSnapping: false,
    gridColor: '#000',
    baseUnit: 'px',
    snappingStep: 10,
    showRulers: true,
    // URL BEHAVIOR CONFIGURATION
    preventAllURLConfig: false,
    preventURLContentLoading: false,
    // EXTENSION CONFIGURATION (see also preventAllURLConfig)
    lockExtensions: false,
    // Disallowed in URL setting
    noDefaultExtensions: false,
    // noDefaultExtensions can only be meaningfully used in `svgedit-config-iife.js` or in the URL
    // EXTENSION-RELATED (GRID)
    showGrid: false,
    // Set by ext-grid.js
    // EXTENSION-RELATED (STORAGE)
    noStorageOnLoad: false,
    // Some interaction with ext-storage.js; prevent even the loading of previously saved local storage
    forceStorage: false,
    // Some interaction with ext-storage.js; strongly discouraged from modification as it bypasses user privacy by preventing them from choosing whether to keep local storage or not
    emptyStorageOnDecline: false,
    // Used by ext-storage.js; empty any prior storage if the user declines to store
    // EXTENSION (CLIENT VS. SERVER SAVING/OPENING)
    avoidClientSide: false,
    // Deprecated in favor of `avoidClientSideDownload`
    avoidClientSideDownload: false,
    avoidClientSideOpen: false
  },

  /**
  * LOCALE.
  * @name module:SVGEditor.uiStrings
  * @type {PlainObject}
  */
  uiStrings$1 = editor.uiStrings = {};
  var svgCanvas,
      urldata = {},
      isReady = false,
      customExportImage = false,
      customExportPDF = false,
      curPrefs = {},
      // Note: The difference between Prefs and Config is that Prefs
  //   can be changed in the UI and are stored in the browser,
  //   while config cannot
  curConfig = {
    // We do not put on defaultConfig to simplify object copying
    //   procedures (we obtain instead from defaultExtensions)
    extensions: [],

    /**
    * Can use `location.origin` to indicate the current
    * origin. Can contain a '*' to allow all domains or 'null' (as
    * a string) to support all `file:///` URLs. Cannot be set by
    * URL for security reasons (not safe, at least for
    * privacy or data integrity of SVG content).
    * Might have been fairly safe to allow
    *   `new URL(location.href).origin` by default but
    *   avoiding it ensures some more security that even third
    *   party apps on the same domain also cannot communicate
    *   with this app by default.
    * For use with `ext-xdomain-messaging.js`
    * @todo We might instead make as a user-facing preference.
    */
    allowedOrigins: []
  };
  /**
   *
   * @param {string} str SVG string
   * @param {PlainObject} [opts={}]
   * @param {boolean} [opts.noAlert]
   * @throws {Error} Upon failure to load SVG
   * @returns {Promise<void>} Resolves to undefined upon success (or if `noAlert` is
   *   falsey, though only until after the `alert` is closed); rejects if SVG
   *   loading fails and `noAlert` is truthy.
   */

  function loadSvgString(_x) {
    return _loadSvgString.apply(this, arguments);
  }
  /**
   * @function module:SVGEditor~getImportLocale
   * @param {PlainObject} defaults
   * @param {string} defaults.defaultLang
   * @param {string} defaults.defaultName
   * @returns {module:SVGEditor~ImportLocale}
   */


  function _loadSvgString() {
    _loadSvgString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(str) {
      var _ref41,
          noAlert,
          success,
          _args24 = arguments;

      return regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _ref41 = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {}, noAlert = _ref41.noAlert;
              success = svgCanvas.setSvgString(str) !== false;

              if (!success) {
                _context24.next = 4;
                break;
              }

              return _context24.abrupt("return");

            case 4:
              if (noAlert) {
                _context24.next = 8;
                break;
              }

              _context24.next = 7;
              return $$c.alert(uiStrings$1.notification.errorLoadingSVG);

            case 7:
              return _context24.abrupt("return");

            case 8:
              throw new Error('Error loading SVG');

            case 9:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    }));
    return _loadSvgString.apply(this, arguments);
  }

  function getImportLocale(_ref) {
    var defaultLang = _ref.defaultLang,
        defaultName = _ref.defaultName;

    /**
     * @function module:SVGEditor~ImportLocale
     * @param {PlainObject} localeInfo
     * @param {string} [localeInfo.name] Defaults to `defaultName` of {@link module:SVGEditor~getImportLocale}
     * @param {string} [localeInfo.lang=defaultLang] Defaults to `defaultLang` of {@link module:SVGEditor~getImportLocale}
     * @returns {Promise<module:locale.LocaleStrings>} Resolves to {@link module:locale.LocaleStrings}
     */
    return /*#__PURE__*/function () {
      var _importLocaleDefaulting = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _ref2,
            _ref2$name,
            name,
            _ref2$lang,
            lang,
            importLocale,
            _importLocale,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _importLocale = function _importLocale3() {
                  _importLocale = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(language) {
                    var url, locale;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            url = "".concat(curConfig.extPath, "ext-locale/").concat(name, "/").concat(language, ".js"); // eslint-disable-next-line node/no-unsupported-features/es-syntax

                            _context.next = 3;
                            return import(url);

                          case 3:
                            locale = _context.sent;
                            return _context.abrupt("return", locale["default"]);

                          case 5:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  return _importLocale.apply(this, arguments);
                };

                importLocale = function _importLocale2(_x2) {
                  return _importLocale.apply(this, arguments);
                };

                _ref2 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref2$name = _ref2.name, name = _ref2$name === void 0 ? defaultName : _ref2$name, _ref2$lang = _ref2.lang, lang = _ref2$lang === void 0 ? defaultLang : _ref2$lang;
                _context2.prev = 3;
                _context2.next = 6;
                return importLocale(lang);

              case 6:
                return _context2.abrupt("return", _context2.sent);

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](3);
                return _context2.abrupt("return", importLocale('en'));

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[3, 9]]);
      }));

      function importLocaleDefaulting() {
        return _importLocaleDefaulting.apply(this, arguments);
      }

      return importLocaleDefaulting;
    }();
  }
  /**
  * EXPORTS.
  */

  /**
  * Store and retrieve preferences.
  * @function module:SVGEditor.pref
  * @param {string} key The preference name to be retrieved or set
  * @param {string} [val] The value. If the value supplied is missing or falsey, no change to the preference will
  * be made unless `mayBeEmpty` is set.
  * @param {boolean} [mayBeEmpty] If value may be falsey.
  * @returns {string|void} If val is missing or falsey and `mayBeEmpty` is not set, the
  * value of the previously stored preference will be returned.
  * @todo Review whether any remaining existing direct references to
  *  getting `curPrefs` can be changed to use `svgEditor.pref()` getting to ensure
  *  `defaultPrefs` fallback (also for sake of `allowInitialUserOverride`);
  *  specifically, `bkgd_color` could be changed so that the pref dialog has a
  *  button to auto-calculate background, but otherwise uses `svgEditor.pref()` to
  *  be able to get default prefs or overridable settings
  */


  editor.pref = function (key, val, mayBeEmpty) {
    if (mayBeEmpty || val) {
      curPrefs[key] = val;
      /**
      * @name curPrefs
      * @memberof module:SVGEditor
      * @implements {module:SVGEditor.Prefs}
      */

      editor.curPrefs = curPrefs; // Update exported value

      return undefined;
    }

    return key in curPrefs ? curPrefs[key] : defaultPrefs[key];
  };
  /*
  * EDITOR PUBLIC METHODS
  // Todo: Sort these methods per invocation order, ideally with init at the end
  // Todo: Prevent execution until init executes if dependent on it?
  */


  editor.putLocale = putLocale;
  editor.readLang = readLang;
  editor.setStrings = setStrings;
  /**
  * Where permitted, sets canvas and/or `defaultPrefs` based on previous
  *  storage. This will override URL settings (for security reasons) but
  *  not `svgedit-config-iife.js` configuration (unless initial user
  *  overriding is explicitly permitted there via `allowInitialUserOverride`).
  * @function module:SVGEditor.loadContentAndPrefs
  * @todo Split `allowInitialUserOverride` into `allowOverrideByURL` and
  *  `allowOverrideByUserStorage` so `svgedit-config-iife.js` can disallow some
  *  individual items for URL setting but allow for user storage AND/OR
  *  change URL setting so that it always uses a different namespace,
  *  so it won't affect pre-existing user storage (but then if users saves
  *  that, it will then be subject to tampering
  * @returns {void}
  */

  editor.loadContentAndPrefs = function () {
    if (!curConfig.forceStorage && (curConfig.noStorageOnLoad || !document.cookie.match(/(?:^|;\s*)svgeditstore=(?:prefsAndContent|prefsOnly)/))) {
      return;
    } // LOAD CONTENT


    if (editor.storage && ( // Cookies do not have enough available memory to hold large documents
    curConfig.forceStorage || !curConfig.noStorageOnLoad && document.cookie.match(/(?:^|;\s*)svgeditstore=prefsAndContent/))) {
      var _name = 'svgedit-' + curConfig.canvasName;

      var cached = editor.storage.getItem(_name);

      if (cached) {
        editor.loadFromString(cached);
      }
    } // LOAD PREFS


    Object.keys(defaultPrefs).forEach(function (key) {
      var storeKey = 'svg-edit-' + key;

      if (editor.storage) {
        var val = editor.storage.getItem(storeKey);

        if (val) {
          defaultPrefs[key] = String(val); // Convert to string for FF (.value fails in Webkit)
        }
      } else if (window.widget) {
        defaultPrefs[key] = window.widget.preferenceForKey(storeKey);
      } else {
        var result = document.cookie.match(new RegExp('(?:^|;\\s*)' + regexEscape(encodeURIComponent(storeKey)) + '=([^;]+)'));
        defaultPrefs[key] = result ? decodeURIComponent(result[1]) : '';
      }
    });
  };
  /**
  * Allows setting of preferences or configuration (including extensions).
  * @function module:SVGEditor.setConfig
  * @param {module:SVGEditor.Config|module:SVGEditor.Prefs} opts The preferences or configuration (including extensions). See the tutorial on {@tutorial ConfigOptions} for info on config and preferences.
  * @param {PlainObject} [cfgCfg] Describes configuration which applies to the
  *    particular batch of supplied options
  * @param {boolean} [cfgCfg.allowInitialUserOverride=false] Set to true if you wish
  *  to allow initial overriding of settings by the user via the URL
  *  (if permitted) or previously stored preferences (if permitted);
  *  note that it will be too late if you make such calls in extension
  *  code because the URL or preference storage settings will
  *   have already taken place.
  * @param {boolean} [cfgCfg.overwrite=true] Set to false if you wish to
  *  prevent the overwriting of prior-set preferences or configuration
  *  (URL settings will always follow this requirement for security
  *  reasons, so `svgedit-config-iife.js` settings cannot be overridden unless it
  *  explicitly permits via `allowInitialUserOverride` but extension config
  *  can be overridden as they will run after URL settings). Should
  *   not be needed in `svgedit-config-iife.js`.
  * @returns {void}
  */


  editor.setConfig = function (opts, cfgCfg) {
    cfgCfg = cfgCfg || {};
    /**
     *
     * @param {module:SVGEditor.Config|module:SVGEditor.Prefs} cfgObj
     * @param {string} key
     * @param {any} val See {@link module:SVGEditor.Config} or {@link module:SVGEditor.Prefs}
     * @returns {void}
     */

    function extendOrAdd(cfgObj, key, val) {
      if (cfgObj[key] && _typeof(cfgObj[key]) === 'object') {
        $$c.extend(true, cfgObj[key], val);
      } else {
        cfgObj[key] = val;
      }
    }

    Object.entries(opts).forEach(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          val = _ref4[1];

      // Only allow prefs defined in defaultPrefs or...
      if ({}.hasOwnProperty.call(defaultPrefs, key)) {
        if (cfgCfg.overwrite === false && (curConfig.preventAllURLConfig || {}.hasOwnProperty.call(curPrefs, key))) {
          return;
        }

        if (cfgCfg.allowInitialUserOverride === true) {
          defaultPrefs[key] = val;
        } else {
          editor.pref(key, val);
        }
      } else if (['extensions', 'allowedOrigins'].includes(key)) {
        if (cfgCfg.overwrite === false && (curConfig.preventAllURLConfig || ['allowedOrigins'].includes(key) || key === 'extensions' && curConfig.lockExtensions)) {
          return;
        }

        curConfig[key] = curConfig[key].concat(val); // We will handle any dupes later
        // Only allow other curConfig if defined in defaultConfig
      } else if ({}.hasOwnProperty.call(defaultConfig, key)) {
        if (cfgCfg.overwrite === false && (curConfig.preventAllURLConfig || {}.hasOwnProperty.call(curConfig, key))) {
          return;
        } // Potentially overwriting of previously set config


        if ({}.hasOwnProperty.call(curConfig, key)) {
          if (cfgCfg.overwrite === false) {
            return;
          }

          extendOrAdd(curConfig, key, val);
        } else if (cfgCfg.allowInitialUserOverride === true) {
          extendOrAdd(defaultConfig, key, val);
        } else if (defaultConfig[key] && _typeof(defaultConfig[key]) === 'object') {
          curConfig[key] = Array.isArray(defaultConfig[key]) ? [] : {};
          $$c.extend(true, curConfig[key], val); // Merge properties recursively, e.g., on initFill, initStroke objects
        } else {
          curConfig[key] = val;
        }
      }
    });
    /**
    * @name curConfig
    * @memberof module:SVGEditor
    * @implements {module:SVGEditor.Config}
    */

    editor.curConfig = curConfig; // Update exported value
  };
  /**
  * All methods are optional.
  * @interface module:SVGEditor.CustomHandler
  * @type {PlainObject}
  */

  /**
  * Its responsibilities are:
  *  - invoke a file chooser dialog in 'open' mode
  *  - let user pick a SVG file
  *  - calls [svgCanvas.setSvgString()]{@link module:svgcanvas.SvgCanvas#setSvgString} with the string contents of that file.
  * Not passed any parameters.
  * @function module:SVGEditor.CustomHandler#open
  * @returns {void}
  */

  /**
  * Its responsibilities are:
  *  - accept the string contents of the current document
  *  - invoke a file chooser dialog in 'save' mode
  *  - save the file to location chosen by the user.
  * @function module:SVGEditor.CustomHandler#save
  * @param {external:Window} win
  * @param {module:svgcanvas.SvgCanvas#event:saved} svgStr A string of the SVG
  * @listens module:svgcanvas.SvgCanvas#event:saved
  * @returns {void}
  */

  /**
  * Its responsibilities (with regard to the object it is supplied in its 2nd argument) are:
  *  - inform user of any issues supplied via the "issues" property
  *  - convert the "svg" property SVG string into an image for export;
  *    utilize the properties "type" (currently 'PNG', 'JPEG', 'BMP',
  *    'WEBP', 'PDF'), "mimeType", and "quality" (for 'JPEG' and 'WEBP'
  *    types) to determine the proper output.
  * @function module:SVGEditor.CustomHandler#exportImage
  * @param {external:Window} win
  * @param {module:svgcanvas.SvgCanvas#event:exported} data
  * @listens module:svgcanvas.SvgCanvas#event:exported
  * @returns {void}
  */

  /**
  * @function module:SVGEditor.CustomHandler#exportPDF
  * @param {external:Window} win
  * @param {module:svgcanvas.SvgCanvas#event:exportedPDF} data
  * @listens module:svgcanvas.SvgCanvas#event:exportedPDF
  * @returns {void}
  */

  /**
  * Allows one to override default SVGEdit `open`, `save`, and
  * `export` editor behaviors.
  * @function module:SVGEditor.setCustomHandlers
  * @param {module:SVGEditor.CustomHandler} opts Extension mechanisms may call `setCustomHandlers` with three functions: `opts.open`, `opts.save`, and `opts.exportImage`
  * @returns {Promise<void>}
  */


  editor.setCustomHandlers = function (opts) {
    return editor.ready(function () {
      if (opts.open) {
        $$c('#tool_open > input[type="file"]').remove();
        $$c('#tool_open').show();
        svgCanvas.open = opts.open;
      }

      if (opts.save) {
        editor.showSaveWarning = false;
        svgCanvas.bind('saved', opts.save);
      }

      if (opts.exportImage) {
        customExportImage = opts.exportImage;
        svgCanvas.bind('exported', customExportImage); // canvg and our RGBColor will be available to the method
      }

      if (opts.exportPDF) {
        customExportPDF = opts.exportPDF;
        svgCanvas.bind('exportedPDF', customExportPDF); // jsPDF and our RGBColor will be available to the method
      }
    });
  };
  /**
   * @function module:SVGEditor.randomizeIds
   * @param {boolean} arg
   * @returns {void}
   */


  editor.randomizeIds = function (arg) {
    svgCanvas.randomizeIds(arg);
  };
  /**
  * Auto-run after a Promise microtask.
  * @function module:SVGEditor.init
  * @returns {void}
  */


  editor.init = function () {
    var modularVersion = !('svgEditor' in window) || !window.svgEditor || window.svgEditor.modules !== false;

    if (!modularVersion) {
      Object.assign(defaultConfig, {
        langPath: '../../dist/locale/',
        extPath: '../../dist/extensions/',
        canvgPath: '../../dist/',
        jspdfPath: '../../dist/'
      });
    } // const host = location.hostname,
    //  onWeb = host && host.includes('.');
    // Some FF versions throw security errors here when directly accessing


    try {
      if ('localStorage' in window) {
        // && onWeb removed so Webkit works locally

        /**
        * The built-in interface implemented by `localStorage`
        * @external Storage
        */

        /**
        * @name storage
        * @memberof module:SVGEditor
        * @type {external:Storage}
        */
        editor.storage = localStorage;
      }
    } catch (err) {} // Todo: Avoid const-defined functions and group functions together, etc. where possible


    var goodLangs = [];
    $$c('#lang_select option').each(function () {
      goodLangs.push(this.value);
    });
    /**
     * Sets up current preferences based on defaults.
     * @returns {void}
     */

    function setupCurPrefs() {
      curPrefs = $$c.extend(true, {}, defaultPrefs, curPrefs); // Now safe to merge with priority for curPrefs in the event any are already set
      // Export updated prefs

      editor.curPrefs = curPrefs;
    }
    /**
     * Sets up current config based on defaults.
     * @returns {void}
     */


    function setupCurConfig() {
      curConfig = $$c.extend(true, {}, defaultConfig, curConfig); // Now safe to merge with priority for curConfig in the event any are already set
      // Now deal with extensions and other array config

      if (!curConfig.noDefaultExtensions) {
        curConfig.extensions = curConfig.extensions.concat(defaultExtensions);
      } // ...and remove any dupes


      ['extensions', 'allowedOrigins'].forEach(function (cfg) {
        curConfig[cfg] = $$c.grep(curConfig[cfg], function (n, i) {
          // Supposedly faster than filter per http://amandeep1986.blogspot.hk/2015/02/jquery-grep-vs-js-filter.html
          return i === curConfig[cfg].indexOf(n);
        });
      }); // Export updated config

      editor.curConfig = curConfig;
    }

    (function () {
      // Load config/data from URL if given
      var _URL = new URL(location),
          search = _URL.search,
          searchParams = _URL.searchParams;

      if (search) {
        urldata = deparam(searchParams.toString(), true);
        ['initStroke', 'initFill'].forEach(function (prop) {
          if (searchParams.has("".concat(prop, "[color]"))) {
            // Restore back to original non-deparamed value to avoid color
            //  strings being converted to numbers
            urldata[prop].color = searchParams.get("".concat(prop, "[color]"));
          }
        });

        if (searchParams.has('bkgd_color')) {
          urldata.bkgd_color = '#' + searchParams.get('bkgd_color');
        }

        if (urldata.dimensions) {
          urldata.dimensions = urldata.dimensions.split(',');
        }

        if (urldata.extensions) {
          // For security reasons, disallow cross-domain or cross-folder
          //  extensions via URL
          urldata.extensions = urldata.extensions.match(/[:/\\]/) ? '' : urldata.extensions.split(',');
        } // Disallowing extension paths via URL for
        // security reasons, even for same-domain
        // ones given potential to interact in undesirable
        // ways with other script resources


        ['langPath', 'extPath', 'canvgPath', 'jspdfPath', 'imgPath', 'jGraduatePath', 'extIconsPath'].forEach(function (pathConfig) {
          if (urldata[pathConfig]) {
            delete urldata[pathConfig];
          }
        }); // Note: `source` and `url` (as with `storagePrompt` later) are not
        //  set on config but are used below

        editor.setConfig(urldata, {
          overwrite: false
        });
        setupCurConfig();

        if (!curConfig.preventURLContentLoading) {
          var _urldata = urldata,
              source = _urldata.source;

          if (!source) {
            // urldata.source may have been null if it ended with '='
            var src = searchParams.get('source');

            if (src && src.startsWith('data:')) {
              source = src;
            }
          }

          if (source) {
            if (source.startsWith('data:')) {
              editor.loadFromDataURI(source);
            } else {
              editor.loadFromString(source);
            }

            return;
          }

          if (urldata.url) {
            editor.loadFromURL(urldata.url);
            return;
          }
        }

        if (!urldata.noStorageOnLoad || curConfig.forceStorage) {
          editor.loadContentAndPrefs();
        }
      } else {
        setupCurConfig();
        editor.loadContentAndPrefs();
      }
    })();

    setupCurPrefs();
    /**
    * Called internally.
    * @function module:SVGEditor.setIcon
    * @param {string|Element|external:jQuery} elem
    * @param {string|external:jQuery} iconId
    * @param {Float} forcedSize Not in use
    * @returns {void}
    */

    var setIcon = editor.setIcon = function (elem, iconId, forcedSize) {
      var icon = typeof iconId === 'string' ? $$c.getSvgIcon(iconId, true) : iconId.clone();

      if (!icon) {
        // Todo: Investigate why this still occurs in some cases
        console.log('NOTE: Icon image missing: ' + iconId); // eslint-disable-line no-console

        return;
      }

      $$c(elem).empty().append(icon);
    };
    /**
     * @fires module:svgcanvas.SvgCanvas#event:ext_addLangData
     * @fires module:svgcanvas.SvgCanvas#event:ext_langReady
     * @fires module:svgcanvas.SvgCanvas#event:ext_langChanged
     * @fires module:svgcanvas.SvgCanvas#event:extensions_added
     * @returns {Promise<module:locale.LangAndData>} Resolves to result of {@link module:locale.readLang}
     */


    var extAndLocaleFunc = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _yield$editor$putLoca, langParam, langData, _uiStrings$common, ok, cancel;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return editor.putLocale(editor.pref('lang'), goodLangs, curConfig);

              case 2:
                _yield$editor$putLoca = _context4.sent;
                langParam = _yield$editor$putLoca.langParam;
                langData = _yield$editor$putLoca.langData;
                _context4.next = 7;
                return setLang(langParam, langData);

              case 7:
                _uiStrings$common = uiStrings$1.common, ok = _uiStrings$common.ok, cancel = _uiStrings$common.cancel;
                jQueryPluginDBox($$c, {
                  ok: ok,
                  cancel: cancel
                });
                setIcons(); // Wait for dbox as needed for i18n

                _context4.prev = 10;
                _context4.next = 13;
                return Promise.all(curConfig.extensions.map( /*#__PURE__*/function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(extname) {
                    var extensionName, url, imported, _imported$default, _imported$default$nam, _name2, init, importLocale;

                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            extensionName = extname.match(/^ext-(.+)\.js/); // const {extName} = extname.match(/^ext-(?<extName>.+)\.js/).groups;

                            if (extensionName) {
                              _context3.next = 3;
                              break;
                            }

                            return _context3.abrupt("return", undefined);

                          case 3:
                            url = curConfig.extPath + extname;
                            /**
                             * @tutorial ExtensionDocs
                             * @typedef {PlainObject} module:SVGEditor.ExtensionObject
                             * @property {string} [name] Name of the extension. Used internally; no need for i18n. Defaults to extension name without beginning "ext-" or ending ".js".
                             * @property {module:svgcanvas.ExtensionInitCallback} [init]
                             */

                            _context3.prev = 4;
                            _context3.next = 7;
                            return import(url);

                          case 7:
                            imported = _context3.sent;
                            _imported$default = imported["default"], _imported$default$nam = _imported$default.name, _name2 = _imported$default$nam === void 0 ? extensionName[1] : _imported$default$nam, init = _imported$default.init; // const {name = extName, init} = imported;

                            importLocale = getImportLocale({
                              defaultLang: langParam,
                              defaultName: _name2
                            });
                            return _context3.abrupt("return", editor.addExtension(_name2, init && init.bind(editor), {
                              $: $$c,
                              importLocale: importLocale
                            }));

                          case 13:
                            _context3.prev = 13;
                            _context3.t0 = _context3["catch"](4);
                            // Todo: Add config to alert any errors
                            console.log(_context3.t0); // eslint-disable-line no-console

                            console.error('Extension failed to load: ' + extname + '; ' + _context3.t0); // eslint-disable-line no-console

                            return _context3.abrupt("return", undefined);

                          case 18:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, null, [[4, 13]]);
                  }));

                  return function (_x3) {
                    return _ref6.apply(this, arguments);
                  };
                }()));

              case 13:
                svgCanvas.bind('extensions_added',
                /**
                * @param {external:Window} win
                * @param {module:svgcanvas.SvgCanvas#event:extensions_added} data
                * @listens module:svgcanvas.SvgCanvas#event:extensions_added
                * @returns {void}
                */
                function (win, data) {
                  extensionsAdded = true;
                  Actions.setAll();
                  $$c('.flyout_arrow_horiz:empty').each(function () {
                    $$c(this).append($$c.getSvgIcon('arrow_right', true).width(5).height(5));
                  });

                  if (editor.storagePromptState === 'ignore') {
                    updateCanvas(true);
                  }

                  messageQueue.forEach(
                  /**
                   * @param {module:svgcanvas.SvgCanvas#event:message} messageObj
                   * @fires module:svgcanvas.SvgCanvas#event:message
                   * @returns {void}
                   */
                  function (messageObj) {
                    svgCanvas.call('message', messageObj);
                  });
                });
                svgCanvas.call('extensions_added');
                _context4.next = 20;
                break;

              case 17:
                _context4.prev = 17;
                _context4.t0 = _context4["catch"](10);
                // Todo: Report errors through the UI
                console.log(_context4.t0); // eslint-disable-line no-console

              case 20:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[10, 17]]);
      }));

      return function extAndLocaleFunc() {
        return _ref5.apply(this, arguments);
      };
    }();

    var stateObj = {
      tool_scale: editor.tool_scale
    };
    /**
    *
    * @returns {void}
    */

    var setFlyoutPositions = function setFlyoutPositions() {
      $$c('.tools_flyout').each(function () {
        var shower = $$c('#' + this.id + '_show');

        var _shower$offset = shower.offset(),
            left = _shower$offset.left,
            top = _shower$offset.top;

        var w = shower.outerWidth();
        $$c(this).css({
          left: (left + w) * editor.tool_scale,
          top: top
        });
      });
    };
    /**
    * @type {string}
    */


    var uaPrefix = function () {
      var regex = /^(?:Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;
      var someScript = document.getElementsByTagName('script')[0];

      for (var prop in someScript.style) {
        if (regex.test(prop)) {
          // test is faster than match, so it's better to perform
          // that on the lot and match only when necessary
          return prop.match(regex)[0];
        }
      } // Nothing found so far?


      if ('WebkitOpacity' in someScript.style) {
        return 'Webkit';
      }

      if ('KhtmlOpacity' in someScript.style) {
        return 'Khtml';
      }

      return '';
    }();
    /**
    * @param {external:jQuery} elems
    * @param {Float} scale
    * @returns {void}
    */


    var scaleElements = function scaleElements(elems, scale) {
      // const prefix = '-' + uaPrefix.toLowerCase() + '-'; // Currently unused
      var sides = ['top', 'left', 'bottom', 'right'];
      elems.each(function () {
        // Handled in CSS
        // this.style[uaPrefix + 'Transform'] = 'scale(' + scale + ')';
        var el = $$c(this);
        var w = el.outerWidth() * (scale - 1);
        var h = el.outerHeight() * (scale - 1); // const margins = {}; // Currently unused

        for (var i = 0; i < 4; i++) {
          var s = sides[i];
          var cur = el.data('orig_margin-' + s);

          if (isNullish(cur)) {
            cur = Number.parseInt(el.css('margin-' + s)); // Cache the original margin

            el.data('orig_margin-' + s, cur);
          }

          var val = cur * scale;

          if (s === 'right') {
            val += w;
          } else if (s === 'bottom') {
            val += h;
          }

          el.css('margin-' + s, val); // el.css('outline', '1px solid red');
        }
      });
    };
    /**
    * Called internally.
    * @function module:SVGEditor.setIconSize
    * @param {module:SVGEditor.IconSize} size
    * @returns {void}
    */


    var setIconSize = editor.setIconSize = function (size) {
      // const elems = $('.tool_button, .push_button, .tool_button_current, .disabled, .icon_label, #url_notice, #tool_open');
      var selToscale = '#tools_top .toolset, #editor_panel > *, #history_panel > *,' + '        #main_button, #tools_left > *, #path_node_panel > *, #multiselected_panel > *,' + '        #g_panel > *, #tool_font_size > *, .tools_flyout';
      var elems = $$c(selToscale);
      var scale = 1;

      if (typeof size === 'number') {
        scale = size;
      } else {
        var iconSizes = {
          s: 0.75,
          m: 1,
          l: 1.25,
          xl: 1.5
        };
        scale = iconSizes[size];
      }

      stateObj.tool_scale = editor.tool_scale = scale;
      setFlyoutPositions(); // $('.tools_flyout').each(function () {
      //   const pos = $(this).position();
      //   console.log($(this), pos.left+(34 * scale));
      //   $(this).css({left: pos.left+(34 * scale), top: pos.top+(77 * scale)});
      //   console.log('l', $(this).css('left'));
      // });
      //
      // const scale = .75;

      var hiddenPs = elems.parents(':hidden');
      hiddenPs.css('visibility', 'hidden').show();
      scaleElements(elems, scale);
      hiddenPs.css('visibility', 'visible').hide(); // return;

      editor.pref('iconsize', size);
      $$c('#iconsize').val(size); // Note that all rules will be prefixed with '#svg_editor' when parsed

      var cssResizeRules = {
        '#tools_top': {
          left: 50 + $$c('#main_button').width(),
          height: 72
        },
        '#tools_left': {
          width: 31,
          top: 74
        },
        'div#workarea': {
          left: 38,
          top: 74
        }
      };
      var ruleElem = $$c('#tool_size_rules');

      if (!ruleElem.length) {
        ruleElem = $$c('<style id="tool_size_rules"></style>').appendTo('head');
      } else {
        ruleElem.empty();
      }

      if (size !== 'm') {
        var styleStr = '';
        $$c.each(cssResizeRules, function (selector, rules) {
          selector = '#svg_editor ' + selector.replace(/,/g, ', #svg_editor');
          styleStr += selector + '{';
          $$c.each(rules, function (prop, values) {
            var val;

            if (typeof values === 'number') {
              val = values * scale + 'px';
            } else if (values[size] || values.all) {
              val = values[size] || values.all;
            }

            styleStr += prop + ':' + val + ';';
          });
          styleStr += '}';
        }); // this.style[uaPrefix + 'Transform'] = 'scale(' + scale + ')';

        var prefix = '-' + uaPrefix.toLowerCase() + '-';
        styleStr += selToscale + '{' + prefix + 'transform: scale(' + scale + ');}' + ' #svg_editor div.toolset .toolset {' + prefix + 'transform: scale(1); margin: 1px !important;}' + // Hack for markers
        ' #svg_editor .ui-slider {' + prefix + 'transform: scale(' + 1 / scale + ');}' // Hack for sliders
        ;
        ruleElem.text(styleStr);
      }

      setFlyoutPositions();
    };
    /**
     * Setup SVG icons.
     * @returns {void}
     */


    function setIcons() {
      $$c.svgIcons(curConfig.imgPath + 'svg_edit_icons.svg', {
        w: 24,
        h: 24,
        id_match: false,
        no_img: !isWebkit(),
        // Opera & Firefox 4 gives odd behavior w/images
        fallback_path: curConfig.imgPath,
        // Todo: Set `alts: {}` with keys as the IDs in fallback set to
        //   `uiStrings` (localized) values
        fallback: {
          logo: 'logo.png',
          select: 'select.png',
          select_node: 'select_node.png',
          square: 'square.png',
          rect: 'rect.png',
          fh_rect: 'freehand-square.png',
          circle: 'circle.png',
          ellipse: 'ellipse.png',
          fh_ellipse: 'freehand-circle.png',
          pencil: 'fhpath.png',
          pen: 'line.png',
          text: 'text.png',
          path: 'path.png',
          add_subpath: 'add_subpath.png',
          close_path: 'closepath.png',
          open_path: 'openpath.png',
          image: 'image.png',
          zoom: 'zoom.png',
          arrow_right: 'flyouth.png',
          arrow_right_big: 'arrow_right_big.png',
          arrow_down: 'dropdown.gif',
          fill: 'fill.png',
          stroke: 'stroke.png',
          opacity: 'opacity.png',
          new_image: 'clear.png',
          save: 'save.png',
          "export": 'export.png',
          open: 'open.png',
          "import": 'import.png',
          docprops: 'document-properties.png',
          source: 'source.png',
          wireframe: 'wireframe.png',
          undo: 'undo.png',
          redo: 'redo.png',
          clone: 'clone.png',
          "delete": 'delete.png',
          go_up: 'go-up.png',
          go_down: 'go-down.png',
          context_menu: 'context_menu.png',
          move_bottom: 'move_bottom.png',
          move_top: 'move_top.png',
          to_path: 'to_path.png',
          link_controls: 'link_controls.png',
          reorient: 'reorient.png',
          group_elements: 'shape_group_elements.png',
          ungroup: 'shape_ungroup.png',
          unlink_use: 'unlink_use.png',
          width: 'width.png',
          height: 'height.png',
          c_radius: 'c_radius.png',
          angle: 'angle.png',
          blur: 'blur.png',
          fontsize: 'fontsize.png',
          align: 'align.png',
          align_left: 'align-left.png',
          align_center: 'align-center.png',
          align_right: 'align-right.png',
          align_top: 'align-top.png',
          align_middle: 'align-middle.png',
          align_bottom: 'align-bottom.png',
          linecap_butt: 'linecap_butt.png',
          linecap_square: 'linecap_square.png',
          linecap_round: 'linecap_round.png',
          linejoin_miter: 'linejoin_miter.png',
          linejoin_bevel: 'linejoin_bevel.png',
          linejoin_round: 'linejoin_round.png',
          eye: 'eye.png',
          no_color: 'no_color.png',
          ok: 'save.png',
          cancel: 'cancel.png',
          warning: 'warning.png',
          node_delete: 'node_delete.png',
          node_clone: 'node_clone.png',
          globe_link: 'globe_link.png',
          config: 'config.png'
        },
        placement: {
          '#logo': 'logo',
          '#tool_clear div,#layer_new': 'new_image',
          '#tool_save div': 'save',
          '#tool_export div': 'export',
          '#tool_open div': 'open',
          '#tool_import div': 'import',
          '#tool_source': 'source',
          '#tool_docprops > div': 'docprops',
          '#tool_editor_prefs > div': 'config',
          '#tool_editor_homepage > div': 'globe_link',
          '#tool_wireframe': 'wireframe',
          '#tool_undo': 'undo',
          '#tool_redo': 'redo',
          '#tool_select': 'select',
          '#tool_fhpath': 'pencil',
          '#tool_line': 'pen',
          '#tool_rect,#tools_rect_show': 'rect',
          '#tool_square': 'square',
          '#tool_fhrect': 'fh_rect',
          '#tool_ellipse,#tools_ellipse_show': 'ellipse',
          '#tool_circle': 'circle',
          '#tool_fhellipse': 'fh_ellipse',
          '#tool_path': 'path',
          '#tool_text,#layer_rename': 'text',
          '#tool_image': 'image',
          '#tool_zoom': 'zoom',
          '#tool_clone,#tool_clone_multi': 'clone',
          '#tool_node_clone': 'node_clone',
          '#layer_delete,#tool_delete,#tool_delete_multi': 'delete',
          '#tool_node_delete': 'node_delete',
          '#tool_add_subpath': 'add_subpath',
          '#tool_openclose_path': 'open_path',
          '#tool_move_top': 'move_top',
          '#tool_move_bottom': 'move_bottom',
          '#tool_topath': 'to_path',
          '#tool_node_link': 'link_controls',
          '#tool_reorient': 'reorient',
          '#tool_group_elements': 'group_elements',
          '#tool_ungroup': 'ungroup',
          '#tool_unlink_use': 'unlink_use',
          '#tool_alignleft, #tool_posleft': 'align_left',
          '#tool_aligncenter, #tool_poscenter': 'align_center',
          '#tool_alignright, #tool_posright': 'align_right',
          '#tool_aligntop, #tool_postop': 'align_top',
          '#tool_alignmiddle, #tool_posmiddle': 'align_middle',
          '#tool_alignbottom, #tool_posbottom': 'align_bottom',
          '#cur_position': 'align',
          '#linecap_butt,#cur_linecap': 'linecap_butt',
          '#linecap_round': 'linecap_round',
          '#linecap_square': 'linecap_square',
          '#linejoin_miter,#cur_linejoin': 'linejoin_miter',
          '#linejoin_round': 'linejoin_round',
          '#linejoin_bevel': 'linejoin_bevel',
          '#url_notice': 'warning',
          '#layer_up': 'go_up',
          '#layer_down': 'go_down',
          '#layer_moreopts': 'context_menu',
          '#layerlist td.layervis': 'eye',
          '#tool_source_save,#tool_docprops_save,#tool_prefs_save': 'ok',
          '#tool_source_cancel,#tool_docprops_cancel,#tool_prefs_cancel': 'cancel',
          '#rwidthLabel, #iwidthLabel': 'width',
          '#rheightLabel, #iheightLabel': 'height',
          '#cornerRadiusLabel span': 'c_radius',
          '#angleLabel': 'angle',
          '#linkLabel,#tool_make_link,#tool_make_link_multi': 'globe_link',
          '#zoomLabel': 'zoom',
          '#tool_fill label': 'fill',
          '#tool_stroke .icon_label': 'stroke',
          '#group_opacityLabel': 'opacity',
          '#blurLabel': 'blur',
          '#font_sizeLabel': 'fontsize',
          '.flyout_arrow_horiz': 'arrow_right',
          '.dropdown button, #main_button .dropdown': 'arrow_down',
          '#palette .palette_item:first, #fill_bg, #stroke_bg': 'no_color'
        },
        resize: {
          '#logo .svg_icon': 28,
          '.flyout_arrow_horiz .svg_icon': 5,
          '.layer_button .svg_icon, #layerlist td.layervis .svg_icon': 14,
          '.dropdown button .svg_icon': 7,
          '#main_button .dropdown .svg_icon': 9,
          '.palette_item:first .svg_icon': 15,
          '#fill_bg .svg_icon, #stroke_bg .svg_icon': 16,
          '.toolbar_button button .svg_icon': 16,
          '.stroke_tool div div .svg_icon': 20,
          '#tools_bottom label .svg_icon': 18
        },
        callback: function callback(icons) {
          return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
            var tleft, minHeight, size;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    $$c('.toolbar_button button > svg, .toolbar_button button > img').each(function () {
                      $$c(this).parent().prepend(this);
                    });
                    tleft = $$c('#tools_left');

                    if (tleft.length) {
                      minHeight = tleft.offset().top + tleft.outerHeight();
                    }

                    size = editor.pref('iconsize');
                    editor.setIconSize(size || ($$c(window).height() < minHeight ? 's' : 'm')); // Look for any missing flyout icons from plugins

                    $$c('.tools_flyout').each(function () {
                      var shower = $$c('#' + this.id + '_show');
                      var sel = shower.attr('data-curopt'); // Check if there's an icon here

                      if (!shower.children('svg, img').length) {
                        var clone = $$c(sel).children().clone();

                        if (clone.length) {
                          clone[0].removeAttribute('style'); // Needed for Opera

                          shower.append(clone);
                        }
                      }
                    });
                    $$c('#svg_container')[0].style.visibility = 'visible';
                    _context5.next = 9;
                    return editor.runCallbacks();

                  case 9:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }))();
        }
      });
    }
    /**
    * @name module:SVGEditor.canvas
    * @type {module:svgcanvas.SvgCanvas}
    */


    editor.canvas = svgCanvas = new SvgCanvas(document.getElementById('svgcanvas'), curConfig);
    var palette = [// Todo: Make into configuration item?
    '#000000', '#3f3f3f', '#7f7f7f', '#bfbfbf', '#ffffff', '#ff0000', '#ff7f00', '#ffff00', '#7fff00', '#00ff00', '#00ff7f', '#00ffff', '#007fff', '#0000ff', '#7f00ff', '#ff00ff', '#ff007f', '#7f0000', '#7f3f00', '#7f7f00', '#3f7f00', '#007f00', '#007f3f', '#007f7f', '#003f7f', '#00007f', '#3f007f', '#7f007f', '#7f003f', '#ffaaaa', '#ffd4aa', '#ffffaa', '#d4ffaa', '#aaffaa', '#aaffd4', '#aaffff', '#aad4ff', '#aaaaff', '#d4aaff', '#ffaaff', '#ffaad4'],
        modKey = isMac() ? 'meta+' : 'ctrl+',
        path = svgCanvas.pathActions,
        _svgCanvas = svgCanvas,
        undoMgr = _svgCanvas.undoMgr,
        workarea = $$c('#workarea'),
        canvMenu = $$c('#cmenu_canvas'),
        paintBox = {
      fill: null,
      stroke: null
    };
    var resizeTimer, curScrollPos;
    var exportWindow = null,
        defaultImageURL = curConfig.imgPath + 'logo.png',
        zoomInIcon = 'crosshair',
        zoomOutIcon = 'crosshair',
        uiContext = 'toolbars'; // For external openers

    (function () {
      // let the opener know SVG Edit is ready (now that config is set up)
      var w = window.opener || window.parent;

      if (w) {
        try {
          /**
           * Triggered on a containing `document` (of `window.opener`
           * or `window.parent`) when the editor is loaded.
           * @event module:SVGEditor#event:svgEditorReadyEvent
           * @type {Event}
           * @property {true} bubbles
           * @property {true} cancelable
           */

          /**
           * @name module:SVGEditor.svgEditorReadyEvent
           * @type {module:SVGEditor#event:svgEditorReadyEvent}
           */
          var svgEditorReadyEvent = new w.CustomEvent('svgEditorReady', {
            bubbles: true,
            cancelable: true
          });
          w.document.documentElement.dispatchEvent(svgEditorReadyEvent);
        } catch (e) {}
      }
    })();
    /**
    *
    * @returns {void}
    */


    var setSelectMode = function setSelectMode() {
      var curr = $$c('.tool_button_current');

      if (curr.length && curr[0].id !== 'tool_select') {
        curr.removeClass('tool_button_current').addClass('tool_button');
        $$c('#tool_select').addClass('tool_button_current').removeClass('tool_button');
        $$c('#styleoverrides').text("\n        #svgcanvas svg * {\n          cursor: move;\n          pointer-events: all;\n        }\n        #svgcanvas svg {\n          cursor: default;\n        }\n      ");
      }

      svgCanvas.setMode('select');
      workarea.css('cursor', 'auto');
    }; // used to make the flyouts stay on the screen longer the very first time
    // const flyoutspeed = 1250; // Currently unused
    // let textBeingEntered = false; // Currently unused


    var origTitle = $$c('title:first').text(); // Make [1,2,5] array

    var rIntervals = [];

    for (var i = 0.1; i < 1e5; i *= 10) {
      rIntervals.push(i);
      rIntervals.push(2 * i);
      rIntervals.push(5 * i);
    }
    /**
     * This function highlights the layer passed in (by fading out the other layers).
     * If no layer is passed in, this function restores the other layers.
     * @param {string} [layerNameToHighlight]
     * @returns {void}
    */


    var toggleHighlightLayer = function toggleHighlightLayer(layerNameToHighlight) {
      var i;
      var curNames = [],
          numLayers = svgCanvas.getCurrentDrawing().getNumLayers();

      for (i = 0; i < numLayers; i++) {
        curNames[i] = svgCanvas.getCurrentDrawing().getLayerName(i);
      }

      if (layerNameToHighlight) {
        curNames.forEach(function (curName) {
          if (curName !== layerNameToHighlight) {
            svgCanvas.getCurrentDrawing().setLayerOpacity(curName, 0.5);
          }
        });
      } else {
        curNames.forEach(function (curName) {
          svgCanvas.getCurrentDrawing().setLayerOpacity(curName, 1.0);
        });
      }
    };
    /**
    *
    * @returns {void}
    */


    var populateLayers = function populateLayers() {
      svgCanvas.clearSelection();
      var layerlist = $$c('#layerlist tbody').empty();
      var selLayerNames = $$c('#selLayerNames').empty();
      var drawing = svgCanvas.getCurrentDrawing();
      var currentLayerName = drawing.getCurrentLayerName();
      var icon = $$c.getSvgIcon('eye');
      var layer = svgCanvas.getCurrentDrawing().getNumLayers(); // we get the layers in the reverse z-order (the layer rendered on top is listed first)

      while (layer--) {
        var _name3 = drawing.getLayerName(layer);

        var layerTr = $$c('<tr class="layer">').toggleClass('layersel', _name3 === currentLayerName);
        var layerVis = $$c('<td class="layervis">').toggleClass('layerinvis', !drawing.getLayerVisibility(_name3));
        var layerName = $$c('<td class="layername">' + _name3 + '</td>');
        layerlist.append(layerTr.append(layerVis, layerName));
        selLayerNames.append('<option value="' + _name3 + '">' + _name3 + '</option>');
      }

      if (icon !== undefined) {
        var copy = icon.clone();
        $$c('td.layervis', layerlist).append(copy);
        $$c.resizeSvgIcons({
          'td.layervis .svg_icon': 14
        });
      } // handle selection of layer


      $$c('#layerlist td.layername').mouseup(function (evt) {
        $$c('#layerlist tr.layer').removeClass('layersel');
        $$c(this.parentNode).addClass('layersel');
        svgCanvas.setCurrentLayer(this.textContent);
        evt.preventDefault();
      }).mouseover(function () {
        toggleHighlightLayer(this.textContent);
      }).mouseout(function () {
        toggleHighlightLayer();
      });
      $$c('#layerlist td.layervis').click(function () {
        var row = $$c(this.parentNode).prevAll().length;
        var name = $$c('#layerlist tr.layer:eq(' + row + ') td.layername').text();
        var vis = $$c(this).hasClass('layerinvis');
        svgCanvas.setLayerVisibility(name, vis);
        $$c(this).toggleClass('layerinvis');
      }); // if there were too few rows, let's add a few to make it not so lonely

      var num = 5 - $$c('#layerlist tr.layer').size();

      while (num-- > 0) {
        // TODO: there must a better way to do this
        layerlist.append('<tr><td style="color:white">_</td><td/></tr>');
      }
    };

    var editingsource = false;
    var origSource = '';
    /**
    * @param {Event} [e] Not used.
    * @param {boolean} forSaving
    * @returns {void}
    */

    var showSourceEditor = function showSourceEditor(e, forSaving) {
      if (editingsource) {
        return;
      }

      editingsource = true;
      origSource = svgCanvas.getSvgString();
      $$c('#save_output_btns').toggle(Boolean(forSaving));
      $$c('#tool_source_back').toggle(!forSaving);
      $$c('#svg_source_textarea').val(origSource);
      $$c('#svg_source_editor').fadeIn();
      $$c('#svg_source_textarea').focus();
    };

    var selectedElement = null;
    var multiselected = false;
    /**
    * @param {boolean} editmode
    * @param {module:svgcanvas.SvgCanvas#event:selected} elems
    * @returns {void}
    */

    var togglePathEditMode = function togglePathEditMode(editmode, elems) {
      $$c('#path_node_panel').toggle(editmode);
      $$c('#tools_bottom_2,#tools_bottom_3').toggle(!editmode);

      if (editmode) {
        // Change select icon
        $$c('.tool_button_current').removeClass('tool_button_current').addClass('tool_button');
        $$c('#tool_select').addClass('tool_button_current').removeClass('tool_button');
        setIcon('#tool_select', 'select_node');
        multiselected = false;

        if (elems.length) {
          selectedElement = elems[0];
        }
      } else {
        setTimeout(function () {
          setIcon('#tool_select', 'select');
        }, 1000);
      }
    };
    /**
     * @type {module:svgcanvas.EventHandler}
     * @param {external:Window} wind
     * @param {module:svgcanvas.SvgCanvas#event:saved} svg The SVG source
     * @listens module:svgcanvas.SvgCanvas#event:saved
     * @returns {void}
     */


    var saveHandler = function saveHandler(wind, svg) {
      editor.showSaveWarning = false; // by default, we add the XML prolog back, systems integrating SVG-edit (wikis, CMSs)
      // can just provide their own custom save handler and might not want the XML prolog

      svg = '<?xml version="1.0"?>\n' + svg; // IE9 doesn't allow standalone Data URLs
      // https://connect.microsoft.com/IE/feedback/details/542600/data-uri-images-fail-when-loaded-by-themselves

      if (isIE()) {
        showSourceEditor(0, true);
        return;
      } // Since saving SVGs by opening a new window was removed in Chrome use artificial link-click
      // https://stackoverflow.com/questions/45603201/window-is-not-allowed-to-navigate-top-frame-navigations-to-data-urls


      var a = document.createElement('a');
      a.href = 'data:image/svg+xml;base64,' + encode64(svg);
      a.download = 'icon.svg';
      a.style.display = 'none';
      document.body.append(a); // Need to append for Firefox

      a.click(); // Alert will only appear the first time saved OR the
      //   first time the bug is encountered

      var done = editor.pref('save_notice_done');

      if (done !== 'all') {
        var note = uiStrings$1.notification.saveFromBrowser.replace('%s', 'SVG'); // Check if FF and has <defs/>

        if (isGecko()) {
          if (svg.includes('<defs')) {
            // warning about Mozilla bug #308590 when applicable (seems to be fixed now in Feb 2013)
            note += '\n\n' + uiStrings$1.notification.defsFailOnSave;
            editor.pref('save_notice_done', 'all');
            done = 'all';
          } else {
            editor.pref('save_notice_done', 'part');
          }
        } else {
          editor.pref('save_notice_done', 'all');
        }

        if (done !== 'part') {
          $$c.alert(note);
        }
      }
    };
    /**
     * @param {external:Window} win
     * @param {module:svgcanvas.SvgCanvas#event:exported} data
     * @listens module:svgcanvas.SvgCanvas#event:exported
     * @returns {void}
     */


    var exportHandler = function exportHandler(win, data) {
      var issues = data.issues,
          exportWindowName = data.exportWindowName;
      exportWindow = window.open(blankPageObjectURL || '', exportWindowName); // A hack to get the window via JSON-able name without opening a new one

      if (!exportWindow || exportWindow.closed) {
        /* await */
        $$c.alert(uiStrings$1.notification.popupWindowBlocked);
        return;
      }

      exportWindow.location.href = data.bloburl || data.datauri;
      var done = editor.pref('export_notice_done');

      if (done !== 'all') {
        var note = uiStrings$1.notification.saveFromBrowser.replace('%s', data.type); // Check if there are issues

        if (issues.length) {
          var pre = "\n \u2022 ";
          note += '\n\n' + uiStrings$1.notification.noteTheseIssues + pre + issues.join(pre);
        } // Note that this will also prevent the notice even though new issues may appear later.
        // May want to find a way to deal with that without annoying the user


        editor.pref('export_notice_done', 'all');
        exportWindow.alert(note);
      }
    };
    /**
    *
    * @returns {void}
    */


    var operaRepaint = function operaRepaint() {
      // Repaints canvas in Opera. Needed for stroke-dasharray change as well as fill change
      if (!window.opera) {
        return;
      }

      $$c('<p/>').hide().appendTo('body').remove();
    };
    /**
     *
     * @param {Element} opt
     * @param {boolean} changeElem
     * @returns {void}
     */


    function setStrokeOpt(opt, changeElem) {
      var id = opt.id;
      var bits = id.split('_');

      var _bits = _slicedToArray(bits, 2),
          pre = _bits[0],
          val = _bits[1];

      if (changeElem) {
        svgCanvas.setStrokeAttr('stroke-' + pre, val);
      }

      operaRepaint();
      setIcon('#cur_' + pre, id, 20);
      $$c(opt).addClass('current').siblings().removeClass('current');
    }
    /**
    * This is a common function used when a tool has been clicked (chosen).
    * It does several common things:
    * - Removes the `tool_button_current` class from whatever tool currently has it.
    * - Hides any flyouts.
    * - Adds the `tool_button_current` class to the button passed in.
    * @function module:SVGEditor.toolButtonClick
    * @param {string|Element} button The DOM element or string selector representing the toolbar button
    * @param {boolean} noHiding Whether not to hide any flyouts
    * @returns {boolean} Whether the button was disabled or not
    */


    var toolButtonClick = editor.toolButtonClick = function (button, noHiding) {
      if ($$c(button).hasClass('disabled')) {
        return false;
      }

      if ($$c(button).parent().hasClass('tools_flyout')) {
        return true;
      }

      var fadeFlyouts = 'normal';

      if (!noHiding) {
        $$c('.tools_flyout').fadeOut(fadeFlyouts);
      }

      $$c('#styleoverrides').text('');
      workarea.css('cursor', 'auto');
      $$c('.tool_button_current').removeClass('tool_button_current').addClass('tool_button');
      $$c(button).addClass('tool_button_current').removeClass('tool_button');
      return true;
    };
    /**
    * Unless the select toolbar button is disabled, sets the button
    * and sets the select mode and cursor styles.
    * @function module:SVGEditor.clickSelect
    * @returns {void}
    */


    var clickSelect = editor.clickSelect = function () {
      if (toolButtonClick('#tool_select')) {
        svgCanvas.setMode('select');
        $$c('#styleoverrides').text("\n        #svgcanvas svg * {\n          cursor: move;\n          pointer-events: all;\n        }\n        #svgcanvas svg {\n          cursor: default;\n        }\n      ");
      }
    };
    /**
    * Set a selected image's URL.
    * @function module:SVGEditor.setImageURL
    * @param {string} url
    * @returns {void}
    */


    var setImageURL = editor.setImageURL = function (url) {
      if (!url) {
        url = defaultImageURL;
      }

      svgCanvas.setImageURL(url);
      $$c('#image_url').val(url);

      if (url.startsWith('data:')) {
        // data URI found
        $$c('#image_url').hide();
        $$c('#change_image_url').show();
      } else {
        // regular URL
        svgCanvas.embedImage(url, function (dataURI) {
          // Couldn't embed, so show warning
          $$c('#url_notice').toggle(!dataURI);
          defaultImageURL = url;
        });
        $$c('#image_url').show();
        $$c('#change_image_url').hide();
      }
    };
    /**
     *
     * @param {string} color
     * @param {string} url
     * @returns {void}
     */


    function setBackground(color, url) {
      // if (color == editor.pref('bkgd_color') && url == editor.pref('bkgd_url')) { return; }
      editor.pref('bkgd_color', color);
      editor.pref('bkgd_url', url, true); // This should be done in svgcanvas.js for the borderRect fill

      svgCanvas.setBackground(color, url);
    }
    /**
     * @param {PlainObject} [opts={}]
     * @param {boolean} [opts.cancelDeletes=false}]
     * @returns {Promise<void>} Resolves to `undefined`
     */


    function promptImgURL() {
      return _promptImgURL.apply(this, arguments);
    }
    /**
    * @param {Element} elem
    * @returns {void}
    */


    function _promptImgURL() {
      _promptImgURL = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
        var _ref27,
            _ref27$cancelDeletes,
            cancelDeletes,
            curhref,
            url,
            _args19 = arguments;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _ref27 = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : {}, _ref27$cancelDeletes = _ref27.cancelDeletes, cancelDeletes = _ref27$cancelDeletes === void 0 ? false : _ref27$cancelDeletes;
                curhref = svgCanvas.getHref(selectedElement);
                curhref = curhref.startsWith('data:') ? '' : curhref;
                _context19.next = 5;
                return $$c.prompt(uiStrings$1.notification.enterNewImgURL, curhref);

              case 5:
                url = _context19.sent;

                if (url) {
                  setImageURL(url);
                } else if (cancelDeletes) {
                  svgCanvas.deleteSelectedElements();
                }

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));
      return _promptImgURL.apply(this, arguments);
    }

    var setInputWidth = function setInputWidth(elem) {
      var w = Math.min(Math.max(12 + elem.value.length * 6, 50), 300);
      $$c(elem).width(w);
    };
    /**
     *
     * @param {HTMLDivElement} [scanvas]
     * @param {Float} [zoom]
     * @returns {void}
     */


    function updateRulers(scanvas, zoom) {
      if (!zoom) {
        zoom = svgCanvas.getZoom();
      }

      if (!scanvas) {
        scanvas = $$c('#svgcanvas');
      }

      var d, i;
      var limit = 30000;
      var contentElem = svgCanvas.getContentElem();
      var units = getTypeMap();
      var unit = units[curConfig.baseUnit]; // 1 = 1px
      // draw x ruler then y ruler

      for (d = 0; d < 2; d++) {
        var isX = d === 0;
        var dim = isX ? 'x' : 'y';
        var lentype = isX ? 'width' : 'height';
        var contentDim = Number(contentElem.getAttribute(dim));
        var $hcanvOrig = $$c('#ruler_' + dim + ' canvas:first'); // Bit of a hack to fully clear the canvas in Safari & IE9

        var $hcanv = $hcanvOrig.clone();
        $hcanvOrig.replaceWith($hcanv);
        var hcanv = $hcanv[0]; // Set the canvas size to the width of the container

        var rulerLen = scanvas[lentype]();
        var totalLen = rulerLen;
        hcanv.parentNode.style[lentype] = totalLen + 'px';
        var ctx = hcanv.getContext('2d');
        var ctxArr = void 0,
            num = void 0,
            ctxArrNum = void 0;
        ctx.fillStyle = 'rgb(200,0,0)';
        ctx.fillRect(0, 0, hcanv.width, hcanv.height); // Remove any existing canvasses

        $hcanv.siblings().remove(); // Create multiple canvases when necessary (due to browser limits)

        if (rulerLen >= limit) {
          ctxArrNum = Number.parseInt(rulerLen / limit) + 1;
          ctxArr = [];
          ctxArr[0] = ctx;
          var copy = void 0;

          for (i = 1; i < ctxArrNum; i++) {
            hcanv[lentype] = limit;
            copy = hcanv.cloneNode(true);
            hcanv.parentNode.append(copy);
            ctxArr[i] = copy.getContext('2d');
          }

          copy[lentype] = rulerLen % limit; // set copy width to last

          rulerLen = limit;
        }

        hcanv[lentype] = rulerLen;
        var uMulti = unit * zoom; // Calculate the main number interval

        var rawM = 50 / uMulti;
        var multi = 1;

        for (i = 0; i < rIntervals.length; i++) {
          num = rIntervals[i];
          multi = num;

          if (rawM <= num) {
            break;
          }
        }

        var bigInt = multi * uMulti;
        ctx.font = '9px sans-serif';
        var rulerD = contentDim / uMulti % multi * uMulti;
        var labelPos = rulerD - bigInt; // draw big intervals

        var ctxNum = 0;

        while (rulerD < totalLen) {
          labelPos += bigInt; // const realD = rulerD - contentDim; // Currently unused

          var curD = Math.round(rulerD) + 0.5;

          if (isX) {
            ctx.moveTo(curD, 15);
            ctx.lineTo(curD, 0);
          } else {
            ctx.moveTo(15, curD);
            ctx.lineTo(0, curD);
          }

          num = (labelPos - contentDim) / uMulti;
          var label = void 0;

          if (multi >= 1) {
            label = Math.round(num);
          } else {
            var decs = String(multi).split('.')[1].length;
            label = num.toFixed(decs);
          } // Change 1000s to Ks


          if (label !== 0 && label !== 1000 && label % 1000 === 0) {
            label = label / 1000 + 'K';
          }

          if (isX) {
            ctx.fillText(label, rulerD + 2, 8);
          } else {
            // draw label vertically
            var _str = String(label).split('');

            for (i = 0; i < _str.length; i++) {
              ctx.fillText(_str[i], 1, rulerD + 9 + i * 9);
            }
          }

          var part = bigInt / 10; // draw the small intervals

          for (i = 1; i < 10; i++) {
            var subD = Math.round(rulerD + part * i) + 0.5;

            if (ctxArr && subD > rulerLen) {
              ctxNum++;
              ctx.stroke();

              if (ctxNum >= ctxArrNum) {
                i = 10;
                rulerD = totalLen;
                continue;
              }

              ctx = ctxArr[ctxNum];
              rulerD -= limit;
              subD = Math.round(rulerD + part * i) + 0.5;
            } // odd lines are slighly longer


            var lineNum = i % 2 ? 12 : 10;

            if (isX) {
              ctx.moveTo(subD, 15);
              ctx.lineTo(subD, lineNum);
            } else {
              ctx.moveTo(15, subD);
              ctx.lineTo(lineNum, subD);
            }
          }

          rulerD += bigInt;
        }

        ctx.strokeStyle = '#000';
        ctx.stroke();
      }
    }
    /**
    * @function module:SVGEditor.updateCanvas
    * @param {boolean} center
    * @param {module:math.XYObject} newCtr
    * @returns {void}
    */


    var updateCanvas = editor.updateCanvas = function (center, newCtr) {
      var zoom = svgCanvas.getZoom();
      var wArea = workarea;
      var cnvs = $$c('#svgcanvas');
      var w = workarea.width(),
          h = workarea.height();
      var wOrig = w,
          hOrig = h;
      var oldCtr = {
        x: wArea[0].scrollLeft + wOrig / 2,
        y: wArea[0].scrollTop + hOrig / 2
      };
      var multi = curConfig.canvas_expansion;
      w = Math.max(wOrig, svgCanvas.contentW * zoom * multi);
      h = Math.max(hOrig, svgCanvas.contentH * zoom * multi);

      if (w === wOrig && h === hOrig) {
        workarea.css('overflow', 'hidden');
      } else {
        workarea.css('overflow', 'scroll');
      }

      var oldCanY = cnvs.height() / 2;
      var oldCanX = cnvs.width() / 2;
      cnvs.width(w).height(h);
      var newCanY = h / 2;
      var newCanX = w / 2;
      var offset = svgCanvas.updateCanvas(w, h);
      var ratio = newCanX / oldCanX;
      var scrollX = w / 2 - wOrig / 2; // eslint-disable-line no-shadow

      var scrollY = h / 2 - hOrig / 2; // eslint-disable-line no-shadow

      if (!newCtr) {
        var oldDistX = oldCtr.x - oldCanX;
        var newX = newCanX + oldDistX * ratio;
        var oldDistY = oldCtr.y - oldCanY;
        var newY = newCanY + oldDistY * ratio;
        newCtr = {
          x: newX,
          y: newY
        };
      } else {
        newCtr.x += offset.x;
        newCtr.y += offset.y;
      }

      if (center) {
        // Go to top-left for larger documents
        if (svgCanvas.contentW > wArea.width()) {
          // Top-left
          workarea[0].scrollLeft = offset.x - 10;
          workarea[0].scrollTop = offset.y - 10;
        } else {
          // Center
          wArea[0].scrollLeft = scrollX;
          wArea[0].scrollTop = scrollY;
        }
      } else {
        wArea[0].scrollLeft = newCtr.x - wOrig / 2;
        wArea[0].scrollTop = newCtr.y - hOrig / 2;
      }

      if (curConfig.showRulers) {
        updateRulers(cnvs, zoom);
        workarea.scroll();
      }

      if (urldata.storagePrompt !== true && editor.storagePromptState === 'ignore') {
        $$c('#dialog_box').hide();
      }
    };
    /**
     * @fires module:svgcanvas.SvgCanvas#event:ext_toolButtonStateUpdate
     * @returns {void}
     */


    var updateToolButtonState = function updateToolButtonState() {
      var bNoFill = svgCanvas.getColor('fill') === 'none';
      var bNoStroke = svgCanvas.getColor('stroke') === 'none';
      var buttonsNeedingStroke = ['#tool_fhpath', '#tool_line'];
      var buttonsNeedingFillAndStroke = ['#tools_rect .tool_button', '#tools_ellipse .tool_button', '#tool_text', '#tool_path'];

      if (bNoStroke) {
        buttonsNeedingStroke.forEach(function (btn) {
          if ($$c(btn).hasClass('tool_button_current')) {
            clickSelect();
          }

          $$c(btn).addClass('disabled');
        });
      } else {
        buttonsNeedingStroke.forEach(function (btn) {
          $$c(btn).removeClass('disabled');
        });
      }

      if (bNoStroke && bNoFill) {
        buttonsNeedingFillAndStroke.forEach(function (btn) {
          if ($$c(btn).hasClass('tool_button_current')) {
            clickSelect();
          }

          $$c(btn).addClass('disabled');
        });
      } else {
        buttonsNeedingFillAndStroke.forEach(function (btn) {
          $$c(btn).removeClass('disabled');
        });
      }

      svgCanvas.runExtensions('toolButtonStateUpdate',
      /** @type {module:svgcanvas.SvgCanvas#event:ext_toolButtonStateUpdate} */
      {
        nofill: bNoFill,
        nostroke: bNoStroke
      }); // Disable flyouts if all inside are disabled

      $$c('.tools_flyout').each(function () {
        var shower = $$c('#' + this.id + '_show');
        var hasEnabled = false;
        $$c(this).children().each(function () {
          if (!$$c(this).hasClass('disabled')) {
            hasEnabled = true;
          }
        });
        shower.toggleClass('disabled', !hasEnabled);
      });
      operaRepaint();
    };
    /**
    * Updates the toolbar (colors, opacity, etc) based on the selected element.
    * This function also updates the opacity and id elements that are in the
    * context panel.
    * @returns {void}
    */


    var updateToolbar = function updateToolbar() {
      var i, len;

      if (!isNullish(selectedElement)) {
        switch (selectedElement.tagName) {
          case 'use':
          case 'image':
          case 'foreignObject':
            break;

          case 'g':
          case 'a':
            {
              // Look for common styles
              var childs = selectedElement.getElementsByTagName('*');
              var gWidth = null;

              for (i = 0, len = childs.length; i < len; i++) {
                var swidth = childs[i].getAttribute('stroke-width');

                if (i === 0) {
                  gWidth = swidth;
                } else if (gWidth !== swidth) {
                  gWidth = null;
                }
              }

              $$c('#stroke_width').val(gWidth === null ? '' : gWidth);
              paintBox.fill.update(true);
              paintBox.stroke.update(true);
              break;
            }

          default:
            {
              paintBox.fill.update(true);
              paintBox.stroke.update(true);
              $$c('#stroke_width').val(selectedElement.getAttribute('stroke-width') || 1);
              $$c('#stroke_style').val(selectedElement.getAttribute('stroke-dasharray') || 'none');
              var attr = selectedElement.getAttribute('stroke-linejoin') || 'miter';

              if ($$c('#linejoin_' + attr).length) {
                setStrokeOpt($$c('#linejoin_' + attr)[0]);
              }

              attr = selectedElement.getAttribute('stroke-linecap') || 'butt';

              if ($$c('#linecap_' + attr).length) {
                setStrokeOpt($$c('#linecap_' + attr)[0]);
              }
            }
        }
      } // All elements including image and group have opacity


      if (!isNullish(selectedElement)) {
        var opacPerc = (selectedElement.getAttribute('opacity') || 1.0) * 100;
        $$c('#group_opacity').val(opacPerc);
        $$c('#opac_slider').slider('option', 'value', opacPerc);
        $$c('#elem_id').val(selectedElement.id);
        $$c('#elem_class').val(selectedElement.getAttribute('class'));
      }

      updateToolButtonState();
    };
    /**
    * Updates the context panel tools based on the selected element.
    * @returns {void}
    */


    var updateContextPanel = function updateContextPanel() {
      var elem = selectedElement; // If element has just been deleted, consider it null

      if (!isNullish(elem) && !elem.parentNode) {
        elem = null;
      }

      var currentLayerName = svgCanvas.getCurrentDrawing().getCurrentLayerName();
      var currentMode = svgCanvas.getMode();
      var unit = curConfig.baseUnit !== 'px' ? curConfig.baseUnit : null;
      var isNode = currentMode === 'pathedit'; // elem ? (elem.id && elem.id.startsWith('pathpointgrip')) : false;

      var menuItems = $$c('#cmenu_canvas li');
      $$c('#selected_panel, #multiselected_panel, #g_panel, #rect_panel, #circle_panel,' + '#ellipse_panel, #line_panel, #text_panel, #image_panel, #container_panel,' + ' #use_panel, #a_panel').hide();

      if (!isNullish(elem)) {
        var elname = elem.nodeName; // If this is a link with no transform and one child, pretend
        // its child is selected
        // if (elname === 'a') { // && !$(elem).attr('transform')) {
        //   elem = elem.firstChild;
        // }

        var angle = svgCanvas.getRotationAngle(elem);
        $$c('#angle').val(angle);
        var blurval = svgCanvas.getBlur(elem);
        $$c('#blur').val(blurval);
        $$c('#blur_slider').slider('option', 'value', blurval);

        if (svgCanvas.addedNew) {
          if (elname === 'image' && svgCanvas.getMode() === 'image') {
            // Prompt for URL if not a data URL
            if (!svgCanvas.getHref(elem).startsWith('data:')) {
              /* await */
              promptImgURL({
                cancelDeletes: true
              });
            }
          }
          /* else if (elname == 'text') {
            // TODO: Do something here for new text
          } */

        }

        if (!isNode && currentMode !== 'pathedit') {
          $$c('#selected_panel').show(); // Elements in this array already have coord fields

          if (['line', 'circle', 'ellipse'].includes(elname)) {
            $$c('#xy_panel').hide();
          } else {
            var x, y; // Get BBox vals for g, polyline and path

            if (['g', 'polyline', 'path'].includes(elname)) {
              var bb = svgCanvas.getStrokedBBox([elem]);

              if (bb) {
                x = bb.x;
                y = bb.y;
              }
            } else {
              x = elem.getAttribute('x');
              y = elem.getAttribute('y');
            }

            if (unit) {
              x = convertUnit(x);
              y = convertUnit(y);
            }

            $$c('#selected_x').val(x || 0);
            $$c('#selected_y').val(y || 0);
            $$c('#xy_panel').show();
          } // Elements in this array cannot be converted to a path


          var noPath = !['image', 'text', 'path', 'g', 'use'].includes(elname);
          $$c('#tool_topath').toggle(noPath);
          $$c('#tool_reorient').toggle(elname === 'path');
          $$c('#tool_reorient').toggleClass('disabled', angle === 0);
        } else {
          var point = path.getNodePoint();
          $$c('#tool_add_subpath').removeClass('push_button_pressed').addClass('tool_button');
          $$c('#tool_node_delete').toggleClass('disabled', !path.canDeleteNodes); // Show open/close button based on selected point

          setIcon('#tool_openclose_path', path.closed_subpath ? 'open_path' : 'close_path');

          if (point) {
            var segType = $$c('#seg_type');

            if (unit) {
              point.x = convertUnit(point.x);
              point.y = convertUnit(point.y);
            }

            $$c('#path_node_x').val(point.x);
            $$c('#path_node_y').val(point.y);

            if (point.type) {
              segType.val(point.type).removeAttr('disabled');
            } else {
              segType.val(4).attr('disabled', 'disabled');
            }
          }

          return;
        } // update contextual tools here


        var panels = {
          g: [],
          a: [],
          rect: ['rx', 'width', 'height'],
          image: ['width', 'height'],
          circle: ['cx', 'cy', 'r'],
          ellipse: ['cx', 'cy', 'rx', 'ry'],
          line: ['x1', 'y1', 'x2', 'y2'],
          text: [],
          use: []
        };
        var _elem = elem,
            tagName = _elem.tagName; // if ($(elem).data('gsvg')) {
        //   $('#g_panel').show();
        // }

        var linkHref = null;

        if (tagName === 'a') {
          linkHref = svgCanvas.getHref(elem);
          $$c('#g_panel').show();
        }

        if (elem.parentNode.tagName === 'a') {
          if (!$$c(elem).siblings().length) {
            $$c('#a_panel').show();
            linkHref = svgCanvas.getHref(elem.parentNode);
          }
        } // Hide/show the make_link buttons


        $$c('#tool_make_link, #tool_make_link').toggle(!linkHref);

        if (linkHref) {
          $$c('#link_url').val(linkHref);
        }

        if (panels[tagName]) {
          var curPanel = panels[tagName];
          $$c('#' + tagName + '_panel').show();
          $$c.each(curPanel, function (i, item) {
            var attrVal = elem.getAttribute(item);

            if (curConfig.baseUnit !== 'px' && elem[item]) {
              var bv = elem[item].baseVal.value;
              attrVal = convertUnit(bv);
            }

            $$c('#' + tagName + '_' + item).val(attrVal || 0);
          });

          if (tagName === 'text') {
            $$c('#text_panel').css('display', 'inline');
            $$c('#tool_font_size').css('display', 'inline');

            if (svgCanvas.getItalic()) {
              $$c('#tool_italic').addClass('push_button_pressed').removeClass('tool_button');
            } else {
              $$c('#tool_italic').removeClass('push_button_pressed').addClass('tool_button');
            }

            if (svgCanvas.getBold()) {
              $$c('#tool_bold').addClass('push_button_pressed').removeClass('tool_button');
            } else {
              $$c('#tool_bold').removeClass('push_button_pressed').addClass('tool_button');
            }

            $$c('#font_family').val(elem.getAttribute('font-family'));
            $$c('#font_size').val(elem.getAttribute('font-size'));
            $$c('#text').val(elem.textContent);

            if (svgCanvas.addedNew) {
              // Timeout needed for IE9
              setTimeout(function () {
                $$c('#text').focus().select();
              }, 100);
            } // text

          } else if (tagName === 'image' && svgCanvas.getMode() === 'image') {
            setImageURL(svgCanvas.getHref(elem)); // image
          } else if (tagName === 'g' || tagName === 'use') {
            $$c('#container_panel').show();
            var title = svgCanvas.getTitle();
            var label = $$c('#g_title')[0];
            label.value = title;
            setInputWidth(label);
            $$c('#g_title').prop('disabled', tagName === 'use');
          }
        }

        menuItems[(tagName === 'g' ? 'en' : 'dis') + 'ableContextMenuItems']('#ungroup');
        menuItems[(tagName === 'g' || !multiselected ? 'dis' : 'en') + 'ableContextMenuItems']('#group'); // if (!Utils.isNullish(elem))
      } else if (multiselected) {
        $$c('#multiselected_panel').show();
        menuItems.enableContextMenuItems('#group').disableContextMenuItems('#ungroup');
      } else {
        menuItems.disableContextMenuItems('#delete,#cut,#copy,#group,#ungroup,#move_front,#move_up,#move_down,#move_back');
      } // update history buttons


      $$c('#tool_undo').toggleClass('disabled', undoMgr.getUndoStackSize() === 0);
      $$c('#tool_redo').toggleClass('disabled', undoMgr.getRedoStackSize() === 0);
      svgCanvas.addedNew = false;

      if (elem && !isNode || multiselected) {
        // update the selected elements' layer
        $$c('#selLayerNames').removeAttr('disabled').val(currentLayerName); // Enable regular menu options

        canvMenu.enableContextMenuItems('#delete,#cut,#copy,#move_front,#move_up,#move_down,#move_back');
      } else {
        $$c('#selLayerNames').attr('disabled', 'disabled');
      }
    };
    /**
    *
    * @returns {void}
    */


    var updateWireFrame = function updateWireFrame() {
      // Test support
      if (supportsNonSS) {
        return;
      }

      var rule = "\n      #workarea.wireframe #svgcontent * {\n        stroke-width: ".concat(1 / svgCanvas.getZoom(), "px;\n      }\n    ");
      $$c('#wireframe_rules').text(workarea.hasClass('wireframe') ? rule : '');
    };

    var curContext = '';
    /**
    * @param {string} [title=svgCanvas.getDocumentTitle()]
    * @returns {void}
    */

    var updateTitle = function updateTitle(title) {
      title = title || svgCanvas.getDocumentTitle();
      var newTitle = origTitle + (title ? ': ' + title : ''); // Remove title update with current context info, isn't really necessary
      // if (curContext) {
      //   new_title = new_title + curContext;
      // }

      $$c('title:first').text(newTitle);
    }; // called when we've selected a different element

    /**
    *
    * @param {external:Window} win
    * @param {module:svgcanvas.SvgCanvas#event:selected} elems Array of elements that were selected
    * @listens module:svgcanvas.SvgCanvas#event:selected
    * @fires module:svgcanvas.SvgCanvas#event:ext_selectedChanged
    * @returns {void}
    */


    var selectedChanged = function selectedChanged(win, elems) {
      var mode = svgCanvas.getMode();

      if (mode === 'select') {
        setSelectMode();
      }

      var isNode = mode === 'pathedit'; // if elems[1] is present, then we have more than one element

      selectedElement = elems.length === 1 || isNullish(elems[1]) ? elems[0] : null;
      multiselected = elems.length >= 2 && !isNullish(elems[1]);

      if (!isNullish(selectedElement)) {
        // unless we're already in always set the mode of the editor to select because
        // upon creation of a text element the editor is switched into
        // select mode and this event fires - we need our UI to be in sync
        if (!isNode) {
          updateToolbar();
        }
      } // if (!Utils.isNullish(elem))
      // Deal with pathedit mode


      togglePathEditMode(isNode, elems);
      updateContextPanel();
      svgCanvas.runExtensions('selectedChanged',
      /** @type {module:svgcanvas.SvgCanvas#event:ext_selectedChanged} */
      {
        elems: elems,
        selectedElement: selectedElement,
        multiselected: multiselected
      });
    }; // Call when part of element is in process of changing, generally
    // on mousemove actions like rotate, move, etc.

    /**
     * @param {external:Window} win
     * @param {module:svgcanvas.SvgCanvas#event:transition} elems
     * @listens module:svgcanvas.SvgCanvas#event:transition
     * @fires module:svgcanvas.SvgCanvas#event:ext_elementTransition
     * @returns {void}
     */


    var elementTransition = function elementTransition(win, elems) {
      var mode = svgCanvas.getMode();
      var elem = elems[0];

      if (!elem) {
        return;
      }

      multiselected = elems.length >= 2 && !isNullish(elems[1]); // Only updating fields for single elements for now

      if (!multiselected) {
        switch (mode) {
          case 'rotate':
            {
              var ang = svgCanvas.getRotationAngle(elem);
              $$c('#angle').val(ang);
              $$c('#tool_reorient').toggleClass('disabled', ang === 0);
              break; // TODO: Update values that change on move/resize, etc
              // } case 'select': {
              // } case 'resize': {
              //   break;
              // }
            }
        }
      }

      svgCanvas.runExtensions('elementTransition',
      /** @type {module:svgcanvas.SvgCanvas#event:ext_elementTransition} */
      {
        elems: elems
      });
    };
    /**
     * Test whether an element is a layer or not.
     * @param {SVGGElement} elem - The SVGGElement to test.
     * @returns {boolean} True if the element is a layer
     */


    function isLayer(elem) {
      return elem && elem.tagName === 'g' && Layer.CLASS_REGEX.test(elem.getAttribute('class'));
    } // called when any element has changed

    /**
     * @param {external:Window} win
     * @param {module:svgcanvas.SvgCanvas#event:changed} elems
     * @listens module:svgcanvas.SvgCanvas#event:changed
     * @fires module:svgcanvas.SvgCanvas#event:ext_elementChanged
     * @returns {void}
     */


    var elementChanged = function elementChanged(win, elems) {
      var mode = svgCanvas.getMode();

      if (mode === 'select') {
        setSelectMode();
      }

      elems.forEach(function (elem) {
        var isSvgElem = elem && elem.tagName === 'svg';

        if (isSvgElem || isLayer(elem)) {
          populateLayers(); // if the element changed was the svg, then it could be a resolution change

          if (isSvgElem) {
            updateCanvas();
          } // Update selectedElement if element is no longer part of the image.
          // This occurs for the text elements in Firefox

        } else if (elem && selectedElement && isNullish(selectedElement.parentNode)) {
          // || elem && elem.tagName == "path" && !multiselected) { // This was added in r1430, but not sure why
          selectedElement = elem;
        }
      });
      editor.showSaveWarning = true; // we update the contextual panel with potentially new
      // positional/sizing information (we DON'T want to update the
      // toolbar here as that creates an infinite loop)
      // also this updates the history buttons
      // we tell it to skip focusing the text control if the
      // text element was previously in focus

      updateContextPanel(); // In the event a gradient was flipped:

      if (selectedElement && mode === 'select') {
        paintBox.fill.update();
        paintBox.stroke.update();
      }

      svgCanvas.runExtensions('elementChanged',
      /** @type {module:svgcanvas.SvgCanvas#event:ext_elementChanged} */
      {
        elems: elems
      });
    };
    /**
     * @returns {void}
     */


    var zoomDone = function zoomDone() {
      updateWireFrame(); // updateCanvas(); // necessary?
    };
    /**
    * @typedef {PlainObject} module:SVGEditor.BBoxObjectWithFactor (like `DOMRect`)
    * @property {Float} x
    * @property {Float} y
    * @property {Float} width
    * @property {Float} height
    * @property {Float} [factor] Needed if width or height are 0
    * @property {Float} [zoom]
    * @see module:svgcanvas.SvgCanvas#event:zoomed
    */

    /**
    * @function module:svgcanvas.SvgCanvas#zoomChanged
    * @param {external:Window} win
    * @param {module:svgcanvas.SvgCanvas#event:zoomed} bbox
    * @param {boolean} autoCenter
    * @listens module:svgcanvas.SvgCanvas#event:zoomed
    * @returns {void}
    */


    var zoomChanged = svgCanvas.zoomChanged = function (win, bbox, autoCenter) {
      var scrbar = 15,
          // res = svgCanvas.getResolution(), // Currently unused
      wArea = workarea; // const canvasPos = $('#svgcanvas').position(); // Currently unused

      var zInfo = svgCanvas.setBBoxZoom(bbox, wArea.width() - scrbar, wArea.height() - scrbar);

      if (!zInfo) {
        return;
      }

      var zoomlevel = zInfo.zoom,
          bb = zInfo.bbox;

      if (zoomlevel < 0.001) {
        changeZoom({
          value: 0.1
        });
        return;
      }

      $$c('#zoom').val((zoomlevel * 100).toFixed(1));

      if (autoCenter) {
        updateCanvas();
      } else {
        updateCanvas(false, {
          x: bb.x * zoomlevel + bb.width * zoomlevel / 2,
          y: bb.y * zoomlevel + bb.height * zoomlevel / 2
        });
      }

      if (svgCanvas.getMode() === 'zoom' && bb.width) {
        // Go to select if a zoom box was drawn
        setSelectMode();
      }

      zoomDone();
    };
    /**
    * @type {module:jQuerySpinButton.ValueCallback}
    */


    var changeZoom = function changeZoom(ctl) {
      var zoomlevel = ctl.value / 100;

      if (zoomlevel < 0.001) {
        ctl.value = 0.1;
        return;
      }

      var zoom = svgCanvas.getZoom();
      var wArea = workarea;
      zoomChanged(window, {
        width: 0,
        height: 0,
        // center pt of scroll position
        x: (wArea[0].scrollLeft + wArea.width() / 2) / zoom,
        y: (wArea[0].scrollTop + wArea.height() / 2) / zoom,
        zoom: zoomlevel
      }, true);
    };

    $$c('#cur_context_panel').delegate('a', 'click', function () {
      var link = $$c(this);

      if (link.attr('data-root')) {
        svgCanvas.leaveContext();
      } else {
        svgCanvas.setContext(link.text());
      }

      svgCanvas.clearSelection();
      return false;
    });
    /**
     * @param {external:Window} win
     * @param {module:svgcanvas.SvgCanvas#event:contextset} context
     * @listens module:svgcanvas.SvgCanvas#event:contextset
     * @returns {void}
     */

    var contextChanged = function contextChanged(win, context) {
      var linkStr = '';

      if (context) {
        var _str2 = '';
        linkStr = '<a href="#" data-root="y">' + svgCanvas.getCurrentDrawing().getCurrentLayerName() + '</a>';
        $$c(context).parentsUntil('#svgcontent > g').andSelf().each(function () {
          if (this.id) {
            _str2 += ' > ' + this.id;

            if (this !== context) {
              linkStr += ' > <a href="#">' + this.id + '</a>';
            } else {
              linkStr += ' > ' + this.id;
            }
          }
        });
        curContext = _str2;
      } else {
        curContext = null;
      }

      $$c('#cur_context_panel').toggle(Boolean(context)).html(linkStr);
      updateTitle();
    };
    /**
    * Makes sure the current selected paint is available to work with.
    * @returns {void}
    */


    var prepPaints = function prepPaints() {
      paintBox.fill.prep();
      paintBox.stroke.prep();
    };

    var flyoutFuncs = {};
    /**
    *
    * @returns {void}
    */

    var setFlyoutTitles = function setFlyoutTitles() {
      $$c('.tools_flyout').each(function () {
        var shower = $$c('#' + this.id + '_show');

        if (shower.data('isLibrary')) {
          return;
        }

        var tooltips = $$c(this).children().map(function () {
          return this.title;
        }).get();
        shower[0].title = tooltips.join(' / ');
      });
    };

    var allHolders = {};
    /**
     * @param {PlainObject<string, module:SVGEditor.ToolButton>} holders Key is a selector
     * @returns {void}
     */

    var setupFlyouts = function setupFlyouts(holders) {
      $$c.each(holders, function (holdSel, btnOpts) {
        var _allHolders$holdSel;

        if (!allHolders[holdSel]) {
          allHolders[holdSel] = [];
        }

        (_allHolders$holdSel = allHolders[holdSel]).push.apply(_allHolders$holdSel, _toConsumableArray(btnOpts));

        var buttons = $$c(holdSel).children().not('.tool_button_evt_handled');
        var showSel = holdSel + '_show';
        var shower = $$c(showSel);
        var def = false;
        buttons.addClass('tool_button tool_button_evt_handled').unbind('click mousedown mouseup') // may not be necessary
        .each(function () {
          // Get this button's options
          var idSel = '#' + this.getAttribute('id');

          var _Object$entries$find = Object.entries(btnOpts).find(function (_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2),
                _ = _ref8[0],
                sel = _ref8[1].sel;

            return sel === idSel;
          }),
              _Object$entries$find2 = _slicedToArray(_Object$entries$find, 2),
              i = _Object$entries$find2[0],
              opts = _Object$entries$find2[1]; // Remember the function that goes with this ID


          flyoutFuncs[opts.sel] = opts.fn;

          if (opts.isDefault) {
            def = i;
          }
          /**
           * Clicking the icon in flyout should set this set's icon.
           * @param {Event} ev
           * @returns {boolean}
           */


          var flyoutAction = function flyoutAction(ev) {
            var options = opts; // Find the currently selected tool if comes from keystroke

            if (ev.type === 'keydown') {
              var flyoutIsSelected = $$c(options.parent + '_show').hasClass('tool_button_current');
              var currentOperation = $$c(options.parent + '_show').attr('data-curopt');
              Object.entries(holders[opts.parent]).some(function (_ref9) {
                var _ref10 = _slicedToArray(_ref9, 2),
                    j = _ref10[0],
                    tool = _ref10[1];

                if (tool.sel !== currentOperation) {
                  return false;
                }

                if (!ev.shiftKey || !flyoutIsSelected) {
                  options = tool;
                } else {
                  // If flyout is selected, allow shift key to iterate through subitems
                  j = Number.parseInt(j); // Use `allHolders` to include both extension `includeWith` and toolbarButtons

                  options = allHolders[opts.parent][j + 1] || holders[opts.parent][0];
                }

                return true;
              });
            }

            if ($$c(this).hasClass('disabled')) {
              return false;
            }

            if (toolButtonClick(showSel)) {
              options.fn();
            }

            var icon;

            if (options.icon) {
              icon = $$c.getSvgIcon(options.icon, true);
            } else {
              icon = $$c(options.sel).children().eq(0).clone();
            }

            icon[0].setAttribute('width', shower.width());
            icon[0].setAttribute('height', shower.height());
            shower.children(':not(.flyout_arrow_horiz)').remove();
            shower.append(icon).attr('data-curopt', options.sel); // This sets the current mode

            return true;
          };

          $$c(this).mouseup(flyoutAction);

          if (opts.key) {
            $$c(document).bind('keydown', opts.key[0] + ' shift+' + opts.key[0], flyoutAction);
          }

          return true;
        });

        if (def) {
          shower.attr('data-curopt', btnOpts[def].sel);
        } else if (!shower.attr('data-curopt')) {
          // Set first as default
          shower.attr('data-curopt', btnOpts[0].sel);
        }

        var timer; // Clicking the "show" icon should set the current mode

        shower.mousedown(function (evt) {
          if (shower.hasClass('disabled')) {
            return false;
          }

          var holder = $$c(holdSel);
          var pos = $$c(showSel).position();
          var l = pos.left + 34;
          var w = holder.width() * -1;
          var time = holder.data('shown_popop') ? 200 : 0;
          timer = setTimeout(function () {
            // Show corresponding menu
            if (!shower.data('isLibrary')) {
              holder.css('left', w).show().animate({
                left: l
              }, 150);
            } else {
              holder.css('left', l).show();
            }

            holder.data('shown_popop', true);
          }, time);
          evt.preventDefault();
          return true;
        }).mouseup(function (evt) {
          clearTimeout(timer);
          var opt = $$c(this).attr('data-curopt'); // Is library and popped up, so do nothing

          if (shower.data('isLibrary') && $$c(showSel.replace('_show', '')).is(':visible')) {
            toolButtonClick(showSel, true);
            return;
          }

          if (toolButtonClick(showSel) && flyoutFuncs[opt]) {
            flyoutFuncs[opt]();
          }
        }); // $('#tools_rect').mouseleave(function () { $('#tools_rect').fadeOut(); });
      });
      setFlyoutTitles();
      setFlyoutPositions();
    };
    /**
    * @param {string} id
    * @param {external:jQuery} child
    * @returns {external:jQuery}
    */


    var makeFlyoutHolder = function makeFlyoutHolder(id, child) {
      var div = $$c('<div>', {
        "class": 'tools_flyout',
        id: id
      }).appendTo('#svg_editor').append(child);
      return div;
    };
    /**
    * @param {string} elemSel
    * @param {string} listSel
    * @param {external:jQuery.Function} callback
    * @param {PlainObject} opts
    * @param {boolean} opts.dropUp
    * @param {boolean} opts.seticon
    * @param {boolean} opts.multiclick
    * @todo Combine this with `addDropDown` or find other way to optimize.
    * @returns {void}
    */


    var addAltDropDown = function addAltDropDown(elemSel, listSel, callback, opts) {
      var button = $$c(elemSel);
      var dropUp = opts.dropUp;
      var list = $$c(listSel);

      if (dropUp) {
        $$c(elemSel).addClass('dropup');
      }

      list.find('li').bind('mouseup', function () {
        if (opts.seticon) {
          setIcon('#cur_' + button[0].id, $$c(this).children());
          $$c(this).addClass('current').siblings().removeClass('current');
        }

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        callback.apply.apply(callback, [this].concat(args));
      });
      var onButton = false;
      $$c(window).mouseup(function (evt) {
        if (!onButton) {
          button.removeClass('down');
          list.hide();
          list.css({
            top: 0,
            left: 0
          });
        }

        onButton = false;
      }); // const height = list.height(); // Currently unused

      button.bind('mousedown', function () {
        var off = button.offset();

        if (dropUp) {
          off.top -= list.height();
          off.left += 8;
        } else {
          off.top += button.height();
        }

        list.offset(off);

        if (!button.hasClass('down')) {
          list.show();
          onButton = true;
        } else {
          // CSS position must be reset for Webkit
          list.hide();
          list.css({
            top: 0,
            left: 0
          });
        }

        button.toggleClass('down');
      }).hover(function () {
        onButton = true;
      }).mouseout(function () {
        onButton = false;
      });

      if (opts.multiclick) {
        list.mousedown(function () {
          onButton = true;
        });
      }
    };

    var extsPreLang = [];
    /**
     * @param {external:Window} win
     * @param {module:svgcanvas.SvgCanvas#event:extension_added} ext
     * @listens module:svgcanvas.SvgCanvas#event:extension_added
     * @returns {Promise<void>|void} Resolves to `undefined`
     */

    var extAdded = /*#__PURE__*/function () {
      var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(win, ext) {
        var cbCalled, resizeDone, lang, prepResize, runCallback, btnSelects, svgicons, fallbackObj, altsObj, placementObj, holders;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                prepResize = function _prepResize() {
                  if (resizeTimer) {
                    clearTimeout(resizeTimer);
                    resizeTimer = null;
                  }

                  if (!resizeDone) {
                    resizeTimer = setTimeout(function () {
                      resizeDone = true;
                      setIconSize(editor.pref('iconsize'));
                    }, 50);
                  }
                };

                if (ext) {
                  _context6.next = 3;
                  break;
                }

                return _context6.abrupt("return", undefined);

              case 3:
                cbCalled = false;
                resizeDone = false;

                if (!ext.langReady) {
                  _context6.next = 14;
                  break;
                }

                if (!editor.langChanged) {
                  _context6.next = 13;
                  break;
                }

                // We check for this since the "lang" pref could have been set by storage
                lang = editor.pref('lang');
                _context6.next = 10;
                return ext.langReady({
                  lang: lang,
                  uiStrings: uiStrings$1,
                  importLocale: getImportLocale({
                    defaultLang: lang,
                    defaultName: ext.name
                  })
                });

              case 10:
                loadedExtensionNames.push(ext.name);
                _context6.next = 14;
                break;

              case 13:
                extsPreLang.push(ext);

              case 14:
                /**
                *
                * @returns {void}
                */
                runCallback = function runCallback() {
                  if (ext.callback && !cbCalled) {
                    cbCalled = true;
                    ext.callback.call(editor);
                  }
                };

                btnSelects = [];
                /**
                * @typedef {PlainObject} module:SVGEditor.ContextTool
                * @property {string} panel The ID of the existing panel to which the tool is being added. Required.
                * @property {string} id The ID of the actual tool element. Required.
                * @property {PlainObject<string, external:jQuery.Function>|PlainObject<"change", external:jQuery.Function>} events DOM event names keyed to associated functions. Example: `{change () { alert('Option was changed') } }`. "change" event is one specifically handled for the "button-select" type. Required.
                * @property {string} title The tooltip text that will appear when the user hovers over the tool. Required.
                * @property {"tool_button"|"select"|"button-select"|"input"|string} type The type of tool being added. Expected.
                * @property {PlainObject<string, string>} [options] List of options and their labels for select tools. Example: `{1: 'One', 2: 'Two', all: 'All' }`. Required by "select" tools.
                * @property {string} [container_id] The ID to be given to the tool's container element.
                * @property {string} [defval] Default value
                * @property {string|Integer} [colnum] Added as part of the option list class.
                * @property {string} [label] Label associated with the tool, visible in the UI
                * @property {Integer} [size] Value of the "size" attribute of the tool input
                * @property {module:jQuerySpinButton.SpinButtonConfig} [spindata] When added to a tool of type "input", this tool becomes a "spinner" which allows the number to be in/decreased.
                */

                if (ext.context_tools) {
                  $$c.each(ext.context_tools, function (i, tool) {
                    // Add select tool
                    var contId = tool.container_id ? ' id="' + tool.container_id + '"' : '';
                    var panel = $$c('#' + tool.panel); // create the panel if it doesn't exist

                    if (!panel.length) {
                      panel = $$c('<div>', {
                        id: tool.panel
                      }).appendTo('#tools_top');
                    }

                    var html; // TODO: Allow support for other types, or adding to existing tool

                    switch (tool.type) {
                      case 'tool_button':
                        {
                          html = '<div class="tool_button">' + tool.id + '</div>';
                          var div = $$c(html).appendTo(panel);

                          if (tool.events) {
                            $$c.each(tool.events, function (evt, func) {
                              $$c(div).bind(evt, func);
                            });
                          }

                          break;
                        }

                      case 'select':
                        {
                          html = '<label' + contId + '>' + '<select id="' + tool.id + '">';
                          $$c.each(tool.options, function (val, text) {
                            var sel = val === tool.defval ? ' selected' : '';
                            html += '<option value="' + val + '"' + sel + '>' + text + '</option>';
                          });
                          html += '</select></label>'; // Creates the tool, hides & adds it, returns the select element

                          var sel = $$c(html).appendTo(panel).find('select');
                          $$c.each(tool.events, function (evt, func) {
                            $$c(sel).bind(evt, func);
                          });
                          break;
                        }

                      case 'button-select':
                        {
                          html = '<div id="' + tool.id + '" class="dropdown toolset" title="' + tool.title + '">' + '<div id="cur_' + tool.id + '" class="icon_label"></div><button></button></div>';
                          var list = $$c('<ul id="' + tool.id + '_opts"></ul>').appendTo('#option_lists');

                          if (tool.colnum) {
                            list.addClass('optcols' + tool.colnum);
                          } // Creates the tool, hides & adds it, returns the select element

                          /* const dropdown = */


                          $$c(html).appendTo(panel).children();
                          btnSelects.push({
                            elem: '#' + tool.id,
                            list: '#' + tool.id + '_opts',
                            title: tool.title,
                            callback: tool.events.change,
                            cur: '#cur_' + tool.id
                          });
                          break;
                        }

                      case 'input':
                        {
                          html = '<label' + contId + '>' + '<span id="' + tool.id + '_label">' + tool.label + ':</span>' + '<input id="' + tool.id + '" title="' + tool.title + '" size="' + (tool.size || '4') + '" value="' + (tool.defval || '') + '" type="text"/></label>'; // Creates the tool, hides & adds it, returns the select element
                          // Add to given tool.panel

                          var inp = $$c(html).appendTo(panel).find('input');

                          if (tool.spindata) {
                            inp.SpinButton(tool.spindata);
                          }

                          if (tool.events) {
                            $$c.each(tool.events, function (evt, func) {
                              inp.bind(evt, func);
                            });
                          }

                          break;
                        }
                    }
                  });
                }

                svgicons = ext.svgicons;

                if (!ext.buttons) {
                  _context6.next = 24;
                  break;
                }

                fallbackObj = {}, altsObj = {}, placementObj = {}, holders = {};
                /**
                * @typedef {GenericArray} module:SVGEditor.KeyArray
                * @property {string} 0 The key to bind (on `keydown`)
                * @property {boolean} 1 Whether to `preventDefault` on the `keydown` event
                * @property {boolean} 2 Not apparently in use (NoDisableInInput)
                */

                /**
                 * @typedef {string|module:SVGEditor.KeyArray} module:SVGEditor.Key
                 */

                /**
                * @typedef {PlainObject} module:SVGEditor.Button
                * @property {string} id A unique identifier for this button. If SVG icons are used, this must match the ID used in the icon file. Required.
                * @property {"mode_flyout"|"mode"|"context"|"app_menu"} type Type of button. Required.
                * @property {string} title The tooltip text that will appear when the user hovers over the icon. Required.
                * @property {PlainObject<string, external:jQuery.Function>|PlainObject<"click", external:jQuery.Function>} events DOM event names with associated functions. Example: `{click () { alert('Button was clicked') } }`. Click is used with `includeWith` and `type` of "mode_flyout" (and "mode"); any events may be added if `list` is not present. Expected.
                * @property {string} panel The ID of the context panel to be included, if type is "context". Required only if type is "context".
                * @property {string} icon The file path to the raster version of the icon image source. Required only if no `svgicons` is supplied from [ExtensionInitResponse]{@link module:svgcanvas.ExtensionInitResponse}.
                * @property {string} [svgicon] If absent, will utilize the button "id"; used to set "placement" on the `svgIcons` call
                * @property {string} [list] Points to the "id" of a `context_tools` item of type "button-select" into which the button will be added as a panel list item
                * @property {Integer} [position] The numeric index for placement; defaults to last position (as of the time of extension addition) if not present. For use with {@link http://api.jquery.com/eq/}.
                * @property {boolean} [isDefault] Whether or not the button is the default. Used with `list`.
                * @property {PlainObject} [includeWith] Object with flyout menu data
                * @property {boolean} [includeWith.isDefault] Indicates whether button is default in flyout list or not.
                * @property {string} includeWith.button jQuery selector of the existing button to be joined. Example: '#tool_line'. Required if `includeWith` is used.
                * @property {"last"|Integer} [includeWith.position] Position of icon in flyout list; will be added to end if not indicated. Integer is for use with {@link http://api.jquery.com/eq/}.
                * @property {module:SVGEditor.Key} [key] The key to bind to the button
                */
                // Add buttons given by extension

                $$c.each(ext.buttons, function (i,
                /** @type {module:SVGEditor.Button} */
                btn) {
                  var id = btn.id;
                  var num = i; // Give button a unique ID

                  while ($$c('#' + id).length) {
                    id = btn.id + '_' + ++num;
                  }

                  var icon;

                  if (!svgicons) {
                    icon = $$c('<img src="' + btn.icon + (btn.title ? '" alt="' + btn.title : '') + '">');
                  } else {
                    fallbackObj[id] = btn.icon;
                    altsObj[id] = btn.title;
                    var svgicon = btn.svgicon || btn.id;

                    if (btn.type === 'app_menu') {
                      placementObj['#' + id + ' > div'] = svgicon;
                    } else {
                      placementObj['#' + id] = svgicon;
                    }
                  }

                  var cls, parent; // Set button up according to its type

                  switch (btn.type) {
                    case 'mode_flyout':
                    case 'mode':
                      cls = 'tool_button';
                      parent = '#tools_left';
                      break;

                    case 'context':
                      cls = 'tool_button';
                      parent = '#' + btn.panel; // create the panel if it doesn't exist

                      if (!$$c(parent).length) {
                        $$c('<div>', {
                          id: btn.panel
                        }).appendTo('#tools_top');
                      }

                      break;

                    case 'app_menu':
                      cls = '';
                      parent = '#main_menu ul';
                      break;
                  }

                  var flyoutHolder, showBtn, refData, refBtn;
                  var button = $$c(btn.list || btn.type === 'app_menu' ? '<li/>' : '<div/>').attr('id', id).attr('title', btn.title).addClass(cls);

                  if (!btn.includeWith && !btn.list) {
                    if ('position' in btn) {
                      if ($$c(parent).children().eq(btn.position).length) {
                        $$c(parent).children().eq(btn.position).before(button);
                      } else {
                        $$c(parent).children().last().after(button);
                      }
                    } else {
                      button.appendTo(parent);
                    }

                    if (btn.type === 'mode_flyout') {
                      // Add to flyout menu / make flyout menu
                      // const opts = btn.includeWith;
                      // // opts.button, default, position
                      refBtn = $$c(button);
                      flyoutHolder = refBtn.parent(); // Create a flyout menu if there isn't one already

                      var tlsId;

                      if (!refBtn.parent().hasClass('tools_flyout')) {
                        // Create flyout placeholder
                        tlsId = refBtn[0].id.replace('tool_', 'tools_');
                        showBtn = refBtn.clone().attr('id', tlsId + '_show').append($$c('<div>', {
                          "class": 'flyout_arrow_horiz'
                        }));
                        refBtn.before(showBtn); // Create a flyout div

                        flyoutHolder = makeFlyoutHolder(tlsId, refBtn);
                        flyoutHolder.data('isLibrary', true);
                        showBtn.data('isLibrary', true);
                      } // refData = Actions.getButtonData(opts.button);


                      placementObj['#' + tlsId + '_show'] = btn.id; // TODO: Find way to set the current icon using the iconloader if this is not default
                      // Include data for extension button as well as ref button

                      /* curH = */

                      holders['#' + flyoutHolder[0].id] = [{
                        sel: '#' + id,
                        fn: btn.events.click,
                        icon: btn.id,
                        // key: btn.key,
                        isDefault: true
                      }]; // , refData
                      //
                      // // {sel:'#tool_rect', fn: clickRect, evt: 'mouseup', key: 4, parent: '#tools_rect', icon: 'rect'}
                      //
                      // const pos = ('position' in opts)?opts.position:'last';
                      // const len = flyoutHolder.children().length;
                      //
                      // // Add at given position or end
                      // if (!isNaN(pos) && pos >= 0 && pos < len) {
                      //   flyoutHolder.children().eq(pos).before(button);
                      // } else {
                      //   flyoutHolder.append(button);
                      //   curH.reverse();
                      // }
                    } else if (btn.type === 'app_menu') {
                      button.append('<div>').append(btn.title);
                    }
                  } else if (btn.list) {
                    // Add button to list
                    button.addClass('push_button');
                    $$c('#' + btn.list + '_opts').append(button);

                    if (btn.isDefault) {
                      $$c('#cur_' + btn.list).append(button.children().clone());

                      var _svgicon = btn.svgicon || btn.id;

                      placementObj['#cur_' + btn.list] = _svgicon;
                    }
                  } else if (btn.includeWith) {
                    // Add to flyout menu / make flyout menu
                    var opts = btn.includeWith; // opts.button, default, position

                    refBtn = $$c(opts.button);
                    flyoutHolder = refBtn.parent(); // Create a flyout menu if there isn't one already

                    var _tlsId;

                    if (!refBtn.parent().hasClass('tools_flyout')) {
                      // Create flyout placeholder
                      _tlsId = refBtn[0].id.replace('tool_', 'tools_');
                      showBtn = refBtn.clone().attr('id', _tlsId + '_show').append($$c('<div>', {
                        "class": 'flyout_arrow_horiz'
                      }));
                      refBtn.before(showBtn); // Create a flyout div

                      flyoutHolder = makeFlyoutHolder(_tlsId, refBtn);
                    }

                    refData = Actions.getButtonData(opts.button);

                    if (opts.isDefault) {
                      placementObj['#' + _tlsId + '_show'] = btn.id;
                    } // TODO: Find way to set the current icon using the iconloader if this is not default
                    // Include data for extension button as well as ref button


                    var curH = holders['#' + flyoutHolder[0].id] = [{
                      sel: '#' + id,
                      fn: btn.events.click,
                      icon: btn.id,
                      key: btn.key,
                      isDefault: Boolean(btn.includeWith && btn.includeWith.isDefault)
                    }, refData]; // {sel:'#tool_rect', fn: clickRect, evt: 'mouseup', key: 4, parent: '#tools_rect', icon: 'rect'}

                    var pos = 'position' in opts ? opts.position : 'last';
                    var len = flyoutHolder.children().length; // Add at given position or end

                    if (!isNaN(pos) && pos >= 0 && pos < len) {
                      flyoutHolder.children().eq(pos).before(button);
                    } else {
                      flyoutHolder.append(button);
                      curH.reverse();
                    }
                  }

                  if (!svgicons) {
                    button.append(icon);
                  }

                  if (!btn.list) {
                    // Add given events to button
                    $$c.each(btn.events, function (name, func) {
                      if (name === 'click' && btn.type === 'mode') {
                        // `touch.js` changes `touchstart` to `mousedown`,
                        //   so we must map extension click events as well
                        if (isTouch() && name === 'click') {
                          name = 'mousedown';
                        }

                        if (btn.includeWith) {
                          button.bind(name, func);
                        } else {
                          button.bind(name, function () {
                            if (toolButtonClick(button)) {
                              func();
                            }
                          });
                        }

                        if (btn.key) {
                          $$c(document).bind('keydown', btn.key, func);

                          if (btn.title) {
                            button.attr('title', btn.title + ' [' + btn.key + ']');
                          }
                        }
                      } else {
                        button.bind(name, func);
                      }
                    });
                  }

                  setupFlyouts(holders);
                });
                $$c.each(btnSelects, function () {
                  addAltDropDown(this.elem, this.list, this.callback, {
                    seticon: true
                  });
                });

                if (!svgicons) {
                  _context6.next = 24;
                  break;
                }

                return _context6.abrupt("return", new Promise(function (resolve, reject) {
                  // eslint-disable-line promise/avoid-new
                  $$c.svgIcons(svgicons, {
                    w: 24,
                    h: 24,
                    id_match: false,
                    no_img: !isWebkit(),
                    fallback: fallbackObj,
                    placement: placementObj,
                    callback: function callback(icons) {
                      // Non-ideal hack to make the icon match the current size
                      // if (curPrefs.iconsize && curPrefs.iconsize !== 'm') {
                      if (editor.pref('iconsize') !== 'm') {
                        prepResize();
                      }

                      runCallback();
                      resolve();
                    }
                  });
                }));

              case 24:
                return _context6.abrupt("return", runCallback());

              case 25:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      return function extAdded(_x4, _x5) {
        return _ref11.apply(this, arguments);
      };
    }();
    /**
    * @param {string} color
    * @param {Float} opac
    * @param {string} type
    * @returns {module:jGraduate~Paint}
    */


    var getPaint = function getPaint(color, opac, type) {
      // update the editor's fill paint
      var opts = {
        alpha: opac
      };

      if (color.startsWith('url(#')) {
        var refElem = svgCanvas.getRefElem(color);

        if (refElem) {
          refElem = refElem.cloneNode(true);
        } else {
          refElem = $$c('#' + type + '_color defs *')[0];
        }

        opts[refElem.tagName] = refElem;
      } else if (color.startsWith('#')) {
        opts.solidColor = color.substr(1);
      } else {
        opts.solidColor = 'none';
      }

      return new $$c.jGraduate.Paint(opts);
    }; // $('#text').focus(function () { textBeingEntered = true; });
    // $('#text').blur(function () { textBeingEntered = false; });
    // bind the selected event to our function that handles updates to the UI


    svgCanvas.bind('selected', selectedChanged);
    svgCanvas.bind('transition', elementTransition);
    svgCanvas.bind('changed', elementChanged);
    svgCanvas.bind('saved', saveHandler);
    svgCanvas.bind('exported', exportHandler);
    svgCanvas.bind('exportedPDF', function (win, data) {
      if (!data.output) {
        // Ignore Chrome
        return;
      }

      var exportWindowName = data.exportWindowName;

      if (exportWindowName) {
        exportWindow = window.open('', exportWindowName); // A hack to get the window via JSON-able name without opening a new one
      }

      if (!exportWindow || exportWindow.closed) {
        /* await */
        $$c.alert(uiStrings$1.notification.popupWindowBlocked);
        return;
      }

      exportWindow.location.href = data.output;
    });
    svgCanvas.bind('zoomed', zoomChanged);
    svgCanvas.bind('zoomDone', zoomDone);
    svgCanvas.bind('updateCanvas',
    /**
     * @param {external:Window} win
     * @param {PlainObject} centerInfo
     * @param {false} centerInfo.center
     * @param {module:math.XYObject} centerInfo.newCtr
     * @listens module:svgcanvas.SvgCanvas#event:updateCanvas
     * @returns {void}
     */
    function (win, _ref12) {
      var center = _ref12.center,
          newCtr = _ref12.newCtr;
      updateCanvas(center, newCtr);
    });
    svgCanvas.bind('contextset', contextChanged);
    svgCanvas.bind('extension_added', extAdded);
    svgCanvas.textActions.setInputElem($$c('#text')[0]);
    var str = '<div class="palette_item" data-rgb="none"></div>';
    $$c.each(palette, function (i, item) {
      str += '<div class="palette_item" style="background-color: ' + item + ';" data-rgb="' + item + '"></div>';
    });
    $$c('#palette').append(str); // Set up editor background functionality

    var colorBlocks = ['#FFF', '#888', '#000', 'chessboard'];
    str = '';
    $$c.each(colorBlocks, function (i, e) {
      if (e === 'chessboard') {
        str += '<div class="color_block" data-bgcolor="' + e + '" style="background-image:url(data:image/gif;base64,' + 'R0lGODlhEAAQAIAAAP///9bW1iH5BAAAAAAALAAAAAAQABAAAAIfjG+' + 'gq4jM3IFLJgpswNly/XkcBpIiVaInlLJr9FZWAQA7);"></div>';
      } else {
        str += '<div class="color_block" data-bgcolor="' + e + '" style="background-color:' + e + ';"></div>';
      }
    });
    $$c('#bg_blocks').append(str);
    var blocks = $$c('#bg_blocks div');
    var curBg = 'cur_background';
    blocks.each(function () {
      var blk = $$c(this);
      blk.click(function () {
        blocks.removeClass(curBg);
        $$c(this).addClass(curBg);
      });
    });
    setBackground(editor.pref('bkgd_color'), editor.pref('bkgd_url'));
    $$c('#image_save_opts input').val([editor.pref('img_save')]);
    /**
    * @type {module:jQuerySpinButton.ValueCallback}
    */

    var changeRectRadius = function changeRectRadius(ctl) {
      svgCanvas.setRectRadius(ctl.value);
    };
    /**
    * @type {module:jQuerySpinButton.ValueCallback}
    */


    var changeFontSize = function changeFontSize(ctl) {
      svgCanvas.setFontSize(ctl.value);
    };
    /**
    * @type {module:jQuerySpinButton.ValueCallback}
    */


    var changeStrokeWidth = function changeStrokeWidth(ctl) {
      var val = ctl.value;

      if (val === 0 && selectedElement && ['line', 'polyline'].includes(selectedElement.nodeName)) {
        val = ctl.value = 1;
      }

      svgCanvas.setStrokeWidth(val);
    };
    /**
    * @type {module:jQuerySpinButton.ValueCallback}
    */


    var changeRotationAngle = function changeRotationAngle(ctl) {
      svgCanvas.setRotationAngle(ctl.value);
      $$c('#tool_reorient').toggleClass('disabled', Number.parseInt(ctl.value) === 0);
    };
    /**
    * @param {external:jQuery.fn.SpinButton} ctl Spin Button
    * @param {string} [val=ctl.value]
    * @returns {void}
    */


    var changeOpacity = function changeOpacity(ctl, val) {
      if (isNullish(val)) {
        val = ctl.value;
      }

      $$c('#group_opacity').val(val);

      if (!ctl || !ctl.handle) {
        $$c('#opac_slider').slider('option', 'value', val);
      }

      svgCanvas.setOpacity(val / 100);
    };
    /**
    * @param {external:jQuery.fn.SpinButton} ctl Spin Button
    * @param {string} [val=ctl.value]
    * @param {boolean} noUndo
    * @returns {void}
    */


    var changeBlur = function changeBlur(ctl, val, noUndo) {
      if (isNullish(val)) {
        val = ctl.value;
      }

      $$c('#blur').val(val);
      var complete = false;

      if (!ctl || !ctl.handle) {
        $$c('#blur_slider').slider('option', 'value', val);
        complete = true;
      }

      if (noUndo) {
        svgCanvas.setBlurNoUndo(val);
      } else {
        svgCanvas.setBlur(val, complete);
      }
    };

    $$c('#stroke_style').change(function () {
      svgCanvas.setStrokeAttr('stroke-dasharray', $$c(this).val());
      operaRepaint();
    });
    $$c('#stroke_linejoin').change(function () {
      svgCanvas.setStrokeAttr('stroke-linejoin', $$c(this).val());
      operaRepaint();
    }); // Lose focus for select elements when changed (Allows keyboard shortcuts to work better)

    $$c('select').change(function () {
      $$c(this).blur();
    }); // fired when user wants to move elements to another layer

    var promptMoveLayerOnce = false;
    $$c('#selLayerNames').change( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var destLayer, confirmStr, moveToLayer, ok;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              destLayer = this.options[this.selectedIndex].value;
              confirmStr = uiStrings$1.notification.QmoveElemsToLayer.replace('%s', destLayer);
              /**
              * @param {boolean} ok
              * @returns {void}
              */

              moveToLayer = function moveToLayer(ok) {
                if (!ok) {
                  return;
                }

                promptMoveLayerOnce = true;
                svgCanvas.moveSelectedToLayer(destLayer);
                svgCanvas.clearSelection();
                populateLayers();
              };

              if (!destLayer) {
                _context7.next = 14;
                break;
              }

              if (!promptMoveLayerOnce) {
                _context7.next = 8;
                break;
              }

              moveToLayer(true);
              _context7.next = 14;
              break;

            case 8:
              _context7.next = 10;
              return $$c.confirm(confirmStr);

            case 10:
              ok = _context7.sent;

              if (ok) {
                _context7.next = 13;
                break;
              }

              return _context7.abrupt("return");

            case 13:
              moveToLayer(true);

            case 14:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    })));
    $$c('#font_family').change(function () {
      svgCanvas.setFontFamily(this.value);
    });
    $$c('#seg_type').change(function () {
      svgCanvas.setSegType($$c(this).val());
    });
    $$c('#text').bind('keyup input', function () {
      svgCanvas.setTextContent(this.value);
    });
    $$c('#image_url').change(function () {
      setImageURL(this.value);
    });
    $$c('#link_url').change(function () {
      if (this.value.length) {
        svgCanvas.setLinkURL(this.value);
      } else {
        svgCanvas.removeHyperlink();
      }
    });
    $$c('#g_title').change(function () {
      svgCanvas.setGroupTitle(this.value);
    });
    $$c('.attr_changer').change(function () {
      var attr = this.getAttribute('data-attr');
      var val = this.value;
      var valid = isValidUnit(attr, val, selectedElement);

      if (!valid) {
        this.value = selectedElement.getAttribute(attr);
        /* await */

        $$c.alert(uiStrings$1.notification.invalidAttrValGiven);
        return false;
      }

      if (attr !== 'id' && attr !== 'class') {
        if (isNaN(val)) {
          val = svgCanvas.convertToNum(attr, val);
        } else if (curConfig.baseUnit !== 'px') {
          // Convert unitless value to one with given unit
          var unitData = getTypeMap();

          if (selectedElement[attr] || svgCanvas.getMode() === 'pathedit' || attr === 'x' || attr === 'y') {
            val *= unitData[curConfig.baseUnit];
          }
        }
      } // if the user is changing the id, then de-select the element first
      // change the ID, then re-select it with the new ID


      if (attr === 'id') {
        var elem = selectedElement;
        svgCanvas.clearSelection();
        elem.id = val;
        svgCanvas.addToSelection([elem], true);
      } else {
        svgCanvas.changeSelectedAttribute(attr, val);
      }

      this.blur();
      return true;
    }); // Prevent selection of elements when shift-clicking

    $$c('#palette').mouseover(function () {
      var inp = $$c('<input type="hidden">');
      $$c(this).append(inp);
      inp.focus().remove();
    });
    $$c('.palette_item').mousedown(function (evt) {
      // shift key or right click for stroke
      var picker = evt.shiftKey || evt.button === 2 ? 'stroke' : 'fill';
      var color = $$c(this).data('rgb');
      var paint; // Webkit-based browsers returned 'initial' here for no stroke

      if (color === 'none' || color === 'transparent' || color === 'initial') {
        color = 'none';
        paint = new $$c.jGraduate.Paint();
      } else {
        paint = new $$c.jGraduate.Paint({
          alpha: 100,
          solidColor: color.substr(1)
        });
      }

      paintBox[picker].setPaint(paint);
      svgCanvas.setColor(picker, color);

      if (color !== 'none' && svgCanvas.getPaintOpacity(picker) !== 1) {
        svgCanvas.setPaintOpacity(picker, 1.0);
      }

      updateToolButtonState();
    }).bind('contextmenu', function (e) {
      e.preventDefault();
    });
    $$c('#toggle_stroke_tools').on('click', function () {
      $$c('#tools_bottom').toggleClass('expanded');
    });

    (function () {
      var wArea = workarea[0];
      var lastX = null,
          lastY = null,
          panning = false,
          keypan = false;
      $$c('#svgcanvas').bind('mousemove mouseup', function (evt) {
        if (panning === false) {
          return true;
        }

        wArea.scrollLeft -= evt.clientX - lastX;
        wArea.scrollTop -= evt.clientY - lastY;
        lastX = evt.clientX;
        lastY = evt.clientY;

        if (evt.type === 'mouseup') {
          panning = false;
        }

        return false;
      }).mousedown(function (evt) {
        if (evt.button === 1 || keypan === true) {
          panning = true;
          lastX = evt.clientX;
          lastY = evt.clientY;
          return false;
        }

        return true;
      });
      $$c(window).mouseup(function () {
        panning = false;
      });
      $$c(document).bind('keydown', 'space', function (evt) {
        svgCanvas.spaceKey = keypan = true;
        evt.preventDefault();
      }).bind('keyup', 'space', function (evt) {
        evt.preventDefault();
        svgCanvas.spaceKey = keypan = false;
      }).bind('keydown', 'shift', function (evt) {
        if (svgCanvas.getMode() === 'zoom') {
          workarea.css('cursor', zoomOutIcon);
        }
      }).bind('keyup', 'shift', function (evt) {
        if (svgCanvas.getMode() === 'zoom') {
          workarea.css('cursor', zoomInIcon);
        }
      });
      /**
       * @function module:SVGEditor.setPanning
       * @param {boolean} active
       * @returns {void}
       */

      editor.setPanning = function (active) {
        svgCanvas.spaceKey = keypan = active;
      };
    })();

    (function () {
      var button = $$c('#main_icon');
      var overlay = $$c('#main_icon span');
      var list = $$c('#main_menu');
      var onButton = false;
      var height = 0;
      var jsHover = true;
      var setClick = false;
      /*
      // Currently unused
      const hideMenu = function () {
        list.fadeOut(200);
      };
      */

      $$c(window).mouseup(function (evt) {
        if (!onButton) {
          button.removeClass('buttondown'); // do not hide if it was the file input as that input needs to be visible
          // for its change event to fire

          if (evt.target.tagName !== 'INPUT') {
            list.fadeOut(200);
          } else if (!setClick) {
            setClick = true;
            $$c(evt.target).click(function () {
              list.css('margin-left', '-9999px').show();
            });
          }
        }

        onButton = false;
      }).mousedown(function (evt) {
        // $('.contextMenu').hide();
        var islib = $$c(evt.target).closest('div.tools_flyout, .contextMenu').length;

        if (!islib) {
          $$c('.tools_flyout:visible,.contextMenu').fadeOut(250);
        }
      });
      overlay.bind('mousedown', function () {
        if (!button.hasClass('buttondown')) {
          // Margin must be reset in case it was changed before;
          list.css('margin-left', 0).show();

          if (!height) {
            height = list.height();
          } // Using custom animation as slideDown has annoying 'bounce effect'


          list.css('height', 0).animate({
            height: height
          }, 200);
          onButton = true;
        } else {
          list.fadeOut(200);
        }

        button.toggleClass('buttondown buttonup');
      }).hover(function () {
        onButton = true;
      }).mouseout(function () {
        onButton = false;
      });
      var listItems = $$c('#main_menu li'); // Check if JS method of hovering needs to be used (Webkit bug)

      listItems.mouseover(function () {
        jsHover = $$c(this).css('background-color') === 'rgba(0, 0, 0, 0)';
        listItems.unbind('mouseover');

        if (jsHover) {
          listItems.mouseover(function () {
            this.style.backgroundColor = '#FFC';
          }).mouseout(function () {
            this.style.backgroundColor = 'transparent';
            return true;
          });
        }
      });
    })(); // Made public for UI customization.
    // TODO: Group UI functions into a public editor.ui interface.

    /**
     * See {@link http://api.jquery.com/bind/#bind-eventType-eventData-handler}.
     * @callback module:SVGEditor.DropDownCallback
     * @param {external:jQuery.Event} ev See {@link http://api.jquery.com/Types/#Event}
     * @listens external:jQuery.Event
     * @returns {void|boolean} Calls `preventDefault()` and `stopPropagation()`
    */

    /**
     * @function module:SVGEditor.addDropDown
     * @param {Element|string} elem DOM Element or selector
     * @param {module:SVGEditor.DropDownCallback} callback Mouseup callback
     * @param {boolean} dropUp
     * @returns {void}
    */


    editor.addDropDown = function (elem, callback, dropUp) {
      if (!$$c(elem).length) {
        return;
      } // Quit if called on non-existent element


      var button = $$c(elem).find('button');
      var list = $$c(elem).find('ul').attr('id', $$c(elem)[0].id + '-list');

      if (dropUp) {
        $$c(elem).addClass('dropup');
      } else {
        // Move list to place where it can overflow container
        $$c('#option_lists').append(list);
      }

      list.find('li').bind('mouseup', callback);
      var onButton = false;
      $$c(window).mouseup(function (evt) {
        if (!onButton) {
          button.removeClass('down');
          list.hide();
        }

        onButton = false;
      });
      button.bind('mousedown', function () {
        if (!button.hasClass('down')) {
          if (!dropUp) {
            var pos = $$c(elem).position();
            list.css({
              top: pos.top + 24,
              left: pos.left - 10
            });
          }

          list.show();
          onButton = true;
        } else {
          list.hide();
        }

        button.toggleClass('down');
      }).hover(function () {
        onButton = true;
      }).mouseout(function () {
        onButton = false;
      });
    };

    editor.addDropDown('#font_family_dropdown', function () {
      $$c('#font_family').val($$c(this).text()).change();
    });
    editor.addDropDown('#opacity_dropdown', function () {
      if ($$c(this).find('div').length) {
        return;
      }

      var perc = Number.parseInt($$c(this).text().split('%')[0]);
      changeOpacity(false, perc);
    }, true); // For slider usage, see: http://jqueryui.com/demos/slider/

    $$c('#opac_slider').slider({
      start: function start() {
        $$c('#opacity_dropdown li:not(.special)').hide();
      },
      stop: function stop() {
        $$c('#opacity_dropdown li').show();
        $$c(window).mouseup();
      },
      slide: function slide(evt, ui) {
        changeOpacity(ui);
      }
    });
    editor.addDropDown('#blur_dropdown', $$c.noop);
    var slideStart = false;
    $$c('#blur_slider').slider({
      max: 10,
      step: 0.1,
      stop: function stop(evt, ui) {
        slideStart = false;
        changeBlur(ui);
        $$c('#blur_dropdown li').show();
        $$c(window).mouseup();
      },
      start: function start() {
        slideStart = true;
      },
      slide: function slide(evt, ui) {
        changeBlur(ui, null, slideStart);
      }
    });
    editor.addDropDown('#zoom_dropdown', function () {
      var item = $$c(this);
      var val = item.data('val');

      if (val) {
        zoomChanged(window, val);
      } else {
        changeZoom({
          value: Number.parseFloat(item.text())
        });
      }
    }, true);
    addAltDropDown('#stroke_linecap', '#linecap_opts', function () {
      setStrokeOpt(this, true);
    }, {
      dropUp: true
    });
    addAltDropDown('#stroke_linejoin', '#linejoin_opts', function () {
      setStrokeOpt(this, true);
    }, {
      dropUp: true
    });
    addAltDropDown('#tool_position', '#position_opts', function () {
      var letter = this.id.replace('tool_pos', '').charAt(0);
      svgCanvas.alignSelectedElements(letter, 'page');
    }, {
      multiclick: true
    });
    /*
     When a flyout icon is selected
      (if flyout) {
      - Change the icon
      - Make pressing the button run its stuff
      }
      - Run its stuff
     When its shortcut key is pressed
      - If not current in list, do as above
      , else:
      - Just run its stuff
     */
    // Unfocus text input when workarea is mousedowned.

    (function () {
      var inp;
      /**
      *
      * @returns {void}
      */

      var unfocus = function unfocus() {
        $$c(inp).blur();
      };

      $$c('#svg_editor').find('button, select, input:not(#text)').focus(function () {
        inp = this;
        uiContext = 'toolbars';
        workarea.mousedown(unfocus);
      }).blur(function () {
        uiContext = 'canvas';
        workarea.unbind('mousedown', unfocus); // Go back to selecting text if in textedit mode

        if (svgCanvas.getMode() === 'textedit') {
          $$c('#text').focus();
        }
      });
    })();
    /**
    *
    * @returns {void}
    */


    var clickFHPath = function clickFHPath() {
      if (toolButtonClick('#tool_fhpath')) {
        svgCanvas.setMode('fhpath');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickLine = function clickLine() {
      if (toolButtonClick('#tool_line')) {
        svgCanvas.setMode('line');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickSquare = function clickSquare() {
      if (toolButtonClick('#tool_square')) {
        svgCanvas.setMode('square');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickRect = function clickRect() {
      if (toolButtonClick('#tool_rect')) {
        svgCanvas.setMode('rect');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickFHRect = function clickFHRect() {
      if (toolButtonClick('#tool_fhrect')) {
        svgCanvas.setMode('fhrect');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickCircle = function clickCircle() {
      if (toolButtonClick('#tool_circle')) {
        svgCanvas.setMode('circle');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickEllipse = function clickEllipse() {
      if (toolButtonClick('#tool_ellipse')) {
        svgCanvas.setMode('ellipse');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickFHEllipse = function clickFHEllipse() {
      if (toolButtonClick('#tool_fhellipse')) {
        svgCanvas.setMode('fhellipse');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickImage = function clickImage() {
      if (toolButtonClick('#tool_image')) {
        svgCanvas.setMode('image');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickZoom = function clickZoom() {
      if (toolButtonClick('#tool_zoom')) {
        svgCanvas.setMode('zoom');
        workarea.css('cursor', zoomInIcon);
      }
    };
    /**
    * @param {Float} multiplier
    * @returns {void}
    */


    var zoomImage = function zoomImage(multiplier) {
      var res = svgCanvas.getResolution();
      multiplier = multiplier ? res.zoom * multiplier : 1; // setResolution(res.w * multiplier, res.h * multiplier, true);

      $$c('#zoom').val(multiplier * 100);
      svgCanvas.setZoom(multiplier);
      zoomDone();
      updateCanvas(true);
    };
    /**
    *
    * @returns {void}
    */


    var dblclickZoom = function dblclickZoom() {
      if (toolButtonClick('#tool_zoom')) {
        zoomImage();
        setSelectMode();
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickText = function clickText() {
      if (toolButtonClick('#tool_text')) {
        svgCanvas.setMode('text');
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickPath = function clickPath() {
      if (toolButtonClick('#tool_path')) {
        svgCanvas.setMode('path');
      }
    };
    /**
    * Delete is a contextual tool that only appears in the ribbon if
    * an element has been selected.
    * @returns {void}
    */


    var deleteSelected = function deleteSelected() {
      if (!isNullish(selectedElement) || multiselected) {
        svgCanvas.deleteSelectedElements();
      }
    };
    /**
    *
    * @returns {void}
    */


    var cutSelected = function cutSelected() {
      if (!isNullish(selectedElement) || multiselected) {
        svgCanvas.cutSelectedElements();
      }
    };
    /**
    *
    * @returns {void}
    */


    var copySelected = function copySelected() {
      if (!isNullish(selectedElement) || multiselected) {
        svgCanvas.copySelectedElements();
      }
    };
    /**
    *
    * @returns {void}
    */


    var pasteInCenter = function pasteInCenter() {
      var zoom = svgCanvas.getZoom();
      var x = (workarea[0].scrollLeft + workarea.width() / 2) / zoom - svgCanvas.contentW;
      var y = (workarea[0].scrollTop + workarea.height() / 2) / zoom - svgCanvas.contentH;
      svgCanvas.pasteElements('point', x, y);
    };
    /**
    *
    * @returns {void}
    */


    var moveToTopSelected = function moveToTopSelected() {
      if (!isNullish(selectedElement)) {
        svgCanvas.moveToTopSelectedElement();
      }
    };
    /**
    *
    * @returns {void}
    */


    var moveToBottomSelected = function moveToBottomSelected() {
      if (!isNullish(selectedElement)) {
        svgCanvas.moveToBottomSelectedElement();
      }
    };
    /**
    * @param {"Up"|"Down"} dir
    * @returns {void}
    */


    var moveUpDownSelected = function moveUpDownSelected(dir) {
      if (!isNullish(selectedElement)) {
        svgCanvas.moveUpDownSelected(dir);
      }
    };
    /**
    *
    * @returns {void}
    */


    var convertToPath = function convertToPath() {
      if (!isNullish(selectedElement)) {
        svgCanvas.convertToPath();
      }
    };
    /**
    *
    * @returns {void}
    */


    var reorientPath = function reorientPath() {
      if (!isNullish(selectedElement)) {
        path.reorient();
      }
    };
    /**
    *
    * @returns {Promise<void>} Resolves to `undefined`
    */


    var makeHyperlink = /*#__PURE__*/function () {
      var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var url;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!(!isNullish(selectedElement) || multiselected)) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 3;
                return $$c.prompt(uiStrings$1.notification.enterNewLinkURL, 'http://');

              case 3:
                url = _context8.sent;

                if (url) {
                  svgCanvas.makeHyperlink(url);
                }

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      return function makeHyperlink() {
        return _ref14.apply(this, arguments);
      };
    }();
    /**
    * @param {Float} dx
    * @param {Float} dy
    * @returns {void}
    */


    var moveSelected = function moveSelected(dx, dy) {
      if (!isNullish(selectedElement) || multiselected) {
        if (curConfig.gridSnapping) {
          // Use grid snap value regardless of zoom level
          var multi = svgCanvas.getZoom() * curConfig.snappingStep;
          dx *= multi;
          dy *= multi;
        }

        svgCanvas.moveSelectedElements(dx, dy);
      }
    };
    /**
    *
    * @returns {void}
    */


    var linkControlPoints = function linkControlPoints() {
      $$c('#tool_node_link').toggleClass('push_button_pressed tool_button');
      var linked = $$c('#tool_node_link').hasClass('push_button_pressed');
      path.linkControlPoints(linked);
    };
    /**
    *
    * @returns {void}
    */


    var clonePathNode = function clonePathNode() {
      if (path.getNodePoint()) {
        path.clonePathNode();
      }
    };
    /**
    *
    * @returns {void}
    */


    var deletePathNode = function deletePathNode() {
      if (path.getNodePoint()) {
        path.deletePathNode();
      }
    };
    /**
    *
    * @returns {void}
    */


    var addSubPath = function addSubPath() {
      var button = $$c('#tool_add_subpath');
      var sp = !button.hasClass('push_button_pressed');
      button.toggleClass('push_button_pressed tool_button');
      path.addSubPath(sp);
    };
    /**
    *
    * @returns {void}
    */


    var opencloseSubPath = function opencloseSubPath() {
      path.opencloseSubPath();
    };
    /**
    *
    * @returns {void}
    */


    var selectNext = function selectNext() {
      svgCanvas.cycleElement(1);
    };
    /**
    *
    * @returns {void}
    */


    var selectPrev = function selectPrev() {
      svgCanvas.cycleElement(0);
    };
    /**
    * @param {0|1} cw
    * @param {Integer} step
    * @returns {void}
    */


    var rotateSelected = function rotateSelected(cw, step) {
      if (isNullish(selectedElement) || multiselected) {
        return;
      }

      if (!cw) {
        step *= -1;
      }

      var angle = Number.parseFloat($$c('#angle').val()) + step;
      svgCanvas.setRotationAngle(angle);
      updateContextPanel();
    };
    /**
     * @fires module:svgcanvas.SvgCanvas#event:ext_onNewDocument
     * @returns {Promise<void>} Resolves to `undefined`
     */


    var clickClear = /*#__PURE__*/function () {
      var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _curConfig$dimensions, x, y, ok;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _curConfig$dimensions = _slicedToArray(curConfig.dimensions, 2), x = _curConfig$dimensions[0], y = _curConfig$dimensions[1];
                _context9.next = 3;
                return $$c.confirm(uiStrings$1.notification.QwantToClear);

              case 3:
                ok = _context9.sent;

                if (ok) {
                  _context9.next = 6;
                  break;
                }

                return _context9.abrupt("return");

              case 6:
                setSelectMode();
                svgCanvas.clear();
                svgCanvas.setResolution(x, y);
                updateCanvas(true);
                zoomImage();
                populateLayers();
                updateContextPanel();
                prepPaints();
                svgCanvas.runExtensions('onNewDocument');

              case 15:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function clickClear() {
        return _ref15.apply(this, arguments);
      };
    }();
    /**
    *
    * @returns {false}
    */


    var clickBold = function clickBold() {
      svgCanvas.setBold(!svgCanvas.getBold());
      updateContextPanel();
      return false;
    };
    /**
    *
    * @returns {false}
    */


    var clickItalic = function clickItalic() {
      svgCanvas.setItalic(!svgCanvas.getItalic());
      updateContextPanel();
      return false;
    };
    /**
    *
    * @returns {void}
    */


    var clickSave = function clickSave() {
      // In the future, more options can be provided here
      var saveOpts = {
        images: editor.pref('img_save'),
        round_digits: 6
      };
      svgCanvas.save(saveOpts);
    };

    var loadingURL;
    /**
    *
    * @returns {Promise<void>} Resolves to `undefined`
    */

    var clickExport = /*#__PURE__*/function () {
      var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var imgType, exportWindowName, openExportWindow, chrome, quality;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                openExportWindow = function _openExportWindow() {
                  var loadingImage = uiStrings$1.notification.loadingImage;

                  if (curConfig.exportWindowType === 'new') {
                    editor.exportWindowCt++;
                  }

                  exportWindowName = curConfig.canvasName + editor.exportWindowCt;
                  var popHTML, popURL;

                  if (loadingURL) {
                    popURL = loadingURL;
                  } else {
                    popHTML = "<!DOCTYPE html><html>\n          <head>\n            <meta charset=\"utf-8\">\n            <title>".concat(loadingImage, "</title>\n          </head>\n          <body><h1>").concat(loadingImage, "</h1></body>\n        <html>");

                    if (typeof URL !== 'undefined' && URL.createObjectURL) {
                      var blob = new Blob([popHTML], {
                        type: 'text/html'
                      });
                      popURL = URL.createObjectURL(blob);
                    } else {
                      popURL = 'data:text/html;base64;charset=utf-8,' + encode64(popHTML);
                    }

                    loadingURL = popURL;
                  }

                  exportWindow = window.open(popURL, exportWindowName);
                };

                _context10.next = 3;
                return $$c.select('Select an image type for export: ', [// See http://kangax.github.io/jstests/toDataUrl_mime_type_test/ for a useful list of MIME types and browser support
                // 'ICO', // Todo: Find a way to preserve transparency in SVG-Edit if not working presently and do full packaging for x-icon; then switch back to position after 'PNG'
                'PNG', 'JPEG', 'BMP', 'WEBP', 'PDF'], function () {
                  var sel = $$c(this);

                  if (sel.val() === 'JPEG' || sel.val() === 'WEBP') {
                    if (!$$c('#image-slider').length) {
                      $$c("<div><label>".concat(uiStrings$1.ui.quality, "\n              <input id=\"image-slider\"\n                type=\"range\" min=\"1\" max=\"100\" value=\"92\" />\n            </label></div>")).appendTo(sel.parent());
                    }
                  } else {
                    $$c('#image-slider').parent().remove();
                  }
                });

              case 3:
                imgType = _context10.sent;

                if (imgType) {
                  _context10.next = 6;
                  break;
                }

                return _context10.abrupt("return");

              case 6:
                chrome = isChrome();

                if (!(imgType === 'PDF')) {
                  _context10.next = 12;
                  break;
                }

                if (!customExportPDF && !chrome) {
                  openExportWindow();
                }

                svgCanvas.exportPDF(exportWindowName);
                _context10.next = 16;
                break;

              case 12:
                if (!customExportImage) {
                  openExportWindow();
                }

                quality = Number.parseInt($$c('#image-slider').val()) / 100;
                /* const results = */

                _context10.next = 16;
                return svgCanvas.rasterExport(imgType, quality, exportWindowName);

              case 16:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));

      return function clickExport() {
        return _ref16.apply(this, arguments);
      };
    }();
    /**
     * By default, svgCanvas.open() is a no-op. It is up to an extension
     *  mechanism (opera widget, etc.) to call `setCustomHandlers()` which
     *  will make it do something.
     * @returns {void}
     */


    var clickOpen = function clickOpen() {
      svgCanvas.open();
    };
    /**
    *
    * @returns {void}
    */


    var clickImport = function clickImport() {
      /* */
    };
    /**
    *
    * @returns {void}
    */


    var clickUndo = function clickUndo() {
      if (undoMgr.getUndoStackSize() > 0) {
        undoMgr.undo();
        populateLayers();
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickRedo = function clickRedo() {
      if (undoMgr.getRedoStackSize() > 0) {
        undoMgr.redo();
        populateLayers();
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickGroup = function clickGroup() {
      // group
      if (multiselected) {
        svgCanvas.groupSelectedElements(); // ungroup
      } else if (selectedElement) {
        svgCanvas.ungroupSelectedElement();
      }
    };
    /**
    *
    * @returns {void}
    */


    var clickClone = function clickClone() {
      svgCanvas.cloneSelectedElements(20, 20);
    };
    /**
    *
    * @returns {void}
    */


    var clickAlign = function clickAlign() {
      var letter = this.id.replace('tool_align', '').charAt(0);
      svgCanvas.alignSelectedElements(letter, $$c('#align_relative_to').val());
    };
    /**
    *
    * @returns {void}
    */


    var clickWireframe = function clickWireframe() {
      $$c('#tool_wireframe').toggleClass('push_button_pressed tool_button');
      workarea.toggleClass('wireframe');

      if (supportsNonSS) {
        return;
      }

      var wfRules = $$c('#wireframe_rules');

      if (!wfRules.length) {
        /* wfRules = */
        $$c('<style id="wireframe_rules"></style>').appendTo('head');
      } else {
        wfRules.empty();
      }

      updateWireFrame();
    };

    $$c('#svg_docprops_container, #svg_prefs_container').draggable({
      cancel: 'button,fieldset',
      containment: 'window'
    }).css('position', 'absolute');
    var docprops = false;
    var preferences = false;
    /**
    *
    * @returns {void}
    */

    var showDocProperties = function showDocProperties() {
      if (docprops) {
        return;
      }

      docprops = true; // This selects the correct radio button by using the array notation

      $$c('#image_save_opts input').val([editor.pref('img_save')]); // update resolution option with actual resolution

      var res = svgCanvas.getResolution();

      if (curConfig.baseUnit !== 'px') {
        res.w = convertUnit(res.w) + curConfig.baseUnit;
        res.h = convertUnit(res.h) + curConfig.baseUnit;
      }

      $$c('#canvas_width').val(res.w);
      $$c('#canvas_height').val(res.h);
      $$c('#canvas_title').val(svgCanvas.getDocumentTitle());
      $$c('#svg_docprops').show();
    };
    /**
    *
    * @returns {void}
    */


    var showPreferences = function showPreferences() {
      if (preferences) {
        return;
      }

      preferences = true;
      $$c('#main_menu').hide(); // Update background color with current one

      var canvasBg = curPrefs.bkgd_color;
      var url = editor.pref('bkgd_url');
      blocks.each(function () {
        var blk = $$c(this);
        var isBg = blk.data('bgcolor') === canvasBg;
        blk.toggleClass(curBg, isBg);
      });

      if (!canvasBg) {
        blocks.eq(0).addClass(curBg);
      }

      if (url) {
        $$c('#canvas_bg_url').val(url);
      }

      $$c('#grid_snapping_on').prop('checked', curConfig.gridSnapping);
      $$c('#grid_snapping_step').attr('value', curConfig.snappingStep);
      $$c('#grid_color').attr('value', curConfig.gridColor);
      $$c('#svg_prefs').show();
    };
    /**
    *
    * @returns {void}
    */


    var openHomePage = function openHomePage() {
      window.open(homePage, '_blank');
    };
    /**
    *
    * @returns {void}
    */


    var hideSourceEditor = function hideSourceEditor() {
      $$c('#svg_source_editor').hide();
      editingsource = false;
      $$c('#svg_source_textarea').blur();
    };
    /**
    *
    * @returns {Promise<void>} Resolves to `undefined`
    */


    var saveSourceEditor = /*#__PURE__*/function () {
      var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var saveChanges, ok;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (editingsource) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return");

              case 2:
                saveChanges = function saveChanges() {
                  svgCanvas.clearSelection();
                  hideSourceEditor();
                  zoomImage();
                  populateLayers();
                  updateTitle();
                  prepPaints();
                };

                if (svgCanvas.setSvgString($$c('#svg_source_textarea').val())) {
                  _context11.next = 11;
                  break;
                }

                _context11.next = 6;
                return $$c.confirm(uiStrings$1.notification.QerrorsRevertToSource);

              case 6:
                ok = _context11.sent;

                if (ok) {
                  _context11.next = 9;
                  break;
                }

                return _context11.abrupt("return");

              case 9:
                saveChanges();
                return _context11.abrupt("return");

              case 11:
                saveChanges();
                setSelectMode();

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));

      return function saveSourceEditor() {
        return _ref17.apply(this, arguments);
      };
    }();
    /**
    *
    * @returns {void}
    */


    var hideDocProperties = function hideDocProperties() {
      $$c('#svg_docprops').hide();
      $$c('#canvas_width,#canvas_height').removeAttr('disabled');
      $$c('#resolution')[0].selectedIndex = 0;
      $$c('#image_save_opts input').val([editor.pref('img_save')]);
      docprops = false;
    };
    /**
    *
    * @returns {void}
    */


    var hidePreferences = function hidePreferences() {
      $$c('#svg_prefs').hide();
      preferences = false;
    };
    /**
    *
    * @returns {boolean} Whether there were problems saving the document properties
    */


    var saveDocProperties = function saveDocProperties() {
      // set title
      var newTitle = $$c('#canvas_title').val();
      updateTitle(newTitle);
      svgCanvas.setDocumentTitle(newTitle); // update resolution

      var width = $$c('#canvas_width'),
          w = width.val();
      var height = $$c('#canvas_height'),
          h = height.val();

      if (w !== 'fit' && !isValidUnit('width', w)) {
        width.parent().addClass('error');
        /* await */

        $$c.alert(uiStrings$1.notification.invalidAttrValGiven);
        return false;
      }

      width.parent().removeClass('error');

      if (h !== 'fit' && !isValidUnit('height', h)) {
        height.parent().addClass('error');
        /* await */

        $$c.alert(uiStrings$1.notification.invalidAttrValGiven);
        return false;
      }

      height.parent().removeClass('error');

      if (!svgCanvas.setResolution(w, h)) {
        /* await */
        $$c.alert(uiStrings$1.notification.noContentToFitTo);
        return false;
      } // Set image save option


      editor.pref('img_save', $$c('#image_save_opts :checked').val());
      updateCanvas();
      hideDocProperties();
      return true;
    };
    /**
    * Save user preferences based on current values in the UI.
    * @function module:SVGEditor.savePreferences
    * @returns {Promise<void>}
    */


    var savePreferences = editor.savePreferences = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
      var color, lang, _yield$editor$putLoca2, langParam, langData;

      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              // Set background
              color = $$c('#bg_blocks div.cur_background').data('bgcolor') || '#FFF';
              setBackground(color, $$c('#canvas_bg_url').val()); // set language

              lang = $$c('#lang_select').val();

              if (!(lang && lang !== editor.pref('lang'))) {
                _context12.next = 11;
                break;
              }

              _context12.next = 6;
              return editor.putLocale(lang, goodLangs, curConfig);

            case 6:
              _yield$editor$putLoca2 = _context12.sent;
              langParam = _yield$editor$putLoca2.langParam;
              langData = _yield$editor$putLoca2.langData;
              _context12.next = 11;
              return setLang(langParam, langData);

            case 11:
              // set icon size
              setIconSize($$c('#iconsize').val()); // set grid setting

              curConfig.gridSnapping = $$c('#grid_snapping_on')[0].checked;
              curConfig.snappingStep = $$c('#grid_snapping_step').val();
              curConfig.gridColor = $$c('#grid_color').val();
              curConfig.showRulers = $$c('#show_rulers')[0].checked;
              $$c('#rulers').toggle(curConfig.showRulers);

              if (curConfig.showRulers) {
                updateRulers();
              }

              curConfig.baseUnit = $$c('#base_unit').val();
              svgCanvas.setConfig(curConfig);
              updateCanvas();
              hidePreferences();

            case 22:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    var resetScrollPos = $$c.noop;
    /**
    *
    * @returns {Promise<void>} Resolves to `undefined`
    */

    var cancelOverlays = /*#__PURE__*/function () {
      var _ref19 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var ok;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                $$c('#dialog_box').hide();

                if (!(!editingsource && !docprops && !preferences)) {
                  _context13.next = 4;
                  break;
                }

                if (curContext) {
                  svgCanvas.leaveContext();
                }

                return _context13.abrupt("return");

              case 4:
                if (!editingsource) {
                  _context13.next = 15;
                  break;
                }

                if (!(origSource !== $$c('#svg_source_textarea').val())) {
                  _context13.next = 12;
                  break;
                }

                _context13.next = 8;
                return $$c.confirm(uiStrings$1.notification.QignoreSourceChanges);

              case 8:
                ok = _context13.sent;

                if (ok) {
                  hideSourceEditor();
                }

                _context13.next = 13;
                break;

              case 12:
                hideSourceEditor();

              case 13:
                _context13.next = 16;
                break;

              case 15:
                if (docprops) {
                  hideDocProperties();
                } else if (preferences) {
                  hidePreferences();
                }

              case 16:
                resetScrollPos();

              case 17:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));

      return function cancelOverlays() {
        return _ref19.apply(this, arguments);
      };
    }();

    var winWh = {
      width: $$c(window).width(),
      height: $$c(window).height()
    }; // Fix for Issue 781: Drawing area jumps to top-left corner on window resize (IE9)

    if (isIE()) {
      resetScrollPos = function resetScrollPos() {
        if (workarea[0].scrollLeft === 0 && workarea[0].scrollTop === 0) {
          workarea[0].scrollLeft = curScrollPos.left;
          workarea[0].scrollTop = curScrollPos.top;
        }
      };

      curScrollPos = {
        left: workarea[0].scrollLeft,
        top: workarea[0].scrollTop
      };
      $$c(window).resize(resetScrollPos);
      editor.ready(function () {
        // TODO: Find better way to detect when to do this to minimize
        // flickering effect
        return new Promise(function (resolve, reject) {
          // eslint-disable-line promise/avoid-new
          setTimeout(function () {
            resetScrollPos();
            resolve();
          }, 500);
        });
      });
      workarea.scroll(function () {
        curScrollPos = {
          left: workarea[0].scrollLeft,
          top: workarea[0].scrollTop
        };
      });
    }

    $$c(window).resize(function (evt) {
      $$c.each(winWh, function (type, val) {
        var curval = $$c(window)[type]();
        workarea[0]['scroll' + (type === 'width' ? 'Left' : 'Top')] -= (curval - val) / 2;
        winWh[type] = curval;
      });
      setFlyoutPositions();
    });
    workarea.scroll(function () {
      // TODO: jQuery's scrollLeft/Top() wouldn't require a null check
      if ($$c('#ruler_x').length) {
        $$c('#ruler_x')[0].scrollLeft = workarea[0].scrollLeft;
      }

      if ($$c('#ruler_y').length) {
        $$c('#ruler_y')[0].scrollTop = workarea[0].scrollTop;
      }
    });
    $$c('#url_notice').click(function () {
      /* await */
      $$c.alert(this.title);
    });
    $$c('#change_image_url').click(promptImgURL); // added these event handlers for all the push buttons so they
    // behave more like buttons being pressed-in and not images

    (function () {
      var toolnames = ['clear', 'open', 'save', 'source', 'delete', 'delete_multi', 'paste', 'clone', 'clone_multi', 'move_top', 'move_bottom'];
      var curClass = 'tool_button_current';
      var allTools = '';
      $$c.each(toolnames, function (i, item) {
        allTools += (i ? ',' : '') + '#tool_' + item;
      });
      $$c(allTools).mousedown(function () {
        $$c(this).addClass(curClass);
      }).bind('mousedown mouseout', function () {
        $$c(this).removeClass(curClass);
      });
      $$c('#tool_undo, #tool_redo').mousedown(function () {
        if (!$$c(this).hasClass('disabled')) {
          $$c(this).addClass(curClass);
        }
      }).bind('mousedown mouseout', function () {
        $$c(this).removeClass(curClass);
      });
    })(); // switch modifier key in tooltips if mac
    // NOTE: This code is not used yet until I can figure out how to successfully bind ctrl/meta
    // in Opera and Chrome


    if (isMac() && !window.opera) {
      var shortcutButtons = ['tool_clear', 'tool_save', 'tool_source', 'tool_undo', 'tool_redo', 'tool_clone'];
      var _i = shortcutButtons.length;

      while (_i--) {
        var button = document.getElementById(shortcutButtons[_i]);

        if (button) {
          var title = button.title;
          var index = title.indexOf('Ctrl+');
          button.title = [title.substr(0, index), 'Cmd+', title.substr(index + 5)].join('');
        }
      }
    }
    /**
    * @param {external:jQuery} elem
    * @todo Go back to the color boxes having white background-color and then setting
    *  background-image to none.png (otherwise partially transparent gradients look weird)
    * @returns {void}
    */


    var colorPicker = function colorPicker(elem) {
      var picker = elem.attr('id') === 'stroke_color' ? 'stroke' : 'fill'; // const opacity = (picker == 'stroke' ? $('#stroke_opacity') : $('#fill_opacity'));

      var title = picker === 'stroke' ? uiStrings$1.ui.pick_stroke_paint_opacity : uiStrings$1.ui.pick_fill_paint_opacity; // let wasNone = false; // Currently unused

      var pos = elem.offset();
      var paint = paintBox[picker].paint;
      $$c('#color_picker').draggable({
        cancel: '.jGraduate_tabs, .jGraduate_colPick, .jGraduate_gradPick, .jPicker',
        containment: 'window'
      }).css(curConfig.colorPickerCSS || {
        left: pos.left - 140,
        bottom: 40
      }).jGraduate({
        paint: paint,
        window: {
          pickerTitle: title
        },
        images: {
          clientPath: curConfig.jGraduatePath
        },
        newstop: 'inverse'
      }, function (p) {
        paint = new $$c.jGraduate.Paint(p);
        paintBox[picker].setPaint(paint);
        svgCanvas.setPaint(picker, paint);
        $$c('#color_picker').hide();
      }, function () {
        $$c('#color_picker').hide();
      });
    };
    /**
     * Paint box class.
     */


    var PaintBox = /*#__PURE__*/function () {
      /**
       * @param {string|Element|external:jQuery} container
       * @param {"fill"} type
       */
      function PaintBox(container, type) {
        _classCallCheck(this, PaintBox);

        var cur = curConfig[type === 'fill' ? 'initFill' : 'initStroke']; // set up gradients to be used for the buttons

        var svgdocbox = new DOMParser().parseFromString("<svg xmlns=\"http://www.w3.org/2000/svg\">\n          <rect width=\"16.5\" height=\"16.5\"\n            fill=\"#".concat(cur.color, "\" opacity=\"").concat(cur.opacity, "\"/>\n          <defs><linearGradient id=\"gradbox_").concat(PaintBox.ctr++, "\"/></defs>\n        </svg>"), 'text/xml');
        var docElem = svgdocbox.documentElement;
        docElem = $$c(container)[0].appendChild(document.importNode(docElem, true));
        docElem.setAttribute('width', 16.5);
        this.rect = docElem.firstElementChild;
        this.defs = docElem.getElementsByTagName('defs')[0];
        this.grad = this.defs.firstElementChild;
        this.paint = new $$c.jGraduate.Paint({
          solidColor: cur.color
        });
        this.type = type;
      }
      /**
       * @param {module:jGraduate~Paint} paint
       * @param {boolean} apply
       * @returns {void}
       */


      _createClass(PaintBox, [{
        key: "setPaint",
        value: function setPaint(paint, apply) {
          this.paint = paint;
          var ptype = paint.type;
          var opac = paint.alpha / 100;
          var fillAttr = 'none';

          switch (ptype) {
            case 'solidColor':
              fillAttr = paint[ptype] !== 'none' ? '#' + paint[ptype] : paint[ptype];
              break;

            case 'linearGradient':
            case 'radialGradient':
              {
                this.grad.remove();
                this.grad = this.defs.appendChild(paint[ptype]);
                var id = this.grad.id = 'gradbox_' + this.type;
                fillAttr = 'url(#' + id + ')';
                break;
              }
          }

          this.rect.setAttribute('fill', fillAttr);
          this.rect.setAttribute('opacity', opac);

          if (apply) {
            svgCanvas.setColor(this.type, this._paintColor, true);
            svgCanvas.setPaintOpacity(this.type, this._paintOpacity, true);
          }
        }
        /**
         * @param {boolean} apply
         * @returns {void}
         */

      }, {
        key: "update",
        value: function update(apply) {
          if (!selectedElement) {
            return;
          }

          var type = this.type;

          switch (selectedElement.tagName) {
            case 'use':
            case 'image':
            case 'foreignObject':
              // These elements don't have fill or stroke, so don't change
              // the current value
              return;

            case 'g':
            case 'a':
              {
                var childs = selectedElement.getElementsByTagName('*');
                var gPaint = null;

                for (var _i2 = 0, len = childs.length; _i2 < len; _i2++) {
                  var elem = childs[_i2];
                  var p = elem.getAttribute(type);

                  if (_i2 === 0) {
                    gPaint = p;
                  } else if (gPaint !== p) {
                    gPaint = null;
                    break;
                  }
                }

                if (gPaint === null) {
                  // No common color, don't update anything
                  this._paintColor = null;
                  return;
                }

                this._paintColor = gPaint;
                this._paintOpacity = 1;
                break;
              }

            default:
              {
                this._paintOpacity = Number.parseFloat(selectedElement.getAttribute(type + '-opacity'));

                if (Number.isNaN(this._paintOpacity)) {
                  this._paintOpacity = 1.0;
                }

                var defColor = type === 'fill' ? 'black' : 'none';
                this._paintColor = selectedElement.getAttribute(type) || defColor;
              }
          }

          if (apply) {
            svgCanvas.setColor(type, this._paintColor, true);
            svgCanvas.setPaintOpacity(type, this._paintOpacity, true);
          }

          this._paintOpacity *= 100;
          var paint = getPaint(this._paintColor, this._paintOpacity, type); // update the rect inside #fill_color/#stroke_color

          this.setPaint(paint);
        }
        /**
         * @returns {void}
         */

      }, {
        key: "prep",
        value: function prep() {
          var ptype = this.paint.type;

          switch (ptype) {
            case 'linearGradient':
            case 'radialGradient':
              {
                var paint = new $$c.jGraduate.Paint({
                  copy: this.paint
                });
                svgCanvas.setPaint(this.type, paint);
                break;
              }
          }
        }
      }]);

      return PaintBox;
    }();

    PaintBox.ctr = 0;
    paintBox.fill = new PaintBox('#fill_color', 'fill');
    paintBox.stroke = new PaintBox('#stroke_color', 'stroke');
    $$c('#stroke_width').val(curConfig.initStroke.width);
    $$c('#group_opacity').val(curConfig.initOpacity * 100); // Use this SVG elem to test vectorEffect support

    var testEl = paintBox.fill.rect.cloneNode(false);
    testEl.setAttribute('style', 'vector-effect:non-scaling-stroke');
    var supportsNonSS = testEl.style.vectorEffect === 'non-scaling-stroke';
    testEl.removeAttribute('style');
    var svgdocbox = paintBox.fill.rect.ownerDocument; // Use this to test support for blur element. Seems to work to test support in Webkit

    var blurTest = svgdocbox.createElementNS(NS.SVG, 'feGaussianBlur');

    if (blurTest.stdDeviationX === undefined) {
      $$c('#tool_blur').hide();
    }

    $$c(blurTest).remove(); // Test for zoom icon support

    (function () {
      var pre = '-' + uaPrefix.toLowerCase() + '-zoom-';
      var zoom = pre + 'in';
      workarea.css('cursor', zoom);

      if (workarea.css('cursor') === zoom) {
        zoomInIcon = zoom;
        zoomOutIcon = pre + 'out';
      }

      workarea.css('cursor', 'auto');
    })(); // Test for embedImage support (use timeout to not interfere with page load)


    setTimeout(function () {
      svgCanvas.embedImage('images/logo.png', function (datauri) {
        if (!datauri) {
          // Disable option
          $$c('#image_save_opts [value=embed]').attr('disabled', 'disabled');
          $$c('#image_save_opts input').val(['ref']);
          editor.pref('img_save', 'ref');
          $$c('#image_opt_embed').css('color', '#666').attr('title', uiStrings$1.notification.featNotSupported);
        }
      });
    }, 1000);
    $$c('#fill_color, #tool_fill .icon_label').click(function () {
      colorPicker($$c('#fill_color'));
      updateToolButtonState();
    });
    $$c('#stroke_color, #tool_stroke .icon_label').click(function () {
      colorPicker($$c('#stroke_color'));
      updateToolButtonState();
    });
    $$c('#group_opacityLabel').click(function () {
      $$c('#opacity_dropdown button').mousedown();
      $$c(window).mouseup();
    });
    $$c('#zoomLabel').click(function () {
      $$c('#zoom_dropdown button').mousedown();
      $$c(window).mouseup();
    });
    $$c('#tool_move_top').mousedown(function (evt) {
      $$c('#tools_stacking').show();
      evt.preventDefault();
    });
    $$c('.layer_button').mousedown(function () {
      $$c(this).addClass('layer_buttonpressed');
    }).mouseout(function () {
      $$c(this).removeClass('layer_buttonpressed');
    }).mouseup(function () {
      $$c(this).removeClass('layer_buttonpressed');
    });
    $$c('.push_button').mousedown(function () {
      if (!$$c(this).hasClass('disabled')) {
        $$c(this).addClass('push_button_pressed').removeClass('push_button');
      }
    }).mouseout(function () {
      $$c(this).removeClass('push_button_pressed').addClass('push_button');
    }).mouseup(function () {
      $$c(this).removeClass('push_button_pressed').addClass('push_button');
    }); // ask for a layer name

    $$c('#layer_new').click( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
      var uniqName, i, newName;
      return regeneratorRuntime.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              i = svgCanvas.getCurrentDrawing().getNumLayers();

              do {
                uniqName = uiStrings$1.layers.layer + ' ' + ++i;
              } while (svgCanvas.getCurrentDrawing().hasLayer(uniqName));

              _context14.next = 4;
              return $$c.prompt(uiStrings$1.notification.enterUniqueLayerName, uniqName);

            case 4:
              newName = _context14.sent;

              if (newName) {
                _context14.next = 7;
                break;
              }

              return _context14.abrupt("return");

            case 7:
              if (!svgCanvas.getCurrentDrawing().hasLayer(newName)) {
                _context14.next = 10;
                break;
              }

              /* await */
              $$c.alert(uiStrings$1.notification.dupeLayerName);
              return _context14.abrupt("return");

            case 10:
              svgCanvas.createLayer(newName);
              updateContextPanel();
              populateLayers();

            case 13:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    })));
    /**
     *
     * @returns {void}
     */

    function deleteLayer() {
      if (svgCanvas.deleteCurrentLayer()) {
        updateContextPanel();
        populateLayers(); // This matches what SvgCanvas does
        // TODO: make this behavior less brittle (svg-editor should get which
        // layer is selected from the canvas and then select that one in the UI)

        $$c('#layerlist tr.layer').removeClass('layersel');
        $$c('#layerlist tr.layer:first').addClass('layersel');
      }
    }
    /**
     *
     * @returns {Promise<void>}
     */


    function cloneLayer() {
      return _cloneLayer.apply(this, arguments);
    }
    /**
     *
     * @returns {void}
     */


    function _cloneLayer() {
      _cloneLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
        var name, newName;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                name = svgCanvas.getCurrentDrawing().getCurrentLayerName() + ' copy';
                _context20.next = 3;
                return $$c.prompt(uiStrings$1.notification.enterUniqueLayerName, name);

              case 3:
                newName = _context20.sent;

                if (newName) {
                  _context20.next = 6;
                  break;
                }

                return _context20.abrupt("return");

              case 6:
                if (!svgCanvas.getCurrentDrawing().hasLayer(newName)) {
                  _context20.next = 9;
                  break;
                }

                /* await */
                $$c.alert(uiStrings$1.notification.dupeLayerName);
                return _context20.abrupt("return");

              case 9:
                svgCanvas.cloneLayer(newName);
                updateContextPanel();
                populateLayers();

              case 12:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20);
      }));
      return _cloneLayer.apply(this, arguments);
    }

    function mergeLayer() {
      if ($$c('#layerlist tr.layersel').index() === svgCanvas.getCurrentDrawing().getNumLayers() - 1) {
        return;
      }

      svgCanvas.mergeLayer();
      updateContextPanel();
      populateLayers();
    }
    /**
     * @param {Integer} pos
     * @returns {void}
     */


    function moveLayer(pos) {
      var total = svgCanvas.getCurrentDrawing().getNumLayers();
      var curIndex = $$c('#layerlist tr.layersel').index();

      if (curIndex > 0 || curIndex < total - 1) {
        curIndex += pos;
        svgCanvas.setCurrentLayerPosition(total - curIndex - 1);
        populateLayers();
      }
    }

    $$c('#layer_delete').click(deleteLayer);
    $$c('#layer_up').click(function () {
      moveLayer(-1);
    });
    $$c('#layer_down').click(function () {
      moveLayer(1);
    });
    $$c('#layer_rename').click( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
      var oldName, newName;
      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              // const curIndex = $('#layerlist tr.layersel').prevAll().length; // Currently unused
              oldName = $$c('#layerlist tr.layersel td.layername').text();
              _context15.next = 3;
              return $$c.prompt(uiStrings$1.notification.enterNewLayerName, '');

            case 3:
              newName = _context15.sent;

              if (newName) {
                _context15.next = 6;
                break;
              }

              return _context15.abrupt("return");

            case 6:
              if (!(oldName === newName || svgCanvas.getCurrentDrawing().hasLayer(newName))) {
                _context15.next = 9;
                break;
              }

              /* await */
              $$c.alert(uiStrings$1.notification.layerHasThatName);
              return _context15.abrupt("return");

            case 9:
              svgCanvas.renameCurrentLayer(newName);
              populateLayers();

            case 11:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    })));
    var SIDEPANEL_MAXWIDTH = 300;
    var SIDEPANEL_OPENWIDTH = 150;
    var sidedrag = -1,
        sidedragging = false,
        allowmove = false;
    /**
     * @param {Float} delta
     * @fires module:svgcanvas.SvgCanvas#event:ext_workareaResized
     * @returns {void}
     */

    var changeSidePanelWidth = function changeSidePanelWidth(delta) {
      var rulerX = $$c('#ruler_x');
      $$c('#sidepanels').width('+=' + delta);
      $$c('#layerpanel').width('+=' + delta);
      rulerX.css('right', Number.parseInt(rulerX.css('right')) + delta);
      workarea.css('right', Number.parseInt(workarea.css('right')) + delta);
      svgCanvas.runExtensions('workareaResized');
    };
    /**
    * @param {Event} evt
    * @returns {void}
    */


    var resizeSidePanel = function resizeSidePanel(evt) {
      if (!allowmove) {
        return;
      }

      if (sidedrag === -1) {
        return;
      }

      sidedragging = true;
      var deltaX = sidedrag - evt.pageX;
      var sideWidth = $$c('#sidepanels').width();

      if (sideWidth + deltaX > SIDEPANEL_MAXWIDTH) {
        deltaX = SIDEPANEL_MAXWIDTH - sideWidth; // sideWidth = SIDEPANEL_MAXWIDTH;
      } else if (sideWidth + deltaX < 2) {
        deltaX = 2 - sideWidth; // sideWidth = 2;
      }

      if (deltaX === 0) {
        return;
      }

      sidedrag -= deltaX;
      changeSidePanelWidth(deltaX);
    };
    /**
     * If width is non-zero, then fully close it; otherwise fully open it.
     * @param {boolean} close Forces the side panel closed
     * @returns {void}
     */


    var toggleSidePanel = function toggleSidePanel(close) {
      var dpr = window.devicePixelRatio || 1;
      var w = $$c('#sidepanels').width();
      var isOpened = (dpr < 1 ? w : w / dpr) > 2;
      var zoomAdjustedSidepanelWidth = (dpr < 1 ? 1 : dpr) * SIDEPANEL_OPENWIDTH;
      var deltaX = (isOpened || close ? 0 : zoomAdjustedSidepanelWidth) - w;
      changeSidePanelWidth(deltaX);
    };

    $$c('#sidepanel_handle').mousedown(function (evt) {
      sidedrag = evt.pageX;
      $$c(window).mousemove(resizeSidePanel);
      allowmove = false; // Silly hack for Chrome, which always runs mousemove right after mousedown

      setTimeout(function () {
        allowmove = true;
      }, 20);
    }).mouseup(function (evt) {
      if (!sidedragging) {
        toggleSidePanel();
      }

      sidedrag = -1;
      sidedragging = false;
    });
    $$c(window).mouseup(function () {
      sidedrag = -1;
      sidedragging = false;
      $$c('#svg_editor').unbind('mousemove', resizeSidePanel);
    });
    populateLayers(); // function changeResolution (x,y) {
    //   const {zoom} = svgCanvas.getResolution();
    //   setResolution(x * zoom, y * zoom);
    // }

    var centerCanvas = function centerCanvas() {
      // this centers the canvas vertically in the workarea (horizontal handled in CSS)
      workarea.css('line-height', workarea.height() + 'px');
    };

    $$c(window).bind('load resize', centerCanvas);
    /**
     * @type {module:jQuerySpinButton.StepCallback}
     */

    function stepFontSize(elem, step) {
      var origVal = Number(elem.value);
      var sugVal = origVal + step;
      var increasing = sugVal >= origVal;

      if (step === 0) {
        return origVal;
      }

      if (origVal >= 24) {
        if (increasing) {
          return Math.round(origVal * 1.1);
        }

        return Math.round(origVal / 1.1);
      }

      if (origVal <= 1) {
        if (increasing) {
          return origVal * 2;
        }

        return origVal / 2;
      }

      return sugVal;
    }
    /**
     * @type {module:jQuerySpinButton.StepCallback}
     */


    function stepZoom(elem, step) {
      var origVal = Number(elem.value);

      if (origVal === 0) {
        return 100;
      }

      var sugVal = origVal + step;

      if (step === 0) {
        return origVal;
      }

      if (origVal >= 100) {
        return sugVal;
      }

      if (sugVal >= origVal) {
        return origVal * 2;
      }

      return origVal / 2;
    } // function setResolution (w, h, center) {
    //   updateCanvas();
    //   // w -= 0; h -= 0;
    //   // $('#svgcanvas').css({width: w, height: h});
    //   // $('#canvas_width').val(w);
    //   // $('#canvas_height').val(h);
    //   //
    //   // if (center) {
    //   //   const wArea = workarea;
    //   //   const scrollY = h/2 - wArea.height()/2;
    //   //   const scrollX = w/2 - wArea.width()/2;
    //   //   wArea[0].scrollTop = scrollY;
    //   //   wArea[0].scrollLeft = scrollX;
    //   // }
    // }


    $$c('#resolution').change(function () {
      var wh = $$c('#canvas_width,#canvas_height');

      if (!this.selectedIndex) {
        if ($$c('#canvas_width').val() === 'fit') {
          wh.removeAttr('disabled').val(100);
        }
      } else if (this.value === 'content') {
        wh.val('fit').attr('disabled', 'disabled');
      } else {
        var dims = this.value.split('x');
        $$c('#canvas_width').val(dims[0]);
        $$c('#canvas_height').val(dims[1]);
        wh.removeAttr('disabled');
      }
    }); // Prevent browser from erroneously repopulating fields

    $$c('input,select').attr('autocomplete', 'off');
    var dialogSelectors = ['#tool_source_cancel', '#tool_docprops_cancel', '#tool_prefs_cancel', '.overlay'];
    /* eslint-disable jsdoc/require-property */

    /**
     * Associate all button actions as well as non-button keyboard shortcuts.
     * @namespace {PlainObject} module:SVGEditor~Actions
     */

    var Actions = function () {
      /* eslint-enable jsdoc/require-property */

      /**
      * @typedef {PlainObject} module:SVGEditor.ToolButton
      * @property {string} sel The CSS selector for the tool
      * @property {external:jQuery.Function} fn A handler to be attached to the `evt`
      * @property {string} evt The event for which the `fn` listener will be added
      * @property {module:SVGEditor.Key} [key] [key, preventDefault, NoDisableInInput]
      * @property {string} [parent] Selector
      * @property {boolean} [hidekey] Whether to show key value in title
      * @property {string} [icon] The button ID
      * @property {boolean} isDefault For flyout holders
      */

      /**
       *
       * @name module:SVGEditor~ToolButtons
       * @type {module:SVGEditor.ToolButton[]}
       */
      var toolButtons = [{
        sel: '#tool_select',
        fn: clickSelect,
        evt: 'click',
        key: ['V', true]
      }, {
        sel: '#tool_fhpath',
        fn: clickFHPath,
        evt: 'click',
        key: ['Q', true]
      }, {
        sel: '#tool_line',
        fn: clickLine,
        evt: 'click',
        key: ['L', true],
        parent: '#tools_line',
        prepend: true
      }, {
        sel: '#tool_rect',
        fn: clickRect,
        evt: 'mouseup',
        key: ['R', true],
        parent: '#tools_rect',
        icon: 'rect'
      }, {
        sel: '#tool_square',
        fn: clickSquare,
        evt: 'mouseup',
        parent: '#tools_rect',
        icon: 'square'
      }, {
        sel: '#tool_fhrect',
        fn: clickFHRect,
        evt: 'mouseup',
        parent: '#tools_rect',
        icon: 'fh_rect'
      }, {
        sel: '#tool_ellipse',
        fn: clickEllipse,
        evt: 'mouseup',
        key: ['E', true],
        parent: '#tools_ellipse',
        icon: 'ellipse'
      }, {
        sel: '#tool_circle',
        fn: clickCircle,
        evt: 'mouseup',
        parent: '#tools_ellipse',
        icon: 'circle'
      }, {
        sel: '#tool_fhellipse',
        fn: clickFHEllipse,
        evt: 'mouseup',
        parent: '#tools_ellipse',
        icon: 'fh_ellipse'
      }, {
        sel: '#tool_path',
        fn: clickPath,
        evt: 'click',
        key: ['P', true]
      }, {
        sel: '#tool_text',
        fn: clickText,
        evt: 'click',
        key: ['T', true]
      }, {
        sel: '#tool_image',
        fn: clickImage,
        evt: 'mouseup'
      }, {
        sel: '#tool_zoom',
        fn: clickZoom,
        evt: 'mouseup',
        key: ['Z', true]
      }, {
        sel: '#tool_clear',
        fn: clickClear,
        evt: 'mouseup',
        key: ['N', true]
      }, {
        sel: '#tool_save',
        fn: function fn() {
          if (editingsource) {
            saveSourceEditor();
          } else {
            clickSave();
          }
        },
        evt: 'mouseup',
        key: ['S', true]
      }, {
        sel: '#tool_export',
        fn: clickExport,
        evt: 'mouseup'
      }, {
        sel: '#tool_open',
        fn: clickOpen,
        evt: 'mouseup',
        key: ['O', true]
      }, {
        sel: '#tool_import',
        fn: clickImport,
        evt: 'mouseup'
      }, {
        sel: '#tool_source',
        fn: showSourceEditor,
        evt: 'click',
        key: ['U', true]
      }, {
        sel: '#tool_wireframe',
        fn: clickWireframe,
        evt: 'click',
        key: ['F', true]
      }, {
        key: ['esc', false, false],
        fn: function fn() {
          if (dialogSelectors.every(function (sel) {
            return $$c(sel + ':hidden').length;
          })) {
            svgCanvas.clearSelection();
          }
        },
        hidekey: true
      }, {
        sel: dialogSelectors.join(','),
        fn: cancelOverlays,
        evt: 'click',
        key: ['esc', false, false],
        hidekey: true
      }, {
        sel: '#tool_source_save',
        fn: saveSourceEditor,
        evt: 'click'
      }, {
        sel: '#tool_docprops_save',
        fn: saveDocProperties,
        evt: 'click'
      }, {
        sel: '#tool_docprops',
        fn: showDocProperties,
        evt: 'click'
      }, {
        sel: '#tool_prefs_save',
        fn: savePreferences,
        evt: 'click'
      }, {
        sel: '#tool_editor_prefs',
        fn: showPreferences,
        evt: 'click'
      }, {
        sel: '#tool_editor_homepage',
        fn: openHomePage,
        evt: 'click'
      }, {
        sel: '#tool_open',
        fn: function fn() {
          window.dispatchEvent(new CustomEvent('openImage'));
        },
        evt: 'click'
      }, {
        sel: '#tool_import',
        fn: function fn() {
          window.dispatchEvent(new CustomEvent('importImage'));
        },
        evt: 'click'
      }, {
        sel: '#tool_delete,#tool_delete_multi',
        fn: deleteSelected,
        evt: 'click',
        key: ['del/backspace', true]
      }, {
        sel: '#tool_reorient',
        fn: reorientPath,
        evt: 'click'
      }, {
        sel: '#tool_node_link',
        fn: linkControlPoints,
        evt: 'click'
      }, {
        sel: '#tool_node_clone',
        fn: clonePathNode,
        evt: 'click'
      }, {
        sel: '#tool_node_delete',
        fn: deletePathNode,
        evt: 'click'
      }, {
        sel: '#tool_openclose_path',
        fn: opencloseSubPath,
        evt: 'click'
      }, {
        sel: '#tool_add_subpath',
        fn: addSubPath,
        evt: 'click'
      }, {
        sel: '#tool_move_top',
        fn: moveToTopSelected,
        evt: 'click',
        key: 'ctrl+shift+]'
      }, {
        sel: '#tool_move_bottom',
        fn: moveToBottomSelected,
        evt: 'click',
        key: 'ctrl+shift+['
      }, {
        sel: '#tool_topath',
        fn: convertToPath,
        evt: 'click'
      }, {
        sel: '#tool_make_link,#tool_make_link_multi',
        fn: makeHyperlink,
        evt: 'click'
      }, {
        sel: '#tool_undo',
        fn: clickUndo,
        evt: 'click'
      }, {
        sel: '#tool_redo',
        fn: clickRedo,
        evt: 'click'
      }, {
        sel: '#tool_clone,#tool_clone_multi',
        fn: clickClone,
        evt: 'click',
        key: ['D', true]
      }, {
        sel: '#tool_group_elements',
        fn: clickGroup,
        evt: 'click',
        key: ['G', true]
      }, {
        sel: '#tool_ungroup',
        fn: clickGroup,
        evt: 'click'
      }, {
        sel: '#tool_unlink_use',
        fn: clickGroup,
        evt: 'click'
      }, {
        sel: '[id^=tool_align]',
        fn: clickAlign,
        evt: 'click'
      }, // these two lines are required to make Opera work properly with the flyout mechanism
      // {sel: '#tools_rect_show', fn: clickRect, evt: 'click'},
      // {sel: '#tools_ellipse_show', fn: clickEllipse, evt: 'click'},
      {
        sel: '#tool_bold',
        fn: clickBold,
        evt: 'mousedown'
      }, {
        sel: '#tool_italic',
        fn: clickItalic,
        evt: 'mousedown'
      }, {
        sel: '#sidepanel_handle',
        fn: toggleSidePanel,
        key: ['X']
      }, {
        sel: '#copy_save_done',
        fn: cancelOverlays,
        evt: 'click'
      }, // Shortcuts not associated with buttons
      {
        key: 'ctrl+left',
        fn: function fn() {
          rotateSelected(0, 1);
        }
      }, {
        key: 'ctrl+right',
        fn: function fn() {
          rotateSelected(1, 1);
        }
      }, {
        key: 'ctrl+shift+left',
        fn: function fn() {
          rotateSelected(0, 5);
        }
      }, {
        key: 'ctrl+shift+right',
        fn: function fn() {
          rotateSelected(1, 5);
        }
      }, {
        key: 'shift+O',
        fn: selectPrev
      }, {
        key: 'shift+P',
        fn: selectNext
      }, {
        key: [modKey + 'up', true],
        fn: function fn() {
          zoomImage(2);
        }
      }, {
        key: [modKey + 'down', true],
        fn: function fn() {
          zoomImage(0.5);
        }
      }, {
        key: [modKey + ']', true],
        fn: function fn() {
          moveUpDownSelected('Up');
        }
      }, {
        key: [modKey + '[', true],
        fn: function fn() {
          moveUpDownSelected('Down');
        }
      }, {
        key: ['up', true],
        fn: function fn() {
          moveSelected(0, -1);
        }
      }, {
        key: ['down', true],
        fn: function fn() {
          moveSelected(0, 1);
        }
      }, {
        key: ['left', true],
        fn: function fn() {
          moveSelected(-1, 0);
        }
      }, {
        key: ['right', true],
        fn: function fn() {
          moveSelected(1, 0);
        }
      }, {
        key: 'shift+up',
        fn: function fn() {
          moveSelected(0, -10);
        }
      }, {
        key: 'shift+down',
        fn: function fn() {
          moveSelected(0, 10);
        }
      }, {
        key: 'shift+left',
        fn: function fn() {
          moveSelected(-10, 0);
        }
      }, {
        key: 'shift+right',
        fn: function fn() {
          moveSelected(10, 0);
        }
      }, {
        key: ['alt+up', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(0, -1);
        }
      }, {
        key: ['alt+down', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(0, 1);
        }
      }, {
        key: ['alt+left', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(-1, 0);
        }
      }, {
        key: ['alt+right', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(1, 0);
        }
      }, {
        key: ['alt+shift+up', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(0, -10);
        }
      }, {
        key: ['alt+shift+down', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(0, 10);
        }
      }, {
        key: ['alt+shift+left', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(-10, 0);
        }
      }, {
        key: ['alt+shift+right', true],
        fn: function fn() {
          svgCanvas.cloneSelectedElements(10, 0);
        }
      }, {
        key: 'a',
        fn: function fn() {
          svgCanvas.selectAllInCurrentLayer();
        }
      }, {
        key: modKey + 'a',
        fn: function fn() {
          svgCanvas.selectAllInCurrentLayer();
        }
      }, // Standard shortcuts
      {
        key: modKey + 'z',
        fn: clickUndo
      }, {
        key: modKey + 'shift+z',
        fn: clickRedo
      }, {
        key: modKey + 'y',
        fn: clickRedo
      }, {
        key: modKey + 'x',
        fn: cutSelected
      }, {
        key: modKey + 'c',
        fn: copySelected
      }, {
        key: modKey + 'v',
        fn: pasteInCenter
      }]; // Tooltips not directly associated with a single function

      var keyAssocs = {
        '4/Shift+4': '#tools_rect_show',
        '5/Shift+5': '#tools_ellipse_show'
      };
      return {
        /** @lends module:SVGEditor~Actions */

        /**
         * @returns {void}
         */
        setAll: function setAll() {
          var flyouts = {};
          var keyHandler = {}; // will contain the action for each pressed key

          toolButtons.forEach(function (opts) {
            // Bind function to button
            var btn;

            if (opts.sel) {
              btn = $q$1(opts.sel);

              if (btn === null) {
                return true;
              } // Skip if markup does not exist


              if (opts.evt) {
                // `touch.js` changes `touchstart` to `mousedown`,
                //   so we must map tool button click events as well
                if (isTouch() && opts.evt === 'click') {
                  opts.evt = 'mousedown';
                }

                btn.addEventListener(opts.evt, opts.fn);
              } // Add to parent flyout menu, if able to be displayed


              if (opts.parent && $$c(opts.parent + '_show').length) {
                var fH = $$c(opts.parent);

                if (!fH.length) {
                  fH = makeFlyoutHolder(opts.parent.substr(1));
                }

                if (opts.prepend) {
                  btn.style.margin = 'initial';
                }

                fH[opts.prepend ? 'prepend' : 'append'](btn);

                if (!Array.isArray(flyouts[opts.parent])) {
                  flyouts[opts.parent] = [];
                }

                flyouts[opts.parent].push(opts);
              }
            } // Bind function to shortcut key


            if (opts.key) {
              // Set shortcut based on options
              var keyval = opts.key;
              var pd = false;

              if (Array.isArray(opts.key)) {
                keyval = opts.key[0];

                if (opts.key.length > 1) {
                  pd = opts.key[1];
                }
              }

              keyval = String(keyval);
              var fn = opts.fn;
              keyval.split('/').forEach(function (key) {
                keyHandler[key] = {
                  fn: fn,
                  pd: pd
                };
              }); // Put shortcut in title

              if (opts.sel && !opts.hidekey && btn.title) {
                var newTitle = "".concat(btn.title.split('[')[0], " (").concat(keyval, ")");
                keyAssocs[keyval] = opts.sel; // Disregard for menu items

                if (btn.closest('#main_menu') === null) {
                  btn.title = newTitle;
                }
              }
            }

            return true;
          }); // register the keydown event

          document.addEventListener('keydown', function (e) {
            // only track keyboard shortcuts for the body containing the SVG-Editor
            if (e.target.nodeName !== 'BODY') return; // normalize key

            var key = "".concat(e.metaKey ? 'meta+' : '').concat(e.ctrlKey ? 'ctrl+' : '').concat(e.key.toLowerCase()); // return if no shortcut defined for this key

            if (!keyHandler[key]) return; // launch associated handler and preventDefault if necessary

            keyHandler[key].fn();

            if (keyHandler[key].pd) {
              e.preventDefault();
            }
          }); // Setup flyouts

          setupFlyouts(flyouts); // Misc additional actions
          // Make 'return' keypress trigger the change event

          $$c('.attr_changer, #image_url').bind('keydown', 'return', function (evt) {
            $$c(this).change();
            evt.preventDefault();
          });
          $$c(window).bind('keydown', 'tab', function (e) {
            if (uiContext === 'canvas') {
              e.preventDefault();
              selectNext();
            }
          }).bind('keydown', 'shift+tab', function (e) {
            if (uiContext === 'canvas') {
              e.preventDefault();
              selectPrev();
            }
          });
          $$c('#tool_zoom').dblclick(dblclickZoom);
        },

        /**
         * @returns {void}
         */
        setTitles: function setTitles() {
          $$c.each(keyAssocs, function (keyval, sel) {
            var menu = $$c(sel).parents('#main_menu').length;
            $$c(sel).each(function () {
              var t;

              if (menu) {
                t = $$c(this).text().split(' [')[0];
              } else {
                t = this.title.split(' [')[0];
              }

              var keyStr = ''; // Shift+Up

              $$c.each(keyval.split('/'), function (i, key) {
                var modBits = key.split('+');
                var mod = '';

                if (modBits.length > 1) {
                  mod = modBits[0] + '+';
                  key = modBits[1];
                }

                keyStr += (i ? '/' : '') + mod + (uiStrings$1['key_' + key] || key);
              });

              if (menu) {
                this.lastChild.textContent = t + ' [' + keyStr + ']';
              } else {
                this.title = t + ' [' + keyStr + ']';
              }
            });
          });
        },

        /**
         * @param {string} sel Selector to match
         * @returns {module:SVGEditor.ToolButton}
         */
        getButtonData: function getButtonData(sel) {
          return Object.values(toolButtons).find(function (btn) {
            return btn.sel === sel;
          });
        }
      };
    }(); // Select given tool


    editor.ready(function () {
      var tool;
      var itool = curConfig.initTool,
          container = $$c('#tools_left, #svg_editor .tools_flyout'),
          preTool = container.find('#tool_' + itool),
          regTool = container.find('#' + itool);

      if (preTool.length) {
        tool = preTool;
      } else if (regTool.length) {
        tool = regTool;
      } else {
        tool = $$c('#tool_select');
      }

      tool.click().mouseup();

      if (curConfig.wireframe) {
        $$c('#tool_wireframe').click();
      }

      if (curConfig.showlayers) {
        toggleSidePanel();
      }

      $$c('#rulers').toggle(Boolean(curConfig.showRulers));

      if (curConfig.showRulers) {
        $$c('#show_rulers')[0].checked = true;
      }

      if (curConfig.baseUnit) {
        $$c('#base_unit').val(curConfig.baseUnit);
      }

      if (curConfig.gridSnapping) {
        $$c('#grid_snapping_on')[0].checked = true;
      }

      if (curConfig.snappingStep) {
        $$c('#grid_snapping_step').val(curConfig.snappingStep);
      }

      if (curConfig.gridColor) {
        $$c('#grid_color').val(curConfig.gridColor);
      }
    }); // init SpinButtons

    $$c('#rect_rx').SpinButton({
      min: 0,
      max: 1000,
      stateObj: stateObj,
      callback: changeRectRadius
    });
    $$c('#stroke_width').SpinButton({
      min: 0,
      max: 99,
      smallStep: 0.1,
      stateObj: stateObj,
      callback: changeStrokeWidth
    });
    $$c('#angle').SpinButton({
      min: -180,
      max: 180,
      step: 5,
      stateObj: stateObj,
      callback: changeRotationAngle
    });
    $$c('#font_size').SpinButton({
      min: 0.001,
      stepfunc: stepFontSize,
      stateObj: stateObj,
      callback: changeFontSize
    });
    $$c('#group_opacity').SpinButton({
      min: 0,
      max: 100,
      step: 5,
      stateObj: stateObj,
      callback: changeOpacity
    });
    $$c('#blur').SpinButton({
      min: 0,
      max: 10,
      step: 0.1,
      stateObj: stateObj,
      callback: changeBlur
    });
    $$c('#zoom').SpinButton({
      min: 0.001,
      max: 10000,
      step: 50,
      stepfunc: stepZoom,
      stateObj: stateObj,
      callback: changeZoom // Set default zoom

    }).val(svgCanvas.getZoom() * 100);
    $$c('#workarea').contextMenu({
      menu: 'cmenu_canvas',
      inSpeed: 0
    }, function (action, el, pos) {
      switch (action) {
        case 'delete':
          deleteSelected();
          break;

        case 'cut':
          cutSelected();
          break;

        case 'copy':
          copySelected();
          break;

        case 'paste':
          svgCanvas.pasteElements();
          break;

        case 'paste_in_place':
          svgCanvas.pasteElements('in_place');
          break;

        case 'group':
        case 'group_elements':
          svgCanvas.groupSelectedElements();
          break;

        case 'ungroup':
          svgCanvas.ungroupSelectedElement();
          break;

        case 'move_front':
          moveToTopSelected();
          break;

        case 'move_up':
          moveUpDownSelected('Up');
          break;

        case 'move_down':
          moveUpDownSelected('Down');
          break;

        case 'move_back':
          moveToBottomSelected();
          break;

        default:
          if (hasCustomHandler(action)) {
            getCustomHandler(action).call();
          }

          break;
      }
    });
    /**
    * Implements {@see module:jQueryContextMenu.jQueryContextMenuListener}.
    * @param {"dupe"|"delete"|"merge_down"|"merge_all"} action
    * @param {external:jQuery} el
    * @param {{x: Float, y: Float, docX: Float, docY: Float}} pos
    * @returns {void}
    */

    var lmenuFunc = function lmenuFunc(action, el, pos) {
      switch (action) {
        case 'dupe':
          /* await */
          cloneLayer();
          break;

        case 'delete':
          deleteLayer();
          break;

        case 'merge_down':
          mergeLayer();
          break;

        case 'merge_all':
          svgCanvas.mergeAllLayers();
          updateContextPanel();
          populateLayers();
          break;
      }
    };

    $$c('#layerlist').contextMenu({
      menu: 'cmenu_layers',
      inSpeed: 0
    }, lmenuFunc);
    $$c('#layer_moreopts').contextMenu({
      menu: 'cmenu_layers',
      inSpeed: 0,
      allowLeft: true
    }, lmenuFunc);
    $$c('.contextMenu li').mousedown(function (ev) {
      ev.preventDefault();
    });
    $$c('#cmenu_canvas li').disableContextMenu();
    canvMenu.enableContextMenuItems('#delete,#cut,#copy');
    /**
     * @returns {void}
     */

    function enableOrDisableClipboard() {
      var svgeditClipboard;

      try {
        svgeditClipboard = localStorage.getItem('svgedit_clipboard');
      } catch (err) {}

      canvMenu[(svgeditClipboard ? 'en' : 'dis') + 'ableContextMenuItems']('#paste,#paste_in_place');
    }

    enableOrDisableClipboard();
    window.addEventListener('storage', function (e) {
      if (e.key !== 'svgedit_clipboard') {
        return;
      }

      enableOrDisableClipboard();
    });
    window.addEventListener('beforeunload', function (e) {
      // Suppress warning if page is empty
      if (undoMgr.getUndoStackSize() === 0) {
        editor.showSaveWarning = false;
      } // showSaveWarning is set to 'false' when the page is saved.


      if (!curConfig.no_save_warning && editor.showSaveWarning) {
        // Browser already asks question about closing the page
        e.returnValue = uiStrings$1.notification.unsavedChanges; // Firefox needs this when beforeunload set by addEventListener (even though message is not used)

        return uiStrings$1.notification.unsavedChanges;
      }

      return true;
    });
    /**
    * Expose the `uiStrings`.
    * @function module:SVGEditor.canvas.getUIStrings
    * @returns {module:SVGEditor.uiStrings}
    */

    editor.canvas.getUIStrings = function () {
      return uiStrings$1;
    };
    /**
     * @function module:SVGEditor.openPrep
     * @returns {boolean|Promise<boolean>} Resolves to boolean indicating `true` if there were no changes
     *  and `false` after the user confirms.
     */


    editor.openPrep = function () {
      $$c('#main_menu').hide();

      if (undoMgr.getUndoStackSize() === 0) {
        return true;
      }

      return $$c.confirm(uiStrings$1.notification.QwantToOpen);
    };
    /**
     *
     * @param {Event} e
     * @returns {void}
     */


    function onDragEnter(e) {
      e.stopPropagation();
      e.preventDefault(); // and indicator should be displayed here, such as "drop files here"
    }
    /**
     *
     * @param {Event} e
     * @returns {void}
     */


    function onDragOver(e) {
      e.stopPropagation();
      e.preventDefault();
    }
    /**
     *
     * @param {Event} e
     * @returns {void}
     */


    function onDragLeave(e) {
      e.stopPropagation();
      e.preventDefault(); // hypothetical indicator should be removed here
    } // Use HTML5 File API: http://www.w3.org/TR/FileAPI/
    // if browser has HTML5 File API support, then we will show the open menu item
    // and provide a file input to click. When that change event fires, it will
    // get the text contents of the file and send it to the canvas


    if (window.FileReader) {
      /**
      * @param {Event} e
      * @returns {void}
      */
      var importImage = function importImage(e) {
        $$c.process_cancel(uiStrings$1.notification.loadingImage);
        e.stopPropagation();
        e.preventDefault();
        $$c('#workarea').removeAttr('style');
        $$c('#main_menu').hide();
        var file = e.type === 'drop' ? e.dataTransfer.files[0] : this.files[0];

        if (!file) {
          $$c('#dialog_box').hide();
          return;
        }
        /* if (file.type === 'application/pdf') { // Todo: Handle PDF imports
         }
        else */


        if (!file.type.includes('image')) {
          return;
        } // Detected an image
        // svg handling


        var reader;

        if (file.type.includes('svg')) {
          reader = new FileReader();

          reader.onloadend = function (ev) {
            var newElement = svgCanvas.importSvgString(ev.target.result, true);
            svgCanvas.ungroupSelectedElement();
            svgCanvas.ungroupSelectedElement();
            svgCanvas.groupSelectedElements();
            svgCanvas.alignSelectedElements('m', 'page');
            svgCanvas.alignSelectedElements('c', 'page'); // highlight imported element, otherwise we get strange empty selectbox

            svgCanvas.selectOnly([newElement]);
            $$c('#dialog_box').hide();
          };

          reader.readAsText(file);
        } else {
          // bitmap handling
          reader = new FileReader();

          reader.onloadend = function (_ref22) {
            var result = _ref22.target.result;

            /**
            * Insert the new image until we know its dimensions.
            * @param {Float} width
            * @param {Float} height
            * @returns {void}
            */
            var insertNewImage = function insertNewImage(width, height) {
              var newImage = svgCanvas.addSVGElementFromJson({
                element: 'image',
                attr: {
                  x: 0,
                  y: 0,
                  width: width,
                  height: height,
                  id: svgCanvas.getNextId(),
                  style: 'pointer-events:inherit'
                }
              });
              svgCanvas.setHref(newImage, result);
              svgCanvas.selectOnly([newImage]);
              svgCanvas.alignSelectedElements('m', 'page');
              svgCanvas.alignSelectedElements('c', 'page');
              updateContextPanel();
              $$c('#dialog_box').hide();
            }; // create dummy img so we know the default dimensions


            var imgWidth = 100;
            var imgHeight = 100;
            var img = new Image();
            img.style.opacity = 0;
            img.addEventListener('load', function () {
              imgWidth = img.offsetWidth || img.naturalWidth || img.width;
              imgHeight = img.offsetHeight || img.naturalHeight || img.height;
              insertNewImage(imgWidth, imgHeight);
            });
            img.src = result;
          };

          reader.readAsDataURL(file);
        }
      };

      workarea[0].addEventListener('dragenter', onDragEnter);
      workarea[0].addEventListener('dragover', onDragOver);
      workarea[0].addEventListener('dragleave', onDragLeave);
      workarea[0].addEventListener('drop', importImage);
      var open = $$c('<input type="file">').change( /*#__PURE__*/function () {
        var _ref23 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(e) {
          var ok, reader;
          return regeneratorRuntime.wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  _context17.next = 2;
                  return editor.openPrep();

                case 2:
                  ok = _context17.sent;

                  if (ok) {
                    _context17.next = 5;
                    break;
                  }

                  return _context17.abrupt("return");

                case 5:
                  svgCanvas.clear();

                  if (this.files.length === 1) {
                    $$c.process_cancel(uiStrings$1.notification.loadingImage);
                    reader = new FileReader();

                    reader.onloadend = /*#__PURE__*/function () {
                      var _ref25 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref24) {
                        var target;
                        return regeneratorRuntime.wrap(function _callee16$(_context16) {
                          while (1) {
                            switch (_context16.prev = _context16.next) {
                              case 0:
                                target = _ref24.target;
                                _context16.next = 3;
                                return loadSvgString(target.result);

                              case 3:
                                updateCanvas();

                              case 4:
                              case "end":
                                return _context16.stop();
                            }
                          }
                        }, _callee16);
                      }));

                      return function (_x7) {
                        return _ref25.apply(this, arguments);
                      };
                    }();

                    reader.readAsText(this.files[0]);
                  }

                case 7:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17, this);
        }));

        return function (_x6) {
          return _ref23.apply(this, arguments);
        };
      }());
      $$c('#tool_open').show();
      $$c(window).on('openImage', function () {
        return open.click();
      });
      var imgImport = $$c('<input type="file">').change(importImage);
      $$c('#tool_import').show();
      $$c(window).on('importImage', function () {
        return imgImport.click();
      });
    }

    updateCanvas(true); //  const revnums = 'svg-editor.js ($Rev$) ';
    //  revnums += svgCanvas.getVersion();
    //  $('#copyright')[0].setAttribute('title', revnums);

    var loadedExtensionNames = [];
    /**
    * @function module:SVGEditor.setLang
    * @param {string} lang The language code
    * @param {module:locale.LocaleStrings} allStrings See {@tutorial LocaleDocs}
    * @fires module:svgcanvas.SvgCanvas#event:ext_langReady
    * @fires module:svgcanvas.SvgCanvas#event:ext_langChanged
    * @returns {Promise<void>} A Promise which resolves to `undefined`
    */

    var setLang = editor.setLang = /*#__PURE__*/function () {
      var _ref26 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(lang, allStrings) {
        var oldLayerName, renameLayer, elems;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                editor.langChanged = true;
                editor.pref('lang', lang);
                $$c('#lang_select').val(lang);

                if (allStrings) {
                  _context18.next = 5;
                  break;
                }

                return _context18.abrupt("return");

              case 5:
                // Todo: Remove `allStrings.lang` property in locale in
                //   favor of just `lang`?
                document.documentElement.lang = allStrings.lang; // lang;
                // Todo: Add proper RTL Support!
                // Todo: Use RTL detection instead and take out of locales?
                // document.documentElement.dir = allStrings.dir;

                $$c.extend(uiStrings$1, allStrings); // const notif = allStrings.notification; // Currently unused
                // $.extend will only replace the given strings

                oldLayerName = $$c('#layerlist tr.layersel td.layername').text();
                renameLayer = oldLayerName === uiStrings$1.common.layer + ' 1';
                svgCanvas.setUiStrings(allStrings);
                Actions.setTitles();

                if (renameLayer) {
                  svgCanvas.renameCurrentLayer(uiStrings$1.common.layer + ' 1');
                  populateLayers();
                } // In case extensions loaded before the locale, now we execute a callback on them


                if (!extsPreLang.length) {
                  _context18.next = 18;
                  break;
                }

                _context18.next = 15;
                return Promise.all(extsPreLang.map(function (ext) {
                  loadedExtensionNames.push(ext.name);
                  return ext.langReady({
                    lang: lang,
                    uiStrings: uiStrings$1,
                    importLocale: getImportLocale({
                      defaultLang: lang,
                      defaultName: ext.name
                    })
                  });
                }));

              case 15:
                extsPreLang.length = 0;
                _context18.next = 19;
                break;

              case 18:
                loadedExtensionNames.forEach(function (loadedExtensionName) {
                  svgCanvas.runExtension(loadedExtensionName, 'langReady',
                  /** @type {module:svgcanvas.SvgCanvas#event:ext_langReady} */
                  {
                    lang: lang,
                    uiStrings: uiStrings$1,
                    importLocale: getImportLocale({
                      defaultLang: lang,
                      defaultName: loadedExtensionName
                    })
                  });
                });

              case 19:
                svgCanvas.runExtensions('langChanged',
                /** @type {module:svgcanvas.SvgCanvas#event:ext_langChanged} */
                lang); // Update flyout tooltips

                setFlyoutTitles(); // Copy title for certain tool elements

                elems = {
                  '#stroke_color': '#tool_stroke .icon_label, #tool_stroke .color_block',
                  '#fill_color': '#tool_fill label, #tool_fill .color_block',
                  '#linejoin_miter': '#cur_linejoin',
                  '#linecap_butt': '#cur_linecap'
                };
                $$c.each(elems, function (source, dest) {
                  $$c(dest).attr('title', $$c(source)[0].title);
                }); // Copy alignment titles

                $$c('#multiselected_panel div[id^=tool_align]').each(function () {
                  $$c('#tool_pos' + this.id.substr(10))[0].title = this.title;
                });

              case 24:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      return function (_x8, _x9) {
        return _ref26.apply(this, arguments);
      };
    }();

    init$7(
    /**
    * @implements {module:locale.LocaleEditorInit}
    */
    {
      /**
      * Gets an array of results from extensions with a `addLangData` method,
      * returning an object with a `data` property set to its locales (to be
      * merged with regular locales).
      * @param {string} langParam
      * @fires module:svgcanvas.SvgCanvas#event:ext_addLangData
      * @todo Can we forego this in favor of `langReady` (or forego `langReady`)?
      * @returns {module:locale.AddLangExtensionLocaleData[]}
      */
      addLangData: function addLangData(langParam) {
        return svgCanvas.runExtensions('addLangData',
        /**
         * @function
         * @type {module:svgcanvas.ExtensionVarBuilder}
         * @param {string} name
         * @returns {module:svgcanvas.SvgCanvas#event:ext_addLangData}
         */
        function (name) {
          // We pass in a function as we don't know the extension name here when defining this `addLangData` method
          return {
            lang: langParam,
            importLocale: getImportLocale({
              defaultLang: langParam,
              defaultName: name
            })
          };
        }, true);
      },
      curConfig: curConfig
    }); // Load extensions
    // Bit of a hack to run extensions in local Opera/IE9

    if (document.location.protocol === 'file:') {
      setTimeout(extAndLocaleFunc, 100);
    } else {
      // Returns a promise (if we wanted to fire 'extensions-loaded' event,
      //   potentially useful to hide interface as some extension locales
      //   are only available after this)
      extAndLocaleFunc();
    }
  };
  /**
  * @callback module:SVGEditor.ReadyCallback
  * @returns {Promise<void>|void}
  */

  /**
  * Queues a callback to be invoked when the editor is ready (or
  *   to be invoked immediately if it is already ready--i.e.,
  *   if `runCallbacks` has been run).
  * @function module:SVGEditor.ready
  * @param {module:SVGEditor.ReadyCallback} cb Callback to be queued to invoke
  * @returns {Promise<ArbitraryCallbackResult>} Resolves when all callbacks, including the supplied have resolved
  */


  editor.ready = function (cb) {
    // eslint-disable-line promise/prefer-await-to-callbacks
    return new Promise(function (resolve, reject) {
      // eslint-disable-line promise/avoid-new
      if (isReady) {
        resolve(cb()); // eslint-disable-line node/callback-return, promise/prefer-await-to-callbacks

        return;
      }

      callbacks.push([cb, resolve, reject]);
    });
  };
  /**
  * Invokes the callbacks previous set by `svgEditor.ready`
  * @function module:SVGEditor.runCallbacks
  * @returns {Promise<void>} Resolves to `undefined` if all callbacks succeeded and rejects otherwise
  */


  editor.runCallbacks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
    return regeneratorRuntime.wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            _context21.prev = 0;
            _context21.next = 3;
            return Promise.all(callbacks.map(function (_ref29) {
              var _ref30 = _slicedToArray(_ref29, 1),
                  cb = _ref30[0];

              return cb(); // eslint-disable-line promise/prefer-await-to-callbacks
            }));

          case 3:
            _context21.next = 9;
            break;

          case 5:
            _context21.prev = 5;
            _context21.t0 = _context21["catch"](0);
            callbacks.forEach(function (_ref31) {
              var _ref32 = _slicedToArray(_ref31, 3),
                  reject = _ref32[2];

              reject();
            });
            throw _context21.t0;

          case 9:
            callbacks.forEach(function (_ref33) {
              var _ref34 = _slicedToArray(_ref33, 2),
                  resolve = _ref34[1];

              resolve();
            });
            isReady = true;

          case 11:
          case "end":
            return _context21.stop();
        }
      }
    }, _callee21, null, [[0, 5]]);
  }));
  /**
   * @function module:SVGEditor.loadFromString
   * @param {string} str The SVG string to load
   * @param {PlainObject} [opts={}]
   * @param {boolean} [opts.noAlert=false] Option to avoid alert to user and instead get rejected promise
   * @returns {Promise<void>}
   */

  editor.loadFromString = function (str) {
    var _ref35 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        noAlert = _ref35.noAlert;

    return editor.ready( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
      return regeneratorRuntime.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              _context22.next = 3;
              return loadSvgString(str, {
                noAlert: noAlert
              });

            case 3:
              _context22.next = 9;
              break;

            case 5:
              _context22.prev = 5;
              _context22.t0 = _context22["catch"](0);

              if (!noAlert) {
                _context22.next = 9;
                break;
              }

              throw _context22.t0;

            case 9:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, null, [[0, 5]]);
    })));
  };
  /**
  * Not presently in use.
  * @function module:SVGEditor.disableUI
  * @param {PlainObject} featList
  * @returns {void}
  */


  editor.disableUI = function (featList) {// $(function () {
    //   $('#tool_wireframe, #tool_image, #main_button, #tool_source, #sidepanels').remove();
    //   $('#tools_top').css('left', 5);
    // });
  };
  /**
   * @callback module:SVGEditor.URLLoadCallback
   * @param {boolean} success
   * @returns {void}
   */

  /**
   * @function module:SVGEditor.loadFromURL
   * @param {string} url URL from which to load an SVG string via Ajax
   * @param {PlainObject} [opts={}] May contain properties: `cache`, `callback`
   * @param {boolean} [opts.cache]
   * @param {boolean} [opts.noAlert]
   * @returns {Promise<void>} Resolves to `undefined` or rejects upon bad loading of
   *   the SVG (or upon failure to parse the loaded string) when `noAlert` is
   *   enabled
   */


  editor.loadFromURL = function (url) {
    var _ref37 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        cache = _ref37.cache,
        noAlert = _ref37.noAlert;

    return editor.ready(function () {
      return new Promise(function (resolve, reject) {
        // eslint-disable-line promise/avoid-new
        $$c.ajax({
          url: url,
          dataType: 'text',
          cache: Boolean(cache),
          beforeSend: function beforeSend() {
            $$c.process_cancel(uiStrings$1.notification.loadingImage);
          },
          success: function success(str) {
            resolve(loadSvgString(str, {
              noAlert: noAlert
            }));
          },
          error: function error(xhr, stat, err) {
            if (xhr.status !== 404 && xhr.responseText) {
              resolve(loadSvgString(xhr.responseText, {
                noAlert: noAlert
              }));
              return;
            }

            if (noAlert) {
              reject(new Error('URLLoadFail'));
              return;
            }

            $$c.alert(uiStrings$1.notification.URLLoadFail + ': \n' + err);
            resolve();
          },
          complete: function complete() {
            $$c('#dialog_box').hide();
          }
        });
      });
    });
  };
  /**
  * @function module:SVGEditor.loadFromDataURI
  * @param {string} str The Data URI to base64-decode (if relevant) and load
  * @param {PlainObject} [opts={}]
  * @param {boolean} [opts.noAlert]
  * @returns {Promise<void>} Resolves to `undefined` and rejects if loading SVG string fails and `noAlert` is enabled
  */


  editor.loadFromDataURI = function (str) {
    var _ref38 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        noAlert = _ref38.noAlert;

    return editor.ready(function () {
      var base64 = false;
      var pre = str.match(/^data:image\/svg\+xml;base64,/);

      if (pre) {
        base64 = true;
      } else {
        pre = str.match(/^data:image\/svg\+xml(?:;|;utf8)?,/);
      }

      if (pre) {
        pre = pre[0];
      }

      var src = str.slice(pre.length);
      return loadSvgString(base64 ? decode64(src) : decodeURIComponent(src), {
        noAlert: noAlert
      });
    });
  };
  /**
   * @function module:SVGEditor.addExtension
   * @param {string} name Used internally; no need for i18n.
   * @param {module:svgcanvas.ExtensionInitCallback} init Config to be invoked on this module
   * @param {module:svgcanvas.ExtensionInitArgs} initArgs
   * @throws {Error} If called too early
   * @returns {Promise<void>} Resolves to `undefined`
  */


  editor.addExtension = function (name, init, initArgs) {
    // Note that we don't want this on editor.ready since some extensions
    // may want to run before then (like server_opensave).
    // $(function () {
    if (!svgCanvas) {
      throw new Error('Extension added too early');
    }

    return svgCanvas.addExtension.call(this, name, init, initArgs); // });
  }; // Defer injection to wait out initial menu processing. This probably goes
  //    away once all context menu behavior is brought to context menu.


  editor.ready(function () {
    injectExtendedContextMenuItemsIntoDom();
  });
  var extensionsAdded = false;
  var messageQueue = [];
  /**
   * @param {PlainObject} info
   * @param {any} info.data
   * @param {string} info.origin
   * @fires module:svgcanvas.SvgCanvas#event:message
   * @returns {void}
   */

  var messageListener = function messageListener(_ref39) {
    var data = _ref39.data,
        origin = _ref39.origin;
    // eslint-disable-line no-shadow
    // console.log('data, origin, extensionsAdded', data, origin, extensionsAdded);
    var messageObj = {
      data: data,
      origin: origin
    };

    if (!extensionsAdded) {
      messageQueue.push(messageObj);
    } else {
      // Extensions can handle messages at this stage with their own
      //  canvas `message` listeners
      svgCanvas.call('message', messageObj);
    }
  };

  window.addEventListener('message', messageListener); // Run init once DOM is loaded
  // jQuery(editor.init);

  _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
    return regeneratorRuntime.wrap(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            _context23.prev = 0;
            _context23.next = 3;
            return Promise.resolve();

          case 3:
            editor.init();
            _context23.next = 9;
            break;

          case 6:
            _context23.prev = 6;
            _context23.t0 = _context23["catch"](0);
            console.error(_context23.t0); // eslint-disable-line no-console

          case 9:
          case "end":
            return _context23.stop();
        }
      }
    }, _callee23, null, [[0, 6]]);
  }))();

  editor.setConfig({
    /* To override the ability for URLs to set URL-based SVG content,
    uncomment the following: */
    // preventURLContentLoading: true,

    /* To override the ability for URLs to set other configuration (including
      extension config), uncomment the following: */
    // preventAllURLConfig: true,

    /* To override the ability for URLs to set their own extensions, uncomment the
    following (note that if `setConfig()` is used in extension code, it will still
    be additive to extensions, however): */
    // lockExtensions: true,
  });
  editor.setConfig({
    /*
    Provide default values here which differ from that of the editor but
      which the URL can override
    */
  }, {
    allowInitialUserOverride: true
  }); // EXTENSION CONFIG

  editor.setConfig({
    extensions: [// 'ext-overview_window.js', 'ext-markers.js', 'ext-connector.js',
      //  'ext-eyedropper.js', 'ext-shapes.js', 'ext-imagelib.js',
      //  'ext-grid.js', 'ext-polygon.js', 'ext-star.js', 'ext-panning.js',
      //   'ext-storage.js'
    ],
    // noDefaultExtensions can only be meaningfully used in
    //  `svgedit-config-es.js` or in the URL
    noDefaultExtensions: false
  }); // OTHER CONFIG

  editor.setConfig({// canvasName: 'default',
    // canvas_expansion: 3,
    // initFill: {
    //   color: 'FF0000', // solid red
    //   opacity: 1
    // },
    // initStroke: {
    //   width: 5,
    //   color: '000000', // solid black
    //   opacity: 1
    // },
    // initOpacity: 1,
    // colorPickerCSS: null,
    // initTool: 'select',
    // exportWindowType: 'new', // 'same'
    // wireframe: false,
    // showlayers: false,
    // no_save_warning: false,
    // PATH CONFIGURATION
    // imgPath: 'images/',
    // langPath: '/src/editor/locale/',
    // extPath: 'extensions/',
    // jGraduatePath: 'jgraduate/images/',

    /*
    Uncomment the following to allow at least same domain (embedded) access,
    including `file:///` access.
    Setting as `['*']` would allow any domain to access but would be unsafe to
    data privacy and integrity.
    */
    // May be 'null' (as a string) when used as a `file:///` URL
    // allowedOrigins: [location.origin || 'null'],
    // DOCUMENT PROPERTIES
    // dimensions: [640, 480],
    // EDITOR OPTIONS
    // gridSnapping: false,
    // gridColor: '#000',
    // baseUnit: 'px',
    // snappingStep: 10,
    // showRulers: true,
    // EXTENSION-RELATED (GRID)
    // showGrid: false, // Set by ext-grid.js
    // EXTENSION-RELATED (STORAGE)
    // Some interaction with `ext-storage.js`; prevent even the loading of
    //  previously saved local storage
    // noStorageOnLoad: false,
    // Some interaction with `ext-storage.js`; strongly discouraged from
    //  modification as it bypasses user privacy by preventing them from
    //  choosing whether to keep local storage or not
    // forceStorage: false,
    // Used by `ext-storage.js`; empty any prior storage if the user
    //  declines to store
    // emptyStorageOnDecline: true,
  }); // PREF CHANGES

  /*
  setConfig() can also be used to set preferences in addition to
    configuration (see defaultPrefs in svg-editor.js for a list of
    possible settings), but at least if you are using ext-storage.js
    to store preferences, it will probably be better to let your
    users control these.
  As with configuration, one may use allowInitialUserOverride, but
    in the case of preferences, any previously stored preferences
    will also thereby be enabled to override this setting (and at a
    higher priority than any URL preference setting overrides).
    Failing to use allowInitialUserOverride will ensure preferences
    are hard-coded here regardless of URL or prior user storage setting.
  */

  editor.setConfig({// Set dynamically within locale.js if not previously set
    // lang: '',
    // Will default to 's' if the window height is smaller than the minimum
    //  height and 'm' otherwise
    // iconsize: '',

    /**
    * When showing the preferences dialog, svg-editor.js currently relies
    * on `curPrefs` instead of `svgEditor.pref`, so allowing an override for
    * `bkgd_color` means that this value won't have priority over block
    * auto-detection as far as determining which color shows initially
    * in the preferences dialog (though it can be changed and saved).
    */
    // bkgd_color: '#FFF',
    // bkgd_url: '',
    // img_save: 'embed',
    // Only shows in UI as far as alert notices
    // save_notice_done: false,
    // export_notice_done: false
  });
  editor.setConfig({// Indicate pref settings here if you wish to allow user storage or URL
    //   settings to be able to override your default preferences (unless
    //   other config options have already explicitly prevented one or the
    //   other)
  }, {
    allowInitialUserOverride: true
  });

  var underscoreMin = createCommonjsModule(function (module, exports) {
    !function (n, r) {
       module.exports = r() ;
    }(commonjsGlobal, function () {
      //     Underscore.js 1.10.2
      //     https://underscorejs.org
      //     (c) 2009-2020 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      //     Underscore may be freely distributed under the MIT license.
      var n = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self && self || "object" == _typeof(commonjsGlobal) && commonjsGlobal.global === commonjsGlobal && commonjsGlobal || Function("return this")() || {},
          e = Array.prototype,
          i = Object.prototype,
          p = "undefined" != typeof Symbol ? Symbol.prototype : null,
          u = e.push,
          f = e.slice,
          s = i.toString,
          o = i.hasOwnProperty,
          r = Array.isArray,
          a = Object.keys,
          t = Object.create,
          c = n.isNaN,
          l = n.isFinite,
          v = function v() {};

      function h(n) {
        return n instanceof h ? n : this instanceof h ? void (this._wrapped = n) : new h(n);
      }

      var g = h.VERSION = "1.10.2";

      function y(u, o, n) {
        if (void 0 === o) return u;

        switch (null == n ? 3 : n) {
          case 1:
            return function (n) {
              return u.call(o, n);
            };

          case 3:
            return function (n, r, t) {
              return u.call(o, n, r, t);
            };

          case 4:
            return function (n, r, t, e) {
              return u.call(o, n, r, t, e);
            };
        }

        return function () {
          return u.apply(o, arguments);
        };
      }

      function d(n, r, t) {
        return null == n ? ur : Cn(n) ? y(n, r, t) : Ln(n) && !Kn(n) ? ir(n) : or(n);
      }

      function m(n, r) {
        return d(n, r, 1 / 0);
      }

      function b(n, r, t) {
        return h.iteratee !== m ? h.iteratee(n, r) : d(n, r, t);
      }

      function j(u, o) {
        return o = null == o ? u.length - 1 : +o, function () {
          for (var n = Math.max(arguments.length - o, 0), r = Array(n), t = 0; t < n; t++) {
            r[t] = arguments[t + o];
          }

          switch (o) {
            case 0:
              return u.call(this, r);

            case 1:
              return u.call(this, arguments[0], r);

            case 2:
              return u.call(this, arguments[0], arguments[1], r);
          }

          var e = Array(o + 1);

          for (t = 0; t < o; t++) {
            e[t] = arguments[t];
          }

          return e[o] = r, u.apply(this, e);
        };
      }

      function _(n) {
        if (!Ln(n)) return {};
        if (t) return t(n);
        v.prototype = n;
        var r = new v();
        return v.prototype = null, r;
      }

      function w(r) {
        return function (n) {
          return null == n ? void 0 : n[r];
        };
      }

      function x(n, r) {
        return null != n && o.call(n, r);
      }

      function S(n, r) {
        for (var t = r.length, e = 0; e < t; e++) {
          if (null == n) return;
          n = n[r[e]];
        }

        return t ? n : void 0;
      }

      h.iteratee = m;
      var A = Math.pow(2, 53) - 1,
          O = w("length");

      function M(n) {
        var r = O(n);
        return "number" == typeof r && 0 <= r && r <= A;
      }

      function E(n, r, t) {
        var e, u;
        if (r = y(r, t), M(n)) for (e = 0, u = n.length; e < u; e++) {
          r(n[e], e, n);
        } else {
          var o = Sn(n);

          for (e = 0, u = o.length; e < u; e++) {
            r(n[o[e]], o[e], n);
          }
        }
        return n;
      }

      function N(n, r, t) {
        r = b(r, t);

        for (var e = !M(n) && Sn(n), u = (e || n).length, o = Array(u), i = 0; i < u; i++) {
          var a = e ? e[i] : i;
          o[i] = r(n[a], a, n);
        }

        return o;
      }

      function k(f) {
        return function (n, r, t, e) {
          var u = 3 <= arguments.length;
          return function (n, r, t, e) {
            var u = !M(n) && Sn(n),
                o = (u || n).length,
                i = 0 < f ? 0 : o - 1;

            for (e || (t = n[u ? u[i] : i], i += f); 0 <= i && i < o; i += f) {
              var a = u ? u[i] : i;
              t = r(t, n[a], a, n);
            }

            return t;
          }(n, y(r, e, 4), t, u);
        };
      }

      var I = k(1),
          T = k(-1);

      function B(n, r, t) {
        var e = (M(n) ? on : Tn)(n, r, t);
        if (void 0 !== e && -1 !== e) return n[e];
      }

      function R(n, e, r) {
        var u = [];
        return e = b(e, r), E(n, function (n, r, t) {
          e(n, r, t) && u.push(n);
        }), u;
      }

      function F(n, r, t) {
        r = b(r, t);

        for (var e = !M(n) && Sn(n), u = (e || n).length, o = 0; o < u; o++) {
          var i = e ? e[o] : o;
          if (!r(n[i], i, n)) return !1;
        }

        return !0;
      }

      function q(n, r, t) {
        r = b(r, t);

        for (var e = !M(n) && Sn(n), u = (e || n).length, o = 0; o < u; o++) {
          var i = e ? e[o] : o;
          if (r(n[i], i, n)) return !0;
        }

        return !1;
      }

      function D(n, r, t, e) {
        return M(n) || (n = On(n)), ("number" != typeof t || e) && (t = 0), 0 <= ln(n, r, t);
      }

      var W = j(function (n, t, e) {
        var u, o;
        return Cn(t) ? o = t : Kn(t) && (u = t.slice(0, -1), t = t[t.length - 1]), N(n, function (n) {
          var r = o;

          if (!r) {
            if (u && u.length && (n = S(n, u)), null == n) return;
            r = n[t];
          }

          return null == r ? r : r.apply(n, e);
        });
      });

      function z(n, r) {
        return N(n, or(r));
      }

      function P(n, e, r) {
        var t,
            u,
            o = -1 / 0,
            i = -1 / 0;
        if (null == e || "number" == typeof e && "object" != _typeof(n[0]) && null != n) for (var a = 0, f = (n = M(n) ? n : On(n)).length; a < f; a++) {
          null != (t = n[a]) && o < t && (o = t);
        } else e = b(e, r), E(n, function (n, r, t) {
          u = e(n, r, t), (i < u || u === -1 / 0 && o === -1 / 0) && (o = n, i = u);
        });
        return o;
      }

      function K(n, r, t) {
        if (null == r || t) return M(n) || (n = On(n)), n[ar(n.length - 1)];
        var e = M(n) ? Dn(n) : On(n),
            u = O(e);
        r = Math.max(Math.min(r, u), 0);

        for (var o = u - 1, i = 0; i < r; i++) {
          var a = ar(i, o),
              f = e[i];
          e[i] = e[a], e[a] = f;
        }

        return e.slice(0, r);
      }

      function L(i, r) {
        return function (e, u, n) {
          var o = r ? [[], []] : {};
          return u = b(u, n), E(e, function (n, r) {
            var t = u(n, r, e);
            i(o, n, t);
          }), o;
        };
      }

      var V = L(function (n, r, t) {
        x(n, t) ? n[t].push(r) : n[t] = [r];
      }),
          C = L(function (n, r, t) {
        n[t] = r;
      }),
          J = L(function (n, r, t) {
        x(n, t) ? n[t]++ : n[t] = 1;
      }),
          U = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
      var $ = L(function (n, r, t) {
        n[t ? 0 : 1].push(r);
      }, !0);

      function G(n, r, t) {
        return null == n || n.length < 1 ? null == r ? void 0 : [] : null == r || t ? n[0] : H(n, n.length - r);
      }

      function H(n, r, t) {
        return f.call(n, 0, Math.max(0, n.length - (null == r || t ? 1 : r)));
      }

      function Q(n, r, t) {
        return f.call(n, null == r || t ? 1 : r);
      }

      function X(n, r, t, e) {
        for (var u = (e = e || []).length, o = 0, i = O(n); o < i; o++) {
          var a = n[o];
          if (M(a) && (Kn(a) || Vn(a))) {
            if (r) for (var f = 0, c = a.length; f < c;) {
              e[u++] = a[f++];
            } else X(a, r, t, e), u = e.length;
          } else t || (e[u++] = a);
        }

        return e;
      }

      var Y = j(function (n, r) {
        return rn(n, r);
      });

      function Z(n, r, t, e) {
        er(r) || (e = t, t = r, r = !1), null != t && (t = b(t, e));

        for (var u = [], o = [], i = 0, a = O(n); i < a; i++) {
          var f = n[i],
              c = t ? t(f, i, n) : f;
          r && !t ? (i && o === c || u.push(f), o = c) : t ? D(o, c) || (o.push(c), u.push(f)) : D(u, f) || u.push(f);
        }

        return u;
      }

      var nn = j(function (n) {
        return Z(X(n, !0, !0));
      });
      var rn = j(function (n, r) {
        return r = X(r, !0, !0), R(n, function (n) {
          return !D(r, n);
        });
      });

      function tn(n) {
        for (var r = n && P(n, O).length || 0, t = Array(r), e = 0; e < r; e++) {
          t[e] = z(n, e);
        }

        return t;
      }

      var en = j(tn);

      function un(o) {
        return function (n, r, t) {
          r = b(r, t);

          for (var e = O(n), u = 0 < o ? 0 : e - 1; 0 <= u && u < e; u += o) {
            if (r(n[u], u, n)) return u;
          }

          return -1;
        };
      }

      var on = un(1),
          an = un(-1);

      function fn(n, r, t, e) {
        for (var u = (t = b(t, e, 1))(r), o = 0, i = O(n); o < i;) {
          var a = Math.floor((o + i) / 2);
          t(n[a]) < u ? o = a + 1 : i = a;
        }

        return o;
      }

      function cn(o, i, a) {
        return function (n, r, t) {
          var e = 0,
              u = O(n);
          if ("number" == typeof t) 0 < o ? e = 0 <= t ? t : Math.max(t + u, e) : u = 0 <= t ? Math.min(t + 1, u) : t + u + 1;else if (a && t && u) return n[t = a(n, r)] === r ? t : -1;
          if (r != r) return 0 <= (t = i(f.call(n, e, u), tr)) ? t + e : -1;

          for (t = 0 < o ? e : u - 1; 0 <= t && t < u; t += o) {
            if (n[t] === r) return t;
          }

          return -1;
        };
      }

      var ln = cn(1, on, fn),
          pn = cn(-1, an);

      function sn(n, r, t, e, u) {
        if (!(e instanceof r)) return n.apply(t, u);

        var o = _(n.prototype),
            i = n.apply(o, u);

        return Ln(i) ? i : o;
      }

      var vn = j(function (r, t, e) {
        if (!Cn(r)) throw new TypeError("Bind must be called on a function");
        var u = j(function (n) {
          return sn(r, u, t, this, e.concat(n));
        });
        return u;
      }),
          hn = j(function (u, o) {
        var i = hn.placeholder,
            a = function a() {
          for (var n = 0, r = o.length, t = Array(r), e = 0; e < r; e++) {
            t[e] = o[e] === i ? arguments[n++] : o[e];
          }

          for (; n < arguments.length;) {
            t.push(arguments[n++]);
          }

          return sn(u, a, this, this, t);
        };

        return a;
      });
      hn.placeholder = h;
      var gn = j(function (n, r) {
        var t = (r = X(r, !1, !1)).length;
        if (t < 1) throw new Error("bindAll must be passed function names");

        for (; t--;) {
          var e = r[t];
          n[e] = vn(n[e], n);
        }
      });
      var yn = j(function (n, r, t) {
        return setTimeout(function () {
          return n.apply(null, t);
        }, r);
      }),
          dn = hn(yn, h, 1);

      function mn(n) {
        return function () {
          return !n.apply(this, arguments);
        };
      }

      function bn(n, r) {
        var t;
        return function () {
          return 0 < --n && (t = r.apply(this, arguments)), n <= 1 && (r = null), t;
        };
      }

      var jn = hn(bn, 2),
          _n = !{
        toString: null
      }.propertyIsEnumerable("toString"),
          wn = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];

      function xn(n, r) {
        var t = wn.length,
            e = n.constructor,
            u = Cn(e) && e.prototype || i,
            o = "constructor";

        for (x(n, o) && !D(r, o) && r.push(o); t--;) {
          (o = wn[t]) in n && n[o] !== u[o] && !D(r, o) && r.push(o);
        }
      }

      function Sn(n) {
        if (!Ln(n)) return [];
        if (a) return a(n);
        var r = [];

        for (var t in n) {
          x(n, t) && r.push(t);
        }

        return _n && xn(n, r), r;
      }

      function An(n) {
        if (!Ln(n)) return [];
        var r = [];

        for (var t in n) {
          r.push(t);
        }

        return _n && xn(n, r), r;
      }

      function On(n) {
        for (var r = Sn(n), t = r.length, e = Array(t), u = 0; u < t; u++) {
          e[u] = n[r[u]];
        }

        return e;
      }

      function Mn(n) {
        for (var r = {}, t = Sn(n), e = 0, u = t.length; e < u; e++) {
          r[n[t[e]]] = t[e];
        }

        return r;
      }

      function En(n) {
        var r = [];

        for (var t in n) {
          Cn(n[t]) && r.push(t);
        }

        return r.sort();
      }

      function Nn(f, c) {
        return function (n) {
          var r = arguments.length;
          if (c && (n = Object(n)), r < 2 || null == n) return n;

          for (var t = 1; t < r; t++) {
            for (var e = arguments[t], u = f(e), o = u.length, i = 0; i < o; i++) {
              var a = u[i];
              c && void 0 !== n[a] || (n[a] = e[a]);
            }
          }

          return n;
        };
      }

      var kn = Nn(An),
          In = Nn(Sn);

      function Tn(n, r, t) {
        r = b(r, t);

        for (var e, u = Sn(n), o = 0, i = u.length; o < i; o++) {
          if (r(n[e = u[o]], e, n)) return e;
        }
      }

      function Bn(n, r, t) {
        return r in t;
      }

      var Rn = j(function (n, r) {
        var t = {},
            e = r[0];
        if (null == n) return t;
        Cn(e) ? (1 < r.length && (e = y(e, r[1])), r = An(n)) : (e = Bn, r = X(r, !1, !1), n = Object(n));

        for (var u = 0, o = r.length; u < o; u++) {
          var i = r[u],
              a = n[i];
          e(a, i, n) && (t[i] = a);
        }

        return t;
      }),
          Fn = j(function (n, t) {
        var r,
            e = t[0];
        return Cn(e) ? (e = mn(e), 1 < t.length && (r = t[1])) : (t = N(X(t, !1, !1), String), e = function e(n, r) {
          return !D(t, r);
        }), Rn(n, e, r);
      }),
          qn = Nn(An, !0);

      function Dn(n) {
        return Ln(n) ? Kn(n) ? n.slice() : kn({}, n) : n;
      }

      function Wn(n, r) {
        var t = Sn(r),
            e = t.length;
        if (null == n) return !e;

        for (var u = Object(n), o = 0; o < e; o++) {
          var i = t[o];
          if (r[i] !== u[i] || !(i in u)) return !1;
        }

        return !0;
      }

      function zn(n, r, t, e) {
        if (n === r) return 0 !== n || 1 / n == 1 / r;
        if (null == n || null == r) return !1;
        if (n != n) return r != r;

        var u = _typeof(n);

        return ("function" === u || "object" === u || "object" == _typeof(r)) && function (n, r, t, e) {
          n instanceof h && (n = n._wrapped);
          r instanceof h && (r = r._wrapped);
          var u = s.call(n);
          if (u !== s.call(r)) return !1;

          switch (u) {
            case "[object RegExp]":
            case "[object String]":
              return "" + n == "" + r;

            case "[object Number]":
              return +n != +n ? +r != +r : 0 == +n ? 1 / +n == 1 / r : +n == +r;

            case "[object Date]":
            case "[object Boolean]":
              return +n == +r;

            case "[object Symbol]":
              return p.valueOf.call(n) === p.valueOf.call(r);
          }

          var o = "[object Array]" === u;

          if (!o) {
            if ("object" != _typeof(n) || "object" != _typeof(r)) return !1;
            var i = n.constructor,
                a = r.constructor;
            if (i !== a && !(Cn(i) && i instanceof i && Cn(a) && a instanceof a) && "constructor" in n && "constructor" in r) return !1;
          }

          e = e || [];
          var f = (t = t || []).length;

          for (; f--;) {
            if (t[f] === n) return e[f] === r;
          }

          if (t.push(n), e.push(r), o) {
            if ((f = n.length) !== r.length) return !1;

            for (; f--;) {
              if (!zn(n[f], r[f], t, e)) return !1;
            }
          } else {
            var c,
                l = Sn(n);
            if (f = l.length, Sn(r).length !== f) return !1;

            for (; f--;) {
              if (c = l[f], !x(r, c) || !zn(n[c], r[c], t, e)) return !1;
            }
          }

          return t.pop(), e.pop(), !0;
        }(n, r, t, e);
      }

      function Pn(r) {
        return function (n) {
          return s.call(n) === "[object " + r + "]";
        };
      }

      var Kn = r || Pn("Array");

      function Ln(n) {
        var r = _typeof(n);

        return "function" === r || "object" === r && !!n;
      }

      var Vn = Pn("Arguments"),
          Cn = Pn("Function"),
          Jn = Pn("String"),
          Un = Pn("Number"),
          $n = Pn("Date"),
          Gn = Pn("RegExp"),
          Hn = Pn("Error"),
          Qn = Pn("Symbol"),
          Xn = Pn("Map"),
          Yn = Pn("WeakMap"),
          Zn = Pn("Set"),
          nr = Pn("WeakSet");
      !function () {
        Vn(arguments) || (Vn = function Vn(n) {
          return x(n, "callee");
        });
      }();
      var rr = n.document && n.document.childNodes;

      function tr(n) {
        return Un(n) && c(n);
      }

      function er(n) {
        return !0 === n || !1 === n || "[object Boolean]" === s.call(n);
      }

      function ur(n) {
        return n;
      }

      function or(r) {
        return Kn(r) ? function (n) {
          return S(n, r);
        } : w(r);
      }

      function ir(r) {
        return r = In({}, r), function (n) {
          return Wn(n, r);
        };
      }

      function ar(n, r) {
        return null == r && (r = n, n = 0), n + Math.floor(Math.random() * (r - n + 1));
      }

      "function" != typeof /./ && "object" != (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) && "function" != typeof rr && (Cn = function Cn(n) {
        return "function" == typeof n || !1;
      });

      var fr = Date.now || function () {
        return new Date().getTime();
      },
          cr = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      },
          lr = Mn(cr);

      function pr(r) {
        var t = function t(n) {
          return r[n];
        },
            n = "(?:" + Sn(r).join("|") + ")",
            e = RegExp(n),
            u = RegExp(n, "g");

        return function (n) {
          return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n;
        };
      }

      var sr = pr(cr),
          vr = pr(lr);
      var hr = 0;

      var gr = h.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      },
          yr = /(.)^/,
          dr = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
      },
          mr = /\\|'|\r|\n|\u2028|\u2029/g,
          br = function br(n) {
        return "\\" + dr[n];
      };

      function jr(n, r) {
        return n._chain ? h(r).chain() : r;
      }

      function _r(t) {
        return E(En(t), function (n) {
          var r = h[n] = t[n];

          h.prototype[n] = function () {
            var n = [this._wrapped];
            return u.apply(n, arguments), jr(this, r.apply(h, n));
          };
        }), h;
      }

      E(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (r) {
        var t = e[r];

        h.prototype[r] = function () {
          var n = this._wrapped;
          return t.apply(n, arguments), "shift" !== r && "splice" !== r || 0 !== n.length || delete n[0], jr(this, n);
        };
      }), E(["concat", "join", "slice"], function (n) {
        var r = e[n];

        h.prototype[n] = function () {
          return jr(this, r.apply(this._wrapped, arguments));
        };
      }), h.prototype.valueOf = h.prototype.toJSON = h.prototype.value = function () {
        return this._wrapped;
      }, h.prototype.toString = function () {
        return String(this._wrapped);
      };

      var wr = _r({
        "default": h,
        VERSION: g,
        iteratee: m,
        restArguments: j,
        each: E,
        forEach: E,
        map: N,
        collect: N,
        reduce: I,
        foldl: I,
        inject: I,
        reduceRight: T,
        foldr: T,
        find: B,
        detect: B,
        filter: R,
        select: R,
        reject: function reject(n, r, t) {
          return R(n, mn(b(r)), t);
        },
        every: F,
        all: F,
        some: q,
        any: q,
        contains: D,
        includes: D,
        include: D,
        invoke: W,
        pluck: z,
        where: function where(n, r) {
          return R(n, ir(r));
        },
        findWhere: function findWhere(n, r) {
          return B(n, ir(r));
        },
        max: P,
        min: function min(n, e, r) {
          var t,
              u,
              o = 1 / 0,
              i = 1 / 0;
          if (null == e || "number" == typeof e && "object" != _typeof(n[0]) && null != n) for (var a = 0, f = (n = M(n) ? n : On(n)).length; a < f; a++) {
            null != (t = n[a]) && t < o && (o = t);
          } else e = b(e, r), E(n, function (n, r, t) {
            ((u = e(n, r, t)) < i || u === 1 / 0 && o === 1 / 0) && (o = n, i = u);
          });
          return o;
        },
        shuffle: function shuffle(n) {
          return K(n, 1 / 0);
        },
        sample: K,
        sortBy: function sortBy(n, e, r) {
          var u = 0;
          return e = b(e, r), z(N(n, function (n, r, t) {
            return {
              value: n,
              index: u++,
              criteria: e(n, r, t)
            };
          }).sort(function (n, r) {
            var t = n.criteria,
                e = r.criteria;

            if (t !== e) {
              if (e < t || void 0 === t) return 1;
              if (t < e || void 0 === e) return -1;
            }

            return n.index - r.index;
          }), "value");
        },
        groupBy: V,
        indexBy: C,
        countBy: J,
        toArray: function toArray(n) {
          return n ? Kn(n) ? f.call(n) : Jn(n) ? n.match(U) : M(n) ? N(n, ur) : On(n) : [];
        },
        size: function size(n) {
          return null == n ? 0 : M(n) ? n.length : Sn(n).length;
        },
        partition: $,
        first: G,
        head: G,
        take: G,
        initial: H,
        last: function last(n, r, t) {
          return null == n || n.length < 1 ? null == r ? void 0 : [] : null == r || t ? n[n.length - 1] : Q(n, Math.max(0, n.length - r));
        },
        rest: Q,
        tail: Q,
        drop: Q,
        compact: function compact(n) {
          return R(n, Boolean);
        },
        flatten: function flatten(n, r) {
          return X(n, r, !1);
        },
        without: Y,
        uniq: Z,
        unique: Z,
        union: nn,
        intersection: function intersection(n) {
          for (var r = [], t = arguments.length, e = 0, u = O(n); e < u; e++) {
            var o = n[e];

            if (!D(r, o)) {
              var i;

              for (i = 1; i < t && D(arguments[i], o); i++) {
              }

              i === t && r.push(o);
            }
          }

          return r;
        },
        difference: rn,
        unzip: tn,
        zip: en,
        object: function object(n, r) {
          for (var t = {}, e = 0, u = O(n); e < u; e++) {
            r ? t[n[e]] = r[e] : t[n[e][0]] = n[e][1];
          }

          return t;
        },
        findIndex: on,
        findLastIndex: an,
        sortedIndex: fn,
        indexOf: ln,
        lastIndexOf: pn,
        range: function range(n, r, t) {
          null == r && (r = n || 0, n = 0), t || (t = r < n ? -1 : 1);

          for (var e = Math.max(Math.ceil((r - n) / t), 0), u = Array(e), o = 0; o < e; o++, n += t) {
            u[o] = n;
          }

          return u;
        },
        chunk: function chunk(n, r) {
          if (null == r || r < 1) return [];

          for (var t = [], e = 0, u = n.length; e < u;) {
            t.push(f.call(n, e, e += r));
          }

          return t;
        },
        bind: vn,
        partial: hn,
        bindAll: gn,
        memoize: function memoize(e, u) {
          var o = function o(n) {
            var r = o.cache,
                t = "" + (u ? u.apply(this, arguments) : n);
            return x(r, t) || (r[t] = e.apply(this, arguments)), r[t];
          };

          return o.cache = {}, o;
        },
        delay: yn,
        defer: dn,
        throttle: function throttle(t, e, u) {
          var o,
              i,
              a,
              f,
              c = 0;
          u || (u = {});

          var l = function l() {
            c = !1 === u.leading ? 0 : fr(), o = null, f = t.apply(i, a), o || (i = a = null);
          },
              n = function n() {
            var n = fr();
            c || !1 !== u.leading || (c = n);
            var r = e - (n - c);
            return i = this, a = arguments, r <= 0 || e < r ? (o && (clearTimeout(o), o = null), c = n, f = t.apply(i, a), o || (i = a = null)) : o || !1 === u.trailing || (o = setTimeout(l, r)), f;
          };

          return n.cancel = function () {
            clearTimeout(o), c = 0, o = i = a = null;
          }, n;
        },
        debounce: function debounce(t, e, u) {
          var o,
              i,
              a = function a(n, r) {
            o = null, r && (i = t.apply(n, r));
          },
              n = j(function (n) {
            if (o && clearTimeout(o), u) {
              var r = !o;
              o = setTimeout(a, e), r && (i = t.apply(this, n));
            } else o = yn(a, e, this, n);

            return i;
          });

          return n.cancel = function () {
            clearTimeout(o), o = null;
          }, n;
        },
        wrap: function wrap(n, r) {
          return hn(r, n);
        },
        negate: mn,
        compose: function compose() {
          var t = arguments,
              e = t.length - 1;
          return function () {
            for (var n = e, r = t[e].apply(this, arguments); n--;) {
              r = t[n].call(this, r);
            }

            return r;
          };
        },
        after: function after(n, r) {
          return function () {
            if (--n < 1) return r.apply(this, arguments);
          };
        },
        before: bn,
        once: jn,
        keys: Sn,
        allKeys: An,
        values: On,
        mapObject: function mapObject(n, r, t) {
          r = b(r, t);

          for (var e = Sn(n), u = e.length, o = {}, i = 0; i < u; i++) {
            var a = e[i];
            o[a] = r(n[a], a, n);
          }

          return o;
        },
        pairs: function pairs(n) {
          for (var r = Sn(n), t = r.length, e = Array(t), u = 0; u < t; u++) {
            e[u] = [r[u], n[r[u]]];
          }

          return e;
        },
        invert: Mn,
        functions: En,
        methods: En,
        extend: kn,
        extendOwn: In,
        assign: In,
        findKey: Tn,
        pick: Rn,
        omit: Fn,
        defaults: qn,
        create: function create(n, r) {
          var t = _(n);

          return r && In(t, r), t;
        },
        clone: Dn,
        tap: function tap(n, r) {
          return r(n), n;
        },
        isMatch: Wn,
        isEqual: function isEqual(n, r) {
          return zn(n, r);
        },
        isEmpty: function isEmpty(n) {
          return null == n || (M(n) && (Kn(n) || Jn(n) || Vn(n)) ? 0 === n.length : 0 === Sn(n).length);
        },
        isElement: function isElement(n) {
          return !(!n || 1 !== n.nodeType);
        },
        isArray: Kn,
        isObject: Ln,
        isArguments: Vn,
        isFunction: Cn,
        isString: Jn,
        isNumber: Un,
        isDate: $n,
        isRegExp: Gn,
        isError: Hn,
        isSymbol: Qn,
        isMap: Xn,
        isWeakMap: Yn,
        isSet: Zn,
        isWeakSet: nr,
        isFinite: function isFinite(n) {
          return !Qn(n) && l(n) && !c(parseFloat(n));
        },
        isNaN: tr,
        isBoolean: er,
        isNull: function isNull(n) {
          return null === n;
        },
        isUndefined: function isUndefined(n) {
          return void 0 === n;
        },
        has: function has(n, r) {
          if (!Kn(r)) return x(n, r);

          for (var t = r.length, e = 0; e < t; e++) {
            var u = r[e];
            if (null == n || !o.call(n, u)) return !1;
            n = n[u];
          }

          return !!t;
        },
        identity: ur,
        constant: function constant(n) {
          return function () {
            return n;
          };
        },
        noop: function noop() {},
        property: or,
        propertyOf: function propertyOf(r) {
          return null == r ? function () {} : function (n) {
            return Kn(n) ? S(r, n) : r[n];
          };
        },
        matcher: ir,
        matches: ir,
        times: function times(n, r, t) {
          var e = Array(Math.max(0, n));
          r = y(r, t, 1);

          for (var u = 0; u < n; u++) {
            e[u] = r(u);
          }

          return e;
        },
        random: ar,
        now: fr,
        escape: sr,
        unescape: vr,
        result: function result(n, r, t) {
          Kn(r) || (r = [r]);
          var e = r.length;
          if (!e) return Cn(t) ? t.call(n) : t;

          for (var u = 0; u < e; u++) {
            var o = null == n ? void 0 : n[r[u]];
            void 0 === o && (o = t, u = e), n = Cn(o) ? o.call(n) : o;
          }

          return n;
        },
        uniqueId: function uniqueId(n) {
          var r = ++hr + "";
          return n ? n + r : r;
        },
        templateSettings: gr,
        template: function template(o, n, r) {
          !n && r && (n = r), n = qn({}, n, h.templateSettings);
          var t,
              e = RegExp([(n.escape || yr).source, (n.interpolate || yr).source, (n.evaluate || yr).source].join("|") + "|$", "g"),
              i = 0,
              a = "__p+='";
          o.replace(e, function (n, r, t, e, u) {
            return a += o.slice(i, u).replace(mr, br), i = u + n.length, r ? a += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : t ? a += "'+\n((__t=(" + t + "))==null?'':__t)+\n'" : e && (a += "';\n" + e + "\n__p+='"), n;
          }), a += "';\n", n.variable || (a = "with(obj||{}){\n" + a + "}\n"), a = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + a + "return __p;\n";

          try {
            t = new Function(n.variable || "obj", "_", a);
          } catch (n) {
            throw n.source = a, n;
          }

          var u = function u(n) {
            return t.call(this, n, h);
          },
              f = n.variable || "obj";

          return u.source = "function(" + f + "){\n" + a + "}", u;
        },
        chain: function chain(n) {
          var r = h(n);
          return r._chain = !0, r;
        },
        mixin: _r
      });

      return wr._ = wr;
    });
  });

  var underscoreMin$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), underscoreMin, {
    'default': underscoreMin,
    __moduleExports: underscoreMin
  }));

  var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;

  function init$8() {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray(b64) {
    if (!inited) {
      init$8();
    }

    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice


    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

    arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    if (!inited) {
      init$8();
    }

    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }

  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }

  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$2 = {}.toString;

  var isArray$1 = Array.isArray || function (arr) {
    return toString$2.call(arr) == '[object Array]';
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */


  var INSPECT_MAX_BYTES = 50;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */

  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;
  /*
   * Export kMaxLength after typed array support is determined.
   */

  var _kMaxLength = kMaxLength();

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }

      that.length = length;
    }

    return that;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */


  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    } // Common case.


    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }

      return allocUnsafe(this, arg);
    }

    return from(this, arg, encodingOrOffset, length);
  }

  Buffer.poolSize = 8192; // not used by this implementation
  // TODO: Legacy, not needed anymore. Remove in next major version.

  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/


  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(that, size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }

    return createBuffer(that, size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/


  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }

    return that;
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */


  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }

    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }

    return that;
  }

  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }

        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray$1(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }

    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }

    return Buffer.alloc(+length);
  }

  Buffer.isBuffer = isBuffer;

  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }

  Buffer.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray$1(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.


    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.


  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = INSPECT_MAX_BYTES;

    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }

    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer


    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    } // Normalize val


    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf


    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]

      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    } // must be an even number of digits


    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      } // legacy write(string, encoding, offset, length) - remove in v0.13

    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety


  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".


    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================


  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually


  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }

  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  } // For Node v0.10 support. Remove this eventually.


  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
  }

  var bufferEs6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Buffer: Buffer,
    INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
    SlowBuffer: SlowBuffer,
    isBuffer: isBuffer,
    kMaxLength: _kMaxLength
  });

  var jspdf_min = createCommonjsModule(function (module) {
    /**
     * jsPDF - PDF Document creation from JavaScript
     * Version 1.0.150-git Built on 2014-05-30T00:40
     *                           CommitID dcbc9fcb9b
     *
     * Copyright (c) 2010-2014 James Hall, https://github.com/MrRio/jsPDF
     *               2010 Aaron Spike, https://github.com/acspike
     *               2012 Willow Systems Corporation, willow-systems.com
     *               2012 Pablo Hess, https://github.com/pablohess
     *               2012 Florian Jenett, https://github.com/fjenett
     *               2013 Warren Weckesser, https://github.com/warrenweckesser
     *               2013 Youssef Beddad, https://github.com/lifof
     *               2013 Lee Driscoll, https://github.com/lsdriscoll
     *               2013 Stefan Slonevskiy, https://github.com/stefslon
     *               2013 Jeremy Morel, https://github.com/jmorel
     *               2013 Christoph Hartmann, https://github.com/chris-rock
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 James Makes, https://github.com/dollaruw
     *               2014 Diego Casorran, https://github.com/diegocr
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * Contributor(s):
     *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
     *    kim3er, mfo, alnorth,
     */

    /**
     * jsPDF addHTML PlugIn
     * Copyright (c) 2014 Diego Casorran
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */

    /**
     * jsPDF addImage plugin
     * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
     *               2013 Chris Dowling, https://github.com/gingerchris
     *               2013 Trinh Ho, https://github.com/ineedfat
     *               2013 Edwin Alejandro Perez, https://github.com/eaparango
     *               2013 Norah Smith, https://github.com/burnburnrocket
     *               2014 Diego Casorran, https://github.com/diegocr
     *               2014 James Robb, https://github.com/jamesbrobb
     */

    /**
     * jsPDF Cell plugin
     * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
     *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
     *               2013 Lee Driscoll, https://github.com/lsdriscoll
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 James Hall, james@parall.ax
     *               2014 Diego Casorran, https://github.com/diegocr
     */

    /**
     * jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser
     * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
     *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
     *               2014 Diego Casorran, https://github.com/diegocr
     *               2014 Daniel Husar, https://github.com/danielhusar
     *               2014 Wolfgang Gassler, https://github.com/woolfg
     */

    /**
     * jsPDF JavaScript plugin
     * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
     */

    /**
     * jsPDF PNG PlugIn
     * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
     */

    /**
    jsPDF Silly SVG plugin
    Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
    */

    /**
     * jsPDF split_text_to_size plugin - MIT license.
     * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
     *               2014 Diego Casorran, https://github.com/diegocr
     */

    /**
    jsPDF standard_fonts_metrics plugin
    Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
    MIT license.
    */

    /**
     * jsPDF total_pages plugin
     * Copyright (c) 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
     */

    /* Blob.js
     * A Blob implementation.
     * 2014-05-27
     * By Eli Grey, http://eligrey.com
     * By Devin Samarin, https://github.com/eboyjr
     * License: X11/MIT
     *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
     */

    /* FileSaver.js
     *  A saveAs() FileSaver implementation.
     *  2014-05-27
     *  By Eli Grey, http://eligrey.com
     *  License: X11/MIT
     *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
     */

    /*
     * Copyright (c) 2012 chick307 <chick307@gmail.com>
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */

    /*
     Deflate.js - https://github.com/gildas-lormeau/zip.js
     Copyright (c) 2013 Gildas Lormeau. All rights reserved.
     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:
     1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the distribution.
     3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.
     THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
     INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */

    /*
    # PNG.js
    # Copyright (c) 2011 Devon Govett
    # MIT LICENSE
    #
    */

    /*
     * Extracted from pdf.js
     * https://github.com/andreasgal/pdf.js
     * Copyright (c) 2011 Mozilla Foundation
     * Contributors: Andreas Gal <gal@mozilla.com>
     *               Chris G Jones <cjones@mozilla.com>
     *               Shaon Barman <shaon.barman@gmail.com>
     *               Vivien Nicolas <21@vingtetun.org>
     *               Justin D'Arcangelo <justindarc@gmail.com>
     *               Yury Delendik
     */

    /**
     * JavaScript Polyfill functions for jsPDF
     * Collected from public resources by
     * https://github.com/diegocr
     */
    !function (t, e) {
      e["true"] = t;

      var r = function (t) {

        function e(e) {
          var r = {};
          this.subscribe = function (t, e, n) {
            if ("function" != typeof e) return !1;
            r.hasOwnProperty(t) || (r[t] = {});
            var s = Math.random().toString(35);
            return r[t][s] = [e, !!n], s;
          }, this.unsubscribe = function (t) {
            for (var e in r) {
              if (r[e][t]) return delete r[e][t], !0;
            }

            return !1;
          }, this.publish = function (n) {
            if (r.hasOwnProperty(n)) {
              var s = Array.prototype.slice.call(arguments, 1),
                  o = [];

              for (var i in r[n]) {
                var a = r[n][i];

                try {
                  a[0].apply(e, s);
                } catch (u) {
                  t.console && console.error("jsPDF PubSub Error", u.message, u);
                }

                a[1] && o.push(i);
              }

              o.length && o.forEach(this.unsubscribe);
            }
          };
        }

        function r(a, u, c, l) {
          var f = {};
          "object" == _typeof(a) && (f = a, a = f.orientation, u = f.unit || u, c = f.format || c, l = f.compress || f.compressPdf || l), u = u || "mm", c = c || "a4", a = ("" + (a || "P")).toLowerCase();

          var d,
              h,
              p,
              m,
              w,
              y = ("" + c).toLowerCase(),
              g = !!l && "function" == typeof Uint8Array,
              v = f.textColor || "0 g",
              b = f.drawColor || "0 G",
              q = f.fontSize || 16,
              x = f.lineHeight || 1.15,
              k = f.lineWidth || .200025,
              _ = 2,
              A = !1,
              C = [],
              S = {},
              E = {},
              z = 0,
              I = [],
              T = [],
              B = 0,
              O = 0,
              P = 0,
              R = {
            title: "",
            subject: "",
            author: "",
            keywords: "",
            creator: ""
          },
              D = {},
              U = new e(D),
              F = function F(t) {
            return t.toFixed(2);
          },
              L = function L(t) {
            return t.toFixed(3);
          },
              j = function j(t) {
            return ("0" + parseInt(t)).slice(-2);
          },
              N = function N(t) {
            A ? I[z].push(t) : (P += t.length + 1, T.push(t));
          },
              M = function M() {
            return _++, C[_] = P, N(_ + " 0 obj"), _;
          },
              H = function H(t) {
            N("stream"), N(t), N("endstream");
          },
              G = function G() {
            var e,
                n,
                o,
                i,
                a,
                u,
                c,
                l = m * h,
                f = w * h;

            for (c = t.adler32cs || r.adler32cs, g && "undefined" == typeof c && (g = !1), e = 1; z >= e; e++) {
              if (M(), N("<</Type /Page"), N("/Parent 1 0 R"), N("/Resources 2 0 R"), N("/Contents " + (_ + 1) + " 0 R>>"), N("endobj"), n = I[e].join("\n"), M(), g) {
                for (o = [], i = n.length; i--;) {
                  o[i] = n.charCodeAt(i);
                }

                u = c.from(n), a = new s(6), a.append(new Uint8Array(o)), n = a.flush(), o = new Uint8Array(n.length + 6), o.set(new Uint8Array([120, 156])), o.set(n, 2), o.set(new Uint8Array([255 & u, u >> 8 & 255, u >> 16 & 255, u >> 24 & 255]), n.length + 2), n = String.fromCharCode.apply(null, o), N("<</Length " + n.length + " /Filter [/FlateDecode]>>");
              } else N("<</Length " + n.length + ">>");

              H(n), N("endobj");
            }

            C[1] = P, N("1 0 obj"), N("<</Type /Pages");
            var d = "/Kids [";

            for (i = 0; z > i; i++) {
              d += 3 + 2 * i + " 0 R ";
            }

            N(d + "]"), N("/Count " + z), N("/MediaBox [0 0 " + F(l) + " " + F(f) + "]"), N(">>"), N("endobj");
          },
              J = function J(t) {
            t.objectNumber = M(), N("<</BaseFont/" + t.PostScriptName + "/Type/Font"), "string" == typeof t.encoding && N("/Encoding/" + t.encoding), N("/Subtype/Type1>>"), N("endobj");
          },
              V = function V() {
            for (var t in S) {
              S.hasOwnProperty(t) && J(S[t]);
            }
          },
              W = function W() {
            U.publish("putXobjectDict");
          },
              X = function X() {
            N("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), N("/Font <<");

            for (var t in S) {
              S.hasOwnProperty(t) && N("/" + t + " " + S[t].objectNumber + " 0 R");
            }

            N(">>"), N("/XObject <<"), W(), N(">>");
          },
              Y = function Y() {
            V(), U.publish("putResources"), C[2] = P, N("2 0 obj"), N("<<"), X(), N(">>"), N("endobj"), U.publish("postPutResources");
          },
              K = function K(t, e, r) {
            E.hasOwnProperty(e) || (E[e] = {}), E[e][r] = t;
          },
              Q = function Q(t, e, r, n) {
            var s = "F" + (Object.keys(S).length + 1).toString(10),
                o = S[s] = {
              id: s,
              PostScriptName: t,
              fontName: e,
              fontStyle: r,
              encoding: n,
              metadata: {}
            };
            return K(s, e, r), U.publish("addFont", o), s;
          },
              $ = function $() {
            for (var t = "helvetica", e = "times", r = "courier", n = "normal", s = "bold", o = "italic", i = "bolditalic", a = "StandardEncoding", u = [["Helvetica", t, n], ["Helvetica-Bold", t, s], ["Helvetica-Oblique", t, o], ["Helvetica-BoldOblique", t, i], ["Courier", r, n], ["Courier-Bold", r, s], ["Courier-Oblique", r, o], ["Courier-BoldOblique", r, i], ["Times-Roman", e, n], ["Times-Bold", e, s], ["Times-Italic", e, o], ["Times-BoldItalic", e, i]], c = 0, l = u.length; l > c; c++) {
              var f = Q(u[c][0], u[c][1], u[c][2], a),
                  d = u[c][0].split("-");
              K(f, d[0], d[1] || "");
            }

            U.publish("addFonts", {
              fonts: S,
              dictionary: E
            });
          },
              Z = function Z(e) {
            return e.foo = function () {
              try {
                return e.apply(this, arguments);
              } catch (r) {
                var n = r.stack || "";
                ~n.indexOf(" at ") && (n = n.split(" at ")[1]);
                var s = "Error in function " + n.split("\n")[0].split("<")[0] + ": " + r.message;
                if (!t.console) throw new Error(s);
                console.log(s, r), t.alert && alert(s), console.trace();
              }
            }, e.foo.bar = e, e.foo;
          },
              te = function te(t, e) {
            var r, n, s, o, i, a, u, c, l;

            if (e = e || {}, s = e.sourceEncoding || "Unicode", i = e.outputEncoding, (e.autoencode || i) && S[d].metadata && S[d].metadata[s] && S[d].metadata[s].encoding && (o = S[d].metadata[s].encoding, !i && S[d].encoding && (i = S[d].encoding), !i && o.codePages && (i = o.codePages[0]), "string" == typeof i && (i = o[i]), i)) {
              for (u = !1, a = [], r = 0, n = t.length; n > r; r++) {
                c = i[t.charCodeAt(r)], c ? a.push(String.fromCharCode(c)) : a.push(t[r]), a[r].charCodeAt(0) >> 8 && (u = !0);
              }

              t = a.join("");
            }

            for (r = t.length; void 0 === u && 0 !== r;) {
              t.charCodeAt(r - 1) >> 8 && (u = !0), r--;
            }

            if (!u) return t;

            for (a = e.noBOM ? [] : [254, 255], r = 0, n = t.length; n > r; r++) {
              if (c = t.charCodeAt(r), l = c >> 8, l >> 8) throw new Error("Character at position " + r + " of string '" + t + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
              a.push(l), a.push(c - (l << 8));
            }

            return String.fromCharCode.apply(void 0, a);
          },
              ee = function ee(t, e) {
            return te(t, e).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
          },
              re = function re() {
            N("/Producer (jsPDF " + r.version + ")");

            for (var t in R) {
              R.hasOwnProperty(t) && R[t] && N("/" + t.substr(0, 1).toUpperCase() + t.substr(1) + " (" + ee(R[t]) + ")");
            }

            var e = new Date();
            N(["/CreationDate (D:", e.getFullYear(), j(e.getMonth() + 1), j(e.getDate()), j(e.getHours()), j(e.getMinutes()), j(e.getSeconds()), ")"].join(""));
          },
              ne = function ne() {
            N("/Type /Catalog"), N("/Pages 1 0 R"), N("/OpenAction [3 0 R /FitH null]"), N("/PageLayout /OneColumn"), U.publish("putCatalog");
          },
              se = function se() {
            N("/Size " + (_ + 1)), N("/Root " + _ + " 0 R"), N("/Info " + (_ - 1) + " 0 R");
          },
              oe = function oe() {
            z++, A = !0, I[z] = [];
          },
              ie = function ie() {
            oe(), N(F(k * h) + " w"), N(b), 0 !== B && N(B + " J"), 0 !== O && N(O + " j"), U.publish("addPage", {
              pageNumber: z
            });
          },
              ae = function ae(t, e) {
            var r;
            t = void 0 !== t ? t : S[d].fontName, e = void 0 !== e ? e : S[d].fontStyle;

            try {
              r = E[t][e] || E[t].normal;
            } catch (n) {}

            if (!r) throw new Error("Unable to look up font label for font '" + t + "', '" + e + "'. Refer to getFontList() for available fonts.");
            return r;
          },
              ue = function ue() {
            A = !1, _ = 2, T = [], C = [], N("%PDF-" + o), G(), Y(), M(), N("<<"), re(), N(">>"), N("endobj"), M(), N("<<"), ne(), N(">>"), N("endobj");
            var t,
                e = P,
                r = "0000000000";

            for (N("xref"), N("0 " + (_ + 1)), N(r + " 65535 f "), t = 1; _ >= t; t++) {
              N((r + C[t]).slice(-10) + " 00000 n ");
            }

            return N("trailer"), N("<<"), se(), N(">>"), N("startxref"), N(e), N("%%EOF"), A = !0, T.join("\n");
          },
              ce = function ce(t) {
            var e = "S";
            return "F" === t ? e = "f" : "FD" === t || "DF" === t ? e = "B" : ("f" === t || "f*" === t || "B" === t || "B*" === t) && (e = t), e;
          },
              le = function le() {
            for (var t = ue(), e = t.length, r = new ArrayBuffer(e), n = new Uint8Array(r); e--;) {
              n[e] = t.charCodeAt(e);
            }

            return r;
          },
              fe = function fe() {
            return new Blob([le()], {
              type: "application/pdf"
            });
          },
              de = Z(function (e, r) {
            switch (e) {
              case void 0:
                return ue();

              case "save":
                if (navigator.getUserMedia && (void 0 === t.URL || void 0 === t.URL.createObjectURL)) return D.output("dataurlnewwindow");
                n(fe(), r), "function" == typeof n.unload && t.setTimeout && setTimeout(n.unload, 70);
                break;

              case "arraybuffer":
                return le();

              case "blob":
                return fe();

              case "datauristring":
              case "dataurlstring":
                return "data:application/pdf;base64," + btoa(ue());

              case "datauri":
              case "dataurl":
                t.document.location.href = "data:application/pdf;base64," + btoa(ue());
                break;

              case "dataurlnewwindow":
                t.open("data:application/pdf;base64," + btoa(ue()));
                break;

              default:
                throw new Error('Output type "' + e + '" is not supported.');
            }
          });

          switch (u) {
            case "pt":
              h = 1;
              break;

            case "mm":
              h = 72 / 25.4;
              break;

            case "cm":
              h = 72 / 2.54;
              break;

            case "in":
              h = 72;
              break;

            case "px":
              h = 96 / 72;
              break;

            case "pc":
              h = 12;
              break;

            case "em":
              h = 12;
              break;

            case "ex":
              h = 6;
              break;

            default:
              throw "Invalid unit: " + u;
          }

          if (i.hasOwnProperty(y)) w = i[y][1] / h, m = i[y][0] / h;else try {
            w = c[1], m = c[0];
          } catch (he) {
            throw new Error("Invalid format: " + c);
          }
          if ("p" === a || "portrait" === a) a = "p", m > w && (p = m, m = w, w = p);else {
            if ("l" !== a && "landscape" !== a) throw "Invalid orientation: " + a;
            a = "l", w > m && (p = m, m = w, w = p);
          }
          D.internal = {
            pdfEscape: ee,
            getStyle: ce,
            getFont: function getFont() {
              return S[ae.apply(D, arguments)];
            },
            getFontSize: function getFontSize() {
              return q;
            },
            getLineHeight: function getLineHeight() {
              return q * x;
            },
            write: function write(t) {
              N(1 === arguments.length ? t : Array.prototype.join.call(arguments, " "));
            },
            getCoordinateString: function getCoordinateString(t) {
              return F(t * h);
            },
            getVerticalCoordinateString: function getVerticalCoordinateString(t) {
              return F((w - t) * h);
            },
            collections: {},
            newObject: M,
            putStream: H,
            events: U,
            scaleFactor: h,
            pageSize: {
              width: m,
              height: w
            },
            output: function output(t, e) {
              return de(t, e);
            },
            getNumberOfPages: function getNumberOfPages() {
              return I.length - 1;
            },
            pages: I
          }, D.addPage = function () {
            return ie(), this;
          }, D.text = function (t, e, r, n, s) {
            function o(t) {
              return t = t.split("	").join(Array(f.TabLen || 9).join(" ")), ee(t, n);
            }

            "number" == typeof t && (p = r, r = e, e = t, t = p), "string" == typeof t && t.match(/[\n\r]/) && (t = t.split(/\r\n|\r|\n/g)), "number" == typeof n && (s = n, n = null);
            var i = "",
                a = "Td";

            if (s) {
              s *= Math.PI / 180;
              var u = Math.cos(s),
                  c = Math.sin(s);
              i = [F(u), F(c), F(-1 * c), F(u), ""].join(" "), a = "Tm";
            }

            if (n = n || {}, "noBOM" in n || (n.noBOM = !0), "autoencode" in n || (n.autoencode = !0), "string" == typeof t) t = o(t);else {
              if (!(t instanceof Array)) throw new Error('Type of text must be string or Array. "' + t + '" is not recognized.');

              for (var l = t.concat(), m = [], y = l.length; y--;) {
                m.push(o(l.shift()));
              }

              t = m.join(") Tj\nT* (");
            }
            return N("BT\n/" + d + " " + q + " Tf\n" + q * x + " TL\n" + v + "\n" + i + F(e * h) + " " + F((w - r) * h) + " " + a + "\n(" + t + ") Tj\nET"), this;
          }, D.line = function (t, e, r, n) {
            return this.lines([[r - t, n - e]], t, e);
          }, D.lines = function (t, e, r, n, s, o) {
            var i, a, u, c, l, f, d, m, y, g, v;

            for ("number" == typeof t && (p = r, r = e, e = t, t = p), n = n || [1, 1], N(L(e * h) + " " + L((w - r) * h) + " m "), i = n[0], a = n[1], c = t.length, g = e, v = r, u = 0; c > u; u++) {
              l = t[u], 2 === l.length ? (g = l[0] * i + g, v = l[1] * a + v, N(L(g * h) + " " + L((w - v) * h) + " l")) : (f = l[0] * i + g, d = l[1] * a + v, m = l[2] * i + g, y = l[3] * a + v, g = l[4] * i + g, v = l[5] * a + v, N(L(f * h) + " " + L((w - d) * h) + " " + L(m * h) + " " + L((w - y) * h) + " " + L(g * h) + " " + L((w - v) * h) + " c"));
            }

            return o && N(" h"), null !== s && N(ce(s)), this;
          }, D.rect = function (t, e, r, n, s) {
            ce(s);
            return N([F(t * h), F((w - e) * h), F(r * h), F(-n * h), "re"].join(" ")), null !== s && N(ce(s)), this;
          }, D.triangle = function (t, e, r, n, s, o, i) {
            return this.lines([[r - t, n - e], [s - r, o - n], [t - s, e - o]], t, e, [1, 1], i, !0), this;
          }, D.roundedRect = function (t, e, r, n, s, o, i) {
            var a = 4 / 3 * (Math.SQRT2 - 1);
            return this.lines([[r - 2 * s, 0], [s * a, 0, s, o - o * a, s, o], [0, n - 2 * o], [0, o * a, -(s * a), o, -s, o], [-r + 2 * s, 0], [-(s * a), 0, -s, -(o * a), -s, -o], [0, -n + 2 * o], [0, -(o * a), s * a, -o, s, -o]], t + s, e, [1, 1], i), this;
          }, D.ellipse = function (t, e, r, n, s) {
            var o = 4 / 3 * (Math.SQRT2 - 1) * r,
                i = 4 / 3 * (Math.SQRT2 - 1) * n;
            return N([F((t + r) * h), F((w - e) * h), "m", F((t + r) * h), F((w - (e - i)) * h), F((t + o) * h), F((w - (e - n)) * h), F(t * h), F((w - (e - n)) * h), "c"].join(" ")), N([F((t - o) * h), F((w - (e - n)) * h), F((t - r) * h), F((w - (e - i)) * h), F((t - r) * h), F((w - e) * h), "c"].join(" ")), N([F((t - r) * h), F((w - (e + i)) * h), F((t - o) * h), F((w - (e + n)) * h), F(t * h), F((w - (e + n)) * h), "c"].join(" ")), N([F((t + o) * h), F((w - (e + n)) * h), F((t + r) * h), F((w - (e + i)) * h), F((t + r) * h), F((w - e) * h), "c"].join(" ")), null !== s && N(ce(s)), this;
          }, D.circle = function (t, e, r, n) {
            return this.ellipse(t, e, r, r, n);
          }, D.setProperties = function (t) {
            for (var e in R) {
              R.hasOwnProperty(e) && t[e] && (R[e] = t[e]);
            }

            return this;
          }, D.setFontSize = function (t) {
            return q = t, this;
          }, D.setFont = function (t, e) {
            return d = ae(t, e), this;
          }, D.setFontStyle = D.setFontType = function (t) {
            return d = ae(void 0, t), this;
          }, D.getFontList = function () {
            var t,
                e,
                r,
                n = {};

            for (t in E) {
              if (E.hasOwnProperty(t)) {
                n[t] = r = [];

                for (e in E[t]) {
                  E[t].hasOwnProperty(e) && r.push(e);
                }
              }
            }

            return n;
          }, D.setLineWidth = function (t) {
            return N((t * h).toFixed(2) + " w"), this;
          }, D.setDrawColor = function (t, e, r, n) {
            var s;
            return s = void 0 === e || void 0 === n && t === e === r ? "string" == typeof t ? t + " G" : F(t / 255) + " G" : void 0 === n ? "string" == typeof t ? [t, e, r, "RG"].join(" ") : [F(t / 255), F(e / 255), F(r / 255), "RG"].join(" ") : "string" == typeof t ? [t, e, r, n, "K"].join(" ") : [F(t), F(e), F(r), F(n), "K"].join(" "), N(s), this;
          }, D.setFillColor = function (t, e, r, n) {
            var s;
            return s = void 0 === e || void 0 === n && t === e === r ? "string" == typeof t ? t + " g" : F(t / 255) + " g" : void 0 === n ? "string" == typeof t ? [t, e, r, "rg"].join(" ") : [F(t / 255), F(e / 255), F(r / 255), "rg"].join(" ") : "string" == typeof t ? [t, e, r, n, "k"].join(" ") : [F(t), F(e), F(r), F(n), "k"].join(" "), N(s), this;
          }, D.setTextColor = function (t, e, r) {
            if ("string" == typeof t && /^#[0-9A-Fa-f]{6}$/.test(t)) {
              var n = parseInt(t.substr(1), 16);
              t = n >> 16 & 255, e = n >> 8 & 255, r = 255 & n;
            }

            return v = 0 === t && 0 === e && 0 === r || "undefined" == typeof e ? L(t / 255) + " g" : [L(t / 255), L(e / 255), L(r / 255), "rg"].join(" "), this;
          }, D.CapJoinStyles = {
            0: 0,
            butt: 0,
            but: 0,
            miter: 0,
            1: 1,
            round: 1,
            rounded: 1,
            circle: 1,
            2: 2,
            projecting: 2,
            project: 2,
            square: 2,
            bevel: 2
          }, D.setLineCap = function (t) {
            var e = this.CapJoinStyles[t];
            if (void 0 === e) throw new Error("Line cap style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            return B = e, N(e + " J"), this;
          }, D.setLineJoin = function (t) {
            var e = this.CapJoinStyles[t];
            if (void 0 === e) throw new Error("Line join style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            return O = e, N(e + " j"), this;
          }, D.output = de, D.save = function (t) {
            D.output("save", t);
          };

          for (var pe in r.API) {
            r.API.hasOwnProperty(pe) && ("events" === pe && r.API.events.length ? !function (t, e) {
              var r, n, s;

              for (s = e.length - 1; -1 !== s; s--) {
                r = e[s][0], n = e[s][1], t.subscribe.apply(t, [r].concat("function" == typeof n ? [n] : n));
              }
            }(U, r.API.events) : D[pe] = r.API[pe]);
          }

          return $(), d = "F1", ie(), U.publish("initialized"), D;
        }

        var o = "1.3",
            i = {
          a0: [2383.94, 3370.39],
          a1: [1683.78, 2383.94],
          a2: [1190.55, 1683.78],
          a3: [841.89, 1190.55],
          a4: [595.28, 841.89],
          a5: [419.53, 595.28],
          a6: [297.64, 419.53],
          a7: [209.76, 297.64],
          a8: [147.4, 209.76],
          a9: [104.88, 147.4],
          a10: [73.7, 104.88],
          b0: [2834.65, 4008.19],
          b1: [2004.09, 2834.65],
          b2: [1417.32, 2004.09],
          b3: [1000.63, 1417.32],
          b4: [708.66, 1000.63],
          b5: [498.9, 708.66],
          b6: [354.33, 498.9],
          b7: [249.45, 354.33],
          b8: [175.75, 249.45],
          b9: [124.72, 175.75],
          b10: [87.87, 124.72],
          c0: [2599.37, 3676.54],
          c1: [1836.85, 2599.37],
          c2: [1298.27, 1836.85],
          c3: [918.43, 1298.27],
          c4: [649.13, 918.43],
          c5: [459.21, 649.13],
          c6: [323.15, 459.21],
          c7: [229.61, 323.15],
          c8: [161.57, 229.61],
          c9: [113.39, 161.57],
          c10: [79.37, 113.39],
          dl: [311.81, 623.62],
          letter: [612, 792],
          "government-letter": [576, 756],
          legal: [612, 1008],
          "junior-legal": [576, 360],
          ledger: [1224, 792],
          tabloid: [792, 1224],
          "credit-card": [153, 243]
        };
        return r.API = {
          events: []
        }, r.version = "1.0.150-git 2014-05-30T00:40:diegocr",  t.jsPDF = r, r;
      }("undefined" != typeof self && self || "undefined" != typeof window && window || this);

      !function (t) {

        t.addHTML = function (t, e, r, n, s) {
          if ("undefined" == typeof html2canvas && "undefined" == typeof rasterizeHTML) throw new Error("You need either https://github.com/niklasvh/html2canvas or https://github.com/cburgmer/rasterizeHTML.js");
          "number" != typeof e && (n = e, s = r), "function" == typeof n && (s = n, n = null);
          var o = this.internal,
              i = o.scaleFactor,
              a = o.pageSize.width,
              u = o.pageSize.height;
          if (n = n || {}, n.onrendered = function (t) {
            e = parseInt(e) || 0, r = parseInt(r) || 0;
            var o = n.dim || {},
                c = o.h || 0,
                l = o.w || Math.min(a, t.width / i) - e,
                f = "JPEG";

            if (n.format && (f = n.format), t.height > u && n.pagesplit) {
              var d = function () {
                for (var n = 0;;) {
                  var o = document.createElement("canvas");
                  o.width = Math.min(a * i, t.width), o.height = Math.min(u * i, t.height - n);
                  var c = o.getContext("2d");
                  c.drawImage(t, 0, n, t.width, o.height, 0, 0, o.width, o.height);
                  var d = [o, e, n ? 0 : r, o.width / i, o.height / i, f, null, "SLOW"];
                  if (this.addImage.apply(this, d), n += o.height, n >= t.height) break;
                  this.addPage();
                }

                s(l, n, null, d);
              }.bind(this);

              if ("CANVAS" === t.nodeName) {
                var h = new Image();
                h.onload = d, h.src = t.toDataURL("image/png"), t = h;
              } else d();
            } else {
              var p = Math.random().toString(35),
                  m = [t, e, r, l, c, f, p, "SLOW"];
              this.addImage.apply(this, m), s(l, c, p, m);
            }
          }.bind(this), "undefined" != typeof html2canvas && !n.rstz) return html2canvas(t, n);

          if ("undefined" != typeof rasterizeHTML) {
            var c = "drawDocument";
            return "string" == typeof t && (c = /^http/.test(t) ? "drawURL" : "drawHTML"), n.width = n.width || a * i, rasterizeHTML[c](t, void 0, n).then(function (t) {
              n.onrendered(t.image);
            }, function (t) {
              s(null, t);
            });
          }

          return null;
        };
      }(r.API), function (t) {

        var e = "addImage_",
            r = ["jpeg", "jpg", "png"],
            n = function n(t) {
          var e = this.internal.newObject(),
              r = this.internal.write,
              s = this.internal.putStream;

          if (t.n = e, r("<</Type /XObject"), r("/Subtype /Image"), r("/Width " + t.w), r("/Height " + t.h), t.cs === this.color_spaces.INDEXED ? r("/ColorSpace [/Indexed /DeviceRGB " + (t.pal.length / 3 - 1) + " " + ("smask" in t ? e + 2 : e + 1) + " 0 R]") : (r("/ColorSpace /" + t.cs), t.cs === this.color_spaces.DEVICE_CMYK && r("/Decode [1 0 1 0 1 0 1 0]")), r("/BitsPerComponent " + t.bpc), "f" in t && r("/Filter /" + t.f), "dp" in t && r("/DecodeParms <<" + t.dp + ">>"), "trns" in t && t.trns.constructor == Array) {
            for (var o = "", i = 0, a = t.trns.length; a > i; i++) {
              o += t.trns[i] + " " + t.trns[i] + " ";
            }

            r("/Mask [" + o + "]");
          }

          if ("smask" in t && r("/SMask " + (e + 1) + " 0 R"), r("/Length " + t.data.length + ">>"), s(t.data), r("endobj"), "smask" in t) {
            var u = "/Predictor 15 /Colors 1 /BitsPerComponent " + t.bpc + " /Columns " + t.w,
                c = {
              w: t.w,
              h: t.h,
              cs: "DeviceGray",
              bpc: t.bpc,
              dp: u,
              data: t.smask
            };
            "f" in t && (c.f = t.f), n.call(this, c);
          }

          t.cs === this.color_spaces.INDEXED && (this.internal.newObject(), r("<< /Length " + t.pal.length + ">>"), s(this.arrayBufferToBinaryString(new Uint8Array(t.pal))), r("endobj"));
        },
            s = function s() {
          var t = this.internal.collections[e + "images"];

          for (var r in t) {
            n.call(this, t[r]);
          }
        },
            o = function o() {
          var t,
              r = this.internal.collections[e + "images"],
              n = this.internal.write;

          for (var s in r) {
            t = r[s], n("/I" + t.i, t.n, "0", "R");
          }
        },
            i = function i(e) {
          return e && "string" == typeof e && (e = e.toUpperCase()), e in t.image_compression ? e : t.image_compression.NONE;
        },
            a = function a() {
          var t = this.internal.collections[e + "images"];
          return t || (this.internal.collections[e + "images"] = t = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", o)), t;
        },
            u = function u(t) {
          var e = 0;
          return t && (e = Object.keys ? Object.keys(t).length : function (t) {
            var e = 0;

            for (var r in t) {
              t.hasOwnProperty(r) && e++;
            }

            return e;
          }(t)), e;
        },
            c = function c(t) {
          return "undefined" == typeof t || null === t;
        },
            l = function l() {
          return void 0;
        },
            f = function f(t) {
          return -1 === r.indexOf(t);
        },
            d = function d(e) {
          return "function" != typeof t["process" + e.toUpperCase()];
        },
            h = function h(t) {
          return "object" == _typeof(t) && 1 === t.nodeType;
        },
            p = function p(t, e) {
          if ("IMG" === t.nodeName && t.hasAttribute("src") && 0 === ("" + t.getAttribute("src")).indexOf("data:image/")) return t.getAttribute("src");
          if ("CANVAS" === t.nodeName) var r = t;else {
            var r = document.createElement("canvas");
            r.width = t.clientWidth || t.width, r.height = t.clientHeight || t.height;
            var n = r.getContext("2d");
            if (!n) throw "addImage requires canvas to be supported by browser.";
            n.drawImage(t, 0, 0, r.width, r.height);
          }
          return r.toDataURL("png" == e ? "image/png" : "image/jpeg");
        },
            m = function m(t, e) {
          var r;
          if (e) for (var n in e) {
            if (t === e[n].alias) {
              r = e[n];
              break;
            }
          }
          return r;
        },
            w = function w(t, e, r) {
          return t || e || (t = -96, e = -96), 0 > t && (t = -1 * r.w * 72 / t / this.internal.scaleFactor), 0 > e && (e = -1 * r.h * 72 / e / this.internal.scaleFactor), 0 === t && (t = e * r.w / r.h), 0 === e && (e = t * r.h / r.w), [t, e];
        },
            y = function y(t, e, r, n, s, o, i) {
          var a = w.call(this, r, n, s),
              u = this.internal.getCoordinateString,
              c = this.internal.getVerticalCoordinateString;
          r = a[0], n = a[1], i[o] = s, this.internal.write("q", u(r), "0 0", u(n), u(t), c(e + n), "cm /I" + s.i, "Do Q");
        };

        t.color_spaces = {
          DEVICE_RGB: "DeviceRGB",
          DEVICE_GRAY: "DeviceGray",
          DEVICE_CMYK: "DeviceCMYK",
          CAL_GREY: "CalGray",
          CAL_RGB: "CalRGB",
          LAB: "Lab",
          ICC_BASED: "ICCBased",
          INDEXED: "Indexed",
          PATTERN: "Pattern",
          SEPERATION: "Seperation",
          DEVICE_N: "DeviceN"
        }, t.decode = {
          DCT_DECODE: "DCTDecode",
          FLATE_DECODE: "FlateDecode",
          LZW_DECODE: "LZWDecode",
          JPX_DECODE: "JPXDecode",
          JBIG2_DECODE: "JBIG2Decode",
          ASCII85_DECODE: "ASCII85Decode",
          ASCII_HEX_DECODE: "ASCIIHexDecode",
          RUN_LENGTH_DECODE: "RunLengthDecode",
          CCITT_FAX_DECODE: "CCITTFaxDecode"
        }, t.image_compression = {
          NONE: "NONE",
          FAST: "FAST",
          MEDIUM: "MEDIUM",
          SLOW: "SLOW"
        }, t.isString = function (t) {
          return "string" == typeof t;
        }, t.extractInfoFromBase64DataURI = function (t) {
          return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(t);
        }, t.supportsArrayBuffer = function () {
          return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
        }, t.isArrayBuffer = function (t) {
          return this.supportsArrayBuffer() ? t instanceof ArrayBuffer : !1;
        }, t.isArrayBufferView = function (t) {
          return this.supportsArrayBuffer() ? "undefined" == typeof Uint32Array ? !1 : t instanceof Int8Array || t instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array : !1;
        }, t.binaryStringToUint8Array = function (t) {
          for (var e = t.length, r = new Uint8Array(e), n = 0; e > n; n++) {
            r[n] = t.charCodeAt(n);
          }

          return r;
        }, t.arrayBufferToBinaryString = function (t) {
          this.isArrayBuffer(t) && (t = new Uint8Array(t));

          for (var e = "", r = t.byteLength, n = 0; r > n; n++) {
            e += String.fromCharCode(t[n]);
          }

          return e;
        }, t.arrayBufferToBase64 = function (t) {
          for (var e, r, n, s, o, i = "", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = new Uint8Array(t), c = u.byteLength, l = c % 3, f = c - l, d = 0; f > d; d += 3) {
            o = u[d] << 16 | u[d + 1] << 8 | u[d + 2], e = (16515072 & o) >> 18, r = (258048 & o) >> 12, n = (4032 & o) >> 6, s = 63 & o, i += a[e] + a[r] + a[n] + a[s];
          }

          return 1 == l ? (o = u[f], e = (252 & o) >> 2, r = (3 & o) << 4, i += a[e] + a[r] + "==") : 2 == l && (o = u[f] << 8 | u[f + 1], e = (64512 & o) >> 10, r = (1008 & o) >> 4, n = (15 & o) << 2, i += a[e] + a[r] + a[n] + "="), i;
        }, t.createImageInfo = function (t, e, r, n, s, o, i, a, u, c, l, f) {
          var d = {
            alias: a,
            w: e,
            h: r,
            cs: n,
            bpc: s,
            i: i,
            data: t
          };
          return o && (d.f = o), u && (d.dp = u), c && (d.trns = c), l && (d.pal = l), f && (d.smask = f), d;
        }, t.addImage = function (t, e, n, s, o, w, g, v) {
          if ("number" == typeof e) {
            var b = w;
            w = o, o = s, s = n, n = e, e = b;
          }

          var q,
              x,
              k = a.call(this);

          if (v = i(v), e = (e || "JPEG").toLowerCase(), c(g) && (g = l()), h(t) && (t = p(t, e)), this.isString(t)) {
            var _ = this.extractInfoFromBase64DataURI(t);

            _ ? (e = _[2], t = atob(_[3]), this.supportsArrayBuffer() && (x = t, t = this.binaryStringToUint8Array(t))) : 255 !== t.charCodeAt(0) && (q = m(t, k));
          }

          if (f(e)) throw new Error("addImage currently only supports formats " + r + ", not '" + e + "'");
          if (d(e)) throw new Error("please ensure that the plugin for '" + e + "' support is added");
          var A = u(k),
              C = q;
          if (C || (C = this["process" + e.toUpperCase()](t, A, g, v, x)), !C) throw new Error("An unkwown error occurred whilst processing the image");
          return y.call(this, n, s, o, w, C, A, k), this;
        };

        var g = function g(t) {
          var e, r;
          if (255 === !t.charCodeAt(0) || 216 === !t.charCodeAt(1) || 255 === !t.charCodeAt(2) || 224 === !t.charCodeAt(3) || !t.charCodeAt(6) === "J".charCodeAt(0) || !t.charCodeAt(7) === "F".charCodeAt(0) || !t.charCodeAt(8) === "I".charCodeAt(0) || !t.charCodeAt(9) === "F".charCodeAt(0) || 0 === !t.charCodeAt(10)) throw new Error("getJpegSize requires a binary string jpeg file");

          for (var n = 256 * t.charCodeAt(4) + t.charCodeAt(5), s = 4, o = t.length; o > s;) {
            if (s += n, 255 !== t.charCodeAt(s)) throw new Error("getJpegSize could not find the size of the image");
            if (192 === t.charCodeAt(s + 1) || 193 === t.charCodeAt(s + 1) || 194 === t.charCodeAt(s + 1) || 195 === t.charCodeAt(s + 1) || 196 === t.charCodeAt(s + 1) || 197 === t.charCodeAt(s + 1) || 198 === t.charCodeAt(s + 1) || 199 === t.charCodeAt(s + 1)) return r = 256 * t.charCodeAt(s + 5) + t.charCodeAt(s + 6), e = 256 * t.charCodeAt(s + 7) + t.charCodeAt(s + 8), [e, r];
            s += 2, n = 256 * t.charCodeAt(s) + t.charCodeAt(s + 1);
          }
        },
            v = function v(t) {
          var e = t[0] << 8 | t[1];
          if (65496 !== e) throw new Error("Supplied data is not a JPEG");

          for (var r, n, s, o = t.length, i = (t[4] << 8) + t[5], a = 4; o > a;) {
            if (a += i, r = b(t, a), i = (r[2] << 8) + r[3], (192 === r[1] || 194 === r[1]) && 255 === r[0] && i > 7) return r = b(t, a + 5), n = (r[2] << 8) + r[3], s = (r[0] << 8) + r[1], {
              width: n,
              height: s
            };
            a += 2;
          }

          throw new Error("getJpegSizeFromBytes could not find the size of the image");
        },
            b = function b(t, e) {
          return t.subarray(e, e + 4);
        };

        t.processJPEG = function (t, e, r, n, s) {
          var o,
              i = this.color_spaces.DEVICE_RGB,
              a = this.decode.DCT_DECODE,
              u = 8;
          return this.isString(t) ? (o = g(t), this.createImageInfo(t, o[0], o[1], i, u, a, e, r)) : (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t) ? (o = v(t), t = s || this.arrayBufferToBinaryString(t), this.createImageInfo(t, o.width, o.height, i, u, a, e, r)) : null);
        }, t.processJPG = function () {
          return this.processJPEG.apply(this, arguments);
        };
      }(r.API), function (t) {

        t.autoPrint = function () {
          var t;
          return this.internal.events.subscribe("postPutResources", function () {
            t = this.internal.newObject(), this.internal.write("<< /S/Named /Type/Action /N/Print >>", "endobj");
          }), this.internal.events.subscribe("putCatalog", function () {
            this.internal.write("/OpenAction " + t + " 0 R");
          }), this;
        };
      }(r.API), function (t) {

        var e,
            r,
            n,
            s,
            o = 3,
            i = 13,
            a = {
          x: void 0,
          y: void 0,
          w: void 0,
          h: void 0,
          ln: void 0
        },
            u = 1,
            c = function c(t, e, r, n, s) {
          a = {
            x: t,
            y: e,
            w: r,
            h: n,
            ln: s
          };
        },
            l = function l() {
          return a;
        },
            f = {
          left: 0,
          top: 0,
          bottom: 0
        };

        t.setHeaderFunction = function (t) {
          s = t;
        }, t.getTextDimensions = function (t) {
          e = this.internal.getFont().fontName, r = this.table_font_size || this.internal.getFontSize(), n = this.internal.getFont().fontStyle;
          var s,
              o,
              i = 19.049976 / 25.4;
          return o = document.createElement("font"), o.id = "jsPDFCell", o.style.fontStyle = n, o.style.fontName = e, o.style.fontSize = r + "pt", o.innerText = t, document.body.appendChild(o), s = {
            w: (o.offsetWidth + 1) * i,
            h: (o.offsetHeight + 1) * i
          }, document.body.removeChild(o), s;
        }, t.cellAddPage = function () {
          var t = this.margins || f;
          this.addPage(), c(t.left, t.top, void 0, void 0), u += 1;
        }, t.cellInitialize = function () {
          a = {
            x: void 0,
            y: void 0,
            w: void 0,
            h: void 0,
            ln: void 0
          }, u = 1;
        }, t.cell = function (t, e, r, n, s, a, u) {
          var d = l();
          if (void 0 !== d.ln) if (d.ln === a) t = d.x + d.w, e = d.y;else {
            var h = this.margins || f;
            d.y + d.h + n + i >= this.internal.pageSize.height - h.bottom && (this.cellAddPage(), this.printHeaders && this.tableHeaderRow && this.printHeaderRow(a, !0)), e = l().y + l().h;
          }
          if (void 0 !== s[0]) if (this.printingHeaderRow ? this.rect(t, e, r, n, "FD") : this.rect(t, e, r, n), "right" === u) {
            if (s instanceof Array) for (var p = 0; p < s.length; p++) {
              var m = s[p],
                  w = this.getStringUnitWidth(m) * this.internal.getFontSize();
              this.text(m, t + r - w - o, e + this.internal.getLineHeight() * (p + 1));
            }
          } else this.text(s, t + o, e + this.internal.getLineHeight());
          return c(t, e, r, n, a), this;
        }, t.arrayMax = function (t, e) {
          var r,
              n,
              s,
              o = t[0];

          for (r = 0, n = t.length; n > r; r += 1) {
            s = t[r], e ? -1 === e(o, s) && (o = s) : s > o && (o = s);
          }

          return o;
        }, t.table = function (e, r, n, s, o) {
          if (!n) throw "No data for PDF table";
          var i,
              c,
              l,
              d,
              h,
              p,
              m,
              w,
              y,
              g,
              v = [],
              b = [],
              q = {},
              x = {},
              k = [],
              _ = [],
              A = !1,
              C = !0,
              S = 12,
              E = f;
          if (E.width = this.internal.pageSize.width, o && (o.autoSize === !0 && (A = !0), o.printHeaders === !1 && (C = !1), o.fontSize && (S = o.fontSize), o.margins && (E = o.margins)), this.lnMod = 0, a = {
            x: void 0,
            y: void 0,
            w: void 0,
            h: void 0,
            ln: void 0
          }, u = 1, this.printHeaders = C, this.margins = E, this.setFontSize(S), this.table_font_size = S, void 0 === s || null === s) v = Object.keys(n[0]);else if (s[0] && "string" != typeof s[0]) {
            var z = 19.049976 / 25.4;

            for (c = 0, l = s.length; l > c; c += 1) {
              i = s[c], v.push(i.name), b.push(i.prompt), x[i.name] = i.width * z;
            }
          } else v = s;
          if (A) for (g = function g(t) {
            return t[i];
          }, c = 0, l = v.length; l > c; c += 1) {
            for (i = v[c], q[i] = n.map(g), k.push(this.getTextDimensions(b[c] || i).w), p = q[i], m = 0, d = p.length; d > m; m += 1) {
              h = p[m], k.push(this.getTextDimensions(h).w);
            }

            x[i] = t.arrayMax(k);
          }

          if (C) {
            var I = this.calculateLineHeight(v, x, b.length ? b : v);

            for (c = 0, l = v.length; l > c; c += 1) {
              i = v[c], _.push([e, r, x[i], I, String(b.length ? b[c] : i)]);
            }

            this.setTableHeaderRow(_), this.printHeaderRow(1, !1);
          }

          for (c = 0, l = n.length; l > c; c += 1) {
            var I;

            for (w = n[c], I = this.calculateLineHeight(v, x, w), m = 0, y = v.length; y > m; m += 1) {
              i = v[m], this.cell(e, r, x[i], I, w[i], c + 2, i.align);
            }
          }

          return this.lastCellPos = a, this.table_x = e, this.table_y = r, this;
        }, t.calculateLineHeight = function (t, e, r) {
          for (var n, s = 0, i = 0; i < t.length; i++) {
            n = t[i], r[n] = this.splitTextToSize(String(r[n]), e[n] - o);
            var a = this.internal.getLineHeight() * r[n].length + o;
            a > s && (s = a);
          }

          return s;
        }, t.setTableHeaderRow = function (t) {
          this.tableHeaderRow = t;
        }, t.printHeaderRow = function (t, e) {
          if (!this.tableHeaderRow) throw "Property tableHeaderRow does not exist.";
          var r, n, o, i;

          if (this.printingHeaderRow = !0, void 0 !== s) {
            var a = s(this, u);
            c(a[0], a[1], a[2], a[3], -1);
          }

          this.setFontStyle("bold");
          var l = [];

          for (o = 0, i = this.tableHeaderRow.length; i > o; o += 1) {
            this.setFillColor(200, 200, 200), r = this.tableHeaderRow[o], e && (r[1] = this.margins && this.margins.top || 0, l.push(r)), n = [].concat(r), this.cell.apply(this, n.concat(t));
          }

          l.length > 0 && this.setTableHeaderRow(l), this.setFontStyle("normal"), this.printingHeaderRow = !1;
        };
      }(r.API), function (t) {
        var e, _r, n, s, o, i, a, u, c, l, f, d, h, p, m, w, y;

        e = function () {
          function t() {}

          return function (e) {
            return t.prototype = e, new t();
          };
        }(), a = function a(t) {
          var e, r, n, s, o, i, a;

          for (r = 0, n = t.length, e = void 0, s = !1, i = !1; !s && r !== n;) {
            e = t[r] = t[r].trimLeft(), e && (s = !0), r++;
          }

          for (r = n - 1; n && !i && -1 !== r;) {
            e = t[r] = t[r].trimRight(), e && (i = !0), r--;
          }

          for (o = /\s+$/g, a = !0, r = 0; r !== n;) {
            e = t[r].replace(/\s+/g, " "), a && (e = e.trimLeft()), e && (a = o.test(e)), t[r] = e, r++;
          }

          return t;
        }, u = function u(t, e, r, n) {
          return this.pdf = t, this.x = e, this.y = r, this.settings = n, this.init(), this;
        }, c = function c(t) {
          var e, r, s;

          for (e = void 0, s = t.split(","), r = s.shift(); !e && r;) {
            e = n[r.trim().toLowerCase()], r = s.shift();
          }

          return e;
        }, l = function l(t) {
          t = "auto" === t ? "0px" : t, t.indexOf("em") > -1 && !isNaN(Number(t.replace("em", ""))) && (t = 18.719 * Number(t.replace("em", "")) + "px"), t.indexOf("pt") > -1 && !isNaN(Number(t.replace("pt", ""))) && (t = 1.333 * Number(t.replace("pt", "")) + "px");
          var e, r, n;
          return r = void 0, e = 16, (n = f[t]) ? n : (n = {
            "xx-small": 9,
            "x-small": 11,
            small: 13,
            medium: 16,
            large: 19,
            "x-large": 23,
            "xx-large": 28,
            auto: 0
          }[{
            css_line_height_string: t
          }], n !== r ? f[t] = n / e : (n = parseFloat(t)) ? f[t] = n / e : (n = t.match(/([\d\.]+)(px)/), f[t] = 3 === n.length ? parseFloat(n[1]) / e : 1));
        }, i = function i(t) {
          var e, r, n;
          return n = function (t) {
            var e;
            return e = function (t) {
              return document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(t, null) : t.currentStyle ? t.currentStyle : t.style;
            }(t), function (t) {
              return t = t.replace(/-\D/g, function (t) {
                return t.charAt(1).toUpperCase();
              }), e[t];
            };
          }(t), e = {}, r = void 0, e["font-family"] = c(n("font-family")) || "times", e["font-style"] = s[n("font-style")] || "normal", e["text-align"] = TextAlignMap[n("text-align")] || "left", r = o[n("font-weight")] || "normal", "bold" === r && (e["font-style"] = "normal" === e["font-style"] ? r : r + e["font-style"]), e["font-size"] = l(n("font-size")) || 1, e["line-height"] = l(n("line-height")) || 1, e.display = "inline" === n("display") ? "inline" : "block", "block" === e.display && (e["margin-top"] = l(n("margin-top")) || 0, e["margin-bottom"] = l(n("margin-bottom")) || 0, e["padding-top"] = l(n("padding-top")) || 0, e["padding-bottom"] = l(n("padding-bottom")) || 0, e["margin-left"] = l(n("margin-left")) || 0, e["margin-right"] = l(n("margin-right")) || 0, e["padding-left"] = l(n("padding-left")) || 0, e["padding-right"] = l(n("padding-right")) || 0), e;
        }, d = function d(t, e, r) {
          var n, s, o, i;
          if (o = !1, s = void 0, i = void 0, n = r["#" + t.id]) if ("function" == typeof n) o = n(t, e);else for (s = 0, i = n.length; !o && s !== i;) {
            o = n[s](t, e), s++;
          }
          if (n = r[t.nodeName], !o && n) if ("function" == typeof n) o = n(t, e);else for (s = 0, i = n.length; !o && s !== i;) {
            o = n[s](t, e), s++;
          }
          return o;
        }, y = function y(t, e) {
          var r, n, s, o, i, a, u, c, l, f;

          for (r = [], n = [], s = 0, f = t.rows[0].cells.length, c = t.clientWidth; f > s;) {
            l = t.rows[0].cells[s], n[s] = {
              name: l.textContent.toLowerCase().replace(/\s+/g, ""),
              prompt: l.textContent.replace(/\r?\n/g, ""),
              width: l.clientWidth / c * e.pdf.internal.pageSize.width
            }, s++;
          }

          for (s = 1; s < t.rows.length;) {
            for (a = t.rows[s], i = {}, o = 0; o < a.cells.length;) {
              i[n[o].name] = a.cells[o].textContent.replace(/\r?\n/g, ""), o++;
            }

            r.push(i), s++;
          }

          return u = {
            rows: r,
            headers: n
          };
        };
        var g = {
          SCRIPT: 1,
          STYLE: 1,
          NOSCRIPT: 1,
          OBJECT: 1,
          EMBED: 1,
          SELECT: 1
        },
            v = 1;
        _r = function r(t, e, n) {
          var s, o, a, u, c, l, p, m;

          for (o = t.childNodes, s = void 0, a = i(t), c = "block" === a.display, c && (e.setBlockBoundary(), e.setBlockStyle(a)), u = 0, l = o.length; l > u;) {
            if (s = o[u], "object" == _typeof(s)) {
              if (1 === s.nodeType && "HEADER" === s.nodeName) {
                var w = s,
                    b = e.pdf.margins_doc.top;
                e.pdf.internal.events.subscribe("addPage", function () {
                  e.y = b, _r(w, e, n), e.pdf.margins_doc.top = e.y + 10, e.y += 10;
                }, !1);
              }

              if (8 === s.nodeType && "#comment" === s.nodeName) ~s.textContent.indexOf("ADD_PAGE") && (e.pdf.addPage(), e.y = e.pdf.margins_doc.top);else if (1 !== s.nodeType || g[s.nodeName]) {
                if (3 === s.nodeType) {
                  var q = s.nodeValue;
                  if (s.nodeValue && "LI" === s.parentNode.nodeName) if ("OL" === s.parentNode.parentNode.nodeName) q = v++ + ". " + q;else {
                    var x = 16 * a["font-size"],
                        k = 2;
                    x > 20 && (k = 3), m = function m(t, e) {
                      this.pdf.circle(t, e, k, "FD");
                    };
                  }
                  e.addText(q, a);
                } else "string" == typeof s && e.addText(s, a);
              } else if ("IMG" === s.nodeName && h[s.getAttribute("src")]) e.pdf.internal.pageSize.height - e.pdf.margins_doc.bottom < e.y + s.height && e.y > e.pdf.margins_doc.top && (e.pdf.addPage(), e.y = e.pdf.margins_doc.top), e.pdf.addImage(h[s.getAttribute("src")], e.x, e.y, s.width, s.height), e.y += s.height;else if ("TABLE" === s.nodeName) p = y(s, e), e.y += 10, e.pdf.table(e.x, e.y, p.rows, p.headers, {
                autoSize: !1,
                printHeaders: !0,
                margins: e.pdf.margins_doc
              }), e.y = e.pdf.lastCellPos.y + e.pdf.lastCellPos.h + 20;else if ("OL" === s.nodeName || "UL" === s.nodeName) v = 1, d(s, e, n) || _r(s, e, n), e.y += 10;else if ("LI" === s.nodeName) {
                var _ = e.x;
                e.x += "UL" === s.parentNode.nodeName ? 22 : 10, e.y += 3, d(s, e, n) || _r(s, e, n), e.x = _;
              } else d(s, e, n) || _r(s, e, n);
            }

            u++;
          }

          return c ? e.setBlockBoundary(m) : void 0;
        }, h = {}, p = function p(t, e, r, n) {
          function s() {
            e.pdf.internal.events.publish("imagesLoaded"), n();
          }

          function o(t, e, r) {
            if (t) {
              var n = new Image();
              ++u, n.crossOrigin = "", n.onerror = n.onload = function () {
                n.complete && (0 === n.src.indexOf("data:image/") && (n.width = e || n.width || 0, n.height = r || n.height || 0), n.width + n.height && (h[t] = h[t] || n)), --u || s();
              }, n.src = t;
            }
          }

          for (var i = t.getElementsByTagName("img"), a = i.length, u = 0; a--;) {
            o(i[a].getAttribute("src"), i[a].width, i[a].height);
          }

          return u || s();
        }, m = function m(t, e, n, s) {
          var o = t.getElementsByTagName("footer");

          if (o.length > 0) {
            o = o[0];
            var i = e.pdf.internal.write,
                a = e.y;
            e.pdf.internal.write = function () {}, _r(o, e, n);
            var u = Math.ceil(e.y - a) + 5;
            e.y = a, e.pdf.internal.write = i, e.pdf.margins_doc.bottom += u;

            for (var c = function c(t) {
              var s = void 0 !== t ? t.pageNumber : 1,
                  i = e.y;
              e.y = e.pdf.internal.pageSize.height - e.pdf.margins_doc.bottom, e.pdf.margins_doc.bottom -= u;

              for (var a = o.getElementsByTagName("span"), c = 0; c < a.length; ++c) {
                (" " + a[c].className + " ").replace(/[\n\t]/g, " ").indexOf(" pageCounter ") > -1 && (a[c].innerHTML = s), (" " + a[c].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1 && (a[c].innerHTML = "###jsPDFVarTotalPages###");
              }

              _r(o, e, n), e.pdf.margins_doc.bottom += u, e.y = i;
            }, l = o.getElementsByTagName("span"), f = 0; f < l.length; ++f) {
              (" " + l[f].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1 && e.pdf.internal.events.subscribe("htmlRenderingFinished", e.pdf.putTotalPages.bind(e.pdf, "###jsPDFVarTotalPages###"), !0);
            }

            e.pdf.internal.events.subscribe("addPage", c, !1), c(), g.FOOTER = 1;
          }

          s();
        }, w = function w(t, e, n, s, o, i) {
          if (!e) return !1;
          "string" == typeof e || e.parentNode || (e = "" + e.innerHTML), "string" == typeof e && (e = function (t) {
            var e, r, n, s;
            return n = "jsPDFhtmlText" + Date.now().toString() + (1e3 * Math.random()).toFixed(0), s = "position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;", r = document.createElement("div"), r.style.cssText = s, r.innerHTML = '<iframe style="height:1px;width:1px" name="' + n + '" />', document.body.appendChild(r), e = window.frames[n], e.document.body.innerHTML = t, e.document.body;
          }(e.replace(/<\/?script[^>]*?>/gi, "")));
          var a = new u(t, n, s, o);
          return i = i || function () {}, p.call(this, e, a, o.elementHandlers, function () {
            m.call(this, e, a, o.elementHandlers, function () {
              _r(e, a, o.elementHandlers), a.pdf.internal.events.publish("htmlRenderingFinished"), i(a.dispose());
            });
          }), a.dispose();
        }, u.prototype.init = function () {
          return this.paragraph = {
            text: [],
            style: []
          }, this.pdf.internal.write("q");
        }, u.prototype.dispose = function () {
          return this.pdf.internal.write("Q"), {
            x: this.x,
            y: this.y
          };
        }, u.prototype.splitFragmentsIntoLines = function (t, r) {
          var n, s, o, i, a, u, c, l, f, d, h, p, m, w, y;

          for (s = 12, h = this.pdf.internal.scaleFactor, a = {}, o = void 0, d = void 0, i = void 0, u = void 0, y = void 0, f = void 0, l = void 0, c = void 0, p = [], m = [p], n = 0, w = this.settings.width; t.length;) {
            if (u = t.shift(), y = r.shift(), u) if (o = y["font-family"], d = y["font-style"], i = a[o + d], i || (i = this.pdf.internal.getFont(o, d).metadata.Unicode, a[o + d] = i), f = {
              widths: i.widths,
              kerning: i.kerning,
              fontSize: y["font-size"] * s,
              textIndent: n
            }, l = this.pdf.getStringUnitWidth(u, f) * f.fontSize / h, n + l > w) {
              for (c = this.pdf.splitTextToSize(u, w, f), p.push([c.shift(), y]); c.length;) {
                p = [[c.shift(), y]], m.push(p);
              }

              n = this.pdf.getStringUnitWidth(p[0][0], f) * f.fontSize / h;
            } else p.push([u, y]), n += l;
          }

          if (void 0 !== y["text-align"] && ("center" === y["text-align"] || "right" === y["text-align"] || "justify" === y["text-align"])) for (var g = 0; g < m.length; ++g) {
            var v = this.pdf.getStringUnitWidth(m[g][0][0], f) * f.fontSize / h;
            g > 0 && (m[g][0][1] = e(m[g][0][1]));
            var b = w - v;
            if ("right" === y["text-align"]) m[g][0][1]["margin-left"] = b;else if ("center" === y["text-align"]) m[g][0][1]["margin-left"] = b / 2;else if ("justify" === y["text-align"]) {
              var q = m[g][0][0].split(" ").length - 1;
              m[g][0][1]["word-spacing"] = b / q, g === m.length - 1 && (m[g][0][1]["word-spacing"] = 0);
            }
          }
          return m;
        }, u.prototype.RenderTextFragment = function (t, e) {
          var r, n;
          this.pdf.internal.pageSize.height - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize() && (this.pdf.internal.write("ET", "Q"), this.pdf.addPage(), this.y = this.pdf.margins_doc.top, this.pdf.internal.write("q", "BT", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td")), r = 12, n = this.pdf.internal.getFont(e["font-family"], e["font-style"]), void 0 !== e["word-spacing"] && e["word-spacing"] > 0 && this.pdf.internal.write(e["word-spacing"].toFixed(2), "Tw"), this.pdf.internal.write("/" + n.id, (r * e["font-size"]).toFixed(2), "Tf", "(" + this.pdf.internal.pdfEscape(t) + ") Tj"), void 0 !== e["word-spacing"] && this.pdf.internal.write(0, "Tw");
        }, u.prototype.renderParagraph = function (t) {
          var e, r, n, s, o, i, u, c, l, f, d, h, p, m, w;

          if (s = a(this.paragraph.text), m = this.paragraph.style, e = this.paragraph.blockstyle, p = this.paragraph.blockstyle || {}, this.paragraph = {
            text: [],
            style: [],
            blockstyle: {},
            priorblockstyle: e
          }, s.join("").trim()) {
            c = this.splitFragmentsIntoLines(s, m), u = void 0, l = void 0, r = 12, n = r / this.pdf.internal.scaleFactor, h = (Math.max((e["margin-top"] || 0) - (p["margin-bottom"] || 0), 0) + (e["padding-top"] || 0)) * n, d = ((e["margin-bottom"] || 0) + (e["padding-bottom"] || 0)) * n, f = this.pdf.internal.write, o = void 0, i = void 0, this.y += h, f("q", "BT", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");

            for (var y = 0; c.length;) {
              for (u = c.shift(), l = 0, o = 0, i = u.length; o !== i;) {
                u[o][0].trim() && (l = Math.max(l, u[o][1]["line-height"], u[o][1]["font-size"]), w = 7 * u[o][1]["font-size"]), o++;
              }

              var g = 0;

              for (void 0 !== u[0][1]["margin-left"] && u[0][1]["margin-left"] > 0 && (wantedIndent = this.pdf.internal.getCoordinateString(u[0][1]["margin-left"]), g = wantedIndent - y, y = wantedIndent), f(g, (-1 * r * l).toFixed(2), "Td"), o = 0, i = u.length; o !== i;) {
                u[o][0] && this.RenderTextFragment(u[o][0], u[o][1]), o++;
              }

              this.y += l * n;
            }

            return t && "function" == typeof t && t.call(this, this.x - 9, this.y - w / 2), f("ET", "Q"), this.y += d;
          }
        }, u.prototype.setBlockBoundary = function (t) {
          return this.renderParagraph(t);
        }, u.prototype.setBlockStyle = function (t) {
          return this.paragraph.blockstyle = t;
        }, u.prototype.addText = function (t, e) {
          return this.paragraph.text.push(t), this.paragraph.style.push(e);
        }, n = {
          helvetica: "helvetica",
          "sans-serif": "helvetica",
          "times new roman": "times",
          serif: "times",
          times: "times",
          monospace: "courier",
          courier: "courier"
        }, o = {
          100: "normal",
          200: "normal",
          300: "normal",
          400: "normal",
          500: "bold",
          600: "bold",
          700: "bold",
          800: "bold",
          900: "bold",
          normal: "normal",
          bold: "bold",
          bolder: "bold",
          lighter: "normal"
        }, s = {
          normal: "normal",
          italic: "italic",
          oblique: "italic"
        }, TextAlignMap = {
          left: "left",
          right: "right",
          center: "center",
          justify: "justify"
        }, f = {
          normal: 1
        }, t.fromHTML = function (t, e, r, n, s, o) {

          return this.margins_doc = o || {
            top: 0,
            bottom: 0
          }, n || (n = {}), n.elementHandlers || (n.elementHandlers = {}), w(this, t, e || 4, r || 4, n, s);
        };
      }(r.API), function (t) {

        var e, r, n;

        t.addJS = function (t) {
          return n = t, this.internal.events.subscribe("postPutResources", function () {
            e = this.internal.newObject(), this.internal.write("<< /Names [(EmbeddedJS) " + (e + 1) + " 0 R] >>", "endobj"), r = this.internal.newObject(), this.internal.write("<< /S /JavaScript /JS (", n, ") >>", "endobj");
          }), this.internal.events.subscribe("putCatalog", function () {
            void 0 !== e && void 0 !== r && this.internal.write("/Names <</JavaScript " + e + " 0 R>>");
          }), this;
        };
      }(r.API), function (t) {

        var e = function e() {
          return "function" != typeof PNG || "function" != typeof i;
        },
            r = function r(e) {
          return e !== t.image_compression.NONE && n();
        },
            n = function n() {
          var t = "function" == typeof s;
          if (!t) throw new Error("requires deflate.js for compression");
          return t;
        },
            o = function o(e, r, n, _o) {
          var i = 5,
              l = d;

          switch (_o) {
            case t.image_compression.FAST:
              i = 3, l = f;
              break;

            case t.image_compression.MEDIUM:
              i = 6, l = h;
              break;

            case t.image_compression.SLOW:
              i = 9, l = p;
          }

          e = c(e, r, n, l);
          var m = new Uint8Array(a()),
              w = u(e),
              y = new s(i),
              g = y.append(e),
              v = y.flush(),
              b = m.length + g.length + v.length,
              q = new Uint8Array(b + 4);
          return q.set(m), q.set(g, m.length), q.set(v, m.length + g.length), q[b++] = w >>> 24 & 255, q[b++] = w >>> 16 & 255, q[b++] = w >>> 8 & 255, q[b++] = 255 & w, t.arrayBufferToBinaryString(q);
        },
            a = function a(t, e) {
          var r = 8,
              n = Math.LOG2E * Math.log(32768) - 8,
              s = n << 4 | r,
              o = s << 8,
              i = Math.min(3, (e - 1 & 255) >> 1);
          return o |= i << 6, o |= 0, o += 31 - o % 31, [s, 255 & o & 255];
        },
            u = function u(t, e) {
          for (var r, n = 1, s = 65535 & n, o = n >>> 16 & 65535, i = t.length, a = 0; i > 0;) {
            r = i > e ? e : i, i -= r;

            do {
              s += t[a++], o += s;
            } while (--r);

            s %= 65521, o %= 65521;
          }

          return (o << 16 | s) >>> 0;
        },
            c = function c(t, e, r, n) {
          for (var s, o, i, a = t.length / e, u = new Uint8Array(t.length + a), c = w(), l = 0; a > l; l++) {
            if (i = l * e, s = t.subarray(i, i + e), n) u.set(n(s, r, o), i + l);else {
              for (var f = 0, d = c.length, h = []; d > f; f++) {
                h[f] = c[f](s, r, o);
              }

              var p = y(h.concat());
              u.set(h[p], i + l);
            }
            o = s;
          }

          return u;
        },
            l = function l(t) {
          var e = Array.apply([], t);
          return e.unshift(0), e;
        },
            f = function f(t, e) {
          var r,
              n = [],
              s = 0,
              o = t.length;

          for (n[0] = 1; o > s; s++) {
            r = t[s - e] || 0, n[s + 1] = t[s] - r + 256 & 255;
          }

          return n;
        },
            d = function d(t, e, r) {
          var n,
              s = [],
              o = 0,
              i = t.length;

          for (s[0] = 2; i > o; o++) {
            n = r && r[o] || 0, s[o + 1] = t[o] - n + 256 & 255;
          }

          return s;
        },
            h = function h(t, e, r) {
          var n,
              s,
              o = [],
              i = 0,
              a = t.length;

          for (o[0] = 3; a > i; i++) {
            n = t[i - e] || 0, s = r && r[i] || 0, o[i + 1] = t[i] + 256 - (n + s >>> 1) & 255;
          }

          return o;
        },
            p = function p(t, e, r) {
          var n,
              s,
              o,
              i,
              a = [],
              u = 0,
              c = t.length;

          for (a[0] = 4; c > u; u++) {
            n = t[u - e] || 0, s = r && r[u] || 0, o = r && r[u - e] || 0, i = m(n, s, o), a[u + 1] = t[u] - i + 256 & 255;
          }

          return a;
        },
            m = function m(t, e, r) {
          var n = t + e - r,
              s = Math.abs(n - t),
              o = Math.abs(n - e),
              i = Math.abs(n - r);
          return o >= s && i >= s ? t : i >= o ? e : r;
        },
            w = function w() {
          return [l, f, d, h, p];
        },
            y = function y(t) {
          for (var e, r, n, s = 0, o = t.length; o > s;) {
            e = g(t[s].slice(1)), (r > e || !r) && (r = e, n = s), s++;
          }

          return n;
        },
            g = function g(t) {
          for (var e = 0, r = t.length, n = 0; r > e;) {
            n += Math.abs(t[e++]);
          }

          return n;
        };

        t.processPNG = function (t, n, s, i) {
          var a,
              u,
              c,
              l,
              f,
              d,
              h = this.color_spaces.DEVICE_RGB,
              p = this.decode.FLATE_DECODE,
              m = 8;

          if (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t)) {
            if (e()) throw new Error("PNG support requires png.js and zlib.js");

            if (a = new PNG(t), t = a.imgData, m = a.bits, h = a.colorSpace, l = a.colors, -1 !== [4, 6].indexOf(a.colorType)) {
              if (8 === a.bits) for (var w, y, g = window["Uint" + a.pixelBitlength + "Array"], v = new g(a.decodePixels().buffer), b = v.length, q = new Uint8Array(b * a.colors), x = new Uint8Array(b), k = a.pixelBitlength - a.bits, _ = 0, A = 0; b > _; _++) {
                for (w = v[_], y = 0; k > y;) {
                  q[A++] = w >>> y & 255, y += a.bits;
                }

                x[_] = w >>> y & 255;
              }

              if (16 === a.bits) {
                for (var w, v = new Uint32Array(a.decodePixels().buffer), b = v.length, q = new Uint8Array(b * (32 / a.pixelBitlength) * a.colors), x = new Uint8Array(b * (32 / a.pixelBitlength)), C = a.colors > 1, _ = 0, A = 0, S = 0; b > _;) {
                  w = v[_++], q[A++] = w >>> 0 & 255, C && (q[A++] = w >>> 16 & 255, w = v[_++], q[A++] = w >>> 0 & 255), x[S++] = w >>> 16 & 255;
                }

                m = 8;
              }

              r(i) ? (t = o(q, a.width * a.colors, a.colors, i), d = o(x, a.width, 1, i)) : (t = q, d = x, p = null);
            }

            if (3 === a.colorType && (h = this.color_spaces.INDEXED, f = a.palette, a.transparency.indexed)) {
              for (var E = a.transparency.indexed, z = 0, _ = 0, b = E.length; b > _; ++_) {
                z += E[_];
              }

              if (z /= 255, z === b - 1 && -1 !== E.indexOf(0)) c = [E.indexOf(0)];else if (z !== b) {
                for (var v = a.decodePixels(), x = new Uint8Array(v.length), _ = 0, b = v.length; b > _; _++) {
                  x[_] = E[v[_]];
                }

                d = o(x, a.width, 1);
              }
            }

            return u = p === this.decode.FLATE_DECODE ? "/Predictor 15 /Colors " + l + " /BitsPerComponent " + m + " /Columns " + a.width : "/Colors " + l + " /BitsPerComponent " + m + " /Columns " + a.width, (this.isArrayBuffer(t) || this.isArrayBufferView(t)) && (t = this.arrayBufferToBinaryString(t)), (d && this.isArrayBuffer(d) || this.isArrayBufferView(d)) && (d = this.arrayBufferToBinaryString(d)), this.createImageInfo(t, a.width, a.height, h, m, p, n, s, u, c, f, d);
          }

          throw new Error("Unsupported PNG image data, try using JPEG instead.");
        };
      }(r.API), function (t) {

        t.addSVG = function (t, e, r, n, s) {
          function o(t, e) {
            var r = e.createElement("style");
            r.type = "text/css", r.styleSheet ? r.styleSheet.cssText = t : r.appendChild(e.createTextNode(t)), e.getElementsByTagName("head")[0].appendChild(r);
          }

          function i(t) {
            var e = "childframe",
                r = t.createElement("iframe");
            return o(".jsPDF_sillysvg_iframe {display:none;position:absolute;}", t), r.name = e, r.setAttribute("width", 0), r.setAttribute("height", 0), r.setAttribute("frameborder", "0"), r.setAttribute("scrolling", "no"), r.setAttribute("seamless", "seamless"), r.setAttribute("class", "jsPDF_sillysvg_iframe"), t.body.appendChild(r), r;
          }

          function a(t, e) {
            var r = (e.contentWindow || e.contentDocument).document;
            return r.write(t), r.close(), r.getElementsByTagName("svg")[0];
          }

          function u(t) {
            for (var e = parseFloat(t[1]), r = parseFloat(t[2]), n = [], s = 3, o = t.length; o > s;) {
              "c" === t[s] ? (n.push([parseFloat(t[s + 1]), parseFloat(t[s + 2]), parseFloat(t[s + 3]), parseFloat(t[s + 4]), parseFloat(t[s + 5]), parseFloat(t[s + 6])]), s += 7) : "l" === t[s] ? (n.push([parseFloat(t[s + 1]), parseFloat(t[s + 2])]), s += 3) : s += 1;
            }

            return [e, r, n];
          }

          var c;
          if (e === c || e === c) throw new Error("addSVG needs values for 'x' and 'y'");
          var l = i(document),
              f = a(t, l),
              d = [1, 1],
              h = parseFloat(f.getAttribute("width")),
              p = parseFloat(f.getAttribute("height"));
          h && p && (n && s ? d = [n / h, s / p] : n ? d = [n / h, n / h] : s && (d = [s / p, s / p]));
          var m,
              w,
              y,
              g,
              v = f.childNodes;

          for (m = 0, w = v.length; w > m; m++) {
            y = v[m], y.tagName && "PATH" === y.tagName.toUpperCase() && (g = u(y.getAttribute("d").split(" ")), g[0] = g[0] * d[0] + e, g[1] = g[1] * d[1] + r, this.lines.call(this, g[2], g[0], g[1], d));
          }

          return this;
        };
      }(r.API), function (t) {

        var e = t.getCharWidthsArray = function (t, e) {
          e || (e = {});
          var r,
              n,
              s,
              o = e.widths ? e.widths : this.internal.getFont().metadata.Unicode.widths,
              i = o.fof ? o.fof : 1,
              a = e.kerning ? e.kerning : this.internal.getFont().metadata.Unicode.kerning,
              u = a.fof ? a.fof : 1,
              c = 0,
              l = o[0] || i,
              f = [];

          for (r = 0, n = t.length; n > r; r++) {
            s = t.charCodeAt(r), f.push((o[s] || l) / i + (a[s] && a[s][c] || 0) / u), c = s;
          }

          return f;
        },
            r = function r(t) {
          for (var e = t.length, r = 0; e;) {
            e--, r += t[e];
          }

          return r;
        },
            n = t.getStringUnitWidth = function (t, n) {
          return r(e.call(this, t, n));
        },
            s = function s(t, e, r, n) {
          for (var s = [], o = 0, i = t.length, a = 0; o !== i && a + e[o] < r;) {
            a += e[o], o++;
          }

          s.push(t.slice(0, o));
          var u = o;

          for (a = 0; o !== i;) {
            a + e[o] > n && (s.push(t.slice(u, o)), a = 0, u = o), a += e[o], o++;
          }

          return u !== o && s.push(t.slice(u, o)), s;
        },
            o = function o(t, _o2, i) {
          i || (i = {});
          var a,
              u,
              c,
              l,
              f,
              d,
              h = [],
              p = [h],
              m = i.textIndent || 0,
              w = 0,
              y = 0,
              g = t.split(" "),
              v = e(" ", i)[0];

          if (d = -1 === i.lineIndent ? g[0].length + 2 : i.lineIndent || 0) {
            var b = Array(d).join(" "),
                q = [];
            g.map(function (t) {
              t = t.split(/\s*\n/), t.length > 1 ? q = q.concat(t.map(function (t, e) {
                return (e && t.length ? "\n" : "") + t;
              })) : q.push(t[0]);
            }), g = q, d = n(b, i);
          }

          for (c = 0, l = g.length; l > c; c++) {
            var x = 0;

            if (a = g[c], d && "\n" == a[0] && (a = a.substr(1), x = 1), u = e(a, i), y = r(u), m + w + y > _o2 || x) {
              if (y > _o2) {
                for (f = s(a, u, _o2 - (m + w), _o2), h.push(f.shift()), h = [f.pop()]; f.length;) {
                  p.push([f.shift()]);
                }

                y = r(u.slice(a.length - h[0].length));
              } else h = [a];

              p.push(h), m = y + d, w = v;
            } else h.push(a), m += w + y, w = v;
          }

          if (d) var k = function k(t, e) {
            return (e ? b : "") + t.join(" ");
          };else var k = function k(t) {
            return t.join(" ");
          };
          return p.map(k);
        };

        t.splitTextToSize = function (t, e, r) {
          r || (r = {});

          var n,
              s = r.fontSize || this.internal.getFontSize(),
              i = function (t) {
            var e = {
              0: 1
            },
                r = {};
            if (t.widths && t.kerning) return {
              widths: t.widths,
              kerning: t.kerning
            };
            var n = this.internal.getFont(t.fontName, t.fontStyle),
                s = "Unicode";
            return n.metadata[s] ? {
              widths: n.metadata[s].widths || e,
              kerning: n.metadata[s].kerning || r
            } : {
              widths: e,
              kerning: r
            };
          }.call(this, r);

          n = Array.isArray(t) ? t : t.split(/\r?\n/);
          var a = 1 * this.internal.scaleFactor * e / s;
          i.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / s : 0, i.lineIndent = r.lineIndent;
          var u,
              c,
              l = [];

          for (u = 0, c = n.length; c > u; u++) {
            l = l.concat(o(n[u], a, i));
          }

          return l;
        };
      }(r.API), function (t) {

        var e = function e(t) {
          for (var e = "0123456789abcdef", r = "klmnopqrstuvwxyz", n = {}, s = 0; s < r.length; s++) {
            n[r[s]] = e[s];
          }

          var o,
              i,
              a,
              u,
              c,
              l = {},
              f = 1,
              d = l,
              h = [],
              p = "",
              m = "",
              w = t.length - 1;

          for (s = 1; s != w;) {
            c = t[s], s += 1, "'" == c ? i ? (u = i.join(""), i = o) : i = [] : i ? i.push(c) : "{" == c ? (h.push([d, u]), d = {}, u = o) : "}" == c ? (a = h.pop(), a[0][a[1]] = d, u = o, d = a[0]) : "-" == c ? f = -1 : u === o ? n.hasOwnProperty(c) ? (p += n[c], u = parseInt(p, 16) * f, f = 1, p = "") : p += c : n.hasOwnProperty(c) ? (m += n[c], d[u] = parseInt(m, 16) * f, f = 1, u = o, m = "") : m += c;
          }

          return l;
        },
            r = {
          codePages: ["WinAnsiEncoding"],
          WinAnsiEncoding: e("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
        },
            n = {
          Unicode: {
            Courier: r,
            "Courier-Bold": r,
            "Courier-BoldOblique": r,
            "Courier-Oblique": r,
            Helvetica: r,
            "Helvetica-Bold": r,
            "Helvetica-BoldOblique": r,
            "Helvetica-Oblique": r,
            "Times-Roman": r,
            "Times-Bold": r,
            "Times-BoldItalic": r,
            "Times-Italic": r
          }
        },
            s = {
          Unicode: {
            "Courier-Oblique": e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Times-BoldItalic": e("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
            "Helvetica-Bold": e("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
            Courier: e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Courier-BoldOblique": e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Times-Bold": e("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
            Helvetica: e("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
            "Helvetica-BoldOblique": e("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
            "Courier-Bold": e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
            "Times-Italic": e("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
            "Times-Roman": e("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
            "Helvetica-Oblique": e("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
          }
        };

        t.events.push(["addFonts", function (t) {
          var e,
              r,
              o,
              i,
              a,
              u = "Unicode";

          for (r in t.fonts) {
            t.fonts.hasOwnProperty(r) && (e = t.fonts[r], o = s[u][e.PostScriptName], o && (i = e.metadata[u] ? e.metadata[u] : e.metadata[u] = {}, i.widths = o.widths, i.kerning = o.kerning), a = n[u][e.PostScriptName], a && (i = e.metadata[u] ? e.metadata[u] : e.metadata[u] = {}, i.encoding = a, a.codePages && a.codePages.length && (e.encoding = a.codePages[0])));
          }
        }]);
      }(r.API), function (t) {

        t.putTotalPages = function (t) {
          for (var e = new RegExp(t, "g"), r = 1; r <= this.internal.getNumberOfPages(); r++) {
            for (var n = 0; n < this.internal.pages[r].length; n++) {
              this.internal.pages[r][n] = this.internal.pages[r][n].replace(e, this.internal.getNumberOfPages());
            }
          }

          return this;
        };
      }(r.API), function (t) {

        if (t.URL = t.URL || t.webkitURL, t.Blob && t.URL) try {
          return new Blob(), void 0;
        } catch (e) {}

        var r = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || function (t) {
          var e = function e(t) {
            return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1];
          },
              r = function r() {
            this.data = [];
          },
              n = function n(t, e, r) {
            this.data = t, this.size = t.length, this.type = e, this.encoding = r;
          },
              s = r.prototype,
              o = n.prototype,
              i = t.FileReaderSync,
              a = function a(t) {
            this.code = this[this.name = t];
          },
              u = "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "),
              c = u.length,
              l = t.URL || t.webkitURL || t,
              f = l.createObjectURL,
              d = l.revokeObjectURL,
              h = l,
              p = t.btoa,
              m = t.atob,
              w = t.ArrayBuffer,
              y = t.Uint8Array;

          for (n.fake = o.fake = !0; c--;) {
            a.prototype[u[c]] = c + 1;
          }

          return l.createObjectURL || (h = t.URL = {}), h.createObjectURL = function (t) {
            var e,
                r = t.type;
            return null === r && (r = "application/octet-stream"), t instanceof n ? (e = "data:" + r, "base64" === t.encoding ? e + ";base64," + t.data : "URI" === t.encoding ? e + "," + decodeURIComponent(t.data) : p ? e + ";base64," + p(t.data) : e + "," + encodeURIComponent(t.data)) : f ? f.call(l, t) : void 0;
          }, h.revokeObjectURL = function (t) {
            "data:" !== t.substring(0, 5) && d && d.call(l, t);
          }, s.append = function (t) {
            var r = this.data;

            if (y && (t instanceof w || t instanceof y)) {
              for (var s = "", o = new y(t), u = 0, c = o.length; c > u; u++) {
                s += String.fromCharCode(o[u]);
              }

              r.push(s);
            } else if ("Blob" === e(t) || "File" === e(t)) {
              if (!i) throw new a("NOT_READABLE_ERR");
              var l = new i();
              r.push(l.readAsBinaryString(t));
            } else t instanceof n ? "base64" === t.encoding && m ? r.push(m(t.data)) : "URI" === t.encoding ? r.push(decodeURIComponent(t.data)) : "raw" === t.encoding && r.push(t.data) : ("string" != typeof t && (t += ""), r.push(unescape(encodeURIComponent(t))));
          }, s.getBlob = function (t) {
            return arguments.length || (t = null), new n(this.data.join(""), t, "raw");
          }, s.toString = function () {
            return "[object BlobBuilder]";
          }, o.slice = function (t, e, r) {
            var s = arguments.length;
            return 3 > s && (r = null), new n(this.data.slice(t, s > 1 ? e : this.data.length), r, this.encoding);
          }, o.toString = function () {
            return "[object Blob]";
          }, o.close = function () {
            this.size = this.data.length = 0;
          }, r;
        }(t);

        t.Blob = function (t, e) {
          var n = e ? e.type || "" : "",
              s = new r();
          if (t) for (var o = 0, i = t.length; i > o; o++) {
            s.append(t[o]);
          }
          return s.getBlob(n);
        };
      }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content || this);

      var n = n || "undefined" != typeof navigator && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) || function (t) {

        if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
          var e = t.document,
              r = function r() {
            return t.URL || t.webkitURL || t;
          },
              n = e.createElementNS("http://www.w3.org/1999/xhtml", "a"),
              s = !t.externalHost && "download" in n,
              o = function o(r) {
            var n = e.createEvent("MouseEvents");
            n.initMouseEvent("click", !0, !1, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), r.dispatchEvent(n);
          },
              i = t.webkitRequestFileSystem,
              a = t.requestFileSystem || i || t.mozRequestFileSystem,
              u = function u(e) {
            (t.setImmediate || t.setTimeout)(function () {
              throw e;
            }, 0);
          },
              c = "application/octet-stream",
              l = 0,
              f = [],
              d = function d() {
            for (var t = f.length; t--;) {
              var e = f[t];
              "string" == typeof e ? r().revokeObjectURL(e) : e.remove();
            }

            f.length = 0;
          },
              h = function h(t, e, r) {
            e = [].concat(e);

            for (var n = e.length; n--;) {
              var s = t["on" + e[n]];
              if ("function" == typeof s) try {
                s.call(t, r || t);
              } catch (o) {
                u(o);
              }
            }
          },
              p = function p(e, u) {
            var d,
                p,
                m,
                w = this,
                y = e.type,
                g = !1,
                v = function v() {
              var t = r().createObjectURL(e);
              return f.push(t), t;
            },
                b = function b() {
              h(w, "writestart progress write writeend".split(" "));
            },
                q = function q() {
              (g || !d) && (d = v()), p ? p.location.href = d : window.open(d, "_blank"), w.readyState = w.DONE, b();
            },
                x = function x(t) {
              return function () {
                return w.readyState !== w.DONE ? t.apply(this, arguments) : void 0;
              };
            },
                k = {
              create: !0,
              exclusive: !1
            };

            return w.readyState = w.INIT, u || (u = "download"), s ? (d = v(), n.href = d, n.download = u, o(n), w.readyState = w.DONE, b(), void 0) : (t.chrome && y && y !== c && (m = e.slice || e.webkitSlice, e = m.call(e, 0, e.size, c), g = !0), i && "download" !== u && (u += ".download"), (y === c || i) && (p = t), a ? (l += e.size, a(t.TEMPORARY, l, x(function (t) {
              t.root.getDirectory("saved", k, x(function (t) {
                var r = function r() {
                  t.getFile(u, k, x(function (t) {
                    t.createWriter(x(function (r) {
                      r.onwriteend = function (e) {
                        p.location.href = t.toURL(), f.push(t), w.readyState = w.DONE, h(w, "writeend", e);
                      }, r.onerror = function () {
                        var t = r.error;
                        t.code !== t.ABORT_ERR && q();
                      }, "writestart progress write abort".split(" ").forEach(function (t) {
                        r["on" + t] = w["on" + t];
                      }), r.write(e), w.abort = function () {
                        r.abort(), w.readyState = w.DONE;
                      }, w.readyState = w.WRITING;
                    }), q);
                  }), q);
                };

                t.getFile(u, {
                  create: !1
                }, x(function (t) {
                  t.remove(), r();
                }), x(function (t) {
                  t.code === t.NOT_FOUND_ERR ? r() : q();
                }));
              }), q);
            }), q), void 0) : (q(), void 0));
          },
              m = p.prototype,
              w = function w(t, e) {
            return new p(t, e);
          };

          return m.abort = function () {
            var t = this;
            t.readyState = t.DONE, h(t, "abort");
          }, m.readyState = m.INIT = 0, m.WRITING = 1, m.DONE = 2, m.error = m.onwritestart = m.onprogress = m.onwrite = m.onabort = m.onerror = m.onwriteend = null, t.addEventListener("unload", d, !1), w.unload = function () {
            d(), t.removeEventListener("unload", d, !1);
          }, w;
        }
      }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);

       null !== module ? module.exports = n : "undefined" != typeof undefined   , void function (t, e) {
         module.exports = e() ;
      }(r, function () {
        var t = "function" == typeof ArrayBuffer && "function" == typeof Uint8Array,
            e = null,
            r = function () {
          if (!t) return function () {
            return !1;
          };

          try {
            var r = bufferEs6;
            "function" == typeof r.Buffer && (e = r.Buffer);
          } catch (n) {}

          return function (t) {
            return t instanceof ArrayBuffer || null !== e && t instanceof e;
          };
        }(),
            n = function () {
          return null !== e ? function (t) {
            return new e(t, "utf8").toString("binary");
          } : function (t) {
            return unescape(encodeURIComponent(t));
          };
        }(),
            s = 65521,
            o = function o(t, e) {
          for (var r = 65535 & t, n = t >>> 16, o = 0, i = e.length; i > o; o++) {
            r = (r + (255 & e.charCodeAt(o))) % s, n = (n + r) % s;
          }

          return (n << 16 | r) >>> 0;
        },
            i = function i(t, e) {
          for (var r = 65535 & t, n = t >>> 16, o = 0, i = e.length; i > o; o++) {
            r = (r + e[o]) % s, n = (n + r) % s;
          }

          return (n << 16 | r) >>> 0;
        },
            a = {},
            u = a.Adler32 = function () {
          var e = function e(t) {
            if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
            if (!isFinite(t = null == t ? 1 : +t)) throw new Error("First arguments needs to be a finite number.");
            this.checksum = t >>> 0;
          },
              s = e.prototype = {};

          return s.constructor = e, e.from = function (t) {
            return t.prototype = s, t;
          }(function (t) {
            if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
            if (null == t) throw new Error("First argument needs to be a string.");
            this.checksum = o(1, t.toString());
          }), e.fromUtf8 = function (t) {
            return t.prototype = s, t;
          }(function (t) {
            if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
            if (null == t) throw new Error("First argument needs to be a string.");
            var r = n(t.toString());
            this.checksum = o(1, r);
          }), t && (e.fromBuffer = function (t) {
            return t.prototype = s, t;
          }(function (t) {
            if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
            if (!r(t)) throw new Error("First argument needs to be ArrayBuffer.");
            var n = new Uint8Array(t);
            return this.checksum = i(1, n);
          })), s.update = function (t) {
            if (null == t) throw new Error("First argument needs to be a string.");
            return t = t.toString(), this.checksum = o(this.checksum, t);
          }, s.updateUtf8 = function (t) {
            if (null == t) throw new Error("First argument needs to be a string.");
            var e = n(t.toString());
            return this.checksum = o(this.checksum, e);
          }, t && (s.updateBuffer = function (t) {
            if (!r(t)) throw new Error("First argument needs to be ArrayBuffer.");
            var e = new Uint8Array(t);
            return this.checksum = i(this.checksum, e);
          }), s.clone = function () {
            return new u(this.checksum);
          }, e;
        }();

        return a.from = function (t) {
          if (null == t) throw new Error("First argument needs to be a string.");
          return o(1, t.toString());
        }, a.fromUtf8 = function (t) {
          if (null == t) throw new Error("First argument needs to be a string.");
          var e = n(t.toString());
          return o(1, e);
        }, t && (a.fromBuffer = function (t) {
          if (!r(t)) throw new Error("First argument need to be ArrayBuffer.");
          var e = new Uint8Array(t);
          return i(1, e);
        }), a;
      });

      var s = function () {
        function t() {
          function t(t) {
            var e,
                r,
                s,
                o,
                a,
                u,
                c = n.dyn_tree,
                l = n.stat_desc.static_tree,
                f = n.stat_desc.extra_bits,
                h = n.stat_desc.extra_base,
                p = n.stat_desc.max_length,
                m = 0;

            for (o = 0; i >= o; o++) {
              t.bl_count[o] = 0;
            }

            for (c[2 * t.heap[t.heap_max] + 1] = 0, e = t.heap_max + 1; d > e; e++) {
              r = t.heap[e], o = c[2 * c[2 * r + 1] + 1] + 1, o > p && (o = p, m++), c[2 * r + 1] = o, r > n.max_code || (t.bl_count[o]++, a = 0, r >= h && (a = f[r - h]), u = c[2 * r], t.opt_len += u * (o + a), l && (t.static_len += u * (l[2 * r + 1] + a)));
            }

            if (0 !== m) {
              do {
                for (o = p - 1; 0 === t.bl_count[o];) {
                  o--;
                }

                t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[p]--, m -= 2;
              } while (m > 0);

              for (o = p; 0 !== o; o--) {
                for (r = t.bl_count[o]; 0 !== r;) {
                  s = t.heap[--e], s > n.max_code || (c[2 * s + 1] != o && (t.opt_len += (o - c[2 * s + 1]) * c[2 * s], c[2 * s + 1] = o), r--);
                }
              }
            }
          }

          function e(t, e) {
            var r = 0;

            do {
              r |= 1 & t, t >>>= 1, r <<= 1;
            } while (--e > 0);

            return r >>> 1;
          }

          function r(t, r, n) {
            var s,
                o,
                a,
                u = [],
                c = 0;

            for (s = 1; i >= s; s++) {
              u[s] = c = c + n[s - 1] << 1;
            }

            for (o = 0; r >= o; o++) {
              a = t[2 * o + 1], 0 !== a && (t[2 * o] = e(u[a]++, a));
            }
          }

          var n = this;

          n.build_tree = function (e) {
            var s,
                o,
                i,
                a = n.dyn_tree,
                u = n.stat_desc.static_tree,
                c = n.stat_desc.elems,
                l = -1;

            for (e.heap_len = 0, e.heap_max = d, s = 0; c > s; s++) {
              0 !== a[2 * s] ? (e.heap[++e.heap_len] = l = s, e.depth[s] = 0) : a[2 * s + 1] = 0;
            }

            for (; e.heap_len < 2;) {
              i = e.heap[++e.heap_len] = 2 > l ? ++l : 0, a[2 * i] = 1, e.depth[i] = 0, e.opt_len--, u && (e.static_len -= u[2 * i + 1]);
            }

            for (n.max_code = l, s = Math.floor(e.heap_len / 2); s >= 1; s--) {
              e.pqdownheap(a, s);
            }

            i = c;

            do {
              s = e.heap[1], e.heap[1] = e.heap[e.heap_len--], e.pqdownheap(a, 1), o = e.heap[1], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = o, a[2 * i] = a[2 * s] + a[2 * o], e.depth[i] = Math.max(e.depth[s], e.depth[o]) + 1, a[2 * s + 1] = a[2 * o + 1] = i, e.heap[1] = i++, e.pqdownheap(a, 1);
            } while (e.heap_len >= 2);

            e.heap[--e.heap_max] = e.heap[1], t(e), r(a, n.max_code, e.bl_count);
          };
        }

        function e(t, e, r, n, s) {
          var o = this;
          o.static_tree = t, o.extra_bits = e, o.extra_base = r, o.elems = n, o.max_length = s;
        }

        function r(t, e, r, n, s) {
          var o = this;
          o.good_length = t, o.max_lazy = e, o.nice_length = r, o.max_chain = n, o.func = s;
        }

        function n(t, e, r, n) {
          var s = t[2 * e],
              o = t[2 * r];
          return o > s || s == o && n[e] <= n[r];
        }

        function s() {
          function r() {
            var t;

            for (Ie = 2 * Ce, Be[Pe - 1] = 0, t = 0; Pe - 1 > t; t++) {
              Be[t] = 0;
            }

            We = L[Xe].max_lazy, Ke = L[Xe].good_length, Qe = L[Xe].nice_length, Ve = L[Xe].max_chain, Me = 0, Fe = 0, Ge = 0, Le = Je = Z - 1, Ne = 0, Oe = 0;
          }

          function s() {
            var t;

            for (t = 0; f > t; t++) {
              $e[2 * t] = 0;
            }

            for (t = 0; a > t; t++) {
              Ze[2 * t] = 0;
            }

            for (t = 0; u > t; t++) {
              tr[2 * t] = 0;
            }

            $e[2 * h] = 1, er.opt_len = er.static_len = 0, ar = cr = 0;
          }

          function o() {
            rr.dyn_tree = $e, rr.stat_desc = e.static_l_desc, nr.dyn_tree = Ze, nr.stat_desc = e.static_d_desc, sr.dyn_tree = tr, sr.stat_desc = e.static_bl_desc, fr = 0, dr = 0, lr = 8, s();
          }

          function i(t, e) {
            var r,
                n,
                s = -1,
                o = t[1],
                i = 0,
                a = 7,
                u = 4;

            for (0 === o && (a = 138, u = 3), t[2 * (e + 1) + 1] = 65535, r = 0; e >= r; r++) {
              n = o, o = t[2 * (r + 1) + 1], ++i < a && n == o || (u > i ? tr[2 * n] += i : 0 !== n ? (n != s && tr[2 * n]++, tr[2 * m]++) : 10 >= i ? tr[2 * w]++ : tr[2 * y]++, i = 0, s = n, 0 === o ? (a = 138, u = 3) : n == o ? (a = 6, u = 3) : (a = 7, u = 4));
            }
          }

          function c() {
            var e;

            for (i($e, rr.max_code), i(Ze, nr.max_code), sr.build_tree(er), e = u - 1; e >= 3 && 0 === tr[2 * t.bl_order[e] + 1]; e--) {
            }

            return er.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
          }

          function d(t) {
            er.pending_buf[er.pending++] = t;
          }

          function p(t) {
            d(255 & t), d(t >>> 8 & 255);
          }

          function O(t) {
            d(t >> 8 & 255), d(255 & t & 255);
          }

          function re(t, e) {
            var r,
                n = e;
            dr > g - n ? (r = t, fr |= r << dr & 65535, p(fr), fr = r >>> g - dr, dr += n - g) : (fr |= t << dr & 65535, dr += n);
          }

          function ne(t, e) {
            var r = 2 * t;
            re(65535 & e[r], 65535 & e[r + 1]);
          }

          function se(t, e) {
            var r,
                n,
                s = -1,
                o = t[1],
                i = 0,
                a = 7,
                u = 4;

            for (0 === o && (a = 138, u = 3), r = 0; e >= r; r++) {
              if (n = o, o = t[2 * (r + 1) + 1], !(++i < a && n == o)) {
                if (u > i) {
                  do {
                    ne(n, tr);
                  } while (0 !== --i);
                } else 0 !== n ? (n != s && (ne(n, tr), i--), ne(m, tr), re(i - 3, 2)) : 10 >= i ? (ne(w, tr), re(i - 3, 3)) : (ne(y, tr), re(i - 11, 7));

                i = 0, s = n, 0 === o ? (a = 138, u = 3) : n == o ? (a = 6, u = 3) : (a = 7, u = 4);
              }
            }
          }

          function oe(e, r, n) {
            var s;

            for (re(e - 257, 5), re(r - 1, 5), re(n - 4, 4), s = 0; n > s; s++) {
              re(tr[2 * t.bl_order[s] + 1], 3);
            }

            se($e, e - 1), se(Ze, r - 1);
          }

          function ie() {
            16 == dr ? (p(fr), fr = 0, dr = 0) : dr >= 8 && (d(255 & fr), fr >>>= 8, dr -= 8);
          }

          function ae() {
            re(Q << 1, 3), ne(h, e.static_ltree), ie(), 9 > 1 + lr + 10 - dr && (re(Q << 1, 3), ne(h, e.static_ltree), ie()), lr = 7;
          }

          function ue(e, r) {
            var n, s, o;

            if (er.pending_buf[ur + 2 * ar] = e >>> 8 & 255, er.pending_buf[ur + 2 * ar + 1] = 255 & e, er.pending_buf[or + ar] = 255 & r, ar++, 0 === e ? $e[2 * r]++ : (cr++, e--, $e[2 * (t._length_code[r] + l + 1)]++, Ze[2 * t.d_code(e)]++), 0 === (8191 & ar) && Xe > 2) {
              for (n = 8 * ar, s = Me - Fe, o = 0; a > o; o++) {
                n += Ze[2 * o] * (5 + t.extra_dbits[o]);
              }

              if (n >>>= 3, cr < Math.floor(ar / 2) && n < Math.floor(s / 2)) return !0;
            }

            return ar == ir - 1;
          }

          function ce(e, r) {
            var n,
                s,
                o,
                i,
                a = 0;
            if (0 !== ar) do {
              n = er.pending_buf[ur + 2 * a] << 8 & 65280 | 255 & er.pending_buf[ur + 2 * a + 1], s = 255 & er.pending_buf[or + a], a++, 0 === n ? ne(s, e) : (o = t._length_code[s], ne(o + l + 1, e), i = t.extra_lbits[o], 0 !== i && (s -= t.base_length[o], re(s, i)), n--, o = t.d_code(n), ne(o, r), i = t.extra_dbits[o], 0 !== i && (n -= t.base_dist[o], re(n, i)));
            } while (ar > a);
            ne(h, e), lr = e[2 * h + 1];
          }

          function le() {
            dr > 8 ? p(fr) : dr > 0 && d(255 & fr), fr = 0, dr = 0;
          }

          function fe(t, e, r) {
            le(), lr = 8, r && (p(e), p(~e)), er.pending_buf.set(ze.subarray(t, t + e), er.pending), er.pending += e;
          }

          function de(t, e, r) {
            re((K << 1) + (r ? 1 : 0), 3), fe(t, e, !0);
          }

          function he(t, r, n) {
            var o,
                i,
                a = 0;
            Xe > 0 ? (rr.build_tree(er), nr.build_tree(er), a = c(), o = er.opt_len + 3 + 7 >>> 3, i = er.static_len + 3 + 7 >>> 3, o >= i && (o = i)) : o = i = r + 5, o >= r + 4 && -1 != t ? de(t, r, n) : i == o ? (re((Q << 1) + (n ? 1 : 0), 3), ce(e.static_ltree, e.static_dtree)) : (re(($ << 1) + (n ? 1 : 0), 3), oe(rr.max_code + 1, nr.max_code + 1, a + 1), ce($e, Ze)), s(), n && le();
          }

          function pe(t) {
            he(Fe >= 0 ? Fe : -1, Me - Fe, t), Fe = Me, qe.flush_pending();
          }

          function me() {
            var t, e, r, n;

            do {
              if (n = Ie - Ge - Me, 0 === n && 0 === Me && 0 === Ge) n = Ce;else if (-1 == n) n--;else if (Me >= Ce + Ce - ee) {
                ze.set(ze.subarray(Ce, Ce + Ce), 0), He -= Ce, Me -= Ce, Fe -= Ce, t = Pe, r = t;

                do {
                  e = 65535 & Be[--r], Be[r] = e >= Ce ? e - Ce : 0;
                } while (0 !== --t);

                t = Ce, r = t;

                do {
                  e = 65535 & Te[--r], Te[r] = e >= Ce ? e - Ce : 0;
                } while (0 !== --t);

                n += Ce;
              }
              if (0 === qe.avail_in) return;
              t = qe.read_buf(ze, Me + Ge, n), Ge += t, Ge >= Z && (Oe = 255 & ze[Me], Oe = (Oe << Ue ^ 255 & ze[Me + 1]) & De);
            } while (ee > Ge && 0 !== qe.avail_in);
          }

          function we(t) {
            var e,
                r = 65535;

            for (r > ke - 5 && (r = ke - 5);;) {
              if (1 >= Ge) {
                if (me(), 0 === Ge && t == k) return N;
                if (0 === Ge) break;
              }

              if (Me += Ge, Ge = 0, e = Fe + r, (0 === Me || Me >= e) && (Ge = Me - e, Me = e, pe(!1), 0 === qe.avail_out)) return N;
              if (Me - Fe >= Ce - ee && (pe(!1), 0 === qe.avail_out)) return N;
            }

            return pe(t == C), 0 === qe.avail_out ? t == C ? H : N : t == C ? G : M;
          }

          function ye(t) {
            var e,
                r,
                n = Ve,
                s = Me,
                o = Je,
                i = Me > Ce - ee ? Me - (Ce - ee) : 0,
                a = Qe,
                u = Ee,
                c = Me + te,
                l = ze[s + o - 1],
                f = ze[s + o];
            Je >= Ke && (n >>= 2), a > Ge && (a = Ge);

            do {
              if (e = t, ze[e + o] == f && ze[e + o - 1] == l && ze[e] == ze[s] && ze[++e] == ze[s + 1]) {
                s += 2, e++;

                do {
                } while (ze[++s] == ze[++e] && ze[++s] == ze[++e] && ze[++s] == ze[++e] && ze[++s] == ze[++e] && ze[++s] == ze[++e] && ze[++s] == ze[++e] && ze[++s] == ze[++e] && ze[++s] == ze[++e] && c > s);

                if (r = te - (c - s), s = c - te, r > o) {
                  if (He = t, o = r, r >= a) break;
                  l = ze[s + o - 1], f = ze[s + o];
                }
              }
            } while ((t = 65535 & Te[t & u]) > i && 0 !== --n);

            return Ge >= o ? o : Ge;
          }

          function ge(t) {
            for (var e, r = 0;;) {
              if (ee > Ge) {
                if (me(), ee > Ge && t == k) return N;
                if (0 === Ge) break;
              }

              if (Ge >= Z && (Oe = (Oe << Ue ^ 255 & ze[Me + (Z - 1)]) & De, r = 65535 & Be[Oe], Te[Me & Ee] = Be[Oe], Be[Oe] = Me), 0 !== r && Ce - ee >= (Me - r & 65535) && Ye != q && (Le = ye(r)), Le >= Z) {
                if (e = ue(Me - He, Le - Z), Ge -= Le, We >= Le && Ge >= Z) {
                  Le--;

                  do {
                    Me++, Oe = (Oe << Ue ^ 255 & ze[Me + (Z - 1)]) & De, r = 65535 & Be[Oe], Te[Me & Ee] = Be[Oe], Be[Oe] = Me;
                  } while (0 !== --Le);

                  Me++;
                } else Me += Le, Le = 0, Oe = 255 & ze[Me], Oe = (Oe << Ue ^ 255 & ze[Me + 1]) & De;
              } else e = ue(0, 255 & ze[Me]), Ge--, Me++;
              if (e && (pe(!1), 0 === qe.avail_out)) return N;
            }

            return pe(t == C), 0 === qe.avail_out ? t == C ? H : N : t == C ? G : M;
          }

          function ve(t) {
            for (var e, r, n = 0;;) {
              if (ee > Ge) {
                if (me(), ee > Ge && t == k) return N;
                if (0 === Ge) break;
              }

              if (Ge >= Z && (Oe = (Oe << Ue ^ 255 & ze[Me + (Z - 1)]) & De, n = 65535 & Be[Oe], Te[Me & Ee] = Be[Oe], Be[Oe] = Me), Je = Le, je = He, Le = Z - 1, 0 !== n && We > Je && Ce - ee >= (Me - n & 65535) && (Ye != q && (Le = ye(n)), 5 >= Le && (Ye == b || Le == Z && Me - He > 4096) && (Le = Z - 1)), Je >= Z && Je >= Le) {
                r = Me + Ge - Z, e = ue(Me - 1 - je, Je - Z), Ge -= Je - 1, Je -= 2;

                do {
                  ++Me <= r && (Oe = (Oe << Ue ^ 255 & ze[Me + (Z - 1)]) & De, n = 65535 & Be[Oe], Te[Me & Ee] = Be[Oe], Be[Oe] = Me);
                } while (0 !== --Je);

                if (Ne = 0, Le = Z - 1, Me++, e && (pe(!1), 0 === qe.avail_out)) return N;
              } else if (0 !== Ne) {
                if (e = ue(0, 255 & ze[Me - 1]), e && pe(!1), Me++, Ge--, 0 === qe.avail_out) return N;
              } else Ne = 1, Me++, Ge--;
            }

            return 0 !== Ne && (e = ue(0, 255 & ze[Me - 1]), Ne = 0), pe(t == C), 0 === qe.avail_out ? t == C ? H : N : t == C ? G : M;
          }

          function be(t) {
            return t.total_in = t.total_out = 0, t.msg = null, er.pending = 0, er.pending_out = 0, xe = W, Ae = k, o(), r(), S;
          }

          var qe,
              xe,
              ke,
              Ae,
              Ce,
              Se,
              Ee,
              ze,
              Ie,
              Te,
              Be,
              Oe,
              Pe,
              Re,
              De,
              Ue,
              Fe,
              Le,
              je,
              Ne,
              Me,
              He,
              Ge,
              Je,
              Ve,
              We,
              Xe,
              Ye,
              Ke,
              Qe,
              $e,
              Ze,
              tr,
              er = this,
              rr = new t(),
              nr = new t(),
              sr = new t();

          er.depth = [];
          var or, ir, ar, ur, cr, lr, fr, dr;
          er.bl_count = [], er.heap = [], $e = [], Ze = [], tr = [], er.pqdownheap = function (t, e) {
            for (var r = er.heap, s = r[e], o = e << 1; o <= er.heap_len && (o < er.heap_len && n(t, r[o + 1], r[o], er.depth) && o++, !n(t, s, r[o], er.depth));) {
              r[e] = r[o], e = o, o <<= 1;
            }

            r[e] = s;
          }, er.deflateInit = function (t, e, r, n, s, o) {
            return n || (n = Y), s || (s = R), o || (o = x), t.msg = null, e == v && (e = 6), 1 > s || s > P || n != Y || 9 > r || r > 15 || 0 > e || e > 9 || 0 > o || o > q ? I : (t.dstate = er, Se = r, Ce = 1 << Se, Ee = Ce - 1, Re = s + 7, Pe = 1 << Re, De = Pe - 1, Ue = Math.floor((Re + Z - 1) / Z), ze = new Uint8Array(2 * Ce), Te = [], Be = [], ir = 1 << s + 6, er.pending_buf = new Uint8Array(4 * ir), ke = 4 * ir, ur = Math.floor(ir / 2), or = 3 * ir, Xe = e, Ye = o, be(t));
          }, er.deflateEnd = function () {
            return xe != V && xe != W && xe != X ? I : (er.pending_buf = null, Be = null, Te = null, ze = null, er.dstate = null, xe == W ? T : S);
          }, er.deflateParams = function (t, e, r) {
            var n = S;
            return e == v && (e = 6), 0 > e || e > 9 || 0 > r || r > q ? I : (L[Xe].func != L[e].func && 0 !== t.total_in && (n = t.deflate(_)), Xe != e && (Xe = e, We = L[Xe].max_lazy, Ke = L[Xe].good_length, Qe = L[Xe].nice_length, Ve = L[Xe].max_chain), Ye = r, n);
          }, er.deflateSetDictionary = function (t, e, r) {
            var n,
                s = r,
                o = 0;
            if (!e || xe != V) return I;
            if (Z > s) return S;

            for (s > Ce - ee && (s = Ce - ee, o = r - s), ze.set(e.subarray(o, o + s), 0), Me = s, Fe = s, Oe = 255 & ze[0], Oe = (Oe << Ue ^ 255 & ze[1]) & De, n = 0; s - Z >= n; n++) {
              Oe = (Oe << Ue ^ 255 & ze[n + (Z - 1)]) & De, Te[n & Ee] = Be[Oe], Be[Oe] = n;
            }

            return S;
          }, er.deflate = function (t, e) {
            var r, n, s, o, i;
            if (e > C || 0 > e) return I;
            if (!t.next_out || !t.next_in && 0 !== t.avail_in || xe == X && e != C) return t.msg = j[z - I], I;
            if (0 === t.avail_out) return t.msg = j[z - B], B;

            if (qe = t, o = Ae, Ae = e, xe == V && (n = Y + (Se - 8 << 4) << 8, s = (Xe - 1 & 255) >> 1, s > 3 && (s = 3), n |= s << 6, 0 !== Me && (n |= J), n += 31 - n % 31, xe = W, O(n)), 0 !== er.pending) {
              if (qe.flush_pending(), 0 === qe.avail_out) return Ae = -1, S;
            } else if (0 === qe.avail_in && o >= e && e != C) return qe.msg = j[z - B], B;

            if (xe == X && 0 !== qe.avail_in) return t.msg = j[z - B], B;

            if (0 !== qe.avail_in || 0 !== Ge || e != k && xe != X) {
              switch (i = -1, L[Xe].func) {
                case D:
                  i = we(e);
                  break;

                case U:
                  i = ge(e);
                  break;

                case F:
                  i = ve(e);
              }

              if ((i == H || i == G) && (xe = X), i == N || i == H) return 0 === qe.avail_out && (Ae = -1), S;

              if (i == M) {
                if (e == _) ae();else if (de(0, 0, !1), e == A) for (r = 0; Pe > r; r++) {
                  Be[r] = 0;
                }
                if (qe.flush_pending(), 0 === qe.avail_out) return Ae = -1, S;
              }
            }

            return e != C ? S : E;
          };
        }

        function o() {
          var t = this;
          t.next_in_index = 0, t.next_out_index = 0, t.avail_in = 0, t.total_in = 0, t.avail_out = 0, t.total_out = 0;
        }

        var i = 15,
            a = 30,
            u = 19,
            c = 29,
            l = 256,
            f = l + 1 + c,
            d = 2 * f + 1,
            h = 256,
            p = 7,
            m = 16,
            w = 17,
            y = 18,
            g = 16,
            v = -1,
            b = 1,
            q = 2,
            x = 0,
            k = 0,
            _ = 1,
            A = 3,
            C = 4,
            S = 0,
            E = 1,
            z = 2,
            I = -2,
            T = -3,
            B = -5,
            O = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];
        t._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28], t.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0], t.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576], t.d_code = function (t) {
          return 256 > t ? O[t] : O[256 + (t >>> 7)];
        }, t.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], t.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], t.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], t.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], e.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8], e.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5], e.static_l_desc = new e(e.static_ltree, t.extra_lbits, l + 1, f, i), e.static_d_desc = new e(e.static_dtree, t.extra_dbits, 0, a, i), e.static_bl_desc = new e(null, t.extra_blbits, 0, u, p);
        var P = 9,
            R = 8,
            D = 0,
            U = 1,
            F = 2,
            L = [new r(0, 0, 0, 0, D), new r(4, 4, 8, 4, U), new r(4, 5, 16, 8, U), new r(4, 6, 32, 32, U), new r(4, 4, 16, 16, F), new r(8, 16, 32, 32, F), new r(8, 16, 128, 128, F), new r(8, 32, 128, 256, F), new r(32, 128, 258, 1024, F), new r(32, 258, 258, 4096, F)],
            j = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""],
            N = 0,
            M = 1,
            H = 2,
            G = 3,
            J = 32,
            V = 42,
            W = 113,
            X = 666,
            Y = 8,
            K = 0,
            Q = 1,
            $ = 2,
            Z = 3,
            te = 258,
            ee = te + Z + 1;
        return o.prototype = {
          deflateInit: function deflateInit(t, e) {
            var r = this;
            return r.dstate = new s(), e || (e = i), r.dstate.deflateInit(r, t, e);
          },
          deflate: function deflate(t) {
            var e = this;
            return e.dstate ? e.dstate.deflate(e, t) : I;
          },
          deflateEnd: function deflateEnd() {
            var t = this;
            if (!t.dstate) return I;
            var e = t.dstate.deflateEnd();
            return t.dstate = null, e;
          },
          deflateParams: function deflateParams(t, e) {
            var r = this;
            return r.dstate ? r.dstate.deflateParams(r, t, e) : I;
          },
          deflateSetDictionary: function deflateSetDictionary(t, e) {
            var r = this;
            return r.dstate ? r.dstate.deflateSetDictionary(r, t, e) : I;
          },
          read_buf: function read_buf(t, e, r) {
            var n = this,
                s = n.avail_in;
            return s > r && (s = r), 0 === s ? 0 : (n.avail_in -= s, t.set(n.next_in.subarray(n.next_in_index, n.next_in_index + s), e), n.next_in_index += s, n.total_in += s, s);
          },
          flush_pending: function flush_pending() {
            var t = this,
                e = t.dstate.pending;
            e > t.avail_out && (e = t.avail_out), 0 !== e && (t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out, t.dstate.pending_out + e), t.next_out_index), t.next_out_index += e, t.dstate.pending_out += e, t.total_out += e, t.avail_out -= e, t.dstate.pending -= e, 0 === t.dstate.pending && (t.dstate.pending_out = 0));
          }
        }, function (t) {
          var e = this,
              r = new o(),
              n = 512,
              s = k,
              i = new Uint8Array(n);
          "undefined" == typeof t && (t = v), r.deflateInit(t), r.next_out = i, e.append = function (t, e) {
            var o,
                a,
                u = [],
                c = 0,
                l = 0,
                f = 0;

            if (t.length) {
              r.next_in_index = 0, r.next_in = t, r.avail_in = t.length;

              do {
                if (r.next_out_index = 0, r.avail_out = n, o = r.deflate(s), o != S) throw "deflating: " + r.msg;
                r.next_out_index && (r.next_out_index == n ? u.push(new Uint8Array(i)) : u.push(new Uint8Array(i.subarray(0, r.next_out_index)))), f += r.next_out_index, e && r.next_in_index > 0 && r.next_in_index != c && (e(r.next_in_index), c = r.next_in_index);
              } while (r.avail_in > 0 || 0 === r.avail_out);

              return a = new Uint8Array(f), u.forEach(function (t) {
                a.set(t, l), l += t.length;
              }), a;
            }
          }, e.flush = function () {
            var t,
                e,
                s = [],
                o = 0,
                a = 0;

            do {
              if (r.next_out_index = 0, r.avail_out = n, t = r.deflate(C), t != E && t != S) throw "deflating: " + r.msg;
              n - r.avail_out > 0 && s.push(new Uint8Array(i.subarray(0, r.next_out_index))), a += r.next_out_index;
            } while (r.avail_in > 0 || 0 === r.avail_out);

            return r.deflateEnd(), e = new Uint8Array(a), s.forEach(function (t) {
              e.set(t, o), o += t.length;
            }), e;
          };
        };
      }();

      !function (t) {
        var e;
        e = function () {
          function e(t) {
            var e, r, n, s, o, i, a, u, c, l, f, d, h, p, m;

            for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, i = null;;) {
              switch (e = this.readUInt32(), l = function () {
                var t, e;

                for (e = [], a = t = 0; 4 > t; a = ++t) {
                  e.push(String.fromCharCode(this.data[this.pos++]));
                }

                return e;
              }.call(this).join("")) {
                case "IHDR":
                  this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                  break;

                case "acTL":
                  this.animation = {
                    numFrames: this.readUInt32(),
                    numPlays: this.readUInt32() || 1 / 0,
                    frames: []
                  };
                  break;

                case "PLTE":
                  this.palette = this.read(e);
                  break;

                case "fcTL":
                  i && this.animation.frames.push(i), this.pos += 4, i = {
                    width: this.readUInt32(),
                    height: this.readUInt32(),
                    xOffset: this.readUInt32(),
                    yOffset: this.readUInt32()
                  }, o = this.readUInt16(), s = this.readUInt16() || 100, i.delay = 1e3 * o / s, i.disposeOp = this.data[this.pos++], i.blendOp = this.data[this.pos++], i.data = [];
                  break;

                case "IDAT":
                case "fdAT":
                  for ("fdAT" === l && (this.pos += 4, e -= 4), t = (null != i ? i.data : void 0) || this.imgData, a = h = 0; e >= 0 ? e > h : h > e; a = e >= 0 ? ++h : --h) {
                    t.push(this.data[this.pos++]);
                  }

                  break;

                case "tRNS":
                  switch (this.transparency = {}, this.colorType) {
                    case 3:
                      if (n = this.palette.length / 3, this.transparency.indexed = this.read(e), this.transparency.indexed.length > n) throw new Error("More transparent colors than palette size");
                      if (f = n - this.transparency.indexed.length, f > 0) for (a = p = 0; f >= 0 ? f > p : p > f; a = f >= 0 ? ++p : --p) {
                        this.transparency.indexed.push(255);
                      }
                      break;

                    case 0:
                      this.transparency.grayscale = this.read(e)[0];
                      break;

                    case 2:
                      this.transparency.rgb = this.read(e);
                  }

                  break;

                case "tEXt":
                  d = this.read(e), u = d.indexOf(0), c = String.fromCharCode.apply(String, d.slice(0, u)), this.text[c] = String.fromCharCode.apply(String, d.slice(u + 1));
                  break;

                case "IEND":
                  return i && this.animation.frames.push(i), this.colors = function () {
                    switch (this.colorType) {
                      case 0:
                      case 3:
                      case 4:
                        return 1;

                      case 2:
                      case 6:
                        return 3;
                    }
                  }.call(this), this.hasAlphaChannel = 4 === (m = this.colorType) || 6 === m, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = function () {
                    switch (this.colors) {
                      case 1:
                        return "DeviceGray";

                      case 3:
                        return "DeviceRGB";
                    }
                  }.call(this), this.imgData = new Uint8Array(this.imgData), void 0;

                default:
                  this.pos += e;
              }

              if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
            }
          }

          var n, s, a, u, c, l;
          e.load = function (t, r, n) {
            var s;
            return "function" == typeof r && (n = r), s = new XMLHttpRequest(), s.open("GET", t, !0), s.responseType = "arraybuffer", s.onload = function () {
              var t, o;
              return t = new Uint8Array(s.response || s.mozResponseArrayBuffer), o = new e(t), "function" == typeof (null != r ? r.getContext : void 0) && o.render(r), "function" == typeof n ? n(o) : void 0;
            }, s.send(null);
          }, s = 1, a = 2, n = 0, e.prototype.read = function (t) {
            var e, r, n;

            for (n = [], e = r = 0; t >= 0 ? t > r : r > t; e = t >= 0 ? ++r : --r) {
              n.push(this.data[this.pos++]);
            }

            return n;
          }, e.prototype.readUInt32 = function () {
            var t, e, r, n;
            return t = this.data[this.pos++] << 24, e = this.data[this.pos++] << 16, r = this.data[this.pos++] << 8, n = this.data[this.pos++], t | e | r | n;
          }, e.prototype.readUInt16 = function () {
            var t, e;
            return t = this.data[this.pos++] << 8, e = this.data[this.pos++], t | e;
          }, e.prototype.decodePixels = function (t) {
            var e, r, n, s, o, a, u, c, l, f, d, h, p, m, w, y, g, v, b, q, x, k, _;

            if (null == t && (t = this.imgData), 0 === t.length) return new Uint8Array(0);

            for (t = new i(t), t = t.getBytes(), h = this.pixelBitlength / 8, y = h * this.width, p = new Uint8Array(y * this.height), a = t.length, w = 0, m = 0, r = 0; a > m;) {
              switch (t[m++]) {
                case 0:
                  for (s = b = 0; y > b; s = b += 1) {
                    p[r++] = t[m++];
                  }

                  break;

                case 1:
                  for (s = q = 0; y > q; s = q += 1) {
                    e = t[m++], o = h > s ? 0 : p[r - h], p[r++] = (e + o) % 256;
                  }

                  break;

                case 2:
                  for (s = x = 0; y > x; s = x += 1) {
                    e = t[m++], n = (s - s % h) / h, g = w && p[(w - 1) * y + n * h + s % h], p[r++] = (g + e) % 256;
                  }

                  break;

                case 3:
                  for (s = k = 0; y > k; s = k += 1) {
                    e = t[m++], n = (s - s % h) / h, o = h > s ? 0 : p[r - h], g = w && p[(w - 1) * y + n * h + s % h], p[r++] = (e + Math.floor((o + g) / 2)) % 256;
                  }

                  break;

                case 4:
                  for (s = _ = 0; y > _; s = _ += 1) {
                    e = t[m++], n = (s - s % h) / h, o = h > s ? 0 : p[r - h], 0 === w ? g = v = 0 : (g = p[(w - 1) * y + n * h + s % h], v = n && p[(w - 1) * y + (n - 1) * h + s % h]), u = o + g - v, c = Math.abs(u - o), f = Math.abs(u - g), d = Math.abs(u - v), l = f >= c && d >= c ? o : d >= f ? g : v, p[r++] = (e + l) % 256;
                  }

                  break;

                default:
                  throw new Error("Invalid filter algorithm: " + t[m - 1]);
              }

              w++;
            }

            return p;
          }, e.prototype.decodePalette = function () {
            var t, e, r, n, s, o, i, a, u, c;

            for (n = this.palette, i = this.transparency.indexed || [], o = new Uint8Array((i.length || 0) + n.length), s = 0, r = n.length, t = 0, e = a = 0, u = n.length; u > a; e = a += 3) {
              o[s++] = n[e], o[s++] = n[e + 1], o[s++] = n[e + 2], o[s++] = null != (c = i[t++]) ? c : 255;
            }

            return o;
          }, e.prototype.copyToImageData = function (t, e) {
            var r, n, s, o, i, a, u, c, l, f, d;
            if (n = this.colors, l = null, r = this.hasAlphaChannel, this.palette.length && (l = null != (d = this._decodedPalette) ? d : this._decodedPalette = this.decodePalette(), n = 4, r = !0), s = t.data || t, c = s.length, i = l || e, o = a = 0, 1 === n) for (; c > o;) {
              u = l ? 4 * e[o / 4] : a, f = i[u++], s[o++] = f, s[o++] = f, s[o++] = f, s[o++] = r ? i[u++] : 255, a = u;
            } else for (; c > o;) {
              u = l ? 4 * e[o / 4] : a, s[o++] = i[u++], s[o++] = i[u++], s[o++] = i[u++], s[o++] = r ? i[u++] : 255, a = u;
            }
          }, e.prototype.decode = function () {
            var t;
            return t = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t, this.decodePixels()), t;
          };

          try {
            c = t.document.createElement("canvas"), l = c.getContext("2d");
          } catch (f) {
            return -1;
          }

          return u = function u(t) {
            var e;
            return l.width = t.width, l.height = t.height, l.clearRect(0, 0, t.width, t.height), l.putImageData(t, 0, 0), e = new Image(), e.src = c.toDataURL(), e;
          }, e.prototype.decodeFrames = function (t) {
            var e, r, n, s, o, i, a, c;

            if (this.animation) {
              for (a = this.animation.frames, c = [], r = o = 0, i = a.length; i > o; r = ++o) {
                e = a[r], n = t.createImageData(e.width, e.height), s = this.decodePixels(new Uint8Array(e.data)), this.copyToImageData(n, s), e.imageData = n, c.push(e.image = u(n));
              }

              return c;
            }
          }, e.prototype.renderFrame = function (t, e) {
            var r, o, i;
            return o = this.animation.frames, r = o[e], i = o[e - 1], 0 === e && t.clearRect(0, 0, this.width, this.height), (null != i ? i.disposeOp : void 0) === s ? t.clearRect(i.xOffset, i.yOffset, i.width, i.height) : (null != i ? i.disposeOp : void 0) === a && t.putImageData(i.imageData, i.xOffset, i.yOffset), r.blendOp === n && t.clearRect(r.xOffset, r.yOffset, r.width, r.height), t.drawImage(r.image, r.xOffset, r.yOffset);
          }, e.prototype.animate = function (t) {
            var _e2,
                r,
                n,
                s,
                o,
                i,
                a = this;

            return r = 0, i = this.animation, s = i.numFrames, n = i.frames, o = i.numPlays, (_e2 = function e() {
              var i, u;
              return i = r++ % s, u = n[i], a.renderFrame(t, i), s > 1 && o > r / s ? a.animation._timeout = setTimeout(_e2, u.delay) : void 0;
            })();
          }, e.prototype.stopAnimation = function () {
            var t;
            return clearTimeout(null != (t = this.animation) ? t._timeout : void 0);
          }, e.prototype.render = function (t) {
            var e, r;
            return t._png && t._png.stopAnimation(), t._png = this, t.width = this.width, t.height = this.height, e = t.getContext("2d"), this.animation ? (this.decodeFrames(e), this.animate(e)) : (r = e.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e.putImageData(r, 0, 0));
          }, e;
        }(), t.PNG = e;
      }("undefined" != typeof window && window || this);

      var o = function () {
        function t() {
          this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = null;
        }

        return t.prototype = {
          ensureBuffer: function ensureBuffer(t) {
            var e = this.buffer,
                r = e ? e.byteLength : 0;
            if (r > t) return e;

            for (var n = 512; t > n;) {
              n <<= 1;
            }

            for (var s = new Uint8Array(n), o = 0; r > o; ++o) {
              s[o] = e[o];
            }

            return this.buffer = s;
          },
          getByte: function getByte() {
            for (var t = this.pos; this.bufferLength <= t;) {
              if (this.eof) return null;
              this.readBlock();
            }

            return this.buffer[this.pos++];
          },
          getBytes: function getBytes(t) {
            var e = this.pos;

            if (t) {
              this.ensureBuffer(e + t);

              for (var r = e + t; !this.eof && this.bufferLength < r;) {
                this.readBlock();
              }

              var n = this.bufferLength;
              r > n && (r = n);
            } else {
              for (; !this.eof;) {
                this.readBlock();
              }

              var r = this.bufferLength;
            }

            return this.pos = r, this.buffer.subarray(e, r);
          },
          lookChar: function lookChar() {
            for (var t = this.pos; this.bufferLength <= t;) {
              if (this.eof) return null;
              this.readBlock();
            }

            return String.fromCharCode(this.buffer[this.pos]);
          },
          getChar: function getChar() {
            for (var t = this.pos; this.bufferLength <= t;) {
              if (this.eof) return null;
              this.readBlock();
            }

            return String.fromCharCode(this.buffer[this.pos++]);
          },
          makeSubStream: function makeSubStream(t, e, r) {
            for (var n = t + e; this.bufferLength <= n && !this.eof;) {
              this.readBlock();
            }

            return new Stream(this.buffer, t, e, r);
          },
          skip: function skip(t) {
            t || (t = 1), this.pos += t;
          },
          reset: function reset() {
            this.pos = 0;
          }
        }, t;
      }(),
          i = function () {
        function t(t) {
          throw new Error(t);
        }

        function e(e) {
          var r = 0,
              n = e[r++],
              s = e[r++];
          (-1 == n || -1 == s) && t("Invalid header in flate stream"), 8 != (15 & n) && t("Unknown compression method in flate stream"), ((n << 8) + s) % 31 != 0 && t("Bad FCHECK in flate stream"), 32 & s && t("FDICT bit set in flate stream"), this.bytes = e, this.bytesPos = r, this.codeSize = 0, this.codeBuf = 0, o.call(this);
        }

        if ("undefined" == typeof Uint32Array) return void 0;
        var r = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            n = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]),
            s = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]),
            i = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9],
            a = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
        return e.prototype = Object.create(o.prototype), e.prototype.getBits = function (e) {
          for (var r, n = this.codeSize, s = this.codeBuf, o = this.bytes, i = this.bytesPos; e > n;) {
            "undefined" == typeof (r = o[i++]) && t("Bad encoding in flate stream"), s |= r << n, n += 8;
          }

          return r = s & (1 << e) - 1, this.codeBuf = s >> e, this.codeSize = n -= e, this.bytesPos = i, r;
        }, e.prototype.getCode = function (e) {
          for (var r = e[0], n = e[1], s = this.codeSize, o = this.codeBuf, i = this.bytes, a = this.bytesPos; n > s;) {
            var u;
            "undefined" == typeof (u = i[a++]) && t("Bad encoding in flate stream"), o |= u << s, s += 8;
          }

          var c = r[o & (1 << n) - 1],
              l = c >> 16,
              f = 65535 & c;
          return (0 == s || l > s || 0 == l) && t("Bad encoding in flate stream"), this.codeBuf = o >> l, this.codeSize = s - l, this.bytesPos = a, f;
        }, e.prototype.generateHuffmanTable = function (t) {
          for (var e = t.length, r = 0, n = 0; e > n; ++n) {
            t[n] > r && (r = t[n]);
          }

          for (var s = 1 << r, o = new Uint32Array(s), i = 1, a = 0, u = 2; r >= i; ++i, a <<= 1, u <<= 1) {
            for (var c = 0; e > c; ++c) {
              if (t[c] == i) {
                for (var l = 0, f = a, n = 0; i > n; ++n) {
                  l = l << 1 | 1 & f, f >>= 1;
                }

                for (var n = l; s > n; n += u) {
                  o[n] = i << 16 | c;
                }

                ++a;
              }
            }
          }

          return [o, r];
        }, e.prototype.readBlock = function () {
          function e(t, e, r, n, s) {
            for (var o = t.getBits(r) + n; o-- > 0;) {
              e[k++] = s;
            }
          }

          var o = this.getBits(3);

          if (1 & o && (this.eof = !0), o >>= 1, 0 == o) {
            var u,
                c = this.bytes,
                l = this.bytesPos;
            "undefined" == typeof (u = c[l++]) && t("Bad block header in flate stream");
            var f = u;
            "undefined" == typeof (u = c[l++]) && t("Bad block header in flate stream"), f |= u << 8, "undefined" == typeof (u = c[l++]) && t("Bad block header in flate stream");
            var d = u;
            "undefined" == typeof (u = c[l++]) && t("Bad block header in flate stream"), d |= u << 8, d != (65535 & ~f) && t("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
            var h = this.bufferLength,
                p = this.ensureBuffer(h + f),
                m = h + f;
            this.bufferLength = m;

            for (var w = h; m > w; ++w) {
              if ("undefined" == typeof (u = c[l++])) {
                this.eof = !0;
                break;
              }

              p[w] = u;
            }

            return this.bytesPos = l, void 0;
          }

          var y, g;
          if (1 == o) y = i, g = a;else if (2 == o) {
            for (var v = this.getBits(5) + 257, b = this.getBits(5) + 1, q = this.getBits(4) + 4, x = Array(r.length), k = 0; q > k;) {
              x[r[k++]] = this.getBits(3);
            }

            for (var _ = this.generateHuffmanTable(x), A = 0, k = 0, C = v + b, S = new Array(C); C > k;) {
              var E = this.getCode(_);
              16 == E ? e(this, S, 2, 3, A) : 17 == E ? e(this, S, 3, 3, A = 0) : 18 == E ? e(this, S, 7, 11, A = 0) : S[k++] = A = E;
            }

            y = this.generateHuffmanTable(S.slice(0, v)), g = this.generateHuffmanTable(S.slice(v, C));
          } else t("Unknown block type in flate stream");

          for (var p = this.buffer, z = p ? p.length : 0, I = this.bufferLength;;) {
            var T = this.getCode(y);
            if (256 > T) I + 1 >= z && (p = this.ensureBuffer(I + 1), z = p.length), p[I++] = T;else {
              if (256 == T) return this.bufferLength = I, void 0;
              T -= 257, T = n[T];
              var B = T >> 16;
              B > 0 && (B = this.getBits(B));
              var A = (65535 & T) + B;
              T = this.getCode(g), T = s[T], B = T >> 16, B > 0 && (B = this.getBits(B));
              var O = (65535 & T) + B;
              I + A >= z && (p = this.ensureBuffer(I + A), z = p.length);

              for (var P = 0; A > P; ++P, ++I) {
                p[I] = p[I - O];
              }
            }
          }
        }, e;
      }();

      !function (t) {
        var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        "undefined" == typeof t.btoa && (t.btoa = function (t) {
          var r,
              n,
              s,
              o,
              i,
              a,
              u,
              c,
              l = 0,
              f = 0,
              d = "",
              h = [];
          if (!t) return t;

          do {
            r = t.charCodeAt(l++), n = t.charCodeAt(l++), s = t.charCodeAt(l++), c = r << 16 | n << 8 | s, o = c >> 18 & 63, i = c >> 12 & 63, a = c >> 6 & 63, u = 63 & c, h[f++] = e.charAt(o) + e.charAt(i) + e.charAt(a) + e.charAt(u);
          } while (l < t.length);

          d = h.join("");
          var p = t.length % 3;
          return (p ? d.slice(0, p - 3) : d) + "===".slice(p || 3);
        }), "undefined" == typeof t.atob && (t.atob = function (t) {
          var r,
              n,
              s,
              o,
              i,
              a,
              u,
              c,
              l = 0,
              f = 0,
              d = "",
              h = [];
          if (!t) return t;
          t += "";

          do {
            o = e.indexOf(t.charAt(l++)), i = e.indexOf(t.charAt(l++)), a = e.indexOf(t.charAt(l++)), u = e.indexOf(t.charAt(l++)), c = o << 18 | i << 12 | a << 6 | u, r = c >> 16 & 255, n = c >> 8 & 255, s = 255 & c, h[f++] = 64 == a ? String.fromCharCode(r) : 64 == u ? String.fromCharCode(r, n) : String.fromCharCode(r, n, s);
          } while (l < t.length);

          return d = h.join("");
        }), Array.prototype.map || (Array.prototype.map = function (t) {
          if (void 0 === this || null === this || "function" != typeof t) throw new TypeError();

          for (var e = Object(this), r = e.length >>> 0, n = new Array(r), s = arguments.length > 1 ? arguments[1] : void 0, o = 0; r > o; o++) {
            o in e && (n[o] = t.call(s, e[o], o, e));
          }

          return n;
        }), Array.isArray || (Array.isArray = function (t) {
          return "[object Array]" === Object.prototype.toString.call(t);
        }), Array.prototype.forEach || (Array.prototype.forEach = function (t, e) {

          if (void 0 === this || null === this || "function" != typeof t) throw new TypeError();

          for (var r = Object(this), n = r.length >>> 0, s = 0; n > s; s++) {
            s in r && t.call(e, r[s], s, r);
          }
        }), Object.keys || (Object.keys = function () {

          var t = Object.prototype.hasOwnProperty,
              e = !{
            toString: null
          }.propertyIsEnumerable("toString"),
              r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
              n = r.length;
          return function (s) {
            if ("object" != _typeof(s) && ("function" != typeof s || null === s)) throw new TypeError();
            var o,
                i,
                a = [];

            for (o in s) {
              t.call(s, o) && a.push(o);
            }

            if (e) for (i = 0; n > i; i++) {
              t.call(s, r[i]) && a.push(r[i]);
            }
            return a;
          };
        }()), String.prototype.trim || (String.prototype.trim = function () {
          return this.replace(/^\s+|\s+$/g, "");
        }), String.prototype.trimLeft || (String.prototype.trimLeft = function () {
          return this.replace(/^\s+/g, "");
        }), String.prototype.trimRight || (String.prototype.trimRight = function () {
          return this.replace(/\s+$/g, "");
        });
      }("undefined" != typeof self && self || "undefined" != typeof window && window || this);
    }({}, function () {
      return this;
    }());
  });

  var jspdf_min$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), jspdf_min, {
    'default': jspdf_min,
    __moduleExports: jspdf_min
  }));

  /**
   * For parsing color values.
   * @module RGBColor
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * @see https://www.phpied.com/rgb-color-parser-in-javascript/
   * @license MIT
  */
  var simpleColors = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dodgerblue: '1e90ff',
    feldspar: 'd19275',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgrey: 'd3d3d3',
    lightgreen: '90ee90',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslateblue: '8470ff',
    lightslategray: '778899',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '00ff00',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'ff00ff',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370d8',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'd87093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    red: 'ff0000',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    violetred: 'd02090',
    wheat: 'f5deb3',
    white: 'ffffff',
    whitesmoke: 'f5f5f5',
    yellow: 'ffff00',
    yellowgreen: '9acd32'
  }; // array of color definition objects

  var colorDefs = [{
    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    // re: /^rgb\((?<r>\d{1,3}),\s*(?<g>\d{1,3}),\s*(?<b>\d{1,3})\)$/,
    example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
    process: function process(_) {
      for (var _len = arguments.length, bits = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        bits[_key - 1] = arguments[_key];
      }

      return bits.map(function (b) {
        return Number.parseInt(b);
      });
    }
  }, {
    re: /^(\w{2})(\w{2})(\w{2})$/,
    // re: /^(?<r>\w{2})(?<g>\w{2})(?<b>\w{2})$/,
    example: ['#00ff00', '336699'],
    process: function process(_) {
      for (var _len2 = arguments.length, bits = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        bits[_key2 - 1] = arguments[_key2];
      }

      return bits.map(function (b) {
        return Number.parseInt(b, 16);
      });
    }
  }, {
    re: /^(\w)(\w)(\w)$/,
    // re: /^(?<r>\w{1})(?<g>\w{1})(?<b>\w{1})$/,
    example: ['#fb0', 'f0f'],
    process: function process(_) {
      for (var _len3 = arguments.length, bits = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        bits[_key3 - 1] = arguments[_key3];
      }

      return bits.map(function (b) {
        return Number.parseInt(b + b, 16);
      });
    }
  }];
  /**
   * A class to parse color values.
   */

  var RGBColor = /*#__PURE__*/function () {
    /**
    * @param {string} colorString
    */
    function RGBColor(colorString) {
      var _this = this;

      _classCallCheck(this, RGBColor);

      this.ok = false; // strip any leading #

      if (colorString.charAt(0) === '#') {
        // remove # if any
        colorString = colorString.substr(1, 6);
      }

      colorString = colorString.replace(/ /g, '');
      colorString = colorString.toLowerCase(); // before getting into regexps, try simple matches
      // and overwrite the input

      if (colorString in simpleColors) {
        colorString = simpleColors[colorString];
      } // end of simple type-in colors
      // search through the definitions to find a match


      colorDefs.forEach(function (_ref) {
        var re = _ref.re,
            processor = _ref.process;
        var bits = re.exec(colorString);

        if (bits) {
          var _processor = processor.apply(void 0, _toConsumableArray(bits)),
              _processor2 = _slicedToArray(_processor, 3),
              r = _processor2[0],
              g = _processor2[1],
              b = _processor2[2];

          Object.assign(_this, {
            r: r,
            g: g,
            b: b
          });
          _this.ok = true;
        }
      }); // validate/cleanup values

      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
    } // some getters

    /**
    * @returns {string}
    */


    _createClass(RGBColor, [{
      key: "toRGB",
      value: function toRGB() {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
      }
      /**
      * @returns {string}
      */

    }, {
      key: "toHex",
      value: function toHex() {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);

        if (r.length === 1) {
          r = '0' + r;
        }

        if (g.length === 1) {
          g = '0' + g;
        }

        if (b.length === 1) {
          b = '0' + b;
        }

        return '#' + r + g + b;
      }
      /**
      * Offers a bulleted list of help.
      * @returns {HTMLUListElement}
      */

    }], [{
      key: "getHelpXML",
      value: function getHelpXML() {
        var examples = [].concat(_toConsumableArray(colorDefs.flatMap(function (_ref2) {
          var example = _ref2.example;
          return example;
        })), _toConsumableArray(Object.keys(simpleColors)));
        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        xml.append.apply(xml, _toConsumableArray(examples.map(function (example) {
          try {
            var listItem = document.createElement('li');
            var listColor = new RGBColor(example);
            var exampleDiv = document.createElement('div');
            exampleDiv.style.cssText = "\n  margin: 3px;\n  border: 1px solid black;\n  background: ".concat(listColor.toHex(), ";\n  color: ").concat(listColor.toHex(), ";");
            exampleDiv.append('test');
            var listItemValue = " ".concat(example, " -> ").concat(listColor.toRGB(), " -> ").concat(listColor.toHex());
            listItem.append(exampleDiv, listItemValue);
            return listItem;
          } catch (e) {
            return '';
          }
        })));
        return xml;
      }
    }]);

    return RGBColor;
  }();

  var jsPDFAPI = jsPDF.API;
  var pdfSvgAttr = {
    // allowed attributes. all others are removed from the preview.
    g: ['stroke', 'fill', 'stroke-width'],
    line: ['x1', 'y1', 'x2', 'y2', 'stroke', 'stroke-width'],
    rect: ['x', 'y', 'width', 'height', 'stroke', 'fill', 'stroke-width'],
    ellipse: ['cx', 'cy', 'rx', 'ry', 'stroke', 'fill', 'stroke-width'],
    circle: ['cx', 'cy', 'r', 'stroke', 'fill', 'stroke-width'],
    polygon: ['points', 'stroke', 'fill', 'stroke-width'],
    // polyline attributes are the same as those of polygon
    path: ['d', 'stroke', 'fill', 'stroke-width'],
    text: ['x', 'y', 'font-size', 'font-family', 'text-anchor', 'font-weight', 'font-style', 'fill']
  };

  var attributeIsNotEmpty = function attributeIsNotEmpty(node, attr) {
    var attVal = attr ? node.getAttribute(attr) : node;
    return attVal !== '' && attVal !== null && attVal !== 'null';
  };

  var nodeIs = function nodeIs(node, possible) {
    return possible.includes(node.tagName.toLowerCase());
  };

  var removeAttributes = function removeAttributes(node, attributes) {
    var toRemove = [];
    [].forEach.call(node.attributes, function (a) {
      if (attributeIsNotEmpty(a) && !attributes.includes(a.name.toLowerCase())) {
        toRemove.push(a.name);
      }
    });
    toRemove.forEach(function (a) {
      node.removeAttribute(a.name);
    });
  };

  var numRgx = /[+-]?(?:\d+\.\d*|\d+|\.\d+)(?:[eE]\d+|[eE][+-]\d+|)/g;

  var getLinesOptionsOfPoly = function getLinesOptionsOfPoly(node) {
    var nums = node.getAttribute('points');
    nums = nums && nums.match(numRgx) || [];

    if (nums && nums.length) {
      nums = nums.map(function (n) {
        return Number(n);
      });

      if (nums.length % 2) {
        nums.length--;
      }
    }

    if (nums.length < 4) {
      console.log('invalid points attribute:', node); // eslint-disable-line no-console

      return undefined;
    }

    var _nums = nums,
        _nums2 = _slicedToArray(_nums, 2),
        x = _nums2[0],
        y = _nums2[1],
        lines = [];

    for (var i = 2; i < nums.length; i += 2) {
      lines.push([nums[i] - nums[i - 2], nums[i + 1] - nums[i - 1]]);
    }

    return {
      x: x,
      y: y,
      lines: lines
    };
  };

  var getLinesOptionsOfPath = function getLinesOptionsOfPath(node) {
    var segList = node.pathSegList,
        n = segList.numberOfItems,
        opsList = [];
    var ops = {
      lines: []
    };
    var curr = {
      x: 0,
      y: 0
    };
    var reflectControl = {
      x: 0,
      y: 0
    };

    var toRelative = function toRelative(nums, relativeTo) {
      var re = [];

      for (var i = 0; i < nums.length - 1; i += 2) {
        re[i] = nums[i] - relativeTo.x;
        re[i + 1] = nums[i + 1] - relativeTo.y;
      }

      return re;
    };

    var curveQToC = function curveQToC(nums) {
      var a = 2 / 3;
      var re = [nums[0] * a, nums[1] * a, nums[2] + (nums[0] - nums[2]) * a, nums[3] + (nums[1] - nums[3]) * a, nums[2], nums[3]];
      return re;
    };

    for (var i = 0, letterPrev; i < n; i++) {
      var seg = segList.getItem(i);
      var x1 = seg.x1,
          y1 = seg.y1,
          x2 = seg.x2,
          y2 = seg.y2,
          x = seg.x,
          y = seg.y,
          letter = seg.pathSegTypeAsLetter;
      var isRelative = letter >= 'a'; // lowercase letter

      switch (letter) {
        case 'M':
        case 'm':
          {
            if (ops.lines.length && Object.prototype.hasOwnProperty.call(ops, 'x')) {
              opsList.push(ops);
            }

            ops = {
              lines: [],
              x: isRelative ? x + curr.x : x,
              y: isRelative ? y + curr.y : y,
              closed: false
            };
            ops.closed = false;
            break;
          }

        case 'L':
          {
            ops.lines.push(toRelative([x, y], curr));
            break;
          }

        case 'l':
          {
            ops.lines.push([x, y]);
            break;
          }

        case 'H':
          {
            ops.lines.push([x - curr.x, 0]);
            break;
          }

        case 'h':
          {
            ops.lines.push([x, 0]);
            break;
          }

        case 'V':
          {
            ops.lines.push([0, y - curr.y]);
            break;
          }

        case 'v':
          {
            ops.lines.push([0, y]);
            break;
          }

        case 'Q':
          {
            ops.lines.push(curveQToC(toRelative([x1, y1, x, y], curr)));
            reflectControl.x = x - x1;
            reflectControl.y = y - y1;
            break;
          }

        case 'q':
          {
            ops.lines.push(curveQToC([x1, y1, x, y]));
            reflectControl.x = x - x1;
            reflectControl.y = y - y1;
            break;
          }

        case 'T':
          {
            var p1 = letterPrev && 'QqTt'.includes(letterPrev) ? reflectControl : {
              x: 0,
              y: 0
            };
            ops.lines.push(curveQToC([p1.x, p1.y, x - curr.x, y - curr.y]));
            reflectControl.x = x - curr.x - p1.x;
            reflectControl.y = y - curr.y - p1.y;
            break;
          }

        case 't':
          {
            var _p = letterPrev && 'QqTt'.includes(letterPrev) ? reflectControl : {
              x: 0,
              y: 0
            };

            ops.lines.push([_p.x, _p.y, x, y]);
            reflectControl.x = x - _p.x;
            reflectControl.y = y - _p.y;
            break;
          }

        case 'C':
          {
            ops.lines.push(toRelative([x1, y1, x2, y2, x, y], curr));
            break;
          }

        case 'c':
          {
            ops.lines.push([x1, y1, x2, y2, x, y]);
            break;
          }

        case 'S':
        case 's':
          {
            var _p2 = letterPrev && 'CcSs'.includes(letterPrev) ? reflectControl : {
              x: 0,
              y: 0
            };

            if (isRelative) {
              ops.lines.push([_p2.x, _p2.y, x2, y2, x, y]);
            } else {
              ops.lines.push([_p2.x, _p2.y].concat(toRelative([x2, y2, x, y], curr)));
            }

            reflectControl.x = x - x2;
            reflectControl.y = y - y2;
            break;
          }

        case 'A':
        case 'a':
          {
            // Not support command 'A' and 'a' yet. Treat it as straight line instead.
            if (isRelative) {
              ops.lines.push([x, y]);
            } else {
              ops.lines.push(toRelative([x, y], curr));
            }

            break;
          }

        case 'z':
        case 'Z':
          {
            ops.closed = true;
            break;
          }

        default:
          {
            // throw new Error('Unknown path command ' + letter);
            return opsList;
          }
      }

      if (letter === 'Z' || letter === 'z') {
        curr.x = ops.x;
        curr.y = ops.y;
      } else {
        if (letter !== 'V' && letter !== 'v') {
          curr.x = isRelative ? x + curr.x : x;
        }

        if (letter !== 'H' && letter !== 'h') {
          curr.y = isRelative ? y + curr.y : y;
        }
      }

      letterPrev = letter;
    }

    if (ops.lines.length && Object.prototype.hasOwnProperty.call(ops, 'x')) {
      opsList.push(ops);
    }

    return opsList;
  };

  var svgElementToPdf = function svgElementToPdf(element, pdf, options) {
    // pdf is a jsPDF object
    // console.log('options =', options);
    var remove = options.removeInvalid === undefined ? false : options.removeInvalid;
    var k = options.scale === undefined ? 1.0 : options.scale;
    var colorMode = null;
    [].forEach.call(element.children, function (node) {
      // console.log('passing: ', node);
      // let hasStrokeColor = false;
      var hasFillColor = false;
      var fillRGB;
      colorMode = null;

      if (nodeIs(node, ['g', 'line', 'rect', 'ellipse', 'circle', 'polygon', 'polyline', 'path', 'text'])) {
        var fillColor = node.getAttribute('fill');

        if (attributeIsNotEmpty(fillColor) && node.getAttribute('fill-opacity') !== '0') {
          fillRGB = new RGBColor(fillColor);

          if (fillRGB.ok) {
            hasFillColor = true;
            colorMode = 'F';
          } else {
            colorMode = null;
          }
        }
      }

      if (nodeIs(node, ['g', 'line', 'rect', 'ellipse', 'circle', 'polygon', 'polyline', 'path'])) {
        if (hasFillColor) {
          pdf.setFillColor(fillRGB.r, fillRGB.g, fillRGB.b);
        }

        if (attributeIsNotEmpty(node, 'stroke-width')) {
          pdf.setLineWidth(k * Number.parseInt(node.getAttribute('stroke-width')));
        }

        var strokeColor = node.getAttribute('stroke');

        if (attributeIsNotEmpty(strokeColor) && node.getAttribute('stroke-width') !== '0' && node.getAttribute('stroke-opacity') !== '0') {
          var strokeRGB = new RGBColor(strokeColor);

          if (strokeRGB.ok) {
            // hasStrokeColor = true;
            pdf.setDrawColor(strokeRGB.r, strokeRGB.g, strokeRGB.b);

            if (hasFillColor) {
              colorMode = 'FD';
            } else {
              colorMode = 'S';
            }
          } else {
            colorMode = null;
          }
        }
      }

      var tag = node.tagName.toLowerCase();

      switch (tag) {
        case 'svg':
        case 'a':
        case 'g':
          svgElementToPdf(node, pdf, options);
          removeAttributes(node, pdfSvgAttr.g);
          break;

        case 'line':
          pdf.line(k * Number.parseInt(node.getAttribute('x1')), k * Number.parseInt(node.getAttribute('y1')), k * Number.parseInt(node.getAttribute('x2')), k * Number.parseInt(node.getAttribute('y2')));
          removeAttributes(node, pdfSvgAttr.line);
          break;

        case 'rect':
          pdf.rect(k * Number.parseInt(node.getAttribute('x')), k * Number.parseInt(node.getAttribute('y')), k * Number.parseInt(node.getAttribute('width')), k * Number.parseInt(node.getAttribute('height')), colorMode);
          removeAttributes(node, pdfSvgAttr.rect);
          break;

        case 'ellipse':
          pdf.ellipse(k * Number.parseInt(node.getAttribute('cx')), k * Number.parseInt(node.getAttribute('cy')), k * Number.parseInt(node.getAttribute('rx')), k * Number.parseInt(node.getAttribute('ry')), colorMode);
          removeAttributes(node, pdfSvgAttr.ellipse);
          break;

        case 'circle':
          pdf.circle(k * Number.parseInt(node.getAttribute('cx')), k * Number.parseInt(node.getAttribute('cy')), k * Number.parseInt(node.getAttribute('r')), colorMode);
          removeAttributes(node, pdfSvgAttr.circle);
          break;

        case 'polygon':
        case 'polyline':
          {
            var linesOptions = getLinesOptionsOfPoly(node);

            if (linesOptions) {
              pdf.lines(linesOptions.lines, k * linesOptions.x, k * linesOptions.y, [k, k], colorMode, tag === 'polygon' // polygon is closed, polyline is not closed
              );
            }

            removeAttributes(node, pdfSvgAttr.polygon);
            break;
          }

        case 'path':
          {
            if (colorMode) {
              var linesOptionsList = getLinesOptionsOfPath(node);

              if (linesOptionsList.length > 0) {
                linesOptionsList.forEach(function (linesOptions) {
                  pdf.lines(linesOptions.lines, k * linesOptions.x, k * linesOptions.y, [k, k], null, linesOptions.closed);
                }); // svg fill rule default is nonzero

                var fillRule = node.getAttribute('fill-rule');

                if (fillRule === 'evenodd') {
                  // f* : fill using even-odd rule
                  // B* : stroke and fill using even-odd rule
                  if (colorMode === 'F') {
                    colorMode = 'f*';
                  } else if (colorMode === 'FD') {
                    colorMode = 'B*';
                  }
                }

                pdf.internal.write(pdf.internal.getStyle(colorMode));
              }
            }

            removeAttributes(node, pdfSvgAttr.path);
            break;
          }

        case 'text':
          {
            if (node.hasAttribute('font-family')) {
              switch ((node.getAttribute('font-family') || '').toLowerCase()) {
                case 'serif':
                  pdf.setFont('times');
                  break;

                case 'monospace':
                  pdf.setFont('courier');
                  break;

                case 'times':
                  pdf.setFont('times');
                  break;

                case 'courier':
                  pdf.setFont('courier');
                  break;

                case 'helvetica':
                  pdf.setFont('helvetica');
                  break;

                default:
                  node.setAttribute('font-family', 'sans-serif');
                  pdf.setFont('helvetica');
              }
            }

            if (hasFillColor) {
              pdf.setTextColor(fillRGB.r, fillRGB.g, fillRGB.b);
            }

            var fontType = '';

            if (node.hasAttribute('font-weight')) {
              if (node.getAttribute('font-weight') === 'bold') {
                fontType = 'bold';
              } else {
                node.removeAttribute('font-weight');
              }
            }

            if (node.hasAttribute('font-style')) {
              if (node.getAttribute('font-style') === 'italic') {
                fontType += 'italic';
              } else {
                node.removeAttribute('font-style');
              }
            }

            pdf.setFontType(fontType);
            var pdfFontSize = node.hasAttribute('font-size') ? Number.parseInt(node.getAttribute('font-size')) : 16;
            /**
             *
             * @param {Element} elem
             * @returns {Float}
             */

            var getWidth = function getWidth(elem) {
              var box;

              try {
                box = elem.getBBox(); // Firefox on MacOS will raise error here
              } catch (err) {
                // copy and append to body so that getBBox is available
                var nodeCopy = elem.cloneNode(true);
                var svg = elem.ownerSVGElement.cloneNode(false);
                svg.appendChild(nodeCopy);
                document.body.appendChild(svg);

                try {
                  box = nodeCopy.getBBox();
                } catch (error) {
                  box = {
                    width: 0
                  };
                }

                svg.remove();
              }

              return box.width;
            }; // TODO: use more accurate positioning!!


            var x,
                y,
                xOffset = 0;

            if (node.hasAttribute('text-anchor')) {
              switch (node.getAttribute('text-anchor')) {
                case 'end':
                  xOffset = getWidth(node);
                  break;

                case 'middle':
                  xOffset = getWidth(node) / 2;
                  break;

                case 'start':
                  break;

                case 'default':
                  node.setAttribute('text-anchor', 'start');
                  break;
              }

              x = Number.parseInt(node.getAttribute('x')) - xOffset;
              y = Number.parseInt(node.getAttribute('y'));
            } // console.log('fontSize:', pdfFontSize, 'text:', node.textContent);


            pdf.setFontSize(pdfFontSize).text(k * x, k * y, node.textContent);
            removeAttributes(node, pdfSvgAttr.text);
            break; // TODO: image
          }

        default:
          if (remove) {
            console.log("can't translate to pdf:", node); // eslint-disable-line no-console

            node.remove();
          }

      }
    });
    return pdf;
  };

  jsPDFAPI.addSVG = function (element, x, y, options) {
    options = options === undefined ? {} : options;
    options.x_offset = x;
    options.y_offset = y;

    if (typeof element === 'string') {
      element = new DOMParser().parseFromString(element, 'text/xml').documentElement;
    }

    svgElementToPdf(element, this, options);
    return this;
  };

  var jspdf_plugin_svgToPdf = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

})));
